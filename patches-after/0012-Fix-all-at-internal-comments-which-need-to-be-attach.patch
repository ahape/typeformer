From 0000000000000000000000000000000000000000 Mon Sep 17 00:00:00 2001
From: Jake Bailey <5341706+jakebailey@users.noreply.github.com>
Date: Mon, 12 Sep 2022 20:53:53 -0700
Subject: [PATCH] Fix all at-internal comments, which need to be attached to a
 declaration

---
 src/api-extractor-base.json                |  21 +-
 src/compiler/builder.ts                    |   9 +-
 src/compiler/core.ts                       | 307 +++++++++++++------
 src/compiler/emitter.ts                    |  10 +-
 src/compiler/factory/baseNodeFactory.ts    |   3 +-
 src/compiler/factory/emitHelpers.ts        |  12 +-
 src/compiler/factory/utilities.ts          |  66 ++--
 src/compiler/moduleSpecifiers.ts           |   7 +-
 src/compiler/parser.ts                     |   3 +-
 src/compiler/path.ts                       | 109 ++++---
 src/compiler/perfLogger.ts                 |   7 +-
 src/compiler/performance.ts                |  32 +-
 src/compiler/performanceCore.ts            |   7 +-
 src/compiler/program.ts                    |   3 +-
 src/compiler/resolutionCache.ts            |  10 +-
 src/compiler/semver.ts                     |   6 +-
 src/compiler/sourcemap.ts                  |   3 +-
 src/compiler/transformer.ts                |   3 +-
 src/compiler/transformers/classFields.ts   |   3 +-
 src/compiler/transformers/declarations.ts  |   3 +-
 src/compiler/transformers/destructuring.ts |   6 +-
 src/compiler/transformers/es2017.ts        |   7 +-
 src/compiler/transformers/es5.ts           |   3 +-
 src/compiler/transformers/utilities.ts     |  27 +-
 src/compiler/tsbuildPublic.ts              |   7 +-
 src/compiler/utilities.ts                  | 332 ++++++++++++++-------
 src/compiler/utilitiesPublic.ts            |   3 +-
 src/compiler/watch.ts                      |  28 +-
 src/compiler/watchUtilities.ts             |  21 +-
 src/jsTyping/jsTyping.ts                   |   9 +-
 src/server/editorServices.ts               |  14 +-
 src/server/utilities.ts                    |   7 +-
 src/services/breakpoints.ts                |   3 +-
 src/services/callHierarchy.ts              |  28 +-
 src/services/classifier2020.ts             |   7 +-
 src/services/codefixes/helpers.ts          |   9 +-
 src/services/codefixes/importFixes.ts      |   9 +-
 src/services/completions.ts                |   3 +-
 src/services/findAllReferences.ts          |  14 +-
 src/services/formatting/formatting.ts      |   4 +-
 src/services/goToDefinition.ts             |   7 +-
 src/services/importTracker.ts              |  17 +-
 src/services/jsDoc.ts                      |   3 +-
 src/services/organizeImports.ts            |   9 +-
 src/services/refactorProvider.ts           |   7 +-
 src/services/refactors/extractSymbol.ts    |   8 +-
 src/services/refactors/helpers.ts          |  10 +-
 src/services/services.ts                   |  14 +-
 src/services/shims.ts                      |  21 +-
 src/services/sourcemaps.ts                 |   3 +-
 src/services/textChanges.ts                |  10 +-
 src/services/utilities.ts                  |  88 ++++--
 52 files changed, 938 insertions(+), 424 deletions(-)

diff --git a/src/api-extractor-base.json b/src/api-extractor-base.json
index dbc6360d5a..7832e0cf50 100644
--- a/src/api-extractor-base.json
+++ b/src/api-extractor-base.json
@@ -379,6 +379,23 @@
         "default": {
           "logLevel": "warning"
           // "addToApiReportFile": false
+        },
+
+        "ae-internal-missing-underscore": {
+          "logLevel": "none",
+          "addToApiReportFile": false
+        },
+
+        // TODO(jakebailey): should we explicitly mark things as public?
+        "ae-missing-release-tag": {
+          "logLevel": "none",
+          "addToApiReportFile": false
+        },
+
+        // TODO(jakebailey): Fix these?
+        "ae-unresolved-link": {
+          "logLevel": "none",
+          "addToApiReportFile": false
         }
   
         // "ae-extra-release-tag": {
@@ -398,8 +415,8 @@
        */
       "tsdocMessageReporting": {
         "default": {
-          "logLevel": "warning"
-          // "addToApiReportFile": false
+          "logLevel": "none",
+          "addToApiReportFile": false
         }
   
         // "tsdoc-link-tag-unescaped-text": {
diff --git a/src/compiler/builder.ts b/src/compiler/builder.ts
index db11537f00..04efd3a7d3 100644
--- a/src/compiler/builder.ts
+++ b/src/compiler/builder.ts
@@ -92,9 +92,10 @@ export const enum BuilderFileEmit {
     Full
 }
 
-/** @internal */
 /**
  * State to store the changed files, affected files and cache semantic diagnostics
+ *
+ * @internal
  */
 // TODO: GH#18217 Properties of this interface are frequently asserted to be defined.
 export interface BuilderProgramState extends BuilderState, ReusableBuilderProgramState {
@@ -803,15 +804,17 @@ export type ProgramBuildInfoBuilderStateFileInfo = Omit<BuilderState.FileInfo, "
      */
     signature: string | false | undefined;
 };
-/** @internal */
 /**
  * [fileId, signature] if different from file's signature
  * fileId if file wasnt emitted
+ *
+ * @internal
  */
 export type ProgramBuildInfoEmitSignature = ProgramBuildInfoFileId | [fileId: ProgramBuildInfoFileId, signature: string];
-/** @internal */
 /**
  * ProgramBuildInfoFileInfo is string if FileInfo.version === FileInfo.signature && !FileInfo.affectsGlobalScope otherwise encoded FileInfo
+ *
+ * @internal
  */
 export type ProgramBuildInfoFileInfo = string | ProgramBuildInfoBuilderStateFileInfo;
 /** @internal */
diff --git a/src/compiler/core.ts b/src/compiler/core.ts
index 2e3a662665..70ccdb380f 100644
--- a/src/compiler/core.ts
+++ b/src/compiler/core.ts
@@ -41,11 +41,12 @@ export function length(array: readonly any[] | undefined): number {
     return array ? array.length : 0;
 }
 
-/** @internal */
 /**
  * Iterates through 'array' by index and performs the callback on each element of array until the callback
  * returns a truthy value, then returns that value.
  * If no such value is found, the callback is applied to each element of array and undefined is returned.
+ *
+ * @internal
  */
 export function forEach<T, U>(array: readonly T[] | undefined, callback: (element: T, index: number) => U | undefined): U | undefined {
     if (array) {
@@ -59,9 +60,10 @@ export function forEach<T, U>(array: readonly T[] | undefined, callback: (elemen
     return undefined;
 }
 
-/** @internal */
 /**
  * Like `forEach`, but iterates in reverse order.
+ *
+ * @internal
  */
 export function forEachRight<T, U>(array: readonly T[] | undefined, callback: (element: T, index: number) => U | undefined): U | undefined {
     if (array) {
@@ -75,8 +77,11 @@ export function forEachRight<T, U>(array: readonly T[] | undefined, callback: (e
     return undefined;
 }
 
-/** @internal */
-/** Like `forEach`, but suitable for use with numbers and strings (which may be falsy). */
+/**
+ * Like `forEach`, but suitable for use with numbers and strings (which may be falsy).
+ *
+ * @internal
+ */
 export function firstDefined<T, U>(array: readonly T[] | undefined, callback: (element: T, index: number) => U | undefined): U | undefined {
     if (array === undefined) {
         return undefined;
@@ -151,10 +156,11 @@ export function zipToMap<K, V>(keys: readonly K[], values: readonly V[]): ESMap<
     return map;
 }
 
-/** @internal */
 /**
  * Creates a new array with `element` interspersed in between each element of `input`
  * if there is more than 1 value in `input`. Otherwise, returns the existing array.
+ *
+ * @internal
  */
 export function intersperse<T>(input: T[], element: T): T[] {
     if (input.length <= 1) {
@@ -168,11 +174,12 @@ export function intersperse<T>(input: T[], element: T): T[] {
     return result;
 }
 
-/** @internal */
 /**
  * Iterates through `array` by index and performs the callback on each element of array until the callback
  * returns a falsey value, then returns false.
  * If no such value is found, the callback is applied to each element of array and `true` is returned.
+ *
+ * @internal
  */
 export function every<T>(array: readonly T[] | undefined, callback: (element: T, index: number) => boolean): boolean {
     if (array) {
@@ -186,8 +193,11 @@ export function every<T>(array: readonly T[] | undefined, callback: (element: T,
     return true;
 }
 
-/** @internal */
-/** Works like Array.prototype.find, returning `undefined` if no element satisfying the predicate is found. */
+/**
+ * Works like Array.prototype.find, returning `undefined` if no element satisfying the predicate is found.
+ *
+ * @internal
+ */
 export function find<T, U extends T>(array: readonly T[] | undefined, predicate: (element: T, index: number) => element is U, startIndex?: number): U | undefined;
 /** @internal */
 export function find<T>(array: readonly T[] | undefined, predicate: (element: T, index: number) => boolean, startIndex?: number): T | undefined;
@@ -219,8 +229,11 @@ export function findLast<T>(array: readonly T[] | undefined, predicate: (element
     return undefined;
 }
 
-/** @internal */
-/** Works like Array.prototype.findIndex, returning `-1` if no element satisfying the predicate is found. */
+/**
+ * Works like Array.prototype.findIndex, returning `-1` if no element satisfying the predicate is found.
+ *
+ * @internal
+ */
 export function findIndex<T>(array: readonly T[] | undefined, predicate: (element: T, index: number) => boolean, startIndex?: number): number {
     if (array === undefined) return -1;
     for (let i = startIndex ?? 0; i < array.length; i++) {
@@ -242,10 +255,11 @@ export function findLastIndex<T>(array: readonly T[] | undefined, predicate: (el
     return -1;
 }
 
-/** @internal */
 /**
  * Returns the first truthy result of `callback`, or else fails.
  * This is like `forEach`, but never returns undefined.
+ *
+ * @internal
  */
 export function findMap<T, U>(array: readonly T[], callback: (element: T, index: number) => U | undefined): U {
     for (let i = 0; i < array.length; i++) {
@@ -298,10 +312,11 @@ export function countWhere<T>(array: readonly T[] | undefined, predicate: (x: T,
     return count;
 }
 
-/** @internal */
 /**
  * Filters an array by a predicate function. Returns the same array instance if the predicate is
  * true for all elements, otherwise returns a new array instance containing the filtered subset.
+ *
+ * @internal
  */
 export function filter<T, U extends T>(array: T[], f: (x: T) => x is U): U[];
 /** @internal */
@@ -384,8 +399,10 @@ export function mapIterator<T, U>(iter: Iterator<T>, mapFn: (x: T) => U): Iterat
     };
 }
 
-// Maps from T to T and avoids allocation if all elements map to themselves
-/** @internal */
+/**
+ * Maps from T to T and avoids allocation if all elements map to themselves
+ *
+ * @internal */
 export function sameMap<T>(array: T[], f: (x: T, i: number) => T): T[];
 /** @internal */
 export function sameMap<T>(array: readonly T[], f: (x: T, i: number) => T): readonly T[];
@@ -412,11 +429,12 @@ export function sameMap<T>(array: readonly T[] | undefined, f: (x: T, i: number)
     return array;
 }
 
-/** @internal */
 /**
  * Flattens an array containing a mix of array or non-array elements.
  *
  * @param array The array to flatten.
+ *
+ * @internal
  */
 export function flatten<T>(array: T[][] | readonly (T | readonly T[] | undefined)[]): T[] {
     const result = [];
@@ -433,12 +451,14 @@ export function flatten<T>(array: T[][] | readonly (T | readonly T[] | undefined
     return result;
 }
 
-/** @internal */
+
 /**
  * Maps an array. If the mapped value is an array, it is spread into the result.
  *
  * @param array The array to map.
  * @param mapfn The callback used to map the result into one or more values.
+ *
+ * @internal
  */
 export function flatMap<T, U>(array: readonly T[] | undefined, mapfn: (x: T, i: number) => U | readonly U[] | undefined): readonly U[] {
     let result: U[] | undefined;
@@ -506,13 +526,15 @@ export function flatMapIterator<T, U>(iter: Iterator<T>, mapfn: (x: T) => readon
     }
 }
 
-/** @internal */
+
 /**
  * Maps an array. If the mapped value is an array, it is spread into the result.
  * Avoids allocation if all elements map to themselves.
  *
  * @param array The array to map.
  * @param mapfn The callback used to map the result into one or more values.
+ *
+ * @internal
  */
 export function sameFlatMap<T>(array: T[], mapfn: (x: T, i: number) => T | readonly T[]): T[];
 /** @internal */
@@ -661,13 +683,14 @@ export function singleIterator<T>(value: T): Iterator<T> {
     };
 }
 
-/** @internal */
 /**
  * Maps contiguous spans of values with the same key.
  *
  * @param array The array to map.
  * @param keyfn A callback used to select the key for an element.
  * @param mapfn A callback used to map a contiguous chunk of values to a single value.
+ *
+ * @internal
  */
 export function spanMap<T, K, U>(array: readonly T[], keyfn: (x: T, i: number) => K, mapfn: (chunk: T[], key: K, start: number, end: number) => U): U[];
 /** @internal */
@@ -752,8 +775,11 @@ export function some<T>(array: readonly T[] | undefined, predicate?: (value: T)
     return false;
 }
 
-/** @internal */
-/** Calls the callback with (start, afterEnd) index pairs for each range where 'pred' is true. */
+/**
+ * Calls the callback with (start, afterEnd) index pairs for each range where 'pred' is true.
+ *
+ * @internal
+ */
 export function getRangesWhere<T>(arr: readonly T[], pred: (t: T) => boolean, cb: (start: number, afterEnd: number) => void): void {
     let start: number | undefined;
     for (let i = 0; i < arr.length; i++) {
@@ -824,12 +850,13 @@ function deduplicateEquality<T>(array: readonly T[], equalityComparer: EqualityC
     return result;
 }
 
-/** @internal */
 /**
  * Deduplicates an unsorted array.
  * @param equalityComparer An `EqualityComparer` used to determine if two values are duplicates.
  * @param comparer An optional `Comparer` used to sort entries before comparison, though the
  * result will remain in the original order in `array`.
+ *
+ * @internal
  */
 export function deduplicate<T>(array: readonly T[], equalityComparer: EqualityComparer<T>, comparer?: Comparer<T>): T[] {
     return array.length === 0 ? [] :
@@ -935,9 +962,10 @@ export function arrayIsEqualTo<T>(array1: readonly T[] | undefined, array2: read
     return true;
 }
 
-/** @internal */
 /**
  * Compacts an array, removing any falsey elements.
+ *
+ * @internal
  */
 export function compact<T>(array: (T | undefined | null | false | 0 | "")[]): T[];
 /** @internal */
@@ -966,11 +994,12 @@ export function compact<T>(array: T[]): T[] {
     return result || array;
 }
 
-/** @internal */
 /**
  * Gets the relative complement of `arrayA` with respect to `arrayB`, returning the elements that
  * are not present in `arrayA` but are present in `arrayB`. Assumes both arrays are sorted
  * based on the provided comparer.
+ *
+ * @internal
  */
 export function relativeComplement<T>(arrayA: T[] | undefined, arrayB: T[] | undefined, comparer: Comparer<T>): T[] | undefined {
     if (!arrayB || !arrayA || arrayB.length === 0 || arrayA.length === 0) return arrayB;
@@ -1019,7 +1048,6 @@ export function sum<T extends Record<K, number>, K extends string>(array: readon
     return result;
 }
 
-/** @internal */
 /**
  * Appends a value to an array, returning the array.
  *
@@ -1027,6 +1055,8 @@ export function sum<T extends Record<K, number>, K extends string>(array: readon
  * is created if `value` was appended.
  * @param value The value to append to the array. If `value` is `undefined`, nothing is
  * appended.
+ *
+ * @internal
  */
 export function append<TArray extends any[] | undefined, TValue extends NonNullable<TArray>[number] | undefined>(to: TArray, value: TValue): [undefined, undefined] extends [TArray, TValue] ? TArray : NonNullable<TArray>[number][];
 /** @internal */
@@ -1045,7 +1075,6 @@ export function append<T>(to: T[], value: T | undefined): T[] | undefined {
     return to;
 }
 
-/** @internal */
 /**
  * Combines two arrays, values, or undefineds into the smallest container that can accommodate the resulting set:
  *
@@ -1057,6 +1086,8 @@ export function append<T>(to: T[], value: T | undefined): T[] | undefined {
  * T[] -> T -> T[]         (append)
  * T[] -> T[] -> T[]       (concatenate)
  * ```
+ *
+ * @internal
  */
 export function combine<T>(xs: T | readonly T[] | undefined, ys: T | readonly T[] | undefined): T | readonly T[] | undefined;
 /** @internal */
@@ -1078,7 +1109,6 @@ function toOffset(array: readonly any[], offset: number) {
     return offset < 0 ? array.length + offset : offset;
 }
 
-/** @internal */
 /**
  * Appends a range of value to an array, returning the array.
  *
@@ -1088,6 +1118,8 @@ function toOffset(array: readonly any[], offset: number) {
  * appended. If an element of `from` is `undefined`, that element is not appended.
  * @param start The offset in `from` at which to start copying values.
  * @param end The offset in `from` at which to stop copying values (non-inclusive).
+ *
+ * @internal
  */
 export function addRange<T>(to: T[], from: readonly T[] | undefined, start?: number, end?: number): T[];
 /** @internal */
@@ -1106,9 +1138,10 @@ export function addRange<T>(to: T[] | undefined, from: readonly T[] | undefined,
     return to;
 }
 
-/** @internal */
 /**
  * @return Whether the value was added.
+ *
+ * @internal
  */
 export function pushIfUnique<T>(array: T[], toAdd: T, equalityComparer?: EqualityComparer<T>): boolean {
     if (contains(array, toAdd, equalityComparer)) {
@@ -1120,9 +1153,10 @@ export function pushIfUnique<T>(array: T[], toAdd: T, equalityComparer?: Equalit
     }
 }
 
-/** @internal */
 /**
  * Unlike `pushIfUnique`, this can take `undefined` as an input, and returns a new array.
+ *
+ * @internal
  */
 export function appendIfUnique<T>(array: T[] | undefined, toAdd: T, equalityComparer?: EqualityComparer<T>): T[] {
     if (array) {
@@ -1139,9 +1173,10 @@ function stableSortIndices<T>(array: readonly T[], indices: number[], comparer:
     indices.sort((x, y) => comparer(array[x], array[y]) || compareValues(x, y));
 }
 
-/** @internal */
 /**
  * Returns a new sorted array.
+ *
+ * @internal
  */
 export function sort<T>(array: readonly T[], comparer?: Comparer<T>): SortedReadonlyArray<T> {
     return (array.length === 0 ? array : array.slice().sort(comparer)) as SortedReadonlyArray<T>;
@@ -1177,9 +1212,10 @@ export function arrayReverseIterator<T>(array: readonly T[]): Iterator<T> {
     };
 }
 
-/** @internal */
 /**
  * Stable sort of an array. Elements equal to each other maintain their relative position in the array.
+ *
+ * @internal
  */
 export function stableSort<T>(array: readonly T[], comparer: Comparer<T>): SortedReadonlyArray<T> {
     const indices = indicesOf(array);
@@ -1198,10 +1234,11 @@ export function rangeEquals<T>(array1: readonly T[], array2: readonly T[], pos:
     return true;
 }
 
-/** @internal */
 /**
  * Returns the element at a specific offset in an array if non-empty, `undefined` otherwise.
  * A negative offset indicates the element should be retrieved from the end of the array.
+ *
+ * @internal
  */
 export function elementAt<T>(array: readonly T[] | undefined, offset: number): T | undefined {
     if (array) {
@@ -1213,9 +1250,10 @@ export function elementAt<T>(array: readonly T[] | undefined, offset: number): T
     return undefined;
 }
 
-/** @internal */
 /**
  * Returns the first element of an array if non-empty, `undefined` otherwise.
+ *
+ * @internal
  */
 export function firstOrUndefined<T>(array: readonly T[] | undefined): T | undefined {
     return array === undefined || array.length === 0 ? undefined : array[0];
@@ -1227,9 +1265,10 @@ export function first<T>(array: readonly T[]): T {
     return array[0];
 }
 
-/** @internal */
 /**
  * Returns the last element of an array if non-empty, `undefined` otherwise.
+ *
+ * @internal
  */
 export function lastOrUndefined<T>(array: readonly T[] | undefined): T | undefined {
     return array === undefined || array.length === 0 ? undefined : array[array.length - 1];
@@ -1241,9 +1280,10 @@ export function last<T>(array: readonly T[]): T {
     return array[array.length - 1];
 }
 
-/** @internal */
 /**
  * Returns the only element of an array if it contains only one element, `undefined` otherwise.
+ *
+ * @internal
  */
 export function singleOrUndefined<T>(array: readonly T[] | undefined): T | undefined {
     return array && array.length === 1
@@ -1251,18 +1291,20 @@ export function singleOrUndefined<T>(array: readonly T[] | undefined): T | undef
         : undefined;
 }
 
-/** @internal */
 /**
  * Returns the only element of an array if it contains only one element; throws otherwise.
+ *
+ * @internal
  */
 export function single<T>(array: readonly T[]): T {
     return Debug.checkDefined(singleOrUndefined(array));
 }
 
-/** @internal */
 /**
  * Returns the only element of an array if it contains only one element; otherwise, returns the
  * array.
+ *
+ * @internal
  */
 export function singleOrMany<T>(array: T[]): T | T[];
 /** @internal */
@@ -1285,7 +1327,6 @@ export function replaceElement<T>(array: readonly T[], index: number, value: T):
     return result;
 }
 
-/** @internal */
 /**
  * Performs a binary search, finding the index at which `value` occurs in `array`.
  * If no such index is found, returns the 2's-complement of first index at which
@@ -1296,12 +1337,13 @@ export function replaceElement<T>(array: readonly T[], index: number, value: T):
  * `array`.
  * @param keyComparer A callback used to compare two keys in a sorted array.
  * @param offset An offset into `array` at which to start the search.
+ *
+ * @internal
  */
 export function binarySearch<T, U>(array: readonly T[], value: T, keySelector: (v: T) => U, keyComparer: Comparer<U>, offset?: number): number {
     return binarySearchKey(array, keySelector(value), keySelector, keyComparer, offset);
 }
 
-/** @internal */
 /**
  * Performs a binary search, finding the index at which an object with `key` occurs in `array`.
  * If no such index is found, returns the 2's-complement of first index at which
@@ -1311,6 +1353,8 @@ export function binarySearch<T, U>(array: readonly T[], value: T, keySelector: (
  * @param keySelector A callback used to select the search key from each element of `array`.
  * @param keyComparer A callback used to compare two keys in a sorted array.
  * @param offset An offset into `array` at which to start the search.
+ *
+ * @internal
  */
 export function binarySearchKey<T, U>(array: readonly T[], key: U, keySelector: (v: T, i: number) => U, keyComparer: Comparer<U>, offset?: number): number {
     if (!some(array)) {
@@ -1368,31 +1412,34 @@ export function reduceLeft<T>(array: T[], f: (memo: T, value: T, i: number) => T
 
 const hasOwnProperty = Object.prototype.hasOwnProperty;
 
-/** @internal */
 /**
  * Indicates whether a map-like contains an own property with the specified key.
  *
  * @param map A map-like.
  * @param key A property key.
+ *
+ * @internal
  */
 export function hasProperty(map: MapLike<any>, key: string): boolean {
     return hasOwnProperty.call(map, key);
 }
 
-/** @internal */
 /**
  * Gets the value of an owned property in a map-like.
  *
  * @param map A map-like.
  * @param key A property key.
+ *
+ * @internal
  */
 export function getProperty<T>(map: MapLike<T>, key: string): T | undefined {
     return hasOwnProperty.call(map, key) ? map[key] : undefined;
 }
 
-/** @internal */
 /**
  * Gets the owned, enumerable property keys of a map-like.
+ *
+ * @internal
  */
 export function getOwnKeys<T>(map: MapLike<T>): string[] {
     const keys: string[] = [];
@@ -1452,8 +1499,11 @@ export function arrayOf<T>(count: number, f: (index: number) => T): T[] {
     return result;
 }
 
-/** @internal */
-/** Shims `Array.from`. */
+/**
+ * Shims `Array.from`.
+ *
+ * @internal
+ */
 export function arrayFrom<T, U>(iterator: Iterator<T> | IterableIterator<T>, map: (t: T) => U): U[];
 /** @internal */
 export function arrayFrom<T>(iterator: Iterator<T> | IterableIterator<T>): T[];
@@ -1480,12 +1530,13 @@ export function assign<T extends object>(t: T, ...args: (T | undefined)[]) {
     return t;
 }
 
-/** @internal */
 /**
  * Performs a shallow equality comparison of the contents of two map-likes.
  *
  * @param left A map-like whose properties should be compared.
  * @param right A map-like whose properties should be compared.
+ *
+ * @internal
  */
 export function equalOwnProperties<T>(left: MapLike<T> | undefined, right: MapLike<T> | undefined, equalityComparer: EqualityComparer<T> = equateValues) {
     if (left === right) return true;
@@ -1506,7 +1557,6 @@ export function equalOwnProperties<T>(left: MapLike<T> | undefined, right: MapLi
     return true;
 }
 
-/** @internal */
 /**
  * Creates a map from the elements of an array.
  *
@@ -1516,6 +1566,8 @@ export function equalOwnProperties<T>(left: MapLike<T> | undefined, right: MapLi
  * This function makes no effort to avoid collisions; if any two elements produce
  * the same key with the given 'makeKey' function, then the element with the higher
  * index in the array will be the one associated with the produced key.
+ *
+ * @internal
  */
 export function arrayToMap<K, V>(array: readonly V[], makeKey: (value: V) => K | undefined): ESMap<K, V>;
 /** @internal */
@@ -1584,11 +1636,12 @@ export function clone<T>(object: T): T {
     return result;
 }
 
-/** @internal */
 /**
  * Creates a new object by adding the own properties of `second`, then the own properties of `first`.
  *
  * NOTE: This means that if a property exists in both `first` and `second`, the property in `first` will be chosen.
+ *
+ * @internal
  */
 export function extend<T1, T2>(first: T1, second: T2): T1 & T2 {
     const result: T1 & T2 = {} as any;
@@ -1729,7 +1782,6 @@ export function createQueue<T>(items?: readonly T[]): Queue<T> {
     };
 }
 
-/** @internal */
 /**
  * Creates a Set with custom equality and hash code functionality.  This is useful when you
  * want to use something looser than object identity - e.g. "has the same span".
@@ -1739,6 +1791,8 @@ export function createQueue<T>(items?: readonly T[]): Queue<T> {
  *
  * To facilitate a perf optimization (lazy allocation of bucket arrays), `TElement` is
  * assumed not to be an array type.
+ *
+ * @internal
  */
 export function createSet<TElement, THash = number>(getHashCode: (element: TElement) => THash, equals: EqualityComparer<TElement>): Set<TElement> {
     const multiMap = new Map<THash, TElement | TElement[]>();
@@ -1883,9 +1937,10 @@ export function createSet<TElement, THash = number>(getHashCode: (element: TElem
     return set;
 }
 
-/** @internal */
 /**
  * Tests whether a value is an array.
+ *
+ * @internal
  */
 export function isArray(value: any): value is readonly unknown[] {
     return Array.isArray ? Array.isArray(value) : value instanceof Array;
@@ -1900,9 +1955,10 @@ export function toArray<T>(value: T | T[]): T[] {
     return isArray(value) ? value : [value];
 }
 
-/** @internal */
 /**
  * Tests whether a value is string
+ *
+ * @internal
  */
 export function isString(text: unknown): text is string {
     return typeof text === "string";
@@ -1928,8 +1984,11 @@ export function cast<TOut extends TIn, TIn = any>(value: TIn | undefined, test:
     return Debug.fail(`Invalid cast. The supplied value ${value} did not pass the test '${Debug.getFunctionName(test)}'.`);
 }
 
-/** @internal */
-/** Does nothing. */
+/**
+ * Does nothing.
+ *
+ * @internal
+ */
 export function noop(_?: unknown): void { }
 
 /** @internal */
@@ -1938,32 +1997,47 @@ export const noopPush: Push<any> = {
     length: 0
 };
 
-/** @internal */
-/** Do nothing and return false */
+/**
+ * Do nothing and return false
+ *
+ * @internal
+ */
 export function returnFalse(): false {
     return false;
 }
 
-/** @internal */
-/** Do nothing and return true */
+/**
+ * Do nothing and return true
+ *
+ * @internal
+ */
 export function returnTrue(): true {
     return true;
 }
 
-/** @internal */
-/** Do nothing and return undefined */
+/**
+ * Do nothing and return undefined
+ *
+ * @internal
+ */
 export function returnUndefined(): undefined {
     return undefined;
 }
 
-/** @internal */
-/** Returns its argument. */
+/**
+ * Returns its argument.
+ *
+ * @internal
+ */
 export function identity<T>(x: T) {
     return x;
 }
 
-/** @internal */
-/** Returns lower case string */
+/**
+ * Returns lower case string
+ *
+ * @internal
+ */
 export function toLowerCase(x: string) {
     return x.toLowerCase();
 }
@@ -1991,7 +2065,6 @@ export function toLowerCase(x: string) {
 // But to avoid having to do string building for most common cases, also ignore
 // a-z, 0-9, \u0131, \u00DF, \, /, ., : and space
 const fileNameLowerCaseRegExp = /[^\u0130\u0131\u00DFa-z0-9\\/:\-_\. ]+/g;
-/** @internal */
 /**
  * Case insensitive file systems have descripencies in how they handle some characters (eg. turkish Upper case I with dot on top - \u0130)
  * This function is used in places where we want to make file name as a key on these systems
@@ -2002,6 +2075,8 @@ const fileNameLowerCaseRegExp = /[^\u0130\u0131\u00DFa-z0-9\\/:\-_\. ]+/g;
  * We could use upper case and we would still need to deal with the descripencies but
  * we want to continue using lower case since in most cases filenames are lowercasewe and wont need any case changes and avoid having to store another string for the key
  * So for this function purpose, we go ahead and assume character I with dot on top it as case sensitive since its very unlikely to use lower case form of that special character
+ *
+ * @internal
  */
 export function toFileNameLowerCase(x: string) {
     return fileNameLowerCaseRegExp.test(x) ?
@@ -2009,8 +2084,11 @@ export function toFileNameLowerCase(x: string) {
         x;
 }
 
-/** @internal */
-/** Throws an error because a function is not implemented. */
+/**
+ * Throws an error because a function is not implemented.
+ *
+ * @internal
+ */
 export function notImplemented(): never {
     throw new Error("Not implemented");
 }
@@ -2027,8 +2105,11 @@ export function memoize<T>(callback: () => T): () => T {
     };
 }
 
-/** @internal */
-/** A version of `memoize` that supports a single primitive argument */
+/**
+ * A version of `memoize` that supports a single primitive argument
+ *
+ * @internal
+ */
 export function memoizeOne<A extends string | number | boolean | undefined, T>(callback: (arg: A) => T): (arg: A) => T {
     const map = new Map<string, T>();
     return (arg: A) => {
@@ -2042,12 +2123,13 @@ export function memoizeOne<A extends string | number | boolean | undefined, T>(c
     };
 }
 
-/** @internal */
 /**
  * High-order function, composes functions. Note that functions are composed inside-out;
  * for example, `compose(a, b)` is the equivalent of `x => b(a(x))`.
  *
  * @param args The functions to compose.
+ *
+ * @internal
  */
 export function compose<T>(...args: ((t: T) => T)[]): (t: T) => T;
 /** @internal */
@@ -2085,10 +2167,11 @@ export const enum AssertionLevel {
     VeryAggressive = 3,
 }
 
-/** @internal */
 /**
  * Safer version of `Function` which should not be called.
  * Every function should be assignable to this, but this should not be assignable to every function.
+ *
+ * @internal
  */
 export type AnyFunction = (...args: never[]) => void;
 /** @internal */
@@ -2099,7 +2182,6 @@ export function equateValues<T>(a: T, b: T) {
     return a === b;
 }
 
-/** @internal */
 /**
  * Compare the equality of two strings using a case-sensitive ordinal comparison.
  *
@@ -2107,6 +2189,8 @@ export function equateValues<T>(a: T, b: T) {
  * value of each code-point after applying `toUpperCase` to each string. We always map both
  * strings to their upper-case form as some unicode characters do not properly round-trip to
  * lowercase (such as `ẞ` (German sharp capital s)).
+ *
+ * @internal
  */
 export function equateStringsCaseInsensitive(a: string, b: string) {
     return a === b
@@ -2115,12 +2199,13 @@ export function equateStringsCaseInsensitive(a: string, b: string) {
         && a.toUpperCase() === b.toUpperCase();
 }
 
-/** @internal */
 /**
  * Compare the equality of two strings using a case-sensitive ordinal comparison.
  *
  * Case-sensitive comparisons compare both strings one code-point at a time using the
  * integer value of each code-point.
+ *
+ * @internal
  */
 export function equateStringsCaseSensitive(a: string, b: string) {
     return equateValues(a, b);
@@ -2136,18 +2221,20 @@ function compareComparableValues(a: string | number | undefined, b: string | num
         Comparison.GreaterThan;
 }
 
-/** @internal */
 /**
  * Compare two numeric values for their order relative to each other.
  * To compare strings, use any of the `compareStrings` functions.
+ *
+ * @internal
  */
 export function compareValues(a: number | undefined, b: number | undefined): Comparison {
     return compareComparableValues(a, b);
 }
 
-/** @internal */
 /**
  * Compare two TextSpans, first by `start`, then by `length`.
+ *
+ * @internal
  */
 export function compareTextSpans(a: Partial<TextSpan> | undefined, b: Partial<TextSpan> | undefined): Comparison {
     return compareValues(a?.start, b?.start) || compareValues(a?.length, b?.length);
@@ -2158,7 +2245,6 @@ export function min<T>(a: T, b: T, compare: Comparer<T>): T {
     return compare(a, b) === Comparison.LessThan ? a : b;
 }
 
-/** @internal */
 /**
  * Compare two strings using a case-insensitive ordinal comparison.
  *
@@ -2170,6 +2256,8 @@ export function min<T>(a: T, b: T, compare: Comparer<T>): T {
  * value of each code-point after applying `toUpperCase` to each string. We always map both
  * strings to their upper-case form as some unicode characters do not properly round-trip to
  * lowercase (such as `ẞ` (German sharp capital s)).
+ *
+ * @internal
  */
 export function compareStringsCaseInsensitive(a: string, b: string) {
     if (a === b) return Comparison.EqualTo;
@@ -2180,7 +2268,6 @@ export function compareStringsCaseInsensitive(a: string, b: string) {
     return a < b ? Comparison.LessThan : a > b ? Comparison.GreaterThan : Comparison.EqualTo;
 }
 
-/** @internal */
 /**
  * Compare two strings using a case-sensitive ordinal comparison.
  *
@@ -2190,6 +2277,8 @@ export function compareStringsCaseInsensitive(a: string, b: string) {
  *
  * Case-sensitive comparisons compare both strings one code-point at a time using the integer
  * value of each code-point.
+ *
+ * @internal
  */
 export function compareStringsCaseSensitive(a: string | undefined, b: string | undefined): Comparison {
     return compareComparableValues(a, b);
@@ -2304,7 +2393,6 @@ export function setUILocale(value: string | undefined) {
     }
 }
 
-/** @internal */
 /**
  * Compare two strings in a using the case-sensitive sort behavior of the UI locale.
  *
@@ -2314,6 +2402,8 @@ export function setUILocale(value: string | undefined) {
  *
  * Case-sensitive comparisons compare strings that differ in base characters, or
  * accents/diacritic marks, or case as unequal.
+ *
+ * @internal
  */
 export function compareStringsCaseSensitiveUI(a: string, b: string) {
     const comparer = uiComparerCaseSensitive || (uiComparerCaseSensitive = createUIStringComparer(uiLocale));
@@ -2328,13 +2418,16 @@ export function compareProperties<T extends object, K extends keyof T>(a: T | un
         comparer(a[key], b[key]);
 }
 
-/** @internal */
-/** True is greater than false. */
+
+/**
+ * True is greater than false.
+ *
+ * @internal
+ */
 export function compareBooleans(a: boolean, b: boolean): Comparison {
     return compareValues(a ? 1 : 0, b ? 1 : 0);
 }
 
-/** @internal */
 /**
  * Given a name and a list of names that are *not* equal to the name, return a spelling suggestion if there is one that is close enough.
  * Names less than length 3 only check for case-insensitive equality.
@@ -2346,6 +2439,8 @@ export function compareBooleans(a: boolean, b: boolean): Comparison {
  *      * Whose levenshtein distance is more than 0.4 of the length of the name
  *        (0.4 allows 1 substitution/transposition for every 5 characters,
  *         and 1 insertion/deletion at 3 characters)
+ *
+ * @internal
  */
 export function getSpellingSuggestion<T>(name: string, candidates: T[], getName: (candidate: T) => string | undefined): T | undefined {
     const maximumLengthDifference = Math.max(2, Math.floor(name.length * 0.34));
@@ -2445,9 +2540,10 @@ export function stringContains(str: string, substring: string): boolean {
     return str.indexOf(substring) !== -1;
 }
 
-/** @internal */
 /**
  * Takes a string like "jquery-min.4.2.3" and returns "jquery"
+ *
+ * @internal
  */
 export function removeMinAndVersionNumbers(fileName: string) {
     // We used to use the regex /[.-]((min)|(\d+(\.\d+)*))$/ and would just .replace it twice.
@@ -2497,8 +2593,11 @@ export function removeMinAndVersionNumbers(fileName: string) {
     return end === fileName.length ? fileName : fileName.slice(0, end);
 }
 
-/** @internal */
-/** Remove an item from an array, moving everything to its right one space left. */
+/**
+ * Remove an item from an array, moving everything to its right one space left.
+ *
+ * @internal
+ */
 export function orderedRemoveItem<T>(array: T[], item: T): boolean {
     for (let i = 0; i < array.length; i++) {
         if (array[i] === item) {
@@ -2509,8 +2608,11 @@ export function orderedRemoveItem<T>(array: T[], item: T): boolean {
     return false;
 }
 
-/** @internal */
-/** Remove an item by index from an array, moving everything to its right one space left. */
+/**
+ * Remove an item by index from an array, moving everything to its right one space left.
+ *
+ * @internal
+ */
 export function orderedRemoveItemAt<T>(array: T[], index: number): void {
     // This seems to be faster than either `array.splice(i, 1)` or `array.copyWithin(i, i+ 1)`.
     for (let i = index; i < array.length - 1; i++) {
@@ -2526,8 +2628,11 @@ export function unorderedRemoveItemAt<T>(array: T[], index: number): void {
     array.pop();
 }
 
-/** @internal */
-/** Remove the *first* occurrence of `item` from the array. */
+/**
+ * Remove the *first* occurrence of `item` from the array.
+ *
+ * @internal
+ */
 export function unorderedRemoveItem<T>(array: T[], item: T) {
     return unorderedRemoveFirstItemWhere(array, element => element === item);
 }
@@ -2550,8 +2655,11 @@ export function createGetCanonicalFileName(useCaseSensitiveFileNames: boolean):
     return useCaseSensitiveFileNames ? identity : toFileNameLowerCase;
 }
 
-/** @internal */
-/** Represents a "prefix*suffix" pattern. */
+/**
+ * Represents a "prefix*suffix" pattern.
+ *
+ * @internal
+ */
 export interface Pattern {
     prefix: string;
     suffix: string;
@@ -2562,18 +2670,22 @@ export function patternText({ prefix, suffix }: Pattern): string {
     return `${prefix}*${suffix}`;
 }
 
-/** @internal */
 /**
  * Given that candidate matches pattern, returns the text matching the '*'.
  * E.g.: matchedText(tryParsePattern("foo*baz"), "foobarbaz") === "bar"
+ *
+ * @internal
  */
 export function matchedText(pattern: Pattern, candidate: string): string {
     Debug.assert(isPatternMatch(pattern, candidate));
     return candidate.substring(pattern.prefix.length, candidate.length - pattern.suffix.length);
 }
 
-/** @internal */
-/** Return the object corresponding to the best pattern to match `candidate`. */
+/**
+ * Return the object corresponding to the best pattern to match `candidate`.
+ *
+ * @internal
+ */
 export function findBestPatternMatch<T>(values: readonly T[], getPattern: (value: T) => Pattern, candidate: string): T | undefined {
     let matchedValue: T | undefined;
     // use length of prefix as betterness criteria
@@ -2719,25 +2831,27 @@ function cartesianProductWorker<T>(arrays: readonly (readonly T[])[], result: (r
 }
 
 
-/** @internal */
 /**
  * Returns string left-padded with spaces or zeros until it reaches the given length.
  *
  * @param s String to pad.
  * @param length Final padded length. If less than or equal to 's.length', returns 's' unchanged.
  * @param padString Character to use as padding (default " ").
+ *
+ * @internal
  */
 export function padLeft(s: string, length: number, padString: " " | "0" = " ") {
     return length <= s.length ? s : padString.repeat(length - s.length) + s;
 }
 
-/** @internal */
 /**
  * Returns string right-padded with spaces until it reaches the given length.
  *
  * @param s String to pad.
  * @param length Final padded length. If less than or equal to 's.length', returns 's' unchanged.
  * @param padString Character to use as padding (default " ").
+ *
+ * @internal
  */
 export function padRight(s: string, length: number, padString: " " = " ") {
     return length <= s.length ? s : s + padString.repeat(length - s.length);
@@ -2755,21 +2869,24 @@ export function takeWhile<T>(array: readonly T[], predicate: (element: T) => boo
     return array.slice(0, index);
 }
 
-/** @internal */
 /**
  * Removes the leading and trailing white space and line terminator characters from a string.
+ *
+ * @internal
  */
 export const trimString = !!String.prototype.trim ? ((s: string) => s.trim()) : (s: string) => trimStringEnd(trimStringStart(s));
 
-/** @internal */
 /**
  * Returns a copy with trailing whitespace removed.
+ *
+ * @internal
  */
 export const trimStringEnd = !!String.prototype.trimEnd ? ((s: string) => s.trimEnd()) : trimEndImpl;
 
-/** @internal */
 /**
  * Returns a copy with leading whitespace removed.
+ *
+ * @internal
  */
 export const trimStringStart = !!String.prototype.trimStart ? ((s: string) => s.trimStart()) : (s: string) => s.replace(/^\s+/g, "");
 
diff --git a/src/compiler/emitter.ts b/src/compiler/emitter.ts
index 423023d6d5..30d52243c7 100644
--- a/src/compiler/emitter.ts
+++ b/src/compiler/emitter.ts
@@ -86,7 +86,6 @@ export function isBuildInfoFile(file: string) {
     return fileExtensionIs(file, Extension.TsBuildInfo);
 }
 
-/** @internal */
 /**
  * Iterates over the source files that are expected to have an emit output.
  *
@@ -95,6 +94,8 @@ export function isBuildInfoFile(file: string) {
  * @param sourceFilesOrTargetSourceFile
  *   If an array, the full list of source files to emit.
  *   Else, calls `getSourceFilesToEmit` with the (optional) target source file to determine the list of source files to emit.
+ *
+ * @internal
  */
 export function forEachEmittedFile<T>(
     host: EmitHost, action: (emitFileNames: EmitFileNames, sourceFileOrBundle: SourceFile | Bundle | undefined) => T,
@@ -781,8 +782,11 @@ export const notImplementedResolver: EmitResolver = {
     isImportRequiredByAugmentation: notImplemented,
 };
 
-/** @internal */
-/** File that isnt present resulting in error or output files */
+/**
+ * File that isnt present resulting in error or output files
+ *
+ * @internal
+ */
 export type EmitUsingBuildInfoResult = string | readonly OutputFile[];
 
 /** @internal */
diff --git a/src/compiler/factory/baseNodeFactory.ts b/src/compiler/factory/baseNodeFactory.ts
index b592b1126d..65fa224f89 100644
--- a/src/compiler/factory/baseNodeFactory.ts
+++ b/src/compiler/factory/baseNodeFactory.ts
@@ -13,9 +13,10 @@ export interface BaseNodeFactory {
     createBaseNode(kind: SyntaxKind): Node;
 }
 
-/** @internal */
 /**
  * Creates a `BaseNodeFactory` which can be used to create `Node` instances from the constructors provided by the object allocator.
+ *
+ * @internal
  */
 export function createBaseNodeFactory(): BaseNodeFactory {
     // tslint:disable variable-name
diff --git a/src/compiler/factory/emitHelpers.ts b/src/compiler/factory/emitHelpers.ts
index b4eb142d54..6d10a3a781 100644
--- a/src/compiler/factory/emitHelpers.ts
+++ b/src/compiler/factory/emitHelpers.ts
@@ -421,10 +421,11 @@ export function compareEmitHelpers(x: EmitHelper, y: EmitHelper) {
     return compareValues(x.priority, y.priority);
 }
 
-/** @internal */
 /**
  * @param input Template string input strings
  * @param args Names which need to be made file-level unique
+ *
+ * @internal
  */
 export function helperString(input: TemplateStringsArray, ...args: string[]) {
     return (uniqueName: EmitHelperUniqueNameCallback) => {
@@ -878,7 +879,6 @@ export const exportStarHelper: UnscopedEmitHelper = {
             };`
 };
 
-/** @internal */
 /**
  * Parameters:
  *  @param receiver — The object from which the private member will be read.
@@ -926,6 +926,8 @@ export const exportStarHelper: UnscopedEmitHelper = {
  *
  * Reading from a private static method (TS 4.3+):
  *      __classPrivateFieldGet(<any>, <constructor>, "m", <function>)
+ *
+ * @internal
  */
 export const classPrivateFieldGetHelper: UnscopedEmitHelper = {
     name: "typescript:classPrivateFieldGet",
@@ -939,7 +941,6 @@ export const classPrivateFieldGetHelper: UnscopedEmitHelper = {
             };`
 };
 
-/** @internal */
 /**
  * Parameters:
  *  @param receiver — The object on which the private member will be set.
@@ -990,6 +991,8 @@ export const classPrivateFieldGetHelper: UnscopedEmitHelper = {
  * Writing to a private static method (TS 4.3+):
  *      __classPrivateFieldSet(<any>, <constructor>, <any>, "m", <function>)
  *      NOTE: This always results in a runtime error.
+ *
+ * @internal
  */
 export const classPrivateFieldSetHelper: UnscopedEmitHelper = {
     name: "typescript:classPrivateFieldSet",
@@ -1004,7 +1007,6 @@ export const classPrivateFieldSetHelper: UnscopedEmitHelper = {
             };`
 };
 
-/** @internal */
 /**
  * Parameters:
  *  @param state — One of the following:
@@ -1016,6 +1018,8 @@ export const classPrivateFieldSetHelper: UnscopedEmitHelper = {
  * Usage:
  * This helper is used to transform `#field in expression` to
  *      `__classPrivateFieldIn(<weakMap/weakSet/constructor>, expression)`
+ *
+ * @internal
  */
 export const classPrivateFieldInHelper: UnscopedEmitHelper = {
     name: "typescript:classPrivateFieldIn",
diff --git a/src/compiler/factory/utilities.ts b/src/compiler/factory/utilities.ts
index a679671d17..b6c97f8f3b 100644
--- a/src/compiler/factory/utilities.ts
+++ b/src/compiler/factory/utilities.ts
@@ -344,7 +344,6 @@ export function createExpressionForObjectLiteralElementLike(factory: NodeFactory
     }
 }
 
-/** @internal */
 /**
  * Expand the read and increment/decrement operations a pre- or post-increment or pre- or post-decrement expression.
  *
@@ -376,6 +375,8 @@ export function createExpressionForObjectLiteralElementLike(factory: NodeFactory
  * @param node The original prefix or postfix unary node.
  * @param expression The expression to use as the value to increment or decrement
  * @param resultVariable A temporary variable in which to store the result. Pass `undefined` if the result is discarded, or if the value of `<temp>` is the expected result.
+ *
+ * @internal
  */
 export function expandPreOrPostfixIncrementOrDecrementExpression(factory: NodeFactory, node: PrefixUnaryExpression | PostfixUnaryExpression, expression: Expression, recordTempVariable: (node: Identifier) => void, resultVariable: Identifier | undefined) {
     const operator = node.operator;
@@ -406,26 +407,29 @@ export function expandPreOrPostfixIncrementOrDecrementExpression(factory: NodeFa
     return expression;
 }
 
-/** @internal */
 /**
  * Gets whether an identifier should only be referred to by its internal name.
+ *
+ * @internal
  */
 export function isInternalName(node: Identifier) {
     return (getEmitFlags(node) & EmitFlags.InternalName) !== 0;
 }
 
-/** @internal */
 /**
  * Gets whether an identifier should only be referred to by its local name.
+ *
+ * @internal
  */
 export function isLocalName(node: Identifier) {
     return (getEmitFlags(node) & EmitFlags.LocalName) !== 0;
 }
 
-/** @internal */
 /**
  * Gets whether an identifier should only be referred to by its export representation if the
  * name points to an exported symbol.
+ *
+ * @internal
  */
 export function isExportName(node: Identifier) {
     return (getEmitFlags(node) & EmitFlags.ExportName) !== 0;
@@ -624,9 +628,10 @@ export function getOrCreateExternalHelpersModuleNameIfNeeded(factory: NodeFactor
     }
 }
 
-/** @internal */
 /**
  * Get the name of that target module from an import or export declaration
+ *
+ * @internal
  */
 export function getLocalNameForExternalImport(factory: NodeFactory, node: ImportDeclaration | ExportDeclaration | ImportEqualsDeclaration, sourceFile: SourceFile): Identifier | undefined {
     const namespaceDeclaration = getNamespaceDeclarationNode(node);
@@ -643,7 +648,6 @@ export function getLocalNameForExternalImport(factory: NodeFactory, node: Import
     return undefined;
 }
 
-/** @internal */
 /**
  * Get the name of a target module from an import/export declaration as should be written in the emitted output.
  * The emitted output name can be different from the input if:
@@ -651,6 +655,8 @@ export function getLocalNameForExternalImport(factory: NodeFactory, node: Import
  *  2. --out or --outFile is used, making the name relative to the rootDir
  *  3- The containing SourceFile has an entry in renamedDependencies for the import as requested by some module loaders (e.g. System).
  * Otherwise, a new StringLiteral node representing the module name will be returned.
+ *
+ * @internal
  */
 export function getExternalModuleNameLiteral(factory: NodeFactory, importNode: ImportDeclaration | ExportDeclaration | ImportEqualsDeclaration | ImportCall, sourceFile: SourceFile, host: EmitHost, resolver: EmitResolver, compilerOptions: CompilerOptions) {
     const moduleName = getExternalModuleName(importNode);
@@ -672,13 +678,14 @@ function tryRenameExternalModule(factory: NodeFactory, moduleName: LiteralExpres
     return rename ? factory.createStringLiteral(rename) : undefined;
 }
 
-/** @internal */
 /**
  * Get the name of a module as should be written in the emitted output.
  * The emitted output name can be different from the input if:
  *  1. The module has a /// <amd-module name="<new name>" />
  *  2. --out or --outFile is used, making the name relative to the rootDir
  * Otherwise, a new StringLiteral node representing the module name will be returned.
+ *
+ * @internal
  */
 export function tryGetModuleNameFromFile(factory: NodeFactory, file: SourceFile | undefined, host: EmitHost, options: CompilerOptions): StringLiteral | undefined {
     if (!file) {
@@ -697,9 +704,10 @@ function tryGetModuleNameFromDeclaration(declaration: ImportEqualsDeclaration |
     return tryGetModuleNameFromFile(factory, resolver.getExternalModuleFileFromDeclaration(declaration), host, compilerOptions);
 }
 
-/** @internal */
 /**
  * Gets the initializer of an BindingOrAssignmentElement.
+ *
+ * @internal
  */
 export function getInitializerOfBindingOrAssignmentElement(bindingElement: BindingOrAssignmentElement): Expression | undefined {
     if (isDeclarationBindingElement(bindingElement)) {
@@ -741,9 +749,10 @@ export function getInitializerOfBindingOrAssignmentElement(bindingElement: Bindi
     }
 }
 
-/** @internal */
 /**
  * Gets the name of an BindingOrAssignmentElement.
+ *
+ * @internal
  */
 export function getTargetOfBindingOrAssignmentElement(bindingElement: BindingOrAssignmentElement): BindingOrAssignmentElementTarget | undefined {
     if (isDeclarationBindingElement(bindingElement)) {
@@ -817,9 +826,10 @@ export function getTargetOfBindingOrAssignmentElement(bindingElement: BindingOrA
     return bindingElement;
 }
 
-/** @internal */
 /**
  * Determines whether an BindingOrAssignmentElement is a rest element.
+ *
+ * @internal
  */
 export function getRestIndicatorOfBindingOrAssignmentElement(bindingElement: BindingOrAssignmentElement): BindingOrAssignmentElementRestIndicator | undefined {
     switch (bindingElement.kind) {
@@ -837,9 +847,10 @@ export function getRestIndicatorOfBindingOrAssignmentElement(bindingElement: Bin
     return undefined;
 }
 
-/** @internal */
 /**
  * Gets the property name of a BindingOrAssignmentElement
+ *
+ * @internal
  */
 export function getPropertyNameOfBindingOrAssignmentElement(bindingElement: BindingOrAssignmentElement): Exclude<PropertyName, PrivateIdentifier> | undefined {
     const propertyName = tryGetPropertyNameOfBindingOrAssignmentElement(bindingElement);
@@ -904,9 +915,10 @@ function isStringOrNumericLiteral(node: Node): node is StringLiteral | NumericLi
         || kind === SyntaxKind.NumericLiteral;
 }
 
-/** @internal */
 /**
  * Gets the elements of a BindingOrAssignmentPattern
+ *
+ * @internal
  */
 export function getElementsOfBindingOrAssignmentPattern(name: BindingOrAssignmentPattern): readonly BindingOrAssignmentElement[] {
     switch (name.kind) {
@@ -1257,7 +1269,6 @@ class BinaryExpressionStateMachine<TOuterState, TState, TResult> {
     }
 }
 
-/** @internal */
 /**
  * Creates a state machine that walks a `BinaryExpression` using the heap to reduce call-stack depth on a large tree.
  * @param onEnter Callback evaluated when entering a `BinaryExpression`. Returns new user-defined state to associate with the node while walking.
@@ -1266,6 +1277,8 @@ class BinaryExpressionStateMachine<TOuterState, TState, TResult> {
  * @param onExit Callback evaluated when exiting a `BinaryExpression`. The result returned will either be folded into the parent's state, or returned from the walker if at the top frame.
  * @param foldState Callback evaluated when the result from a nested `onExit` should be folded into the state of that node's parent.
  * @returns A function that walks a `BinaryExpression` node using the above callbacks, returning the result of the call to `onExit` from the outermost `BinaryExpression` node.
+ *
+ * @internal
  */
  export function createBinaryExpressionTrampoline<TState, TResult>(
     onEnter: (node: BinaryExpression, prev: TState | undefined) => TState,
@@ -1275,7 +1288,6 @@ class BinaryExpressionStateMachine<TOuterState, TState, TResult> {
     onExit: (node: BinaryExpression, userState: TState) => TResult,
     foldState: ((userState: TState, result: TResult, side: "left" | "right") => TState) | undefined,
 ): (node: BinaryExpression) => TResult;
-/** @internal */
 /**
  * Creates a state machine that walks a `BinaryExpression` using the heap to reduce call-stack depth on a large tree.
  * @param onEnter Callback evaluated when entering a `BinaryExpression`. Returns new user-defined state to associate with the node while walking.
@@ -1284,6 +1296,8 @@ class BinaryExpressionStateMachine<TOuterState, TState, TResult> {
  * @param onExit Callback evaluated when exiting a `BinaryExpression`. The result returned will either be folded into the parent's state, or returned from the walker if at the top frame.
  * @param foldState Callback evaluated when the result from a nested `onExit` should be folded into the state of that node's parent.
  * @returns A function that walks a `BinaryExpression` node using the above callbacks, returning the result of the call to `onExit` from the outermost `BinaryExpression` node.
+ *
+ * @internal
  */
 export function createBinaryExpressionTrampoline<TOuterState, TState, TResult>(
     onEnter: (node: BinaryExpression, prev: TState | undefined, outerState: TOuterState) => TState,
@@ -1333,9 +1347,10 @@ export function elideNodes<T extends Node>(factory: NodeFactory, nodes: NodeArra
     return setTextRange(factory.createNodeArray([], nodes.hasTrailingComma), nodes);
 }
 
-/** @internal */
 /**
  * Gets the node from which a name should be generated.
+ *
+ * @internal
  */
 export function getNodeForGeneratedName(name: GeneratedIdentifier | GeneratedPrivateIdentifier) {
     if (name.autoGenerateFlags & GeneratedIdentifierFlags.Node) {
@@ -1360,14 +1375,16 @@ export function getNodeForGeneratedName(name: GeneratedIdentifier | GeneratedPri
     return name;
 }
 
-/** @internal */
 /**
  * Formats a prefix or suffix of a generated name.
+ *
+ * @internal
  */
 export function formatGeneratedNamePart(part: string | undefined): string;
-/** @internal */
 /**
  * Formats a prefix or suffix of a generated name. If the part is a {@link GeneratedNamePart}, calls {@link generateName} to format the source node.
+ *
+ * @internal
  */
 export function formatGeneratedNamePart(part: string | GeneratedNamePart | undefined, generateName: (name: GeneratedIdentifier | GeneratedPrivateIdentifier) => string): string;
 /** @internal */
@@ -1389,16 +1406,16 @@ function formatIdentifierWorker(node: Identifier | PrivateIdentifier, generateNa
         idText(node);
 }
 
-/** @internal */
 /**
  * Formats a generated name.
  * @param privateName When `true`, inserts a `#` character at the start of the result.
  * @param prefix The prefix (if any) to include before the base name.
  * @param baseName The base name for the generated name.
  * @param suffix The suffix (if any) to include after the base name.
+ *
+ * @internal
  */
 export function formatGeneratedName(privateName: boolean, prefix: string | undefined, baseName: string, suffix: string | undefined): string;
-/** @internal */
 /**
  * Formats a generated name.
  * @param privateName When `true`, inserts a `#` character at the start of the result.
@@ -1406,6 +1423,8 @@ export function formatGeneratedName(privateName: boolean, prefix: string | undef
  * @param baseName The base name for the generated name.
  * @param suffix The suffix (if any) to include after the base name.
  * @param generateName Called to format the source node of {@link prefix} when it is a {@link GeneratedNamePart}.
+ *
+ * @internal
  */
 export function formatGeneratedName(privateName: boolean, prefix: string | GeneratedNamePart | undefined, baseName: string | Identifier | PrivateIdentifier, suffix: string | GeneratedNamePart | undefined, generateName: (name: GeneratedIdentifier | GeneratedPrivateIdentifier) => string): string;
 /** @internal */
@@ -1417,9 +1436,10 @@ export function formatGeneratedName(privateName: boolean, prefix: string | Gener
 }
 
 
-/** @internal */
 /**
  * Creates a private backing field for an `accessor` {@link PropertyDeclaration}.
+ *
+ * @internal
  */
 export function createAccessorPropertyBackingField(factory: NodeFactory, node: PropertyDeclaration, modifiers: ModifiersArray | undefined, initializer: Expression | undefined) {
     return factory.updatePropertyDeclaration(
@@ -1432,9 +1452,10 @@ export function createAccessorPropertyBackingField(factory: NodeFactory, node: P
     );
 }
 
-/** @internal */
 /**
  * Creates a {@link GetAccessorDeclaration} that reads from a private backing field.
+ *
+ * @internal
  */
 export function createAccessorPropertyGetRedirector(factory: NodeFactory, node: PropertyDeclaration, modifiers: ModifiersArray | undefined, name: PropertyName): GetAccessorDeclaration {
     return factory.createGetAccessorDeclaration(
@@ -1453,9 +1474,10 @@ export function createAccessorPropertyGetRedirector(factory: NodeFactory, node:
     );
 }
 
-/** @internal */
 /**
  * Creates a {@link SetAccessorDeclaration} that writes to a private backing field.
+ *
+ * @internal
  */
 export function createAccessorPropertySetRedirector(factory: NodeFactory, node: PropertyDeclaration, modifiers: ModifiersArray | undefined, name: PropertyName): SetAccessorDeclaration {
     return factory.createSetAccessorDeclaration(
diff --git a/src/compiler/moduleSpecifiers.ts b/src/compiler/moduleSpecifiers.ts
index 78858ac29e..cfa2e7a609 100644
--- a/src/compiler/moduleSpecifiers.ts
+++ b/src/compiler/moduleSpecifiers.ts
@@ -180,8 +180,11 @@ function tryGetModuleSpecifiersFromCacheWorker(
     return [cached?.moduleSpecifiers, moduleSourceFile, cached?.modulePaths, cache];
 }
 
-/** @internal */
-/** Returns an import for each symlink and for the realpath. */
+/**
+ * Returns an import for each symlink and for the realpath.
+ *
+ * @internal
+ */
 export function getModuleSpecifiers(
     moduleSymbol: Symbol,
     checker: TypeChecker,
diff --git a/src/compiler/parser.ts b/src/compiler/parser.ts
index 40c9fda81e..2abe92843f 100644
--- a/src/compiler/parser.ts
+++ b/src/compiler/parser.ts
@@ -915,7 +915,6 @@ export function forEachChild<T>(node: Node, cbNode: (node: Node) => T | undefine
     return fn === undefined ? undefined : fn(node, cbNode, cbNodes);
 }
 
-/** @internal */
 /**
  * Invokes a callback for each child of the given node. The 'cbNode' callback is invoked for all child nodes
  * stored in properties. If a 'cbNodes' callback is specified, it is invoked for embedded arrays; additionally,
@@ -928,6 +927,8 @@ export function forEachChild<T>(node: Node, cbNode: (node: Node) => T | undefine
  *
  * @remarks Unlike `forEachChild`, `forEachChildRecursively` handles recursively invoking the traversal on each child node found,
  * and while doing so, handles traversing the structure without relying on the callstack to encode the tree structure.
+ *
+ * @internal
  */
 export function forEachChildRecursively<T>(rootNode: Node, cbNode: (node: Node, parent: Node) => T | "skip" | undefined, cbNodes?: (nodes: NodeArray<Node>, parent: Node) => T | "skip" | undefined): T | undefined {
     const queue: (Node | NodeArray<Node>)[] = gatherPossibleChildren(rootNode);
diff --git a/src/compiler/path.ts b/src/compiler/path.ts
index 6bdb17f88a..7f84ae19c6 100644
--- a/src/compiler/path.ts
+++ b/src/compiler/path.ts
@@ -4,11 +4,12 @@ import {
     identity, lastOrUndefined, Path, some, startsWith, stringContains,
 } from "./_namespaces/ts";
 
-/** @internal */
 /**
  * Internally, we represent paths as strings with '/' as the directory separator.
  * When we make system calls (eg: LanguageServiceHost.getDirectory()),
  * we expect the host to correctly handle paths in our specified format.
+ *
+ * @internal
  */
 export const directorySeparator = "/";
 /** @internal */
@@ -18,41 +19,44 @@ const backslashRegExp = /\\/g;
 
 //// Path Tests
 
-/** @internal */
 /**
  * Determines whether a charCode corresponds to `/` or `\`.
+ *
+ * @internal
  */
 export function isAnyDirectorySeparator(charCode: number): boolean {
     return charCode === CharacterCodes.slash || charCode === CharacterCodes.backslash;
 }
 
-/** @internal */
 /**
  * Determines whether a path starts with a URL scheme (e.g. starts with `http://`, `ftp://`, `file://`, etc.).
+ *
+ * @internal
  */
 export function isUrl(path: string) {
     return getEncodedRootLength(path) < 0;
 }
 
-/** @internal */
 /**
  * Determines whether a path is an absolute disk path (e.g. starts with `/`, or a dos path
  * like `c:`, `c:\` or `c:/`).
+ *
+ * @internal
  */
 export function isRootedDiskPath(path: string) {
     return getEncodedRootLength(path) > 0;
 }
 
-/** @internal */
 /**
  * Determines whether a path consists only of a path root.
+ *
+ * @internal
  */
 export function isDiskPathRoot(path: string) {
     const rootLength = getEncodedRootLength(path);
     return rootLength > 0 && rootLength === path.length;
 }
 
-/** @internal */
 /**
  * Determines whether a path starts with an absolute path component (i.e. `/`, `c:/`, `file://`, etc.).
  *
@@ -67,23 +71,27 @@ export function isDiskPathRoot(path: string) {
  * pathIsAbsolute("path/to/file.ext") === false
  * pathIsAbsolute("./path/to/file.ext") === false
  * ```
+ *
+ * @internal
  */
 export function pathIsAbsolute(path: string): boolean {
     return getEncodedRootLength(path) !== 0;
 }
 
-/** @internal */
 /**
  * Determines whether a path starts with a relative path component (i.e. `.` or `..`).
+ *
+ * @internal
  */
 export function pathIsRelative(path: string): boolean {
     return /^\.\.?($|[\\/])/.test(path);
 }
 
-/** @internal */
 /**
  * Determines whether a path is neither relative nor absolute, e.g. "path/to/file".
  * Also known misleadingly as "non-relative".
+ *
+ * @internal
  */
 export function pathIsBareSpecifier(path: string): boolean {
     return !pathIsAbsolute(path) && !pathIsRelative(path);
@@ -110,9 +118,10 @@ export function fileExtensionIsOneOf(path: string, extensions: readonly string[]
     return false;
 }
 
-/** @internal */
 /**
  * Determines whether a path has a trailing separator (`/` or `\\`).
+ *
+ * @internal
  */
 export function hasTrailingDirectorySeparator(path: string) {
     return path.length > 0 && isAnyDirectorySeparator(path.charCodeAt(path.length - 1));
@@ -195,7 +204,6 @@ function getEncodedRootLength(path: string): number {
     return 0;
 }
 
-/** @internal */
 /**
  * Returns length of the root part of a path or URL (i.e. length of "/", "x:/", "//server/share/, file:///user/files").
  *
@@ -220,13 +228,14 @@ function getEncodedRootLength(path: string): number {
  * getRootLength("http://server") === 13      // "http://server"
  * getRootLength("http://server/path") === 14 // "http://server/"
  * ```
+ *
+ * @internal
  */
 export function getRootLength(path: string) {
     const rootLength = getEncodedRootLength(path);
     return rootLength < 0 ? ~rootLength : rootLength;
 }
 
-/** @internal */
 /**
  * Returns the path except for its basename. Semantics align with NodeJS's `path.dirname`
  * except that we support URLs as well.
@@ -247,9 +256,10 @@ export function getRootLength(path: string) {
  * getDirectoryPath("http://typescriptlang.org/") === "http://typescriptlang.org/"
  * getDirectoryPath("http://typescriptlang.org") === "http://typescriptlang.org"
  * ```
+ *
+ * @internal
  */
 export function getDirectoryPath(path: Path): Path;
-/** @internal */
 /**
  * Returns the path except for its basename. Semantics align with NodeJS's `path.dirname`
  * except that we support URLs as well.
@@ -278,6 +288,8 @@ export function getDirectoryPath(path: Path): Path;
  * getDirectoryPath("file:///") === "file:///"
  * getDirectoryPath("file://") === "file://"
  * ```
+ *
+ * @internal
  */
 export function getDirectoryPath(path: string): string;
 /** @internal */
@@ -294,7 +306,6 @@ export function getDirectoryPath(path: string): string {
     return path.slice(0, Math.max(rootLength, path.lastIndexOf(directorySeparator)));
 }
 
-/** @internal */
 /**
  * Returns the path except for its containing directory name.
  * Semantics align with NodeJS's `path.basename` except that we support URL's as well.
@@ -323,9 +334,10 @@ export function getDirectoryPath(path: string): string {
  * getBaseFileName("file:///") === ""
  * getBaseFileName("file://") === ""
  * ```
+ *
+ * @internal
  */
 export function getBaseFileName(path: string): string;
-/** @internal */
 /**
  * Gets the portion of a path following the last (non-terminal) separator (`/`).
  * Semantics align with NodeJS's `path.basename` except that we support URL's as well.
@@ -337,6 +349,8 @@ export function getBaseFileName(path: string): string;
  * getBaseFileName("/path/to/file.js", [".ext", ".js"], true) === "file"
  * getBaseFileName("/path/to/file.ext", ".EXT", false) === "file.ext"
  * ```
+ *
+ * @internal
  */
 export function getBaseFileName(path: string, extensions: string | readonly string[], ignoreCase: boolean): string;
 /** @internal */
@@ -376,7 +390,6 @@ function getAnyExtensionFromPathWorker(path: string, extensions: string | readon
     return "";
 }
 
-/** @internal */
 /**
  * Gets the file extension for a path.
  *
@@ -386,9 +399,10 @@ function getAnyExtensionFromPathWorker(path: string, extensions: string | readon
  * getAnyExtensionFromPath("/path/to/file") === ""
  * getAnyExtensionFromPath("/path/to.ext/file") === ""
  * ```
+ *
+ * @internal
  */
 export function getAnyExtensionFromPath(path: string): string;
-/** @internal */
 /**
  * Gets the file extension for a path, provided it is one of the provided extensions.
  *
@@ -397,6 +411,8 @@ export function getAnyExtensionFromPath(path: string): string;
  * getAnyExtensionFromPath("/path/to/file.js", ".ext", true) === ""
  * getAnyExtensionFromPath("/path/to/file.js", [".ext", ".js"], true) === ".js"
  * getAnyExtensionFromPath("/path/to/file.ext", ".EXT", false) === ""
+ *
+ * @internal
  */
 export function getAnyExtensionFromPath(path: string, extensions: string | readonly string[], ignoreCase: boolean): string;
 /** @internal */
@@ -421,7 +437,6 @@ function pathComponents(path: string, rootLength: number) {
     return [root, ...rest];
 }
 
-/** @internal */
 /**
  * Parse a path into an array containing a root component (at index 0) and zero or more path
  * components (at indices > 0). The result is not normalized.
@@ -451,6 +466,9 @@ function pathComponents(path: string, rootLength: number) {
  * getPathComponents("file:///path/to/") === ["file:///", "path", "to"]
  * getPathComponents("file:///") === ["file:///"]
  * getPathComponents("file://") === ["file://"]
+ * ```
+ *
+ * @internal
  */
 export function getPathComponents(path: string, currentDirectory = "") {
     path = combinePaths(currentDirectory, path);
@@ -459,7 +477,6 @@ export function getPathComponents(path: string, currentDirectory = "") {
 
 //// Path Formatting
 
-/** @internal */
 /**
  * Formats a parsed path consisting of a root component (at index 0) and zero or more path
  * segments (at indices > 0).
@@ -467,6 +484,8 @@ export function getPathComponents(path: string, currentDirectory = "") {
  * ```ts
  * getPathFromPathComponents(["/", "path", "to", "file.ext"]) === "/path/to/file.ext"
  * ```
+ *
+ * @internal
  */
 export function getPathFromPathComponents(pathComponents: readonly string[]) {
     if (pathComponents.length === 0) return "";
@@ -477,9 +496,10 @@ export function getPathFromPathComponents(pathComponents: readonly string[]) {
 
 //// Path Normalization
 
-/** @internal */
 /**
  * Normalize path separators, converting `\` into `/`.
+ *
+ * @internal
  */
 export function normalizeSlashes(path: string): string {
     return path.indexOf("\\") !== -1
@@ -487,10 +507,11 @@ export function normalizeSlashes(path: string): string {
         : path;
 }
 
-/** @internal */
 /**
  * Reduce an array of path components to a more simplified path by navigating any
  * `"."` or `".."` entries in the path.
+ *
+ * @internal
  */
 export function reducePathComponents(components: readonly string[]) {
     if (!some(components)) return [];
@@ -513,7 +534,6 @@ export function reducePathComponents(components: readonly string[]) {
     return reduced;
 }
 
-/** @internal */
 /**
  * Combines paths. If a path is absolute, it replaces any previous path. Relative paths are not simplified.
  *
@@ -531,6 +551,8 @@ export function reducePathComponents(components: readonly string[]) {
  * combinePaths("file:///path", "to", "file.ext") === "file:///path/to/file.ext"
  * combinePaths("file:///path", "file:///to", "file.ext") === "file:///to/file.ext"
  * ```
+ *
+ * @internal
  */
 export function combinePaths(path: string, ...paths: (string | undefined)[]): string {
     if (path) path = normalizeSlashes(path);
@@ -547,7 +569,6 @@ export function combinePaths(path: string, ...paths: (string | undefined)[]): st
     return path;
 }
 
-/** @internal */
 /**
  * Combines and resolves paths. If a path is absolute, it replaces any previous path. Any
  * `.` and `..` path components are resolved. Trailing directory separators are preserved.
@@ -557,12 +578,13 @@ export function combinePaths(path: string, ...paths: (string | undefined)[]): st
  * resolvePath("/path", "to", "file.ext/") === "path/to/file.ext/"
  * resolvePath("/path", "dir", "..", "to", "file.ext") === "path/to/file.ext"
  * ```
+ *
+ * @internal
  */
 export function resolvePath(path: string, ...paths: (string | undefined)[]): string {
     return normalizePath(some(paths) ? combinePaths(path, ...paths) : normalizeSlashes(path));
 }
 
-/** @internal */
 /**
  * Parse a path into an array containing a root component (at index 0) and zero or more path
  * components (at indices > 0). The result is normalized.
@@ -572,6 +594,8 @@ export function resolvePath(path: string, ...paths: (string | undefined)[]): str
  * ```ts
  * getNormalizedPathComponents("to/dir/../file.ext", "/path/") === ["/", "path", "to", "file.ext"]
  * ```
+ *
+ * @internal
  */
 export function getNormalizedPathComponents(path: string, currentDirectory: string | undefined) {
     return reducePathComponents(getPathComponents(path, currentDirectory));
@@ -622,7 +646,6 @@ export function toPath(fileName: string, basePath: string | undefined, getCanoni
 
 //// Path Mutation
 
-/** @internal */
 /**
  * Removes a trailing directory separator from a path, if it does not already have one.
  *
@@ -630,6 +653,8 @@ export function toPath(fileName: string, basePath: string | undefined, getCanoni
  * removeTrailingDirectorySeparator("/path/to/file.ext") === "/path/to/file.ext"
  * removeTrailingDirectorySeparator("/path/to/file.ext/") === "/path/to/file.ext"
  * ```
+ *
+ * @internal
  */
 export function removeTrailingDirectorySeparator(path: Path): Path;
 /** @internal */
@@ -643,7 +668,6 @@ export function removeTrailingDirectorySeparator(path: string) {
     return path;
 }
 
-/** @internal */
 /**
  * Adds a trailing directory separator to a path, if it does not already have one.
  *
@@ -651,6 +675,8 @@ export function removeTrailingDirectorySeparator(path: string) {
  * ensureTrailingDirectorySeparator("/path/to/file.ext") === "/path/to/file.ext/"
  * ensureTrailingDirectorySeparator("/path/to/file.ext/") === "/path/to/file.ext/"
  * ```
+ *
+ * @internal
  */
 export function ensureTrailingDirectorySeparator(path: Path): Path;
 /** @internal */
@@ -664,7 +690,6 @@ export function ensureTrailingDirectorySeparator(path: string) {
     return path;
 }
 
-/** @internal */
 /**
  * Ensures a path is either absolute (prefixed with `/` or `c:`) or dot-relative (prefixed
  * with `./` or `../`) so as not to be confused with an unprefixed module name.
@@ -675,21 +700,23 @@ export function ensureTrailingDirectorySeparator(path: string) {
  * ensurePathIsNonModuleName("../path/to/file.ext") === "../path/to/file.ext"
  * ensurePathIsNonModuleName("path/to/file.ext") === "./path/to/file.ext"
  * ```
+ *
+ * @internal
  */
 export function ensurePathIsNonModuleName(path: string): string {
     return !pathIsAbsolute(path) && !pathIsRelative(path) ? "./" + path : path;
 }
 
-/** @internal */
 /**
  * Changes the extension of a path to the provided extension.
  *
  * ```ts
  * changeAnyExtension("/path/to/file.ext", ".js") === "/path/to/file.js"
  * ```
+ *
+ * @internal
  */
 export function changeAnyExtension(path: string, ext: string): string;
-/** @internal */
 /**
  * Changes the extension of a path to the provided extension if it has one of the provided extensions.
  *
@@ -698,6 +725,8 @@ export function changeAnyExtension(path: string, ext: string): string;
  * changeAnyExtension("/path/to/file.ext", ".js", ".ts") === "/path/to/file.ext"
  * changeAnyExtension("/path/to/file.ext", ".js", [".ext", ".ts"]) === "/path/to/file.js"
  * ```
+ *
+ * @internal
  */
 export function changeAnyExtension(path: string, ext: string, extensions: string | readonly string[], ignoreCase: boolean): string;
 /** @internal */
@@ -747,25 +776,28 @@ function comparePathsWorker(a: string, b: string, componentComparer: (a: string,
     return compareValues(aComponents.length, bComponents.length);
 }
 
-/** @internal */
 /**
  * Performs a case-sensitive comparison of two paths. Path roots are always compared case-insensitively.
+ *
+ * @internal
  */
 export function comparePathsCaseSensitive(a: string, b: string) {
     return comparePathsWorker(a, b, compareStringsCaseSensitive);
 }
 
-/** @internal */
 /**
  * Performs a case-insensitive comparison of two paths.
+ *
+ * @internal
  */
 export function comparePathsCaseInsensitive(a: string, b: string) {
     return comparePathsWorker(a, b, compareStringsCaseInsensitive);
 }
 
-/** @internal */
 /**
  * Compare two paths using the provided case sensitivity.
+ *
+ * @internal
  */
 export function comparePaths(a: string, b: string, ignoreCase?: boolean): Comparison;
 /** @internal */
@@ -782,9 +814,10 @@ export function comparePaths(a: string, b: string, currentDirectory?: string | b
     return comparePathsWorker(a, b, getStringComparer(ignoreCase));
 }
 
-/** @internal */
 /**
  * Determines whether a `parent` path contains a `child` path using the provide case sensitivity.
+ *
+ * @internal
  */
 export function containsPath(parent: string, child: string, ignoreCase?: boolean): boolean;
 /** @internal */
@@ -817,12 +850,13 @@ export function containsPath(parent: string, child: string, currentDirectory?: s
     return true;
 }
 
-/** @internal */
 /**
  * Determines whether `fileName` starts with the specified `directoryName` using the provided path canonicalization callback.
  * Comparison is case-sensitive between the canonical paths.
  *
  * Use `containsPath` if file names are not already reduced and absolute.
+ *
+ * @internal
  */
 export function startsWithDirectory(fileName: string, directoryName: string, getCanonicalFileName: GetCanonicalFileName): boolean {
     const canonicalFileName = getCanonicalFileName(fileName);
@@ -857,14 +891,16 @@ export function getPathComponentsRelativeTo(from: string, to: string, stringEqua
     return ["", ...relative, ...components];
 }
 
-/** @internal */
 /**
  * Gets a relative path that can be used to traverse between `from` and `to`.
+ *
+ * @internal
  */
 export function getRelativePathFromDirectory(from: string, to: string, ignoreCase: boolean): string;
-/** @internal */
 /**
  * Gets a relative path that can be used to traverse between `from` and `to`.
+ *
+ * @internal
  */
 export function getRelativePathFromDirectory(fromDirectory: string, to: string, getCanonicalFileName: GetCanonicalFileName): string; // eslint-disable-line @typescript-eslint/unified-signatures
 /** @internal */
@@ -908,9 +944,10 @@ export function getRelativePathToDirectoryOrUrl(directoryPathOrUrl: string, rela
 
 //// Path Traversal
 
-/** @internal */
 /**
  * Calls `callback` on `directory` and every ancestor directory it has, returning the first defined result.
+ *
+ * @internal
  */
 export function forEachAncestorDirectory<T>(directory: Path, callback: (directory: Path) => T | undefined): T | undefined;
 /** @internal */
diff --git a/src/compiler/perfLogger.ts b/src/compiler/perfLogger.ts
index eb225b9ce4..34a59208d6 100644
--- a/src/compiler/perfLogger.ts
+++ b/src/compiler/perfLogger.ts
@@ -38,6 +38,9 @@ catch (e) {
     etwModule = undefined;
 }
 
-/** @internal */
-/** Performance logger that will generate ETW events if possible - check for `logEvent` member, as `etwModule` will be `{}` when browserified */
+/**
+ * Performance logger that will generate ETW events if possible - check for `logEvent` member, as `etwModule` will be `{}` when browserified
+ *
+ * @internal
+ */
 export const perfLogger: PerfLogger = etwModule && etwModule.logEvent ? etwModule : nullLogger;
diff --git a/src/compiler/performance.ts b/src/compiler/performance.ts
index 859dab4134..774f0880e0 100644
--- a/src/compiler/performance.ts
+++ b/src/compiler/performance.ts
@@ -54,11 +54,12 @@ const marks = new Map<string, number>();
 const counts = new Map<string, number>();
 const durations = new Map<string, number>();
 
-/** @internal */
 /**
  * Marks a performance event.
  *
  * @param markName The name of the mark.
+ *
+ * @internal
  */
 export function mark(markName: string) {
     if (enabled) {
@@ -69,7 +70,6 @@ export function mark(markName: string) {
     }
 }
 
-/** @internal */
 /**
  * Adds a performance measurement with the specified name.
  *
@@ -78,6 +78,8 @@ export function mark(markName: string) {
  *      profiler was enabled is used.
  * @param endMarkName The name of the ending mark. If not supplied, the current timestamp is
  *      used.
+ *
+ * @internal
  */
 export function measure(measureName: string, startMarkName?: string, endMarkName?: string) {
     if (enabled) {
@@ -89,31 +91,34 @@ export function measure(measureName: string, startMarkName?: string, endMarkName
     }
 }
 
-/** @internal */
 /**
  * Gets the number of times a marker was encountered.
  *
  * @param markName The name of the mark.
+ *
+ * @internal
  */
 export function getCount(markName: string) {
     return counts.get(markName) || 0;
 }
 
-/** @internal */
 /**
  * Gets the total duration of all measurements with the supplied name.
  *
  * @param measureName The name of the measure whose durations should be accumulated.
+ *
+ * @internal
  */
 export function getDuration(measureName: string) {
     return durations.get(measureName) || 0;
 }
 
-/** @internal */
 /**
  * Iterate over each measure, performing some action
  *
  * @param cb The action to perform for each measure
+ *
+ * @internal
  */
 export function forEachMeasure(cb: (measureName: string, duration: number) => void) {
     durations.forEach((duration, measureName) => cb(measureName, duration));
@@ -144,16 +149,20 @@ export function clearMarks(name?: string) {
     performanceImpl?.clearMarks(name);
 }
 
-/** @internal */
 /**
  * Indicates whether the performance API is enabled.
+ *
+ * @internal
  */
 export function isEnabled() {
     return enabled;
 }
 
-/** @internal */
-/** Enables (and resets) performance measurements for the compiler. */
+/**
+ * Enables (and resets) performance measurements for the compiler.
+ *
+ * @internal
+ */
 export function enable(system: System = sys) {
     if (!enabled) {
         enabled = true;
@@ -172,8 +181,11 @@ export function enable(system: System = sys) {
     return true;
 }
 
-/** @internal */
-/** Disables performance measurements for the compiler. */
+/**
+ * Disables performance measurements for the compiler.
+ *
+ * @internal
+ */
 export function disable() {
     if (enabled) {
         marks.clear();
diff --git a/src/compiler/performanceCore.ts b/src/compiler/performanceCore.ts
index 4373319375..ce65f1d889 100644
--- a/src/compiler/performanceCore.ts
+++ b/src/compiler/performanceCore.ts
@@ -135,8 +135,11 @@ export function tryGetNativePerformanceHooks() {
     return nativePerformanceHooks;
 }
 
-/** @internal */
-/** Gets a timestamp with (at least) ms resolution */
+/**
+ * Gets a timestamp with (at least) ms resolution
+ *
+ * @internal
+ */
 export const timestamp =
     nativePerformance ? () => nativePerformance.now() :
     Date.now ? Date.now :
diff --git a/src/compiler/program.ts b/src/compiler/program.ts
index c8dd95b53c..24a4992ed6 100644
--- a/src/compiler/program.ts
+++ b/src/compiler/program.ts
@@ -4378,11 +4378,12 @@ export function resolveProjectReferencePath(hostOrRef: ResolveProjectReferencePa
     return resolveConfigFileProjectName(passedInRef.path);
 }
 
-/** @internal */
 /**
  * Returns a DiagnosticMessage if we won't include a resolved module due to its extension.
  * The DiagnosticMessage's parameters are the imported module name, and the filename it resolved to.
  * This returns a diagnostic even if the module will be an untyped module.
+ *
+ * @internal
  */
 export function getResolutionDiagnostic(options: CompilerOptions, { extension }: ResolvedModuleFull): DiagnosticMessage | undefined {
     switch (extension) {
diff --git a/src/compiler/resolutionCache.ts b/src/compiler/resolutionCache.ts
index e62622b7a1..482248378e 100644
--- a/src/compiler/resolutionCache.ts
+++ b/src/compiler/resolutionCache.ts
@@ -17,8 +17,11 @@ import {
     returnTrue, Set, some, SourceFile, startsWith, stringContains, trace, unorderedRemoveItem, WatchDirectoryFlags,
 } from "./_namespaces/ts";
 
-/** @internal */
-/** This is the cache of module/typedirectives resolution that can be retained across program */
+/**
+ * This is the cache of module/typedirectives resolution that can be retained across program
+ *
+ * @internal
+ */
 export interface ResolutionCache {
     startRecordingFilesWithChangedResolutions(): void;
     finishRecordingFilesWithChangedResolutions(): Path[] | undefined;
@@ -124,12 +127,13 @@ export function removeIgnoredPath(path: Path): Path | undefined {
         path;
 }
 
-/** @internal */
 /**
  * Filter out paths like
  * "/", "/user", "/user/username", "/user/username/folderAtRoot",
  * "c:/", "c:/users", "c:/users/username", "c:/users/username/folderAtRoot", "c:/folderAtRoot"
  * @param dirPath
+ *
+ * @internal
  */
 export function canWatchDirectoryOrFile(dirPath: Path) {
     const rootLength = getRootLength(dirPath);
diff --git a/src/compiler/semver.ts b/src/compiler/semver.ts
index 3196dbe317..0f2b85848d 100644
--- a/src/compiler/semver.ts
+++ b/src/compiler/semver.ts
@@ -28,9 +28,10 @@ const buildRegExp = /^[a-z0-9-]+(?:\.[a-z0-9-]+)*$/i;
 // > Numeric identifiers MUST NOT include leading zeroes.
 const numericIdentifierRegExp = /^(0|[1-9]\d*)$/;
 
-/** @internal */
 /**
  * Describes a precise semantic version number, https://semver.org
+ *
+ * @internal
  */
 export class Version {
     static readonly zero = new Version(0, 0, 0);
@@ -167,9 +168,10 @@ function comparePrereleaseIdentifiers(left: readonly string[], right: readonly s
     return compareValues(left.length, right.length);
 }
 
-/** @internal */
 /**
  * Describes a semantic version range, per https://github.com/npm/node-semver#ranges
+ *
+ * @internal
  */
 export class VersionRange {
     private _alternatives: readonly (readonly Comparator[])[];
diff --git a/src/compiler/sourcemap.ts b/src/compiler/sourcemap.ts
index ba810d6d00..3fea87a803 100644
--- a/src/compiler/sourcemap.ts
+++ b/src/compiler/sourcemap.ts
@@ -348,9 +348,10 @@ export function getLineInfo(text: string, lineStarts: readonly number[]): LineIn
     };
 }
 
-/** @internal */
 /**
  * Tries to find the sourceMappingURL comment at the end of a file.
+ *
+ * @internal
  */
 export function tryGetSourceMappingURL(lineInfo: LineInfo) {
     for (let index = lineInfo.getLineCount() - 1; index >= 0; index--) {
diff --git a/src/compiler/transformer.ts b/src/compiler/transformer.ts
index 4e6b893c42..6a905084c0 100644
--- a/src/compiler/transformer.ts
+++ b/src/compiler/transformer.ts
@@ -158,7 +158,6 @@ export function noEmitNotification(hint: EmitHint, node: Node, callback: (hint:
     callback(hint, node);
 }
 
-/** @internal */
 /**
  * Transforms an array of SourceFiles by passing them through each transformer.
  *
@@ -168,6 +167,8 @@ export function noEmitNotification(hint: EmitHint, node: Node, callback: (hint:
  * @param nodes An array of nodes to transform.
  * @param transforms An array of `TransformerFactory` callbacks.
  * @param allowDtsFiles A value indicating whether to allow the transformation of .d.ts files.
+ *
+ * @internal
  */
 export function transformNodes<T extends Node>(resolver: EmitResolver | undefined, host: EmitHost | undefined, factory: NodeFactory, options: CompilerOptions, nodes: readonly T[], transformers: readonly TransformerFactory<T>[], allowDtsFiles: boolean): TransformationResult<T> {
     const enabledSyntaxKindFeatures = new Array<SyntaxKindFeatureFlags>(SyntaxKind.Count);
diff --git a/src/compiler/transformers/classFields.ts b/src/compiler/transformers/classFields.ts
index 103561b53f..28be1f5f87 100644
--- a/src/compiler/transformers/classFields.ts
+++ b/src/compiler/transformers/classFields.ts
@@ -159,13 +159,14 @@ const enum ClassFacts {
     NeedsSubstitutionForThisInClassStaticField = 1 << 3,
 }
 
-/** @internal */
 /**
  * Transforms ECMAScript Class Syntax.
  * TypeScript parameter property syntax is transformed in the TypeScript transformer.
  * For now, this transforms public field declarations using TypeScript class semantics,
  * where declarations are elided and initializers are transformed as assignments in the constructor.
  * When --useDefineForClassFields is on, this transforms to ECMAScript semantics, with Object.defineProperty.
+ *
+ * @internal
  */
 export function transformClassFields(context: TransformationContext): (x: SourceFile | Bundle) => SourceFile | Bundle {
     const {
diff --git a/src/compiler/transformers/declarations.ts b/src/compiler/transformers/declarations.ts
index bcb8114d28..10581e002c 100644
--- a/src/compiler/transformers/declarations.ts
+++ b/src/compiler/transformers/declarations.ts
@@ -85,12 +85,13 @@ const declarationEmitNodeBuilderFlags =
     NodeBuilderFlags.GenerateNamesForShadowedTypeParams |
     NodeBuilderFlags.NoTruncation;
 
-/** @internal */
 /**
  * Transforms a ts file into a .d.ts file
  * This process requires type information, which is retrieved through the emit resolver. Because of this,
  * in many places this transformer assumes it will be operating on parse tree nodes directly.
  * This means that _no transforms should be allowed to occur before this one_.
+ *
+ * @internal
  */
 export function transformDeclarations(context: TransformationContext) {
     const throwDiagnostic = () => Debug.fail("Diagnostic emitted without context");
diff --git a/src/compiler/transformers/destructuring.ts b/src/compiler/transformers/destructuring.ts
index 3198bdead1..b4f4739a80 100644
--- a/src/compiler/transformers/destructuring.ts
+++ b/src/compiler/transformers/destructuring.ts
@@ -34,7 +34,6 @@ export const enum FlattenLevel {
     ObjectRest,
 }
 
-/** @internal */
 /**
  * Flattens a DestructuringAssignment or a VariableDeclaration to an expression.
  *
@@ -45,6 +44,8 @@ export const enum FlattenLevel {
  * @param needsValue An optional value indicating whether the value from the right-hand-side of
  * the destructuring assignment is needed as part of a larger expression.
  * @param createAssignmentCallback An optional callback used to create the assignment expression.
+ *
+ * @internal
  */
 export function flattenDestructuringAssignment(
     node: VariableDeclaration | DestructuringAssignment,
@@ -174,7 +175,6 @@ function bindingOrAssignmentPatternContainsNonLiteralComputedName(pattern: Bindi
     return !!forEach(getElementsOfBindingOrAssignmentPattern(pattern), bindingOrAssignmentElementContainsNonLiteralComputedName);
 }
 
-/** @internal */
 /**
  * Flattens a VariableDeclaration or ParameterDeclaration to one or more variable declarations.
  *
@@ -185,6 +185,8 @@ function bindingOrAssignmentPatternContainsNonLiteralComputedName(pattern: Bindi
  * @param skipInitializer A value indicating whether to ignore the initializer of `node`.
  * @param hoistTempVariables Indicates whether temporary variables should not be recorded in-line.
  * @param level Indicates the extent to which flattening should occur.
+ *
+ * @internal
  */
 export function flattenDestructuringBinding(
     node: VariableDeclaration | ParameterDeclaration,
diff --git a/src/compiler/transformers/es2017.ts b/src/compiler/transformers/es2017.ts
index b91b912aa9..3f36d8c450 100644
--- a/src/compiler/transformers/es2017.ts
+++ b/src/compiler/transformers/es2017.ts
@@ -743,8 +743,11 @@ export function transformES2017(context: TransformationContext): (x: SourceFile
     }
 }
 
-/** @internal */
-/** Creates a variable named `_super` with accessor properties for the given property names. */
+/**
+ * Creates a variable named `_super` with accessor properties for the given property names.
+ *
+ * @internal
+ */
 export function createSuperAccessVariableStatement(factory: NodeFactory, resolver: EmitResolver, node: FunctionLikeDeclaration, names: Set<__String>) {
     // Create a variable declaration with a getter/setter (if binding) definition for each name:
     //   const _super = Object.create(null, { x: { get: () => super.x, set: (v) => super.x = v }, ... });
diff --git a/src/compiler/transformers/es5.ts b/src/compiler/transformers/es5.ts
index 5669e76452..8dd340255a 100644
--- a/src/compiler/transformers/es5.ts
+++ b/src/compiler/transformers/es5.ts
@@ -6,11 +6,12 @@ import {
     SourceFile, stringToToken, SyntaxKind, TransformationContext,
 } from "../_namespaces/ts";
 
-/** @internal */
 /**
  * Transforms ES5 syntax into ES3 syntax.
  *
  * @param context Context and state information for the transformation.
+ *
+ * @internal
  */
 export function transformES5(context: TransformationContext): (x: SourceFile | Bundle) => SourceFile | Bundle {
     const { factory } = context;
diff --git a/src/compiler/transformers/utilities.ts b/src/compiler/transformers/utilities.ts
index 269f9b380c..862bdf7c8b 100644
--- a/src/compiler/transformers/utilities.ts
+++ b/src/compiler/transformers/utilities.ts
@@ -274,11 +274,12 @@ function multiMapSparseArrayAdd<V>(map: V[][], key: number, value: V): V[] {
     return values;
 }
 
-/** @internal */
 /**
  * Used in the module transformer to check if an expression is reasonably without sideeffect,
  *  and thus better to copy into multiple places rather than to cache in a temporary variable
  *  - this is mostly subjective beyond the requirement that the expression not be sideeffecting
+ *
+ * @internal
  */
 export function isSimpleCopiableExpression(expression: Expression) {
     return isStringLiteralLike(expression) ||
@@ -287,11 +288,12 @@ export function isSimpleCopiableExpression(expression: Expression) {
         isIdentifier(expression);
 }
 
-/** @internal */
 /**
  * A simple inlinable expression is an expression which can be copied into multiple locations
  * without risk of repeating any sideeffects and whose value could not possibly change between
  * any such locations
+ *
+ * @internal
  */
 export function isSimpleInlineableExpression(expression: Expression) {
     return !isIdentifier(expression) && isSimpleCopiableExpression(expression);
@@ -325,9 +327,10 @@ export function getNonAssignmentOperatorForCompoundAssignment(kind: CompoundAssi
     }
 }
 
-/** @internal */
 /**
  * @returns Contained super() call from descending into the statement ignoring parentheses, if that call exists.
+ *
+ * @internal
  */
 export function getSuperCallFromStatement(statement: Statement): SuperCall | undefined {
     if (!isExpressionStatement(statement)) {
@@ -340,9 +343,10 @@ export function getSuperCallFromStatement(statement: Statement): SuperCall | und
         : undefined;
 }
 
-/** @internal */
 /**
  * @returns The index (after prologue statements) of a super call, or -1 if not found.
+ *
+ * @internal
  */
 export function findSuperStatementIndex(statements: NodeArray<Statement>, indexAfterLastPrologueStatement: number) {
     for (let i = indexAfterLastPrologueStatement; i < statements.length; i += 1) {
@@ -356,12 +360,13 @@ export function findSuperStatementIndex(statements: NodeArray<Statement>, indexA
     return -1;
 }
 
-/** @internal */
 /**
  * Gets all the static or all the instance property declarations of a class
  *
  * @param node The class node.
  * @param isStatic A value indicating whether to get properties from the static or instance side of the class.
+ *
+ * @internal
  */
 export function getProperties(node: ClassExpression | ClassDeclaration, requireInitializer: true, isStatic: boolean): readonly InitializedPropertyDeclaration[];
 /** @internal */
@@ -400,23 +405,25 @@ function isStaticPropertyDeclaration(member: ClassElement) {
     return isPropertyDeclaration(member) && hasStaticModifier(member);
 }
 
-/** @internal */
 /**
  * Gets a value indicating whether a class element is either a static or an instance property declaration with an initializer.
  *
  * @param member The class element node.
  * @param isStatic A value indicating whether the member should be a static or instance member.
+ *
+ * @internal
  */
 export function isInitializedProperty(member: ClassElement): member is PropertyDeclaration & { initializer: Expression; } {
     return member.kind === SyntaxKind.PropertyDeclaration
         && (member as PropertyDeclaration).initializer !== undefined;
 }
 
-/** @internal */
 /**
  * Gets a value indicating whether a class element is a private instance method or accessor.
  *
  * @param member The class element node.
+ *
+ * @internal
  */
 export function isNonStaticMethodOrAccessorWithPrivateName(member: ClassElement): member is PrivateIdentifierMethodDeclaration | PrivateIdentifierAccessorDeclaration | PrivateIdentifierAutoAccessorPropertyDeclaration {
     return !isStatic(member) && (isMethodOrAccessor(member) || isAutoAccessorPropertyDeclaration(member)) && isPrivateIdentifier(member.name);
@@ -450,12 +457,13 @@ function getDecoratorsOfParameters(node: FunctionLikeDeclaration | undefined) {
     return decorators;
 }
 
-/** @internal */
 /**
  * Gets an AllDecorators object containing the decorators for the class and the decorators for the
  * parameters of the constructor of the class.
  *
  * @param node The class node.
+ *
+ * @internal
  */
 export function getAllDecoratorsOfClass(node: ClassLikeDeclaration): AllDecorators | undefined {
     const decorators = getDecorators(node);
@@ -470,12 +478,13 @@ export function getAllDecoratorsOfClass(node: ClassLikeDeclaration): AllDecorato
     };
 }
 
-/** @internal */
 /**
  * Gets an AllDecorators object containing the decorators for the member and its parameters.
  *
  * @param parent The class node that contains the member.
  * @param member The class member.
+ *
+ * @internal
  */
 export function getAllDecoratorsOfClassElement(member: ClassElement, parent: ClassLikeDeclaration): AllDecorators | undefined {
     switch (member.kind) {
diff --git a/src/compiler/tsbuildPublic.ts b/src/compiler/tsbuildPublic.ts
index e425f9918d..bd457dda91 100644
--- a/src/compiler/tsbuildPublic.ts
+++ b/src/compiler/tsbuildPublic.ts
@@ -98,8 +98,11 @@ function getOrCreateValueMapFromConfigFileMap<K extends string, V>(configFileMap
     return getOrCreateValueFromConfigFileMap(configFileMap, resolved, () => new Map());
 }
 
-/** @internal */
-/** Helper to use now method instead of current date for testing purposes to get consistent baselines */
+/**
+ * Helper to use now method instead of current date for testing purposes to get consistent baselines
+ *
+ * @internal
+ */
 export function getCurrentTime(host: { now?(): Date; }) {
     return host.now ? host.now() : new Date();
 }
diff --git a/src/compiler/utilities.ts b/src/compiler/utilities.ts
index d371740a49..3d682a13ce 100644
--- a/src/compiler/utilities.ts
+++ b/src/compiler/utilities.ts
@@ -212,10 +212,11 @@ export function forEachAncestor<T>(node: Node, callback: (n: Node) => T | undefi
     }
 }
 
-/** @internal */
 /**
  * Calls `callback` for each entry in the map, returning the first truthy result.
  * Use `map.forEach` instead for normal iteration.
+ *
+ * @internal
  */
 export function forEachEntry<K, V, U>(map: ReadonlyESMap<K, V>, callback: (value: V, key: K) => U | undefined): U | undefined {
     const iterator = map.entries();
@@ -229,8 +230,11 @@ export function forEachEntry<K, V, U>(map: ReadonlyESMap<K, V>, callback: (value
     return undefined;
 }
 
-/** @internal */
-/** `forEachEntry` for just keys. */
+/**
+ * `forEachEntry` for just keys.
+ *
+ * @internal
+ */
 export function forEachKey<K, T>(map: ReadonlyCollection<K>, callback: (key: K) => T | undefined): T | undefined {
     const iterator = map.keys();
     for (let iterResult = iterator.next(); !iterResult.done; iterResult = iterator.next()) {
@@ -242,8 +246,11 @@ export function forEachKey<K, T>(map: ReadonlyCollection<K>, callback: (key: K)
     return undefined;
 }
 
-/** @internal */
-/** Copy entries from `source` to `target`. */
+/**
+ * Copy entries from `source` to `target`.
+ *
+ * @internal
+ */
 export function copyEntries<K, V>(source: ReadonlyESMap<K, V>, target: ESMap<K, V>): void {
     source.forEach((value, key) => {
         target.set(key, value);
@@ -459,10 +466,11 @@ export function getEndLinePosition(line: number, sourceFile: SourceFileLike): nu
     }
 }
 
-/** @internal */
 /**
  * Returns a value indicating whether a name is unique globally or within the current file.
  * Note: This does not consider whether a name appears as a free identifier or not, so at the expression `x.y` this includes both `x` and `y`.
+ *
+ * @internal
  */
 export function isFileLevelUniqueName(sourceFile: SourceFile, name: string, hasGlobalName?: PrintHandlers["hasGlobalName"]): boolean {
     return !(hasGlobalName && hasGlobalName(name)) && !sourceFile.identifiers.has(name);
@@ -525,9 +533,10 @@ function isAnyPrologueDirective(node: Node) {
     return isPrologueDirective(node) || !!(getEmitFlags(node) & EmitFlags.CustomPrologue);
 }
 
-/** @internal */
 /**
  * Prepends statements to an array while taking care of prologue directives.
+ *
+ * @internal
  */
 export function insertStatementsAfterStandardPrologue<T extends Statement>(to: T[], from: readonly T[] | undefined): T[] {
     return insertStatementsAfterPrologue(to, from, isPrologueDirective);
@@ -538,9 +547,10 @@ export function insertStatementsAfterCustomPrologue<T extends Statement>(to: T[]
     return insertStatementsAfterPrologue(to, from, isAnyPrologueDirective);
 }
 
-/** @internal */
 /**
  * Prepends statements to an array while taking care of prologue directives.
+ *
+ * @internal
  */
 export function insertStatementAfterStandardPrologue<T extends Statement>(to: T[], statement: T | undefined): T[] {
     return insertStatementAfterPrologue(to, statement, isPrologueDirective);
@@ -551,11 +561,12 @@ export function insertStatementAfterCustomPrologue<T extends Statement>(to: T[],
     return insertStatementAfterPrologue(to, statement, isAnyPrologueDirective);
 }
 
-/** @internal */
 /**
  * Determine if the given comment is a triple-slash
  *
  * @return true if the comment is a triple-slash comment else false
+ *
+ * @internal
  */
 export function isRecognizedTripleSlashComment(text: string, commentPos: number, commentEnd: number) {
     // Verify this is /// comment, but do the regexp match only when we first can find /// in the comment text
@@ -690,18 +701,20 @@ function getPos(range: Node) {
     return range.pos;
 }
 
-/** @internal */
 /**
  * Note: it is expected that the `nodeArray` and the `node` are within the same file.
  * For example, searching for a `SourceFile` in a `SourceFile[]` wouldn't work.
+ *
+ * @internal
  */
 export function indexOfNode(nodeArray: readonly Node[], node: Node) {
     return binarySearch(nodeArray, node, getPos, compareValues);
 }
 
-/** @internal */
 /**
  * Gets flags that control emit behavior of a node.
+ *
+ * @internal
  */
 export function getEmitFlags(node: Node): EmitFlags {
     const emitNode = node.emitNode;
@@ -914,19 +927,23 @@ export function isNonGlobalAmbientModule(node: Node): node is ModuleDeclaration
     return isModuleDeclaration(node) && isStringLiteral(node.name);
 }
 
-/** @internal */
 /**
  * An effective module (namespace) declaration is either
  * 1. An actual declaration: namespace X { ... }
  * 2. A Javascript declaration, which is:
  *    An identifier in a nested property access expression: Y in `X.Y.Z = { ... }`
+ *
+ * @internal
  */
 export function isEffectiveModuleDeclaration(node: Node) {
     return isModuleDeclaration(node) || isIdentifier(node);
 }
 
-/** @internal */
-/** Given a symbol for a module, checks that it is a shorthand ambient module. */
+/**
+ * Given a symbol for a module, checks that it is a shorthand ambient module.
+ *
+ * @internal
+ */
 export function isShorthandAmbientModuleSymbol(moduleSymbol: Symbol): boolean {
     return isShorthandAmbientModule(moduleSymbol.valueDeclaration);
 }
@@ -981,9 +998,10 @@ export function isEffectiveExternalModule(node: SourceFile, compilerOptions: Com
     return isExternalModule(node) || compilerOptions.isolatedModules || (isCommonJSContainingModuleKind(getEmitModuleKind(compilerOptions)) && !!node.commonJsModuleIndicator);
 }
 
-/** @internal */
 /**
  * Returns whether the source file will be treated as if it were in strict mode at runtime.
+ *
+ * @internal
  */
 export function isEffectiveStrictModeSourceFile(node: SourceFile, compilerOptions: CompilerOptions) {
     // We can only verify strict mode for JS/TS files
@@ -1690,12 +1708,13 @@ export function forEachYieldExpression(body: Block, visitor: (expr: YieldExpress
     }
 }
 
-/** @internal */
 /**
  * Gets the most likely element type for a TypeNode. This is not an exhaustive test
  * as it assumes a rest argument can only be an array type (either T[], or Array<T>).
  *
  * @param node The type node.
+ *
+ * @internal
  */
 export function getRestParameterElementType(node: TypeNode | undefined) {
     if (node && node.kind === SyntaxKind.ArrayType) {
@@ -1961,9 +1980,10 @@ export function getThisContainer(node: Node, includeArrowFunctions: boolean): No
     }
 }
 
-/** @internal */
 /**
  * @returns Whether the node creates a new 'this' scope for its children.
+ *
+ * @internal
  */
 export function isThisContainerOrFunctionBlock(node: Node): boolean {
     switch (node.kind) {
@@ -2015,7 +2035,6 @@ export function getNewTargetContainer(node: Node) {
     return undefined;
 }
 
-/** @internal */
 /**
  * Given an super call/property node, returns the closest node where
  * - a super call/property access is legal in the node and not legal in the parent node the node.
@@ -2023,6 +2042,8 @@ export function getNewTargetContainer(node: Node) {
  * - the container is an arrow function (so caller might need to call getSuperContainer again in case it needs to climb higher)
  * - a super call/property is definitely illegal in the container (but might be legal in some subnode)
  *   i.e. super property access is illegal in function declaration but can be legal in the statement list
+ *
+ * @internal
  */
 export function getSuperContainer(node: Node, stopOnFunctions: boolean): Node {
     while (true) {
@@ -2089,9 +2110,10 @@ export function isSuperOrSuperProperty(node: Node): node is SuperExpression | Su
         || isSuperProperty(node);
 }
 
-/** @internal */
 /**
  * Determines whether a node is a property or element access expression for `super`.
+ *
+ * @internal
  */
 export function isSuperProperty(node: Node): node is SuperProperty {
     const kind = node.kind;
@@ -2099,9 +2121,10 @@ export function isSuperProperty(node: Node): node is SuperProperty {
         && (node as PropertyAccessExpression | ElementAccessExpression).expression.kind === SyntaxKind.SuperKeyword;
 }
 
-/** @internal */
 /**
  * Determines whether a node is a property or element access expression for `this`.
+ *
+ * @internal
  */
 export function isThisProperty(node: Node): boolean {
     const kind = node.kind;
@@ -2454,11 +2477,12 @@ export function isJSDocIndexSignature(node: TypeReferenceNode | ExpressionWithTy
         (node.typeArguments[0].kind === SyntaxKind.StringKeyword || node.typeArguments[0].kind === SyntaxKind.NumberKeyword);
 }
 
-/** @internal */
 /**
  * Returns true if the node is a CallExpression to the identifier 'require' with
  * exactly one argument (of the form 'require("name")').
  * This function does not test if the node is in a JavaScript file or not.
+ *
+ * @internal
  */
 export function isRequireCall(callExpression: Node, requireStringLiteralLikeArgument: true): callExpression is RequireOrImportCall & { expression: Identifier, arguments: [StringLiteralLike] };
 /** @internal */
@@ -2481,18 +2505,20 @@ export function isRequireCall(callExpression: Node, requireStringLiteralLikeArgu
     return !requireStringLiteralLikeArgument || isStringLiteralLike(arg);
 }
 
-/** @internal */
 /**
  * Returns true if the node is a VariableDeclaration initialized to a require call (see `isRequireCall`).
  * This function does not test if the node is in a JavaScript file or not.
+ *
+ * @internal
  */
 export function isVariableDeclarationInitializedToRequire(node: Node): node is VariableDeclarationInitializedTo<RequireOrImportCall> {
     return isVariableDeclarationInitializedWithRequireHelper(node, /*allowAccessedRequire*/ false);
 }
 
-/** @internal */
 /**
  * Like {@link isVariableDeclarationInitializedToRequire} but allows things like `require("...").foo.bar` or `require("...")["baz"]`.
+ *
+ * @internal
  */
 export function isVariableDeclarationInitializedToBareOrAccessedRequire(node: Node): node is VariableDeclarationInitializedTo<RequireOrImportCall | AccessExpression> {
     return isVariableDeclarationInitializedWithRequireHelper(node, /*allowAccessedRequire*/ true);
@@ -2526,8 +2552,11 @@ export function isAssignmentDeclaration(decl: Declaration) {
     return isBinaryExpression(decl) || isAccessExpression(decl) || isIdentifier(decl) || isCallExpression(decl);
 }
 
-/** @internal */
-/** Get the initializer, taking into account defaulted Javascript initializers */
+/**
+ * Get the initializer, taking into account defaulted Javascript initializers
+ *
+ * @internal
+ */
 export function getEffectiveInitializer(node: HasExpressionInitializer) {
     if (isInJSFile(node) && node.initializer &&
         isBinaryExpression(node.initializer) &&
@@ -2538,8 +2567,11 @@ export function getEffectiveInitializer(node: HasExpressionInitializer) {
     return node.initializer;
 }
 
-/** @internal */
-/** Get the declaration initializer when it is container-like (See getExpandoInitializer). */
+/**
+ * Get the declaration initializer when it is container-like (See getExpandoInitializer).
+ *
+ * @internal
+ */
 export function getDeclaredExpandoInitializer(node: HasExpressionInitializer) {
     const init = getEffectiveInitializer(node);
     return init && getExpandoInitializer(init, isPrototypeAccess(node.name));
@@ -2554,10 +2586,11 @@ function hasExpandoValueProperty(node: ObjectLiteralExpression, isPrototypeAssig
         getExpandoInitializer(p.initializer, isPrototypeAssignment));
 }
 
-/** @internal */
 /**
  * Get the assignment 'initializer' -- the righthand side-- when the initializer is container-like (See getExpandoInitializer).
  * We treat the right hand side of assignments with container-like initializers as declarations.
+ *
+ * @internal
  */
 export function getAssignedExpandoInitializer(node: Node | undefined): Expression | undefined {
     if (node && node.parent && isBinaryExpression(node.parent) && node.parent.operatorToken.kind === SyntaxKind.EqualsToken) {
@@ -2573,7 +2606,6 @@ export function getAssignedExpandoInitializer(node: Node | undefined): Expressio
     }
 }
 
-/** @internal */
 /**
  * Recognized expando initializers are:
  * 1. (function() {})() -- IIFEs
@@ -2583,6 +2615,8 @@ export function getAssignedExpandoInitializer(node: Node | undefined): Expressio
  * 5. { ... } -- Non-empty object literals, when used to initialize a prototype, like `C.prototype = { m() { } }`
  *
  * This function returns the provided initializer, or undefined if it is not valid.
+ *
+ * @internal
  */
 export function getExpandoInitializer(initializer: Node, isPrototypeAssignment: boolean): Expression | undefined {
     if (isCallExpression(initializer)) {
@@ -2624,8 +2658,11 @@ export function isDefaultedExpandoInitializer(node: BinaryExpression) {
     return name && getExpandoInitializer(node.right, isPrototypeAccess(name)) && isEntityNameExpression(name) && isSameEntityName(name, node.left);
 }
 
-/** @internal */
-/** Given an expando initializer, return its declaration name, or the left-hand side of the assignment if it's part of an assignment declaration. */
+/**
+ * Given an expando initializer, return its declaration name, or the left-hand side of the assignment if it's part of an assignment declaration.
+ *
+ * @internal
+ */
 export function getNameOfExpando(node: Declaration): DeclarationName | undefined {
     if (isBinaryExpression(node.parent)) {
         const parent = ((node.parent.operatorToken.kind === SyntaxKind.BarBarToken || node.parent.operatorToken.kind === SyntaxKind.QuestionQuestionToken) && isBinaryExpression(node.parent.parent)) ? node.parent.parent : node.parent;
@@ -2638,7 +2675,6 @@ export function getNameOfExpando(node: Declaration): DeclarationName | undefined
     }
 }
 
-/** @internal */
 /**
  * Is the 'declared' name the same as the one in the initializer?
  * @return true for identical entity names, as well as ones where the initializer is prefixed with
@@ -2647,6 +2683,8 @@ export function getNameOfExpando(node: Declaration): DeclarationName | undefined
  * var my = my || {}
  * var min = window.min || {}
  * my.app = self.my.app || class { }
+ *
+ * @internal
  */
 export function isSameEntityName(name: Expression, initializer: Expression): boolean {
     if (isPropertyNameLiteral(name) && isPropertyNameLiteral(initializer)) {
@@ -2711,27 +2749,39 @@ export function isBindableObjectDefinePropertyCall(expr: CallExpression): expr i
         isBindableStaticNameExpression(expr.arguments[0], /*excludeThisKeyword*/ true);
 }
 
-/** @internal */
-/** x.y OR x[0] */
+/**
+ * x.y OR x[0]
+ *
+ * @internal
+ */
 export function isLiteralLikeAccess(node: Node): node is LiteralLikeElementAccessExpression | PropertyAccessExpression {
     return isPropertyAccessExpression(node) || isLiteralLikeElementAccess(node);
 }
 
-/** @internal */
-/** x[0] OR x['a'] OR x[Symbol.y] */
+/**
+ * x[0] OR x['a'] OR x[Symbol.y]
+ *
+ * @internal
+ */
 export function isLiteralLikeElementAccess(node: Node): node is LiteralLikeElementAccessExpression {
     return isElementAccessExpression(node) && isStringOrNumericLiteralLike(node.argumentExpression);
 }
 
-/** @internal */
-/** Any series of property and element accesses. */
+/**
+ * Any series of property and element accesses.
+ *
+ * @internal
+ */
 export function isBindableStaticAccessExpression(node: Node, excludeThisKeyword?: boolean): node is BindableStaticAccessExpression {
     return isPropertyAccessExpression(node) && (!excludeThisKeyword && node.expression.kind === SyntaxKind.ThisKeyword || isIdentifier(node.name) && isBindableStaticNameExpression(node.expression, /*excludeThisKeyword*/ true))
         || isBindableStaticElementAccessExpression(node, excludeThisKeyword);
 }
 
-/** @internal */
-/** Any series of property and element accesses, ending in a literal element access */
+/**
+ * Any series of property and element accesses, ending in a literal element access
+ *
+ * @internal
+ */
 export function isBindableStaticElementAccessExpression(node: Node, excludeThisKeyword?: boolean): node is BindableStaticElementAccessExpression {
     return isLiteralLikeElementAccess(node)
         && ((!excludeThisKeyword && node.expression.kind === SyntaxKind.ThisKeyword) ||
@@ -3138,8 +3188,11 @@ export function getNextJSDocCommentLocation(node: Node) {
     }
 }
 
-/** @internal */
-/** Does the opposite of `getJSDocParameterTags`: given a JSDoc parameter, finds the parameter corresponding to it. */
+/**
+ * Does the opposite of `getJSDocParameterTags`: given a JSDoc parameter, finds the parameter corresponding to it.
+ *
+ * @internal
+ */
 export function getParameterSymbolFromJSDoc(node: JSDocParameterTag): Symbol | undefined {
     if (node.symbol) {
         return node.symbol;
@@ -3192,8 +3245,11 @@ export function getEffectiveJSDocHost(node: Node): Node | undefined {
     }
 }
 
-/** @internal */
-/** Use getEffectiveJSDocHost if you additionally need to look for jsdoc on parent nodes, like assignments. */
+/**
+ * Use getEffectiveJSDocHost if you additionally need to look for jsdoc on parent nodes, like assignments.
+ *
+ * @internal
+ */
 export function getJSDocHost(node: Node): HasJSDoc | undefined {
     const jsDoc = getJSDocRoot(node);
     if (!jsDoc) {
@@ -3301,10 +3357,11 @@ export type NodeWithPossibleHoistedDeclaration =
     | TryStatement
     | CatchClause;
 
-/** @internal */
 /**
  * Indicates whether a node could contain a `var` VariableDeclarationList that contributes to
  * the same `var` declaration scope as the node's parent.
+ *
+ * @internal
  */
 export function isNodeWithPossibleHoistedDeclaration(node: Node): node is NodeWithPossibleHoistedDeclaration {
     switch (node.kind) {
@@ -3360,11 +3417,12 @@ export function walkUpParenthesizedExpressions(node: Node) {
     return walkUp(node, SyntaxKind.ParenthesizedExpression);
 }
 
-/** @internal */
 /**
  * Walks up parenthesized types.
  * It returns both the outermost parenthesized type and its parent.
  * If given node is not a parenthesiezd type, undefined is return as the former.
+ *
+ * @internal
  */
 export function walkUpParenthesizedTypesAndGetParentAndChild(node: Node): [ParenthesizedTypeNode | undefined, Node] {
     let child: ParenthesizedTypeNode | undefined;
@@ -3602,8 +3660,11 @@ export function getEffectiveImplementsTypeNodes(node: ClassLikeDeclaration): und
     }
 }
 
-/** @internal */
-/** Returns the node in an `extends` or `implements` clause of a class or interface. */
+/**
+ * Returns the node in an `extends` or `implements` clause of a class or interface.
+ *
+ * @internal
+ */
 export function getAllSuperTypeNodes(node: Node): readonly TypeNode[] {
     return isInterfaceDeclaration(node) ? getInterfaceBaseTypeNodes(node) || emptyArray :
         isClassLike(node) ? concatenate(singleElementArray(getEffectiveBaseTypeNode(node)), getEffectiveImplementsTypeNodes(node)) || emptyArray :
@@ -3745,7 +3806,6 @@ export function isSignedNumericLiteral(node: Node): node is PrefixUnaryExpressio
     return isPrefixUnaryExpression(node) && (node.operator === SyntaxKind.PlusToken || node.operator === SyntaxKind.MinusToken) && isNumericLiteral(node.operand);
 }
 
-/** @internal */
 /**
  * A declaration has a dynamic name if all of the following are true:
  *   1. The declaration has a computed property name.
@@ -3753,6 +3813,8 @@ export function isSignedNumericLiteral(node: Node): node is PrefixUnaryExpressio
  *   3. The computed name is *not* expressed as a NumericLiteral.
  *   4. The computed name is *not* expressed as a PlusToken or MinusToken
  *      immediately followed by a NumericLiteral.
+ *
+ * @internal
  */
 export function hasDynamicName(declaration: Declaration): declaration is DynamicNamedDeclaration | DynamicNamedBinaryExpression {
     const name = getNameOfDeclaration(declaration);
@@ -3837,9 +3899,10 @@ export function isPrivateIdentifierSymbol(symbol: Symbol): boolean {
     return startsWith(symbol.escapedName as string, "__#");
 }
 
-/** @internal */
 /**
  * Includes the word "Symbol" with unicode escapes
+ *
+ * @internal
  */
 export function isESSymbolIdentifier(node: Node): boolean {
     return node.kind === SyntaxKind.Identifier && (node as Identifier).escapedText === "Symbol";
@@ -4453,11 +4516,12 @@ function getReplacement(c: string, offset: number, input: string) {
     return escapedCharsMap.get(c) || encodeUtf16EscapeSequence(c.charCodeAt(0));
 }
 
-/** @internal */
 /**
  * Based heavily on the abstract 'Quote'/'QuoteJSONString' operation from ECMA-262 (24.3.2.2),
  * but augmented for a few select characters (e.g. lineSeparator, paragraphSeparator, nextLine)
  * Note that this doesn't actually wrap the input in double quotes.
+ *
+ * @internal
  */
 export function escapeString(s: string, quoteChar?: CharacterCodes.doubleQuote | CharacterCodes.singleQuote | CharacterCodes.backtick): string {
     const escapedCharsRegExp =
@@ -4509,11 +4573,12 @@ export function escapeJsxAttributeString(s: string, quoteChar?: CharacterCodes.d
     return s.replace(escapedCharsRegExp, getJsxAttributeStringReplacement);
 }
 
-/** @internal */
 /**
  * Strip off existed surrounding single quotes, double quotes, or backticks from a given string
  *
  * @return non-quoted string
+ *
+ * @internal
  */
 export function stripQuotes(name: string) {
     const length = name.length;
@@ -4783,9 +4848,10 @@ export function getExternalModuleNameFromDeclaration(host: ResolveModuleNameReso
     return getResolvedExternalModuleName(host, file);
 }
 
-/** @internal */
 /**
  * Resolves a local path to a path which is absolute to the base of the emit
+ *
+ * @internal
  */
 export function getExternalModuleNameFromPath(host: ResolveModuleNameResolutionHost, fileName: string, referencePath?: string): string {
     const getCanonicalFileName = (f: string) => host.getCanonicalFileName(f);
@@ -4834,9 +4900,10 @@ export function getDeclarationEmitExtensionForPath(path: string) {
         Extension.Dts;
 }
 
-/** @internal */
 /**
  * This function is an inverse of `getDeclarationEmitExtensionForPath`.
+ *
+ * @internal
  */
 export function getPossibleOriginalInputExtensionForExtension(path: string) {
     return fileExtensionIsOneOf(path, [Extension.Dmts, Extension.Mjs, Extension.Mts]) ? [Extension.Mts, Extension.Mjs] :
@@ -4850,8 +4917,11 @@ export function outFile(options: CompilerOptions) {
     return options.outFile || options.out;
 }
 
-/** @internal */
-/** Returns 'undefined' if and only if 'options.paths' is undefined. */
+/**
+ * Returns 'undefined' if and only if 'options.paths' is undefined.
+ *
+ * @internal
+ */
 export function getPathsBasePath(options: CompilerOptions, host: { getCurrentDirectory?(): string }) {
     if (!options.paths) return undefined;
     return options.baseUrl ?? Debug.checkDefined(options.pathsBasePath || host.getCurrentDirectory?.(), "Encountered 'paths' without a 'baseUrl', config file, or host 'getCurrentDirectory'.");
@@ -4866,7 +4936,6 @@ export interface EmitFileNames {
     buildInfoPath?: string | undefined;
 }
 
-/** @internal */
 /**
  * Gets the source files that are expected to have an emit output.
  *
@@ -4875,6 +4944,8 @@ export interface EmitFileNames {
  *
  * @param host An EmitHost.
  * @param targetSourceFile An optional target source file to emit.
+ *
+ * @internal
  */
 export function getSourceFilesToEmit(host: EmitHost, targetSourceFile?: SourceFile, forceDtsEmit?: boolean): readonly SourceFile[] {
     const options = host.getCompilerOptions();
@@ -4898,8 +4969,11 @@ export function getSourceFilesToEmit(host: EmitHost, targetSourceFile?: SourceFi
     }
 }
 
-/** @internal */
-/** Don't call this for `--outFile`, just for `--outDir` or plain emit. `--outFile` needs additional checks. */
+/**
+ * Don't call this for `--outFile`, just for `--outDir` or plain emit. `--outFile` needs additional checks.
+ *
+ * @internal
+ */
 export function sourceFileMayBeEmitted(sourceFile: SourceFile, host: SourceFileMayBeEmittedHost, forceDtsEmit?: boolean) {
     const options = host.getCompilerOptions();
     return !(options.noEmitForJsFiles && isSourceFileJS(sourceFile)) &&
@@ -4986,8 +5060,11 @@ export function getSetAccessorValueParameter(accessor: SetAccessorDeclaration):
     }
 }
 
-/** @internal */
-/** Get the type annotation for the value parameter. */
+/**
+ * Get the type annotation for the value parameter.
+ *
+ * @internal
+ */
 export function getSetAccessorTypeAnnotationNode(accessor: SetAccessorDeclaration): TypeNode | undefined {
     const parameter = getSetAccessorValueParameter(accessor);
     return parameter && parameter.type;
@@ -5084,11 +5161,12 @@ export function getAllAccessorDeclarations(declarations: readonly Declaration[],
     };
 }
 
-/** @internal */
 /**
  * Gets the effective type annotation of a variable, parameter, or property. If the node was
  * parsed in a JavaScript file, gets the type annotation from JSDoc.  Also gets the type of
  * functions only the JSDoc case.
+ *
+ * @internal
  */
 export function getEffectiveTypeAnnotationNode(node: Node): TypeNode | undefined {
     if (!isInJSFile(node) && isFunctionDeclaration(node)) return undefined;
@@ -5102,10 +5180,11 @@ export function getTypeAnnotationNode(node: Node): TypeNode | undefined {
     return (node as HasType).type;
 }
 
-/** @internal */
 /**
  * Gets the effective return type annotation of a signature. If the node was parsed in a
  * JavaScript file, gets the return type annotation from JSDoc.
+ *
+ * @internal
  */
 export function getEffectiveReturnTypeNode(node: SignatureDeclaration | JSDocSignature): TypeNode | undefined {
     return isJSDocSignature(node) ?
@@ -5123,10 +5202,11 @@ function isNonTypeAliasTemplate(tag: JSDocTag): tag is JSDocTemplateTag {
     return isJSDocTemplateTag(tag) && !(tag.parent.kind === SyntaxKind.JSDoc && tag.parent.tags!.some(isJSDocTypeAlias));
 }
 
-/** @internal */
 /**
  * Gets the effective type annotation of the value parameter of a set accessor. If the node
  * was parsed in a JavaScript file, gets the type annotation from JSDoc.
+ *
+ * @internal
  */
 export function getEffectiveSetAccessorTypeAnnotationNode(node: SetAccessorDeclaration): TypeNode | undefined {
     const parameter = getSetAccessorValueParameter(node);
@@ -5193,10 +5273,11 @@ export function emitComments(
     }
 }
 
-/** @internal */
 /**
  * Detached comment is a comment at the top of file or function body that is separated from
  * the next statement by space.
+ *
+ * @internal
  */
 export function emitDetachedComments(text: string, lineMap: readonly number[], writer: EmitTextWriter,
     writeComment: (text: string, lineMap: readonly number[], writer: EmitTextWriter, commentPos: number, commentEnd: number, newLine: string) => void,
@@ -5447,11 +5528,12 @@ function getModifierFlagsWorker(node: Node, includeJSDoc: boolean, alwaysInclude
     return node.modifierFlagsCache & ~(ModifierFlags.HasComputedFlags | ModifierFlags.HasComputedJSDocModifiers);
 }
 
-/** @internal */
 /**
  * Gets the effective ModifierFlags for the provided node, including JSDoc modifiers. The modifiers will be cached on the node to improve performance.
  *
  * NOTE: This function may use `parent` pointers.
+ *
+ * @internal
  */
 export function getEffectiveModifierFlags(node: Node): ModifierFlags {
     return getModifierFlagsWorker(node, /*includeJSDoc*/ true);
@@ -5462,11 +5544,12 @@ export function getEffectiveModifierFlagsAlwaysIncludeJSDoc(node: Node): Modifie
     return getModifierFlagsWorker(node, /*includeJSDOc*/ true, /*alwaysIncludeJSDOc*/ true);
 }
 
-/** @internal */
 /**
  * Gets the ModifierFlags for syntactic modifiers on the provided node. The modifiers will be cached on the node to improve performance.
  *
  * NOTE: This function does not use `parent` pointers and will not include modifiers from JSDoc.
+ *
+ * @internal
  */
 export function getSyntacticModifierFlags(node: Node): ModifierFlags {
     return getModifierFlagsWorker(node, /*includeJSDoc*/ false);
@@ -5488,21 +5571,23 @@ function getJSDocModifierFlagsNoCache(node: Node): ModifierFlags {
     return flags;
 }
 
-/** @internal */
 /**
  * Gets the effective ModifierFlags for the provided node, including JSDoc modifiers. The modifier flags cache on the node is ignored.
  *
  * NOTE: This function may use `parent` pointers.
+ *
+ * @internal
  */
 export function getEffectiveModifierFlagsNoCache(node: Node): ModifierFlags {
     return getSyntacticModifierFlagsNoCache(node) | getJSDocModifierFlagsNoCache(node);
 }
 
-/** @internal */
 /**
  * Gets the ModifierFlags for syntactic modifiers on the provided node. The modifier flags cache on the node is ignored.
  *
  * NOTE: This function does not use `parent` pointers and will not include modifiers from JSDoc.
+ *
+ * @internal
  */
 export function getSyntacticModifierFlagsNoCache(node: Node): ModifierFlags {
     let flags = canHaveModifiers(node) ? modifiersToFlags(node.modifiers) : ModifierFlags.None;
@@ -5570,8 +5655,11 @@ export function isAssignmentOperator(token: SyntaxKind): boolean {
     return token >= SyntaxKind.FirstAssignment && token <= SyntaxKind.LastAssignment;
 }
 
-/** @internal */
-/** Get `C` given `N` if `N` is in the position `class C extends N` where `N` is an ExpressionWithTypeArguments. */
+/**
+ * Get `C` given `N` if `N` is in the position `class C extends N` where `N` is an ExpressionWithTypeArguments.
+ *
+ * @internal
+ */
 export function tryGetClassExtendingExpressionWithTypeArguments(node: Node): ClassLikeDeclaration | undefined {
     const cls = tryGetClassImplementingOrExtendingExpressionWithTypeArguments(node);
     return cls && !cls.isImplements ? cls.class : undefined;
@@ -5731,8 +5819,11 @@ function isExportDefaultSymbol(symbol: Symbol): boolean {
     return symbol && length(symbol.declarations) > 0 && hasSyntacticModifier(symbol.declarations![0], ModifierFlags.Default);
 }
 
-/** @internal */
-/** Return ".ts", ".d.ts", or ".tsx", if that is the extension. */
+/**
+ * Return ".ts", ".d.ts", or ".tsx", if that is the extension.
+ *
+ * @internal
+ */
 export function tryExtractTSExtension(fileName: string): string | undefined {
     return find(supportedTSExtensionsForExtractExtension, extension => fileExtensionIs(fileName, extension));
 }
@@ -5776,9 +5867,10 @@ function getExpandedCharCodes(input: string): number[] {
 
 const base64Digits = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/=";
 
-/** @internal */
 /**
  * Converts a string to a base-64 encoded ASCII string.
+ *
+ * @internal
  */
 export function convertToBase64(input: string): string {
     let result = "";
@@ -5924,43 +6016,47 @@ export function getNewLineCharacter(options: CompilerOptions | PrinterOptions, g
     return getNewLine ? getNewLine() : sys ? sys.newLine : carriageReturnLineFeed;
 }
 
-/** @internal */
 /**
  * Creates a new TextRange from the provided pos and end.
  *
  * @param pos The start position.
  * @param end The end position.
+ *
+ * @internal
  */
 export function createRange(pos: number, end: number = pos): TextRange {
     Debug.assert(end >= pos || end === -1);
     return { pos, end };
 }
 
-/** @internal */
 /**
  * Creates a new TextRange from a provided range with a new end position.
  *
  * @param range A TextRange.
  * @param end The new end position.
+ *
+ * @internal
  */
 export function moveRangeEnd(range: TextRange, end: number): TextRange {
     return createRange(range.pos, end);
 }
 
-/** @internal */
 /**
  * Creates a new TextRange from a provided range with a new start position.
  *
  * @param range A TextRange.
  * @param pos The new Start position.
+ *
+ * @internal
  */
 export function moveRangePos(range: TextRange, pos: number): TextRange {
     return createRange(pos, range.end);
 }
 
-/** @internal */
 /**
  * Moves the start position of a range past any decorators.
+ *
+ * @internal
  */
 export function moveRangePastDecorators(node: Node): TextRange {
     const lastDecorator = canHaveModifiers(node) ? findLast(node.modifiers, isDecorator) : undefined;
@@ -5969,9 +6065,10 @@ export function moveRangePastDecorators(node: Node): TextRange {
         : node;
 }
 
-/** @internal */
 /**
  * Moves the start position of a range past any decorators or modifiers.
+ *
+ * @internal
  */
 export function moveRangePastModifiers(node: Node): TextRange {
     const lastModifier = canHaveModifiers(node) ? lastOrUndefined(node.modifiers) : undefined;
@@ -5980,22 +6077,24 @@ export function moveRangePastModifiers(node: Node): TextRange {
         : moveRangePastDecorators(node);
 }
 
-/** @internal */
 /**
  * Determines whether a TextRange has the same start and end positions.
  *
  * @param range A TextRange.
+ *
+ * @internal
  */
 export function isCollapsedRange(range: TextRange) {
     return range.pos === range.end;
 }
 
-/** @internal */
 /**
  * Creates a new TextRange for a token at the provides start position.
  *
  * @param pos The start position.
  * @param token The token.
+ *
+ * @internal
  */
 export function createTokenRange(pos: number, token: SyntaxKind): TextRange {
     return createRange(pos, pos + tokenToString(token)!.length);
@@ -6076,10 +6175,11 @@ function getPreviousNonWhitespacePosition(pos: number, stopPos = 0, sourceFile:
     }
 }
 
-/** @internal */
 /**
  * Determines whether a name was originally the declaration name of an enum or namespace
  * declaration.
+ *
+ * @internal
  */
 export function isDeclarationNameOfEnumOrNamespace(node: Identifier) {
     const parseNode = getParseTreeNode(node);
@@ -6145,8 +6245,11 @@ export function skipAlias(symbol: Symbol, checker: TypeChecker) {
     return symbol.flags & SymbolFlags.Alias ? checker.getAliasedSymbol(symbol) : symbol;
 }
 
-/** @internal */
-/** See comment on `declareModuleMember` in `binder.ts`. */
+/**
+ * See comment on `declareModuleMember` in `binder.ts`.
+ *
+ * @internal
+ */
 export function getCombinedLocalAndExportSymbolFlags(symbol: Symbol): SymbolFlags {
     return symbol.exportSymbol ? symbol.exportSymbol.flags | symbol.flags : symbol.flags;
 }
@@ -6240,9 +6343,10 @@ export function compareDataObjects(dst: any, src: any): boolean {
     return true;
 }
 
-/** @internal */
 /**
  * clears already present map by calling onDeleteExistingValue callback before deleting that key/value
+ *
+ * @internal
  */
 export function clearMap<K, T>(map: { forEach: ESMap<K, T>["forEach"]; clear: ESMap<K, T>["clear"]; }, onDeleteValue: (valueInMap: T, key: K) => void) {
     // Remove all
@@ -6263,9 +6367,10 @@ export interface MutateMapSkippingNewValuesOptions<K, T, U> {
     onExistingValue?(existingValue: T, valueInNewMap: U, key: K): void;
 }
 
-/** @internal */
 /**
  * Mutates the map with newMap such that keys in map will be same as newMap.
+ *
+ * @internal
  */
 export function mutateMapSkippingNewValues<K, T, U>(
     map: ESMap<K, T>,
@@ -6293,9 +6398,10 @@ export interface MutateMapOptions<K, T, U> extends MutateMapSkippingNewValuesOpt
     createNewValue(key: K, valueInNewMap: U): T;
 }
 
-/** @internal */
 /**
  * Mutates the map with newMap such that keys in map will be same as newMap.
+ *
+ * @internal
  */
 export function mutateMap<K, T, U>(map: ESMap<K, T>, newMap: ReadonlyESMap<K, U>, options: MutateMapOptions<K, T, U>) {
     // Needs update
@@ -6369,8 +6475,11 @@ export function getLastChild(node: Node): Node | undefined {
     return lastChild;
 }
 
-/** @internal */
-/** Add a value to a set, and return true if it wasn't already present. */
+/**
+ * Add a value to a set, and return true if it wasn't already present.
+ *
+ * @internal
+ */
 export function addToSeen<K>(seen: ESMap<K, true>, key: K): boolean;
 /** @internal */
 export function addToSeen<K, T>(seen: ESMap<K, T>, key: K, value: T): boolean;
@@ -7360,10 +7469,11 @@ export function getRegularExpressionsForWildcards(specs: readonly string[] | und
         spec && getSubPatternFromSpec(spec, basePath, usage, wildcardMatchers[usage]));
 }
 
-/** @internal */
 /**
  * An "includes" path "foo" is implicitly a glob "foo/** /*" (without the space) if its last component has no extension,
  * and does not contain any glob characters itself.
+ *
+ * @internal
  */
 export function isImplicitGlob(lastPathComponent: string): boolean {
     return !/[.*?]/.test(lastPathComponent);
@@ -7472,8 +7582,11 @@ export interface FileMatcherPatterns {
     basePaths: readonly string[];
 }
 
-/** @internal */
-/** @param path directory of the tsconfig.json */
+/**
+ * @param path directory of the tsconfig.json
+ *
+ * @internal
+ */
 export function getFileMatcherPatterns(path: string, excludes: readonly string[] | undefined, includes: readonly string[] | undefined, useCaseSensitiveFileNames: boolean, currentDirectory: string): FileMatcherPatterns {
     path = normalizePath(path);
     currentDirectory = normalizePath(currentDirectory);
@@ -7493,8 +7606,11 @@ export function getRegexFromPattern(pattern: string, useCaseSensitiveFileNames:
     return new RegExp(pattern, useCaseSensitiveFileNames ? "" : "i");
 }
 
-/** @internal */
-/** @param path directory of the tsconfig.json */
+/**
+ * @param path directory of the tsconfig.json
+ *
+ * @internal
+ */
 export function matchFiles(path: string, extensions: readonly string[] | undefined, excludes: readonly string[] | undefined, includes: readonly string[] | undefined, useCaseSensitiveFileNames: boolean, currentDirectory: string, depth: number | undefined, getFileSystemEntries: (path: string) => FileSystemEntries, realpath: (path: string) => string): string[] {
     path = normalizePath(path);
     currentDirectory = normalizePath(currentDirectory);
@@ -7634,9 +7750,10 @@ export function getScriptKindFromFileName(fileName: string): ScriptKind {
     }
 }
 
-/** @internal */
 /**
  *  Groups of supported extensions in order of file resolution precedence. (eg, TS > TSX > DTS and seperately, CTS > DCTS)
+ *
+ * @internal
  */
 export const supportedTSExtensions: readonly Extension[][] = [[Extension.Ts, Extension.Tsx, Extension.Dts], [Extension.Cts, Extension.Dcts], [Extension.Mts, Extension.Dmts]];
 /** @internal */
@@ -7754,10 +7871,11 @@ export function changeExtension<T extends string | Path>(path: T, newExtension:
     return changeAnyExtension(path, newExtension, extensionsToRemove, /*ignoreCase*/ false) as T;
 }
 
-/** @internal */
 /**
  * Returns the input if there are no stars, a pattern if there is exactly one,
  * and undefined if there are more.
+ *
+ * @internal
  */
 export function tryParsePattern(pattern: string): string | Pattern | undefined {
     const indexOfStar = pattern.indexOf("*");
@@ -7784,8 +7902,11 @@ export function positionIsSynthesized(pos: number): boolean {
     return !(pos >= 0);
 }
 
-/** @internal */
-/** True if an extension is one of the supported TypeScript extensions. */
+/**
+ * True if an extension is one of the supported TypeScript extensions.
+ *
+ * @internal
+ */
 export function extensionIsTS(ext: Extension): boolean {
     return ext === Extension.Ts || ext === Extension.Tsx || ext === Extension.Dts || ext === Extension.Cts || ext === Extension.Mts || ext === Extension.Dmts || ext === Extension.Dcts;
 }
@@ -7795,10 +7916,11 @@ export function resolutionExtensionIsTSOrJson(ext: Extension) {
     return extensionIsTS(ext) || ext === Extension.Json;
 }
 
-/** @internal */
 /**
  * Gets the extension from a path.
  * Path must have a valid extension.
+ *
+ * @internal
  */
 export function extensionFromPath(path: string): Extension {
     const ext = tryGetExtensionFromPath(path);
@@ -7827,11 +7949,12 @@ export const emptyFileSystemEntries: FileSystemEntries = {
 };
 
 
-/** @internal */
 /**
  * patternOrStrings contains both patterns (containing "*") and regular strings.
  * Return an exact match if possible, or a pattern match, or undefined.
  * (These are verified by verifyCompilerOptions to have 0 or 1 "*" characters.)
+ *
+ * @internal
  */
 export function matchPatternOrExact(patternOrStrings: readonly (string | Pattern)[], candidate: string): string | Pattern | undefined {
     const patterns: Pattern[] = [];
@@ -7921,10 +8044,11 @@ export function isJsonEqual(a: unknown, b: unknown): boolean {
     return a === b || typeof a === "object" && a !== null && typeof b === "object" && b !== null && equalOwnProperties(a as MapLike<unknown>, b as MapLike<unknown>, isJsonEqual);
 }
 
-/** @internal */
 /**
  * Converts a bigint literal string, e.g. `0x1234n`,
  * to its decimal string representation, e.g. `4660`.
+ *
+ * @internal
  */
 export function parsePseudoBigInt(stringValue: string): string {
     let log2Base: number;
@@ -8181,19 +8305,21 @@ function isPackedElement(node: Expression) {
     return !isOmittedExpression(node);
 }
 
-/** @internal */
 /**
  * Determines whether the provided node is an ArrayLiteralExpression that contains no missing elements.
+ *
+ * @internal
  */
 export function isPackedArrayLiteral(node: Expression) {
     return isArrayLiteralExpression(node) && every(node.elements, isPackedElement);
 }
 
-/** @internal */
 /**
  * Indicates whether the result of an `Expression` will be unused.
  *
  * NOTE: This requires a node with a valid `parent` pointer.
+ *
+ * @internal
  */
 export function expressionResultIsUnused(node: Expression): boolean {
     Debug.assertIsDefined(node.parent);
diff --git a/src/compiler/utilitiesPublic.ts b/src/compiler/utilitiesPublic.ts
index 547db22486..fa9ffc2bdc 100644
--- a/src/compiler/utilitiesPublic.ts
+++ b/src/compiler/utilitiesPublic.ts
@@ -1697,10 +1697,11 @@ export function isUnaryExpressionWithWrite(expr: Node): expr is PrefixUnaryExpre
     }
 }
 
-/** @internal */
 /**
  * Determines whether a node is an expression based only on its kind.
  * Use `isExpressionNode` if not in transforms.
+ *
+ * @internal
  */
 export function isExpression(node: Node): node is Expression {
     return isExpressionKind(skipPartiallyEmittedExpressions(node).kind);
diff --git a/src/compiler/watch.ts b/src/compiler/watch.ts
index 13cd32f3dd..41db993d31 100644
--- a/src/compiler/watch.ts
+++ b/src/compiler/watch.ts
@@ -27,9 +27,10 @@ const sysFormatDiagnosticsHost: FormatDiagnosticsHost | undefined = sys ? {
     getCanonicalFileName: createGetCanonicalFileName(sys.useCaseSensitiveFileNames)
 } : undefined;
 
-/** @internal */
 /**
  * Create a function that reports error by writing to the system and handles the formatting of the diagnostic
+ *
+ * @internal
  */
 export function createDiagnosticReporter(system: System, pretty?: boolean): DiagnosticReporter {
     const host: FormatDiagnosticsHost = system === sys && sysFormatDiagnosticsHost ? sysFormatDiagnosticsHost : {
@@ -77,9 +78,10 @@ function getPlainDiagnosticFollowingNewLines(diagnostic: Diagnostic, newLine: st
         : newLine;
 }
 
-/** @internal */
 /**
  * Get locale specific time based on whether we are in test mode
+ *
+ * @internal
  */
 export function getLocaleTimeString(system: System) {
     return !system.now ?
@@ -87,9 +89,10 @@ export function getLocaleTimeString(system: System) {
         system.now().toLocaleTimeString("en-US", { timeZone: "UTC" });
 }
 
-/** @internal */
 /**
  * Create a function that reports watch status by writing to the system and handles the formatting of the diagnostic
+ *
+ * @internal
  */
 export function createWatchStatusReporter(system: System, pretty?: boolean): WatchStatusReporter {
     return pretty ?
@@ -113,8 +116,11 @@ export function createWatchStatusReporter(system: System, pretty?: boolean): Wat
         };
 }
 
-/** @internal */
-/** Parses config file using System interface */
+/**
+ * Parses config file using System interface
+ *
+ * @internal
+ */
 export function parseConfigFileWithSystem(configFileName: string, optionsToExtend: CompilerOptions, extendedConfigCache: Map<ExtendedConfigCacheEntry> | undefined, watchOptionsToExtend: WatchOptions | undefined, system: System, reportDiagnostic: DiagnosticReporter) {
     const host: ParseConfigFileHost = system as any;
     host.onUnRecoverableConfigFileDiagnostic = diagnostic => reportUnrecoverableDiagnostic(system, reportDiagnostic, diagnostic);
@@ -461,9 +467,10 @@ function toFileName(file: SourceFile | string, fileNameConvertor?: (fileName: st
     return fileNameConvertor ? fileNameConvertor(fileName) : fileName;
 }
 
-/** @internal */
 /**
  * Helper that emit files, report diagnostics and lists emitted and/or source files depending on compiler options
+ *
+ * @internal
  */
 export function emitFilesAndReportErrors<T extends BuilderProgram>(
     program: Program | T,
@@ -719,9 +726,10 @@ export function setGetSourceFileAsHashVersioned(compilerHost: CompilerHost, host
     };
 }
 
-/** @internal */
 /**
  * Creates the watch compiler host that can be extended with config file or root file names and options host
+ *
+ * @internal
  */
 export function createProgramHost<T extends BuilderProgram = EmitAndSemanticDiagnosticsBuilderProgram>(system: System, createProgram: CreateProgram<T> | undefined): ProgramHost<T> {
     const getDefaultLibLocation = memoize(() => getDirectoryPath(normalizePath(system.getExecutingFilePath())));
@@ -798,9 +806,10 @@ export interface CreateWatchCompilerHostOfConfigFileInput<T extends BuilderProgr
     watchOptionsToExtend?: WatchOptions;
     extraFileExtensions?: readonly FileExtensionInfo[];
 }
-/** @internal */
 /**
  * Creates the watch compiler host from system for config file in watch mode
+ *
+ * @internal
  */
 export function createWatchCompilerHostOfConfigFile<T extends BuilderProgram = EmitAndSemanticDiagnosticsBuilderProgram>({
     configFileName, optionsToExtend, watchOptionsToExtend, extraFileExtensions,
@@ -823,9 +832,10 @@ export interface CreateWatchCompilerHostOfFilesAndCompilerOptionsInput<T extends
     watchOptions: WatchOptions | undefined;
     projectReferences?: readonly ProjectReference[];
 }
-/** @internal */
 /**
  * Creates the watch compiler host from system for compiling root files and options in watch mode
+ *
+ * @internal
  */
 export function createWatchCompilerHostOfFilesAndCompilerOptions<T extends BuilderProgram = EmitAndSemanticDiagnosticsBuilderProgram>({
     rootFiles, options, watchOptions, projectReferences,
diff --git a/src/compiler/watchUtilities.ts b/src/compiler/watchUtilities.ts
index f126713313..5dce173af6 100644
--- a/src/compiler/watchUtilities.ts
+++ b/src/compiler/watchUtilities.ts
@@ -11,9 +11,10 @@ import {
     timestamp, WatchDirectoryFlags, WatchFileKind, WatchOptions,
 } from "./_namespaces/ts";
 
-/** @internal */
 /**
  * Partial interface of the System thats needed to support the caching of directory structure
+ *
+ * @internal
  */
 export interface DirectoryStructureHost {
     fileExists(path: string): boolean;
@@ -332,9 +333,10 @@ export interface SharedExtendedConfigFileWatcher<T> extends FileWatcher {
     projects: Set<T>;
 }
 
-/** @internal */
 /**
  * Updates the map of shared extended config file watches with a new set of extended config files from a base config file of the project
+ *
+ * @internal
  */
 export function updateSharedExtendedConfigFileWatcher<T>(
     projectPath: T,
@@ -373,9 +375,10 @@ export function updateSharedExtendedConfigFileWatcher<T>(
     });
 }
 
-/** @internal */
 /**
  * Remove the project from the extended config file watchers and close not needed watches
+ *
+ * @internal
  */
 export function clearSharedExtendedConfigFileWatcher<T>(
     projectPath: T,
@@ -386,9 +389,10 @@ export function clearSharedExtendedConfigFileWatcher<T>(
     });
 }
 
-/** @internal */
 /**
  * Clean the extendsConfigCache when extended config file has changed
+ *
+ * @internal
  */
 export function cleanExtendedConfigCache(
     extendedConfigCache: ESMap<string, ExtendedConfigCacheEntry>,
@@ -403,9 +407,10 @@ export function cleanExtendedConfigCache(
     });
 }
 
-/** @internal */
 /**
  * Updates watchers based on the package json files used in module resolution
+ *
+ * @internal
  */
 export function updatePackageJsonWatch(
     lookups: readonly (readonly [Path, object | boolean])[],
@@ -423,9 +428,10 @@ export function updatePackageJsonWatch(
     );
 }
 
-/** @internal */
 /**
  * Updates the existing missing file watches with the new set of missing files after new program is created
+ *
+ * @internal
  */
 export function updateMissingFilePathsWatch(
     program: Program,
@@ -455,12 +461,13 @@ export interface WildcardDirectoryWatcher {
     flags: WatchDirectoryFlags;
 }
 
-/** @internal */
 /**
  * Updates the existing wild card directory watches with the new set of wild card directories from the config file
  * after new program is created because the config file was reloaded or program was created first time from the config file
  * Note that there is no need to call this function when the program is updated with additional files without reloading config files,
  * as wildcard directories wont change unless reloading config file
+ *
+ * @internal
  */
 export function updateWatchingWildcardDirectories(
     existingWatchedForWildcards: ESMap<string, WildcardDirectoryWatcher>,
diff --git a/src/jsTyping/jsTyping.ts b/src/jsTyping/jsTyping.ts
index bafe1ee954..0ba0351a50 100644
--- a/src/jsTyping/jsTyping.ts
+++ b/src/jsTyping/jsTyping.ts
@@ -100,9 +100,10 @@ export function nonRelativeModuleNameForTypingCache(moduleName: string) {
     return nodeCoreModules.has(moduleName) ? "node" : moduleName;
 }
 
-/** @internal */
 /**
  * A map of loose file names to library names that we are confident require typings
+ *
+ * @internal
  */
 export type SafeList = ReadonlyESMap<string, string>;
 
@@ -121,7 +122,6 @@ export function loadTypesMap(host: TypingResolutionHost, typesMapPath: Path): Sa
     return undefined;
 }
 
-/** @internal */
 /**
  * @param host is the object providing I/O related operations.
  * @param fileNames are the file names that belong to the same project
@@ -130,6 +130,8 @@ export function loadTypesMap(host: TypingResolutionHost, typesMapPath: Path): Sa
  * @param packageNameToTypingLocation is the map of package names to their cached typing locations and installed versions
  * @param typeAcquisition is used to customize the typing acquisition process
  * @param compilerOptions are used as a source for typing inference
+ *
+ * @internal
  */
 export function discoverTypings(
     host: TypingResolutionHost,
@@ -371,9 +373,10 @@ export interface ScopedPackageNameValidationResult {
 /** @internal */
 export type PackageNameValidationResult = NameValidationResult | ScopedPackageNameValidationResult;
 
-/** @internal */
 /**
  * Validates package name using rules defined at https://docs.npmjs.com/files/package.json
+ *
+ * @internal
  */
 export function validatePackageName(packageName: string): PackageNameValidationResult {
     return validatePackageNameWorker(packageName, /*supportScopedPackage*/ true);
diff --git a/src/server/editorServices.ts b/src/server/editorServices.ts
index 162b6dfb56..b935faca54 100644
--- a/src/server/editorServices.ts
+++ b/src/server/editorServices.ts
@@ -467,8 +467,11 @@ function isAncestorConfigFileInfo(infoOrFileNameOrConfig: OpenScriptInfoOrClosed
     return !!(infoOrFileNameOrConfig as AncestorConfigFileInfo).configFileInfo;
 }
 
-/** @internal */
-/** Kind of operation to perform to get project reference project */
+/**
+ * Kind of operation to perform to get project reference project
+ *
+ * @internal
+ */
 export enum ProjectReferenceProjectLoadKind {
     /** Find existing project for project reference */
     Find,
@@ -639,8 +642,11 @@ function isScriptInfoWatchedFromNodeModules(info: ScriptInfo) {
     return !info.isScriptOpen() && info.mTime !== undefined;
 }
 
-/** @internal */
-/** true if script info is part of project and is not in project because it is referenced from project reference source */
+/**
+ * true if script info is part of project and is not in project because it is referenced from project reference source
+ *
+ * @internal
+ */
 export function projectContainsInfoDirectly(project: Project, info: ScriptInfo) {
     return project.containsScriptInfo(info) &&
         !project.isSourceOfProjectReferenceRedirect(info.path);
diff --git a/src/server/utilities.ts b/src/server/utilities.ts
index 03fb2ded56..95d2483593 100644
--- a/src/server/utilities.ts
+++ b/src/server/utilities.ts
@@ -106,8 +106,11 @@ export function indent(str: string): string {
     return indentStr + str.replace(/\n/g, indentStr);
 }
 
-/** @internal */
-/** Put stringified JSON on the next line, indented. */
+/**
+ * Put stringified JSON on the next line, indented.
+ *
+ * @internal
+ */
 export function stringifyIndented(json: {}): string {
     return indentStr + JSON.stringify(json);
 }
diff --git a/src/services/breakpoints.ts b/src/services/breakpoints.ts
index a39b675707..5b823d698d 100644
--- a/src/services/breakpoints.ts
+++ b/src/services/breakpoints.ts
@@ -13,9 +13,10 @@ import {
     TypeAssertion, VariableDeclaration, VariableDeclarationList, VariableStatement, WhileStatement, WithStatement,
 } from "./_namespaces/ts";
 
-/** @internal */
 /**
  * Get the breakpoint span in given sourceFile
+ *
+ * @internal
  */
 export function spanInSourceFileAtLocation(sourceFile: SourceFile, position: number) {
     // Cannot set breakpoint in dts file
diff --git a/src/services/callHierarchy.ts b/src/services/callHierarchy.ts
index 0c57afa9a2..941cb68946 100644
--- a/src/services/callHierarchy.ts
+++ b/src/services/callHierarchy.ts
@@ -244,8 +244,11 @@ function findImplementationOrAllInitialDeclarations(typeChecker: TypeChecker, no
     return findAllInitialDeclarations(typeChecker, node) ?? node;
 }
 
-/** @internal */
-/** Resolves the call hierarchy declaration for a node. */
+/**
+ * Resolves the call hierarchy declaration for a node.
+ *
+ * @internal
+ */
 export function resolveCallHierarchyDeclaration(program: Program, location: Node): CallHierarchyDeclaration | CallHierarchyDeclaration[] | undefined {
     // A call hierarchy item must refer to either a SourceFile, Module Declaration, Class Static Block, or something intrinsically callable that has a name:
     // - Class Declarations
@@ -315,8 +318,11 @@ export function resolveCallHierarchyDeclaration(program: Program, location: Node
     }
 }
 
-/** @internal */
-/** Creates a `CallHierarchyItem` for a call hierarchy declaration. */
+/**
+ * Creates a `CallHierarchyItem` for a call hierarchy declaration.
+ *
+ * @internal
+ */
 export function createCallHierarchyItem(program: Program, node: CallHierarchyDeclaration): CallHierarchyItem {
     const sourceFile = node.getSourceFile();
     const name = getCallHierarchyItemName(program, node);
@@ -365,8 +371,11 @@ function convertCallSiteGroupToIncomingCall(program: Program, entries: readonly
     return createCallHierarchyIncomingCall(createCallHierarchyItem(program, entries[0].declaration), map(entries, entry => createTextSpanFromRange(entry.range)));
 }
 
-/** @internal */
-/** Gets the call sites that call into the provided call hierarchy declaration. */
+/**
+ * Gets the call sites that call into the provided call hierarchy declaration.
+ *
+ * @internal
+ */
 export function getIncomingCalls(program: Program, declaration: CallHierarchyDeclaration, cancellationToken: CancellationToken): CallHierarchyIncomingCall[] {
     // Source files and modules have no incoming calls.
     if (isSourceFile(declaration) || isModuleDeclaration(declaration) || isClassStaticBlockDeclaration(declaration)) {
@@ -575,8 +584,11 @@ function convertCallSiteGroupToOutgoingCall(program: Program, entries: readonly
     return createCallHierarchyOutgoingCall(createCallHierarchyItem(program, entries[0].declaration), map(entries, entry => createTextSpanFromRange(entry.range)));
 }
 
-/** @internal */
-/** Gets the call sites that call out of the provided call hierarchy declaration. */
+/**
+ * Gets the call sites that call out of the provided call hierarchy declaration.
+ *
+ * @internal
+ */
 export function getOutgoingCalls(program: Program, declaration: CallHierarchyDeclaration): CallHierarchyOutgoingCall[] {
     if (declaration.flags & NodeFlags.Ambient || isMethodSignature(declaration)) {
         return [];
diff --git a/src/services/classifier2020.ts b/src/services/classifier2020.ts
index 7b8c7e1dbb..acad0e9cce 100644
--- a/src/services/classifier2020.ts
+++ b/src/services/classifier2020.ts
@@ -26,8 +26,11 @@ export const enum TokenModifier {
     declaration, static, async, readonly, defaultLibrary, local
 }
 
-/** @internal */
-/** This is mainly used internally for testing */
+/**
+ * This is mainly used internally for testing
+ *
+ * @internal
+ */
 export function getSemanticClassifications(program: Program, cancellationToken: CancellationToken, sourceFile: SourceFile, span: TextSpan): ClassifiedSpan2020[] {
     const classifications = getEncodedSemanticClassifications(program, cancellationToken, sourceFile, span);
 
diff --git a/src/services/codefixes/helpers.ts b/src/services/codefixes/helpers.ts
index 16d72381fe..51f9161fed 100644
--- a/src/services/codefixes/helpers.ts
+++ b/src/services/codefixes/helpers.ts
@@ -17,13 +17,14 @@ import {
 } from "../_namespaces/ts";
 import { ImportAdder } from "../_namespaces/ts.codefix";
 
-/** @internal */
 /**
  * Finds members of the resolved type that are missing in the class pointed to by class decl
  * and generates source code for the missing members.
  * @param possiblyMissingSymbols The collection of symbols to filter and then get insertions for.
  * @param importAdder If provided, type annotations will use identifier type references instead of ImportTypeNodes, and the missing imports will be added to the importAdder.
  * @returns Empty string iff there are no member insertions.
+ *
+ * @internal
  */
 export function createMissingMemberNodes(
     classDeclaration: ClassLikeDeclaration,
@@ -64,10 +65,11 @@ export const enum PreserveOptionalFlags {
     All     = Method | Property
 }
 
-/** @internal */
 /**
  * `addClassElement` will not be called if we can't figure out a representation for `symbol` in `enclosingDeclaration`.
  * @param body If defined, this will be the body of the member node passed to `addClassElement`. Otherwise, the body will default to a stub.
+ *
+ * @internal
  */
 export function addNewNodeForMemberSymbol(
     symbol: Symbol,
@@ -728,11 +730,12 @@ export function findJsonProperty(obj: ObjectLiteralExpression, name: string): Pr
     return find(obj.properties, (p): p is PropertyAssignment => isPropertyAssignment(p) && !!p.name && isStringLiteral(p.name) && p.name.text === name);
 }
 
-/** @internal */
 /**
  * Given a type node containing 'import("./a").SomeType<import("./b").OtherType<...>>',
  * returns an equivalent type reference node with any nested ImportTypeNodes also replaced
  * with type references, and a list of symbols that must be imported to use the type reference.
+ *
+ * @internal
  */
 export function tryGetAutoImportableReferenceFromTypeNode(importTypeNode: TypeNode | undefined, scriptTarget: ScriptTarget) {
     let symbols: Symbol[] | undefined;
diff --git a/src/services/codefixes/importFixes.ts b/src/services/codefixes/importFixes.ts
index f07c1e33c9..b02eeed8f8 100644
--- a/src/services/codefixes/importFixes.ts
+++ b/src/services/codefixes/importFixes.ts
@@ -67,9 +67,10 @@ registerCodeFix({
     },
 });
 
-/** @internal */
 /**
  * Computes multiple import additions to a file and writes them to a ChangeTracker.
+ *
+ * @internal
  */
 export interface ImportAdder {
     hasFixes(): boolean;
@@ -266,9 +267,10 @@ function createImportAdderWorker(sourceFile: SourceFile, program: Program, useAu
     }
 }
 
-/** @internal */
 /**
  * Computes module specifiers for multiple import additions to a file.
+ *
+ * @internal
  */
  export interface ImportSpecifierResolver {
     getModuleSpecifierForBestExportInfo(
@@ -886,10 +888,11 @@ function getUmdSymbol(token: Node, checker: TypeChecker): Symbol | undefined {
         : undefined;
 }
 
-/** @internal */
 /**
  * @param forceImportKeyword Indicates that the user has already typed `import`, so the result must start with `import`.
  * (In other words, do not allow `const x = require("...")` for JS files.)
+ *
+ * @internal
  */
 export function getImportKind(importingFile: SourceFile, exportKind: ExportKind, compilerOptions: CompilerOptions, forceImportKeyword?: boolean): ImportKind {
     switch (exportKind) {
diff --git a/src/services/completions.ts b/src/services/completions.ts
index 1f97c57e5b..f74267058e 100644
--- a/src/services/completions.ts
+++ b/src/services/completions.ts
@@ -99,7 +99,6 @@ export const SortText = {
     },
 };
 
-/** @internal */
 /**
  * Special values for `CompletionInfo['source']` used to disambiguate
  * completion items with the same `name`. (Each completion item must
@@ -110,6 +109,8 @@ export const SortText = {
  * is the module specifier of the suggestion. To avoid collisions,
  * the values here should not be a module specifier we would ever
  * generate for an auto-import.
+ *
+ * @internal
  */
 export enum CompletionSource {
     /** Completions that require `this.` insertion text */
diff --git a/src/services/findAllReferences.ts b/src/services/findAllReferences.ts
index 1ccd8d74e0..5ef8f6436b 100644
--- a/src/services/findAllReferences.ts
+++ b/src/services/findAllReferences.ts
@@ -638,8 +638,11 @@ function isWriteAccessForReference(node: Node): boolean {
     return !!decl && declarationIsWriteAccess(decl) || node.kind === SyntaxKind.DefaultKeyword || isWriteAccess(node);
 }
 
-/** @internal */
-/** Whether a reference, `node`, is a definition of the `target` symbol */
+/**
+ * Whether a reference, `node`, is a definition of the `target` symbol
+ *
+ * @internal
+ */
 export function isDeclarationOfSymbol(node: Node, target: Symbol | undefined): boolean {
     if (!target) return false;
     const source = getDeclarationFromName(node) ||
@@ -712,8 +715,11 @@ function declarationIsWriteAccess(decl: Declaration): boolean {
     }
 }
 
-/** @internal */
-/** Encapsulates the core find-all-references algorithm. */
+/**
+ * Encapsulates the core find-all-references algorithm.
+ *
+ * @internal
+ */
 export namespace Core {
     /** Core find-all-references algorithm. Handles special cases before delegating to `getReferencedSymbolsForSymbol`. */
     export function getReferencedSymbolsForNode(position: number, node: Node, program: Program, sourceFiles: readonly SourceFile[], cancellationToken: CancellationToken, options: Options = {}, sourceFilesSet: ReadonlySet<string> = new Set(sourceFiles.map(f => f.fileName))): readonly SymbolAndEntries[] | undefined {
diff --git a/src/services/formatting/formatting.ts b/src/services/formatting/formatting.ts
index b3913f66ed..0d53a1474d 100644
--- a/src/services/formatting/formatting.ts
+++ b/src/services/formatting/formatting.ts
@@ -1316,9 +1316,9 @@ function formatSpanWorker(
 
 const enum LineAction { None, LineAdded, LineRemoved }
 
-/** @internal */
 /**
- * @param precedingToken pass `null` if preceding token was already computed and result was `undefined`.
+ *
+ * @internal
  */
 export function getRangeOfEnclosingComment(
     sourceFile: SourceFile,
diff --git a/src/services/goToDefinition.ts b/src/services/goToDefinition.ts
index 536026deed..77d5178552 100644
--- a/src/services/goToDefinition.ts
+++ b/src/services/goToDefinition.ts
@@ -415,8 +415,11 @@ function getDefinitionFromSymbol(typeChecker: TypeChecker, symbol: Symbol, node:
     }
 }
 
-/** @internal */
-/** Creates a DefinitionInfo from a Declaration, using the declaration's name if possible. */
+/**
+ * Creates a DefinitionInfo from a Declaration, using the declaration's name if possible.
+ *
+ * @internal
+ */
 export function createDefinitionInfo(declaration: Declaration, checker: TypeChecker, symbol: Symbol, node: Node, unverified?: boolean, failedAliasResolution?: boolean): DefinitionInfo {
     const symbolName = checker.symbolToString(symbol); // Do not get scoped name, just the name of the symbol
     const symbolKind = SymbolDisplay.getSymbolKind(checker, symbol, node);
diff --git a/src/services/importTracker.ts b/src/services/importTracker.ts
index a95a9beadc..020bc712d9 100644
--- a/src/services/importTracker.ts
+++ b/src/services/importTracker.ts
@@ -29,8 +29,11 @@ export interface ImportsResult {
 /** @internal */
 export type ImportTracker = (exportSymbol: Symbol, exportInfo: ExportInfo, isForRename: boolean) => ImportsResult;
 
-/** @internal */
-/** Creates the imports map and returns an ImportTracker that uses it. Call this lazily to avoid calling `getDirectImportsMap` unnecessarily.  */
+/**
+ * Creates the imports map and returns an ImportTracker that uses it. Call this lazily to avoid calling `getDirectImportsMap` unnecessarily.
+ *
+ * @internal
+ */
 export function createImportTracker(sourceFiles: readonly SourceFile[], sourceFilesSet: ReadonlySet<string>, checker: TypeChecker, cancellationToken: CancellationToken | undefined): ImportTracker {
     const allDirectImports = getDirectImportsMap(sourceFiles, checker, cancellationToken);
     return (exportSymbol, exportInfo, isForRename) => {
@@ -39,8 +42,11 @@ export function createImportTracker(sourceFiles: readonly SourceFile[], sourceFi
     };
 }
 
-/** @internal */
-/** Info about an exported symbol to perform recursive search on. */
+/**
+ * Info about an exported symbol to perform recursive search on.
+ *
+ * @internal
+ */
 export interface ExportInfo {
     exportingModuleSymbol: Symbol;
     exportKind: ExportKind;
@@ -479,13 +485,14 @@ export interface ExportedSymbol {
     exportInfo: ExportInfo;
 }
 
-/** @internal */
 /**
  * Given a local reference, we might notice that it's an import/export and recursively search for references of that.
  * If at an import, look locally for the symbol it imports.
  * If at an export, look for all imports of it.
  * This doesn't handle export specifiers; that is done in `getReferencesAtExportSpecifier`.
  * @param comingFromExport If we are doing a search for all exports, don't bother looking backwards for the imported symbol, since that's the reason we're here.
+ *
+ * @internal
  */
 export function getImportOrExportSymbol(node: Node, symbol: Symbol, checker: TypeChecker, comingFromExport: boolean): ImportedSymbol | ExportedSymbol | undefined {
     return comingFromExport ? getExport() : getExport() || getImport();
diff --git a/src/services/jsDoc.ts b/src/services/jsDoc.ts
index 703d6adcb0..edf2e55178 100644
--- a/src/services/jsDoc.ts
+++ b/src/services/jsDoc.ts
@@ -337,7 +337,6 @@ export function getJSDocParameterNameCompletionDetails(name: string): Completion
     };
 }
 
-/** @internal */
 /**
  * Checks if position points to a valid position to add JSDoc comments, and if so,
  * returns the appropriate template. Otherwise returns an empty string.
@@ -360,6 +359,8 @@ export function getJSDocParameterNameCompletionDetails(name: string): Completion
  * @param fileName The file in which to perform the check.
  * @param position The (character-indexed) position in the file where the check should
  * be performed.
+ *
+ * @internal
  */
 export function getDocCommentTemplateAtPosition(newLine: string, sourceFile: SourceFile, position: number, options?: DocCommentTemplateOptions): TextInsertion | undefined {
     const tokenAtPos = getTokenAtPosition(sourceFile, position);
diff --git a/src/services/organizeImports.ts b/src/services/organizeImports.ts
index e004e1a34a..d58abf051a 100644
--- a/src/services/organizeImports.ts
+++ b/src/services/organizeImports.ts
@@ -10,12 +10,13 @@ import {
     stableSort, suppressLeadingTrivia, SyntaxKind, textChanges, TransformFlags, tryCast, UserPreferences,
 } from "./_namespaces/ts";
 
-/** @internal */
 /**
  * Organize imports by:
  *   1) Removing unused imports
  *   2) Coalescing imports from the same module
  *   3) Sorting imports
+ *
+ * @internal
  */
 export function organizeImports(
     sourceFile: SourceFile,
@@ -232,9 +233,10 @@ function getExternalModuleName(specifier: Expression) {
 }
 
 // Internal for testing
-/** @internal */
 /**
  * @param importGroup a list of ImportDeclarations, all with the same module name.
+ *
+ * @internal
  */
 export function coalesceImports(importGroup: readonly ImportDeclaration[]) {
     if (importGroup.length === 0) {
@@ -373,9 +375,10 @@ function getCategorizedImports(importGroup: readonly ImportDeclaration[]) {
 }
 
 // Internal for testing
-/** @internal */
 /**
  * @param exportGroup a list of ExportDeclarations, all with the same module name.
+ *
+ * @internal
  */
 export function coalesceExports(exportGroup: readonly ExportDeclaration[]) {
     if (exportGroup.length === 0) {
diff --git a/src/services/refactorProvider.ts b/src/services/refactorProvider.ts
index 41f9b72547..3fb1751875 100644
--- a/src/services/refactorProvider.ts
+++ b/src/services/refactorProvider.ts
@@ -7,8 +7,11 @@ import { refactorKindBeginsWith } from "./_namespaces/ts.refactor";
 // e.g.  nonSuggestableRefactors[refactorCode] -> the refactor you want
 const refactors = new Map<string, Refactor>();
 
-/** @internal */
-/** @param name An unique code associated with each refactor. Does not have to be human-readable. */
+/**
+ * @param name An unique code associated with each refactor. Does not have to be human-readable.
+ *
+ * @internal
+ */
 export function registerRefactor(name: string, refactor: Refactor) {
     refactors.set(name, refactor);
 }
diff --git a/src/services/refactors/extractSymbol.ts b/src/services/refactors/extractSymbol.ts
index acb6048a1c..5579b4f92b 100644
--- a/src/services/refactors/extractSymbol.ts
+++ b/src/services/refactors/extractSymbol.ts
@@ -49,10 +49,11 @@ registerRefactor(refactorName, {
     getAvailableActions: getRefactorActionsToExtractSymbol,
 });
 
-/** @internal */
 /**
  * Compute the associated code actions
  * Exported for tests.
+ *
+ * @internal
  */
 export function getRefactorActionsToExtractSymbol(context: RefactorContext): readonly ApplicableRefactorInfo[] {
     const requestedRefactor = context.kind;
@@ -297,14 +298,15 @@ type RangeToExtract = {
  */
 type Scope = FunctionLikeDeclaration | SourceFile | ModuleBlock | ClassLikeDeclaration;
 
-/** @internal */
+// exported only for tests
 /**
  * getRangeToExtract takes a span inside a text file and returns either an expression or an array
  * of statements representing the minimum set of nodes needed to extract the entire span. This
  * process may fail, in which case a set of errors is returned instead. These errors are shown to
  * users if they have the provideRefactorNotApplicableReason option set.
+ *
+ * @internal
  */
-// exported only for tests
 export function getRangeToExtract(sourceFile: SourceFile, span: TextSpan, invoked = true): RangeToExtract {
     const { length } = span;
     if (length === 0 && !invoked) {
diff --git a/src/services/refactors/helpers.ts b/src/services/refactors/helpers.ts
index ed7658941d..39f6a16276 100644
--- a/src/services/refactors/helpers.ts
+++ b/src/services/refactors/helpers.ts
@@ -1,23 +1,27 @@
-/** @internal */
+
 /**
  * Returned by refactor functions when some error message needs to be surfaced to users.
+ *
+ * @internal
  */
 export interface RefactorErrorInfo {
     error: string;
 };
 
-/** @internal */
 /**
  * Checks if some refactor info has refactor error info.
+ *
+ * @internal
  */
 export function isRefactorErrorInfo(info: unknown): info is RefactorErrorInfo {
     return (info as RefactorErrorInfo).error !== undefined;
 }
 
-/** @internal */
 /**
  * Checks if string "known" begins with string "requested".
  * Used to match requested kinds with a known kind.
+ *
+ * @internal
  */
 export function refactorKindBeginsWith(known: string, requested: string | undefined): boolean {
     if(!requested) return true;
diff --git a/src/services/services.ts b/src/services/services.ts
index 80f57420c1..c43b84fcc4 100644
--- a/src/services/services.ts
+++ b/src/services/services.ts
@@ -1194,8 +1194,11 @@ class CancellationTokenObject implements CancellationToken {
     }
 }
 
-/** @internal */
-/** A cancellation that throttles calls to the host */
+/**
+ * A cancellation that throttles calls to the host
+ *
+ * @internal
+ */
 export class ThrottledCancellationToken implements CancellationToken {
     // Store when we last tried to cancel.  Checking cancellation can be expensive (as we have
     // to marshall over to the host layer).  So we only bother actually checking once enough
@@ -2797,8 +2800,11 @@ export function createLanguageService(
     return ls;
 }
 
-/** @internal */
-/** Names in the name table are escaped, so an identifier `__foo` will have a name table entry `___foo`. */
+/**
+ * Names in the name table are escaped, so an identifier `__foo` will have a name table entry `___foo`.
+ *
+ * @internal
+ */
 export function getNameTable(sourceFile: SourceFile): UnderscoreEscapedMap<number> {
     if (!sourceFile.nameTable) {
         initializeNameTable(sourceFile);
diff --git a/src/services/shims.ts b/src/services/shims.ts
index 4a1a2d8c19..6303302620 100644
--- a/src/services/shims.ts
+++ b/src/services/shims.ts
@@ -74,8 +74,11 @@ export interface Logger {
     error(s: string): void;
 }
 
-/** @internal */
-/** Public interface of the host of a language service shim instance. */
+/**
+ * Public interface of the host of a language service shim instance.
+ *
+ * @internal
+ */
 export interface LanguageServiceShimHost extends Logger {
     getCompilationSettings(): string;
 
@@ -103,8 +106,11 @@ export interface LanguageServiceShimHost extends Logger {
     directoryExists(directoryName: string): boolean;
 }
 
-/** @internal */
-/** Public interface of the core-services host instance used in managed side */
+/**
+ * Public interface of the core-services host instance used in managed side
+ *
+ * @internal
+ */
 export interface CoreServicesShimHost extends Logger {
     directoryExists(directoryName: string): boolean;
     fileExists(fileName: string): boolean;
@@ -140,8 +146,11 @@ export interface ShimsFileReference {
     length: number;
 }
 
-/** @internal */
-/** Public interface of a language service instance shim. */
+/**
+ * Public interface of a language service instance shim.
+ *
+ * @internal
+ */
 export interface ShimFactory {
     registerShim(shim: Shim): void;
     unregisterShim(shim: Shim): void;
diff --git a/src/services/sourcemaps.ts b/src/services/sourcemaps.ts
index f954eea53b..73079ef532 100644
--- a/src/services/sourcemaps.ts
+++ b/src/services/sourcemaps.ts
@@ -142,10 +142,11 @@ export function getSourceMapper(host: SourceMapperHost): SourceMapper {
     }
 }
 
-/** @internal */
 /**
  * string | undefined to contents of map file to create DocumentPositionMapper from it
  * DocumentPositionMapper | false to give back cached DocumentPositionMapper
+ *
+ * @internal
  */
 export type ReadMapFile = (mapFileName: string, mapFileNameFromDts: string | undefined) => string | undefined | DocumentPositionMapper | false;
 
diff --git a/src/services/textChanges.ts b/src/services/textChanges.ts
index 2aec0843d2..2ddc725e83 100644
--- a/src/services/textChanges.ts
+++ b/src/services/textChanges.ts
@@ -110,7 +110,6 @@ function hasCommentsBeforeLineBreak(text: string, start: number) {
     return false;
 }
 
-/** @internal */
 /**
  * Usually node.pos points to a position immediately after the previous token.
  * If this position is used as a beginning of the span to remove - it might lead to removing the trailing trivia of the previous node, i.e:
@@ -123,6 +122,8 @@ function hasCommentsBeforeLineBreak(text: string, start: number) {
  * By default when removing nodes we adjust start and end positions to respect specification of the trivia above.
  * If pos\end should be interpreted literally (that is, withouth including leading and trailing trivia), `leadingTriviaOption` should be set to `LeadingTriviaOption.Exclude`
  * and `trailingTriviaOption` to `TrailingTriviaOption.Exclude`.
+ *
+ * @internal
  */
 export interface ConfigurableStartEnd extends ConfigurableStart, ConfigurableEnd {}
 
@@ -1614,9 +1615,12 @@ namespace deleteDeclaration {
     }
 }
 
-/** @internal */
-/** Warning: This deletes comments too. See `copyComments` in `convertFunctionToEs6Class`. */
 // Exported for tests only! (TODO: improve tests to not need this)
+/**
+ * Warning: This deletes comments too. See `copyComments` in `convertFunctionToEs6Class`.
+ *
+ * @internal
+ */
 export function deleteNode(changes: ChangeTracker, sourceFile: SourceFile, node: Node, options: ConfigurableStartEnd = { leadingTriviaOption: LeadingTriviaOption.IncludeAll }): void {
     const startPosition = getAdjustedStartPosition(sourceFile, node, options);
     const endPosition = getAdjustedEndPosition(sourceFile, node, options);
diff --git a/src/services/utilities.ts b/src/services/utilities.ts
index 8f859b7df2..1bcf74c162 100644
--- a/src/services/utilities.ts
+++ b/src/services/utilities.ts
@@ -640,9 +640,10 @@ export function startEndOverlapsWithStartEnd(start1: number, end1: number, start
     return start < end;
 }
 
-/** @internal */
 /**
  * Assumes `candidate.start <= position` holds.
+ *
+ * @internal
  */
 export function positionBelongsToNode(candidate: Node, position: number, sourceFile: SourceFile): boolean {
     Debug.assert(candidate.pos <= position);
@@ -1194,43 +1195,50 @@ function getAdjustedLocation(node: Node, forRename: boolean): Node {
     return node;
 }
 
-/** @internal */
 /**
  * Adjusts the location used for "find references" and "go to definition" when the cursor was not
  * on a property name.
+ *
+ * @internal
  */
 export function getAdjustedReferenceLocation(node: Node): Node {
     return getAdjustedLocation(node, /*forRename*/ false);
 }
 
-/** @internal */
 /**
  * Adjusts the location used for "rename" when the cursor was not on a property name.
+ *
+ * @internal
  */
 export function getAdjustedRenameLocation(node: Node): Node {
     return getAdjustedLocation(node, /*forRename*/ true);
 }
 
-/** @internal */
 /**
  * Gets the token whose text has range [start, end) and
  * position >= start and (position < end or (position === end && token is literal or keyword or identifier))
+ *
+ * @internal
  */
 export function getTouchingPropertyName(sourceFile: SourceFile, position: number): Node {
     return getTouchingToken(sourceFile, position, n => isPropertyNameLiteral(n) || isKeyword(n.kind) || isPrivateIdentifier(n));
 }
 
-/** @internal */
 /**
  * Returns the token if position is in [start, end).
  * If position === end, returns the preceding token if includeItemAtEndPosition(previousToken) === true
+ *
+ * @internal
  */
 export function getTouchingToken(sourceFile: SourceFile, position: number, includePrecedingTokenAtEndPosition?: (n: Node) => boolean): Node {
     return getTokenAtPositionWorker(sourceFile, position, /*allowPositionInLeadingTrivia*/ false, includePrecedingTokenAtEndPosition, /*includeEndPosition*/ false);
 }
 
-/** @internal */
-/** Returns a token if position is in [start-of-leading-trivia, end) */
+/**
+ * Returns a token if position is in [start-of-leading-trivia, end)
+ *
+ * @internal
+ */
 export function getTokenAtPosition(sourceFile: SourceFile, position: number): Node {
     return getTokenAtPositionWorker(sourceFile, position, /*allowPositionInLeadingTrivia*/ true, /*includePrecedingTokenAtEndPosition*/ undefined, /*includeEndPosition*/ false);
 }
@@ -1331,10 +1339,11 @@ function getTokenAtPositionWorker(sourceFile: SourceFile, position: number, allo
     }
 }
 
-/** @internal */
 /**
  * Returns the first token where position is in [start, end),
  * excluding `JsxText` tokens containing only whitespace.
+ *
+ * @internal
  */
 export function findFirstNonJsxWhitespaceToken(sourceFile: SourceFile, position: number): Node | undefined {
     let tokenAtPosition = getTokenAtPosition(sourceFile, position);
@@ -1346,7 +1355,6 @@ export function findFirstNonJsxWhitespaceToken(sourceFile: SourceFile, position:
     return tokenAtPosition;
 }
 
-/** @internal */
 /**
  * The token on the left of the position is the token that strictly includes the position
  * or sits to the left of the cursor if it is on a boundary. For example
@@ -1354,6 +1362,8 @@ export function findFirstNonJsxWhitespaceToken(sourceFile: SourceFile, position:
  *   fo|o               -> will return foo
  *   foo <comment> |bar -> will return foo
  *
+ *
+ * @internal
  */
 export function findTokenOnLeftOfPosition(file: SourceFile, position: number): Node | undefined {
     // Ideally, getTokenAtPosition should return a token. However, it is currently
@@ -1386,10 +1396,11 @@ export function findNextToken(previousToken: Node, parent: Node, sourceFile: Sou
     }
 }
 
-/** @internal */
 /**
  * Finds the rightmost token satisfying `token.end <= position`,
  * excluding `JsxText` tokens containing only whitespace.
+ *
+ * @internal
  */
 export function findPrecedingToken(position: number, sourceFile: SourceFileLike, startNode: Node, excludeJsdoc?: boolean): Node | undefined;
 /** @internal */
@@ -1515,9 +1526,9 @@ export function isInString(sourceFile: SourceFile, position: number, previousTok
     return false;
 }
 
-/** @internal */
 /**
- * returns true if the position is in between the open and close elements of an JSX expression.
+ *
+ * @internal
  */
 export function isInsideJsxElementOrAttribute(sourceFile: SourceFile, position: number) {
     const token = getTokenAtPosition(sourceFile, position);
@@ -1793,12 +1804,13 @@ export function getPossibleTypeArgumentsInfo(tokenIn: Node | undefined, sourceFi
     return undefined;
 }
 
-/** @internal */
 /**
  * Returns true if the cursor at position in sourceFile is within a comment.
  *
  * @param tokenAtPosition Must equal `getTokenAtPosition(sourceFile, position)`
  * @param predicate Additional predicate to test on the comment range.
+ *
+ * @internal
  */
 export function isInComment(sourceFile: SourceFile, position: number, tokenAtPosition?: Node): CommentRange | undefined {
     return formatting.getRangeOfEnclosingComment(sourceFile, position, /*precedingToken*/ undefined, tokenAtPosition);
@@ -2027,14 +2039,20 @@ export function isTypeKeywordTokenOrIdentifier(node: Node) {
     return isTypeKeywordToken(node) || isIdentifier(node) && node.text === "type";
 }
 
-/** @internal */
-/** True if the symbol is for an external module, as opposed to a namespace. */
+/**
+ * True if the symbol is for an external module, as opposed to a namespace.
+ *
+ * @internal
+ */
 export function isExternalModuleSymbol(moduleSymbol: Symbol): boolean {
     return !!(moduleSymbol.flags & SymbolFlags.Module) && moduleSymbol.name.charCodeAt(0) === CharacterCodes.doubleQuote;
 }
 
-/** @internal */
-/** Returns `true` the first time it encounters a node and `false` afterwards. */
+/**
+ * Returns `true` the first time it encounters a node and `false` afterwards.
+ *
+ * @internal
+ */
 export type NodeSeenTracker<T = Node> = (node: T) => boolean;
 /** @internal */
 export function nodeSeenTracker<T extends Node>(): NodeSeenTracker<T> {
@@ -2292,11 +2310,12 @@ export function documentSpansEqual(a: DocumentSpan, b: DocumentSpan): boolean {
     return a.fileName === b.fileName && textSpansEqual(a.textSpan, b.textSpan);
 }
 
-/** @internal */
 /**
  * Iterates through 'array' by index and performs the callback on each element of array until the callback
  * returns a truthy value, then returns that value.
  * If no such value is found, the callback is applied to each element of array and undefined is returned.
+ *
+ * @internal
  */
 export function forEachUnique<T, U>(array: readonly T[] | undefined, callback: (element: T, index: number) => U): U | undefined {
     if (array) {
@@ -2633,9 +2652,10 @@ function findLinkNameEnd(text: string) {
 }
 
 const carriageReturnLineFeed = "\r\n";
-/** @internal */
 /**
  * The default is CRLF.
+ *
+ * @internal
  */
 export function getNewLineOrDefaultFromHost(host: FormattingHost, formatSettings?: FormatCodeSettings) {
     return formatSettings?.newLineCharacter ||
@@ -2745,12 +2765,13 @@ export function getPrecedingNonSpaceCharacterPosition(text: string, position: nu
     return position + 1;
 }
 
-/** @internal */
 /**
  * Creates a deep, memberwise clone of a node with no source map location.
  *
  * WARNING: This is an expensive operation and is only intended to be used in refactorings
  * and code fixes (because those are triggered by explicit user actions).
+ *
+ * @internal
  */
 export function getSynthesizedDeepClone<T extends Node | undefined>(node: T, includeTrivia = true): T {
     const clone = node && getSynthesizedDeepCloneWorker(node);
@@ -2820,26 +2841,29 @@ export function getSynthesizedDeepClonesWithReplacements<T extends Node>(
     return factory.createNodeArray(nodes.map(n => getSynthesizedDeepCloneWithReplacements(n, includeTrivia, replaceNode)), nodes.hasTrailingComma);
 }
 
-/** @internal */
 /**
  * Sets EmitFlags to suppress leading and trailing trivia on the node.
+ *
+ * @internal
  */
 export function suppressLeadingAndTrailingTrivia(node: Node) {
     suppressLeadingTrivia(node);
     suppressTrailingTrivia(node);
 }
 
-/** @internal */
 /**
  * Sets EmitFlags to suppress leading trivia on the node.
+ *
+ * @internal
  */
 export function suppressLeadingTrivia(node: Node) {
     addEmitFlagsRecursively(node, EmitFlags.NoLeadingComments, getFirstChild);
 }
 
-/** @internal */
 /**
  * Sets EmitFlags to suppress trailing trivia on the node.
+ *
+ * @internal
  */
 export function suppressTrailingTrivia(node: Node) {
     addEmitFlagsRecursively(node, EmitFlags.NoTrailingComments, getLastChild);
@@ -2886,11 +2910,12 @@ export function getUniqueName(baseName: string, sourceFile: SourceFile): string
     return nameText;
 }
 
-/** @internal */
 /**
  * @return The index of the (only) reference to the extracted symbol.  We want the cursor
  * to be on the reference, rather than the declaration, because it's closer to where the
  * user was before extracting it.
+ *
+ * @internal
  */
 export function getRenameLocation(edits: readonly FileTextChanges[], renameFilename: string, name: string, preferLastLocation: boolean): number {
     let delta = 0;
@@ -2929,13 +2954,14 @@ export function copyTrailingComments(sourceNode: Node, targetNode: Node, sourceF
     forEachTrailingCommentRange(sourceFile.text, sourceNode.end, getAddCommentsFunction(targetNode, sourceFile, commentKind, hasTrailingNewLine, addSyntheticTrailingComment));
 }
 
-/** @internal */
 /**
  * This function copies the trailing comments for the token that comes before `sourceNode`, as leading comments of `targetNode`.
  * This is useful because sometimes a comment that refers to `sourceNode` will be a leading comment for `sourceNode`, according to the
  * notion of trivia ownership, and instead will be a trailing comment for the token before `sourceNode`, e.g.:
  * `function foo(\* not leading comment for a *\ a: string) {}`
  * The comment refers to `a` but belongs to the `(` token, but we might want to copy it.
+ *
+ * @internal
  */
 export function copyTrailingAsLeadingComments(sourceNode: Node, targetNode: Node, sourceFile: SourceFile, commentKind?: CommentKind, hasTrailingNewLine?: boolean) {
     forEachTrailingCommentRange(sourceFile.text, sourceNode.pos, getAddCommentsFunction(targetNode, sourceFile, commentKind, hasTrailingNewLine, addSyntheticLeadingComment));
@@ -3547,10 +3573,11 @@ export function getFixableErrorSpanExpression(sourceFile: SourceFile, span: Text
     return expression;
 }
 
-/** @internal */
 /**
  * If the provided value is an array, the mapping function is applied to each element; otherwise, the mapping function is applied
  * to the provided value itself.
+ *
+ * @internal
  */
 export function mapOneOrMany<T, U>(valueOrArray: T | readonly T[], f: (x: T, i: number) => U): U | U[];
 /** @internal */
@@ -3564,9 +3591,10 @@ export function mapOneOrMany<T, U>(valueOrArray: T | readonly T[] | undefined, f
     return valueOrArray ? isArray(valueOrArray) ? resultSelector(map(valueOrArray, f)) : f(valueOrArray, 0) : undefined;
 }
 
-/** @internal */
 /**
  * If the provided value is an array, the first element of the array is returned; otherwise, the provided value is returned instead.
+ *
+ * @internal
  */
 export function firstOrOnly<T>(valueOrArray: T | readonly T[]): T {
     return isArray(valueOrArray) ? first(valueOrArray) : valueOrArray;
@@ -3616,7 +3644,6 @@ function getSymbolParentOrFail(symbol: Symbol) {
         }).join(", ")}.`);
 }
 
-/** @internal */
 /**
  * Useful to check whether a string contains another string at a specific index
  * without allocating another string or traversing the entire contents of the outer string.
@@ -3634,6 +3661,8 @@ function getSymbolParentOrFail(symbol: Symbol) {
  * @param haystack The string that potentially contains `needle`.
  * @param needle The string whose content might sit within `haystack`.
  * @param startIndex The index within `haystack` to start searching for `needle`.
+ *
+ * @internal
  */
 export function stringContainsAt(haystack: string, needle: string, startIndex: number) {
     const needleLength = needle.length;
@@ -3696,9 +3725,10 @@ export function diagnosticToString(diag: DiagnosticAndArguments): string {
         : getLocaleSpecificMessage(diag);
 }
 
-/** @internal */
 /**
  * Get format code settings for a code writing context (e.g. when formatting text changes or completions code).
+ *
+ * @internal
  */
 export function getFormatCodeSettingsForWriting({ options }: formatting.FormatContext, sourceFile: SourceFile): FormatCodeSettings {
     const shouldAutoDetectSemicolonPreference = !options.semicolons || options.semicolons === SemicolonPreference.Ignore;
-- 
2.37.1

