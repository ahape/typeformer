From 0000000000000000000000000000000000000000 Mon Sep 17 00:00:00 2001
From: Jake Bailey <5341706+jakebailey@users.noreply.github.com>
Date: Sat, 15 Oct 2022 00:03:22 -0700
Subject: [PATCH] Use compiler types in debug project

Now that we're modules, we can remove all of this duplicated code and
instead directly reference the ts namespace from the compiler project.

Optional but nice cleanup enabled by modules.
---
 src/debug/compilerDebug.ts | 187 +++++++------------------------------
 src/debug/tsconfig.json    |   3 +
 2 files changed, 36 insertions(+), 154 deletions(-)

diff --git a/src/debug/compilerDebug.ts b/src/debug/compilerDebug.ts
index 5eca399b05..52ced91473 100644
--- a/src/debug/compilerDebug.ts
+++ b/src/debug/compilerDebug.ts
@@ -1,133 +1,12 @@
-interface Node {
-    kind: number;
-}
-
-type FunctionExpression = Node;
-type ArrowFunction = Node;
-type MethodDeclaration = Node;
-type Expression = Node;
-type SourceFile = Node;
-type VariableDeclaration = Node;
-type BindingElement = Node;
-type CallExpression = Node;
-type BinaryExpression = Node;
-
-interface SwitchStatement extends Node {
-    caseBlock: CaseBlock;
-}
-
-interface CaseBlock extends Node {
-    clauses: (CaseClause | DefaultClause)[];
-}
-
-interface CaseClause extends Node {
-    _caseclauseBrand: any;
-    expression: Expression;
-}
-
-interface DefaultClause extends Node {
-    _defaultClauseBrand: any;
-}
-
-interface TypeScriptModule {
-    readonly SyntaxKind: {
-        readonly CaseClause: number;
-        readonly DefaultClause: number;
-    };
-
-    readonly FlowFlags: {
-        readonly Unreachable: number,
-        readonly Start: number,
-        readonly BranchLabel: number,
-        readonly LoopLabel: number,
-        readonly Assignment: number,
-        readonly TrueCondition: number,
-        readonly FalseCondition: number,
-        readonly SwitchClause: number,
-        readonly ArrayMutation: number,
-        readonly Call: number,
-        readonly ReduceLabel: number,
-        readonly Referenced: number,
-        readonly Shared: number,
-        readonly Label: number,
-        readonly Condition: number,
-    };
-
-    getSourceFileOfNode(node: Node): SourceFile;
-    getSourceTextOfNodeFromSourceFile(sourceFile: SourceFile, node: Node, includeTrivia?: boolean): string;
-    isDefaultClause(node: Node): node is DefaultClause;
-}
-
-type FlowNode =
-    | FlowStart
-    | FlowLabel
-    | FlowAssignment
-    | FlowCall
-    | FlowCondition
-    | FlowSwitchClause
-    | FlowArrayMutation
-    | FlowReduceLabel
-    ;
-
-interface FlowNodeBase {
-    flags: FlowFlags;
-    id?: number;
-}
-
-interface FlowStart extends FlowNodeBase {
-    node?: FunctionExpression | ArrowFunction | MethodDeclaration;
-}
-
-interface FlowLabel extends FlowNodeBase {
-    antecedents: FlowNode[] | undefined;
-}
-
-interface FlowAssignment extends FlowNodeBase {
-    node: Expression | VariableDeclaration | BindingElement;
-    antecedent: FlowNode;
-}
-
-interface FlowCall extends FlowNodeBase {
-    node: CallExpression;
-    antecedent: FlowNode;
-}
-
-interface FlowCondition extends FlowNodeBase {
-    node: Expression;
-    antecedent: FlowNode;
-}
-
-interface FlowSwitchClause extends FlowNodeBase {
-    switchStatement: SwitchStatement;
-    clauseStart: number;
-    clauseEnd: number;
-    antecedent: FlowNode;
-}
-
-interface FlowArrayMutation extends FlowNodeBase {
-    node: CallExpression | BinaryExpression;
-    antecedent: FlowNode;
-}
-
-/** @internal */
-export interface FlowReduceLabel extends FlowNodeBase {
-    target: FlowLabel;
-    antecedents: FlowNode[];
-    antecedent: FlowNode;
-}
+import type {
+    FlowNode, FlowFlags, FlowSwitchClause, FlowLabel, Node,
+} from "../compiler/_namespaces/ts";
 
-type FlowFlags = number;
-let FlowFlags: TypeScriptModule["FlowFlags"];
-let getSourceFileOfNode: TypeScriptModule["getSourceFileOfNode"];
-let getSourceTextOfNodeFromSourceFile: TypeScriptModule["getSourceTextOfNodeFromSourceFile"];
-let isDefaultClause: TypeScriptModule["isDefaultClause"];
+let ts: typeof import("../compiler/_namespaces/ts");
 
 /** @internal */
-export function init(ts: TypeScriptModule) {
-    FlowFlags = ts.FlowFlags;
-    getSourceFileOfNode = ts.getSourceFileOfNode;
-    getSourceTextOfNodeFromSourceFile = ts.getSourceTextOfNodeFromSourceFile;
-    isDefaultClause = ts.isDefaultClause;
+export function init(tsModule: typeof ts) {
+    ts = tsModule;
 }
 
 let nextDebugFlowId = -1;
@@ -194,19 +73,19 @@ export function formatControlFlowGraph(flowNode: FlowNode) {
     }
 
     const hasAntecedentFlags =
-        FlowFlags.Assignment |
-        FlowFlags.Condition |
-        FlowFlags.SwitchClause |
-        FlowFlags.ArrayMutation |
-        FlowFlags.Call |
-        FlowFlags.ReduceLabel;
+        ts.FlowFlags.Assignment |
+        ts.FlowFlags.Condition |
+        ts.FlowFlags.SwitchClause |
+        ts.FlowFlags.ArrayMutation |
+        ts.FlowFlags.Call |
+        ts.FlowFlags.ReduceLabel;
 
     const hasNodeFlags =
-        FlowFlags.Start |
-        FlowFlags.Assignment |
-        FlowFlags.Call |
-        FlowFlags.Condition |
-        FlowFlags.ArrayMutation;
+        ts.FlowFlags.Start |
+        ts.FlowFlags.Assignment |
+        ts.FlowFlags.Call |
+        ts.FlowFlags.Condition |
+        ts.FlowFlags.ArrayMutation;
 
     const links: Record<number, FlowGraphNode> = Object.create(/*o*/ null); // eslint-disable-line no-null/no-null
     const nodes: FlowGraphNode[] = [];
@@ -223,11 +102,11 @@ export function formatControlFlowGraph(flowNode: FlowNode) {
     return renderGraph();
 
     function isFlowSwitchClause(f: FlowNode): f is FlowSwitchClause {
-        return !!(f.flags & FlowFlags.SwitchClause);
+        return !!(f.flags & ts.FlowFlags.SwitchClause);
     }
 
     function hasAntecedents(f: FlowNode): f is FlowLabel & { antecedents: FlowNode[] } {
-        return !!(f.flags & FlowFlags.Label) && !!(f as FlowLabel).antecedents;
+        return !!(f.flags & ts.FlowFlags.Label) && !!(f as FlowLabel).antecedents;
     }
 
     function hasAntecedent(f: FlowNode): f is Extract<FlowNode, { antecedent: FlowNode }> {
@@ -346,23 +225,23 @@ export function formatControlFlowGraph(flowNode: FlowNode) {
     }
 
     function getHeader(flags: FlowFlags) {
-        if (flags & FlowFlags.Start) return "Start";
-        if (flags & FlowFlags.BranchLabel) return "Branch";
-        if (flags & FlowFlags.LoopLabel) return "Loop";
-        if (flags & FlowFlags.Assignment) return "Assignment";
-        if (flags & FlowFlags.TrueCondition) return "True";
-        if (flags & FlowFlags.FalseCondition) return "False";
-        if (flags & FlowFlags.SwitchClause) return "SwitchClause";
-        if (flags & FlowFlags.ArrayMutation) return "ArrayMutation";
-        if (flags & FlowFlags.Call) return "Call";
-        if (flags & FlowFlags.ReduceLabel) return "ReduceLabel";
-        if (flags & FlowFlags.Unreachable) return "Unreachable";
+        if (flags & ts.FlowFlags.Start) return "Start";
+        if (flags & ts.FlowFlags.BranchLabel) return "Branch";
+        if (flags & ts.FlowFlags.LoopLabel) return "Loop";
+        if (flags & ts.FlowFlags.Assignment) return "Assignment";
+        if (flags & ts.FlowFlags.TrueCondition) return "True";
+        if (flags & ts.FlowFlags.FalseCondition) return "False";
+        if (flags & ts.FlowFlags.SwitchClause) return "SwitchClause";
+        if (flags & ts.FlowFlags.ArrayMutation) return "ArrayMutation";
+        if (flags & ts.FlowFlags.Call) return "Call";
+        if (flags & ts.FlowFlags.ReduceLabel) return "ReduceLabel";
+        if (flags & ts.FlowFlags.Unreachable) return "Unreachable";
         throw new Error();
     }
 
     function getNodeText(node: Node) {
-        const sourceFile = getSourceFileOfNode(node);
-        return getSourceTextOfNodeFromSourceFile(sourceFile, node, /*includeTrivia*/ false);
+        const sourceFile = ts.getSourceFileOfNode(node);
+        return ts.getSourceTextOfNodeFromSourceFile(sourceFile, node, /*includeTrivia*/ false);
     }
 
     function renderFlowNode(flowNode: FlowNode, circular: boolean | "circularity") {
@@ -379,7 +258,7 @@ export function formatControlFlowGraph(flowNode: FlowNode) {
             const clauses: string[] = [];
             for (let i = flowNode.clauseStart; i < flowNode.clauseEnd; i++) {
                 const clause = flowNode.switchStatement.caseBlock.clauses[i];
-                if (isDefaultClause(clause)) {
+                if (ts.isDefaultClause(clause)) {
                     clauses.push("default");
                 }
                 else {
diff --git a/src/debug/tsconfig.json b/src/debug/tsconfig.json
index ab17c2cab1..69f9f6b454 100644
--- a/src/debug/tsconfig.json
+++ b/src/debug/tsconfig.json
@@ -4,5 +4,8 @@
         "target": "es2019",
         "lib": ["es2019"],
     },
+    "references": [
+        { "path": "../compiler" }
+    ],
     "include": ["**/*"]
 }
-- 
2.38.0

