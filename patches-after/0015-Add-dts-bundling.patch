From 0000000000000000000000000000000000000000 Mon Sep 17 00:00:00 2001
From: Jake Bailey <5341706+jakebailey@users.noreply.github.com>
Date: Fri, 2 Sep 2022 16:39:54 -0700
Subject: [PATCH] Add dts bundling

---
 .eslintignore                                 |   1 +
 .gitignore                                    |   1 +
 Gulpfile.js                                   |  34 +-
 scripts/dtsBundler.ts                         | 131 ++++
 src/compiler/commandLineParser.ts             |   2 +-
 src/compiler/factory/utilities.ts             |  11 +-
 src/compiler/moduleNameResolver.ts            |   8 +-
 src/compiler/parser.ts                        |   2 +-
 src/compiler/perfLogger.ts                    |  34 +-
 src/compiler/program.ts                       |   8 +-
 src/compiler/resolutionCache.ts               |   6 +-
 src/compiler/sys.ts                           |   4 +-
 src/compiler/tracing.ts                       |   9 +-
 src/compiler/transformers/classFields.ts      |   4 +-
 src/compiler/transformers/es2015.ts           |   4 +-
 src/compiler/transformers/es2016.ts           |   4 +-
 src/compiler/transformers/es2017.ts           |   3 +-
 src/compiler/transformers/es2018.ts           |   4 +-
 src/compiler/transformers/es2019.ts           |   3 +-
 src/compiler/transformers/es2020.ts           |   4 +-
 src/compiler/transformers/es2021.ts           |   4 +-
 src/compiler/transformers/es5.ts              |   3 +-
 src/compiler/transformers/esnext.ts           |   3 +-
 src/compiler/transformers/generators.ts       |   4 +-
 src/compiler/transformers/jsx.ts              |   4 +-
 src/compiler/transformers/legacyDecorators.ts |   4 +-
 .../transformers/module/esnextAnd2015.ts      |   4 +-
 src/compiler/transformers/module/module.ts    |   3 +-
 src/compiler/transformers/module/system.ts    |   4 +-
 src/compiler/transformers/taggedTemplate.ts   |   3 +-
 src/compiler/transformers/typeSerializer.ts   |   6 +-
 src/compiler/transformers/utilities.ts        |   4 +-
 src/compiler/tsbuildPublic.ts                 |   6 +-
 src/compiler/types.ts                         |  16 +-
 src/compiler/utilities.ts                     |   7 +-
 src/compiler/watchPublic.ts                   |   4 +-
 src/compiler/watchUtilities.ts                |   3 +-
 .../4.0/nodeFactoryTopLevelExports.ts         | 592 +++++++++---------
 src/deprecatedCompat/deprecations.ts          |  81 ++-
 src/server/editorServices.ts                  |   6 +-
 src/server/scriptVersionCache.ts              |  15 +-
 .../codefixes/annotateWithTypeFromJSDoc.ts    |   3 +-
 src/services/codefixes/generateAccessors.ts   |  19 +-
 src/services/codefixes/helpers.ts             |  10 +-
 src/services/completions.ts                   |  32 +-
 src/services/getEditsForFileRename.ts         |   8 +-
 src/services/organizeImports.ts               |   9 +-
 src/services/refactors/extractSymbol.ts       |  11 +-
 src/services/sourcemaps.ts                    |   2 +-
 src/services/symbolDisplay.ts                 |   3 +-
 src/services/textChanges.ts                   |   3 +-
 src/services/transform.ts                     |   5 +-
 src/tsserverlibrary/tsserverlibrary.ts        |   6 +-
 src/typescript/typescript.ts                  |   5 +-
 .../baselines/reference/APISample_compile.js  |   2 +-
 tests/baselines/reference/APISample_jsdoc.js  |   8 +-
 tests/baselines/reference/APISample_linter.js |  24 +-
 57 files changed, 739 insertions(+), 464 deletions(-)
 create mode 100644 scripts/dtsBundler.ts

diff --git a/.eslintignore b/.eslintignore
index 8d53899550..ba42c55b01 100644
--- a/.eslintignore
+++ b/.eslintignore
@@ -20,3 +20,4 @@
 /scripts/eslint/built/**
 /internal/**
 /coverage/**
+/dtstesting/**
diff --git a/.gitignore b/.gitignore
index cdf20ba5a2..4ba9e15206 100644
--- a/.gitignore
+++ b/.gitignore
@@ -47,6 +47,7 @@ scripts/configurePrerelease.js
 scripts/configureLanguageServiceBuild.js
 scripts/open-user-pr.js
 scripts/open-cherry-pick-pr.js
+scripts/dtsBundler.js
 scripts/processDiagnosticMessages.d.ts
 scripts/processDiagnosticMessages.js
 scripts/produceLKG.js
diff --git a/Gulpfile.js b/Gulpfile.js
index 79939b403e..cfc42a9070 100644
--- a/Gulpfile.js
+++ b/Gulpfile.js
@@ -127,6 +127,33 @@ const buildSrc = () => buildProject("src");
 // But, if we are bundling, we are running only d.ts emit, so maybe this is fast?
 task("build-src", series(preSrc, buildSrc));
 
+// TODO(jakebailey): split this in two, only build the relavent parts, move down before tests.
+const dtsBundler = async () => {
+    /**
+     * @param {string} projectPath
+     * @param {string} entrypoint
+     * @param {string} output
+     */
+    async function runDtsBundler(projectPath, entrypoint, output) {
+        await exec(process.execPath, ["./scripts/dtsBundler.js", projectPath, entrypoint, output]);
+    }
+
+    // TODO(jakebailey): prepend copyright notice, replace const enums with regular enums
+    if (needsUpdate(["./built/local/typescript/tsconfig.tsbuildinfo", "./scripts/dtsBundler.js"], "./built/local/typescript.d.ts")) {
+        await runDtsBundler("./src/typescript/tsconfig.json", "./built/local/typescript/typescript.d.ts", "./built/local/typescript.d.ts");
+    }
+
+    if (needsUpdate(["./built/local/tsserverlibrary/tsconfig.tsbuildinfo", "./scripts/dtsBundler.js"], "./built/local/tsserverlibrary.d.ts")) {
+        await runDtsBundler("./src/tsserverlibrary/tsconfig.json", "./built/local/tsserverlibrary/tsserverlibrary.d.ts", "./built/local/tsserverlibrary.d.ts");
+    }
+};
+
+// TODO(jakebailey): Some tests depend on the extracted output.
+// TODO(jakebailey): implicit dependency on scripts
+const dts = series(preSrc, buildSrc, dtsBundler);
+dts.displayName = "dts";
+task("dts", dts);
+
 /** @type {string | undefined} */
 let copyrightHeader;
 function getCopyrightHeader() {
@@ -474,7 +501,7 @@ const preTest = parallel(buildTsc, buildTests, buildServices, buildLssl);
 preTest.displayName = "preTest";
 
 const runTests = () => runConsoleTests(testRunner, "mocha-fivemat-progress-reporter", /*runInParallel*/ false, /*watchMode*/ false);
-task("runtests", series(preBuild, preTest, runTests));
+task("runtests", series(preBuild, preTest, dts, runTests));
 task("runtests").description = "Runs the tests using the built run.js file.";
 task("runtests").flags = {
     "-t --tests=<regex>": "Pattern for tests to run.",
@@ -493,7 +520,7 @@ task("runtests").flags = {
 };
 
 const runTestsParallel = () => runConsoleTests(testRunner, "min", /*runInParallel*/ cmdLineOptions.workers > 1, /*watchMode*/ false);
-task("runtests-parallel", series(preBuild, preTest, runTestsParallel));
+task("runtests-parallel", series(preBuild, preTest, dts, runTestsParallel));
 task("runtests-parallel").description = "Runs all the tests in parallel using the built run.js file.";
 task("runtests-parallel").flags = {
     "   --light": "Run tests in light mode (fewer verifications, but tests run faster).",
@@ -597,8 +624,7 @@ const produceLKG = async () => {
     }
 };
 
-// TODO(jakebailey): dependencies on dts
-task("LKG", series(lkgPreBuild, parallel(localize, buildTsc, buildServer, buildServices, buildLssl, buildOtherOutputs), produceLKG));
+task("LKG", series(lkgPreBuild, parallel(localize, buildTsc, buildServer, buildServices, buildLssl, buildOtherOutputs, dts), produceLKG));
 task("LKG").description = "Makes a new LKG out of the built js files";
 task("LKG").flags = {
     "   --built": "Compile using the built version of the compiler.",
diff --git a/scripts/dtsBundler.ts b/scripts/dtsBundler.ts
new file mode 100644
index 0000000000..e78781ccfe
--- /dev/null
+++ b/scripts/dtsBundler.ts
@@ -0,0 +1,131 @@
+import * as assert from "assert";
+import * as fs from "fs";
+import * as path from "path";
+import * as ts from "../lib/typescript";
+
+// (ts as any).Debug.enableDebugInfo();
+
+const [
+    projectPath,
+    entrypoint,
+    output,
+] = process.argv.slice(2);
+
+assert(projectPath);
+assert(entrypoint);
+assert(output);
+
+console.log(`Bundling ${entrypoint} to ${output}, using project ${projectPath}`);
+
+const newLineKind = ts.NewLineKind.LineFeed;
+const newLine = newLineKind === ts.NewLineKind.LineFeed ? "\n" : "\r\n";
+
+function isDeclarationStatement(node: ts.Node): node is ts.DeclarationStatement {
+    return (ts as any).isDeclarationStatement(node);
+}
+
+const compareStringsCaseSensitive: (a: string | undefined, b: string | undefined) => number = (ts as any).compareStringsCaseSensitive;
+
+
+const tsconfigContents = ts.readJsonConfigFile(path.join(projectPath, "tsconfig.json"), ts.sys.readFile);
+const tsconfig = ts.parseJsonConfigFileContent(tsconfigContents, ts.sys, projectPath);
+const program = ts.createProgram([entrypoint], tsconfig.options);
+
+const typeChecker = program.getTypeChecker();
+
+const sourceFile = program.getSourceFile(entrypoint);
+assert(sourceFile);
+const moduleSymbol = typeChecker.getSymbolAtLocation(sourceFile);
+assert(moduleSymbol);
+
+const printer = ts.createPrinter({ newLine: newLineKind });
+
+
+const lines: string[] = [];
+const indent = "    ";
+let currentIndent = "";
+
+function increaseIndent() {
+    currentIndent += indent;
+}
+
+function decreaseIndent() {
+    currentIndent = currentIndent.slice(indent.length);
+}
+
+function write(s = "") {
+    if (!s) {
+        lines.push("");
+    }
+    else {
+        lines.push(...s.split(/\r?\n/).map((line) => (currentIndent + line).trimEnd()));
+    }
+}
+
+const copyrightNotice = fs.readFileSync(path.join(__dirname, "..", "CopyrightNotice.txt"), "utf-8");
+write(copyrightNotice);
+
+function emitAsNamespace(name: string, moduleSymbol: ts.Symbol) {
+    if (name === "ts") {
+        // We will write `export = ts` at the end.
+        write(`declare namespace ${name} {`);
+    }
+    else {
+        write(`export namespace ${name} {`);
+    }
+    increaseIndent();
+
+    let moduleExports = typeChecker.getExportsOfModule(moduleSymbol);
+    moduleExports = moduleExports.slice(0).sort((a, b) => compareStringsCaseSensitive(a.name, b.name));
+
+    for (const me of moduleExports) {
+        if (!me.declarations?.length) {
+            continue;
+        }
+
+        if (me.flags & ts.SymbolFlags.Alias) {
+            const resolved = typeChecker.getAliasedSymbol(me);
+            assert(resolved.flags & ts.SymbolFlags.ValueModule);
+            emitAsNamespace(me.name, resolved);
+            continue;
+        }
+
+        for (const decl of me.declarations) {
+            let output: ts.Node | undefined;
+
+            if (ts.isVariableDeclaration(decl)) {
+                output = ts.factory.createVariableStatement(
+                    [ts.factory.createToken(ts.SyntaxKind.ExportKeyword)],
+                    ts.factory.createVariableDeclarationList([decl], ts.getCombinedNodeFlags(decl))
+                );
+            }
+            else if (isDeclarationStatement(decl)) {
+                output = decl;
+            }
+
+            if (output) {
+                let printed = printer.printNode(ts.EmitHint.Unspecified, output, decl.getSourceFile());
+                // TODO(jakebailey): This could be less hacky.
+                printed = printed.replace("export declare ", "export ");
+                printed = printed.replace("export const enum ", "export enum ");
+                write(printed);
+                write();
+            }
+            else {
+                const declSourceFile = decl.getSourceFile();
+                const lc = declSourceFile.getLineAndCharacterOfPosition(decl.pos);
+                throw new Error(`Unhandled declaration for ${me.name} at ${declSourceFile.fileName}:${lc.line}:${lc.character}`);
+            }
+        }
+    }
+
+    decreaseIndent();
+    write(`}`);
+    write();
+}
+
+emitAsNamespace("ts", moduleSymbol);
+
+write("export = ts;");
+
+fs.writeFileSync(output, lines.join(newLine));
diff --git a/src/compiler/commandLineParser.ts b/src/compiler/commandLineParser.ts
index 31dd774182..2ed978e2d6 100644
--- a/src/compiler/commandLineParser.ts
+++ b/src/compiler/commandLineParser.ts
@@ -2081,7 +2081,7 @@ function getTsconfigRootOptionsMap() {
 }
 
 /** @internal */
-interface JsonConversionNotifier {
+export interface JsonConversionNotifier {
     /**
      * Notifies parent option object is being set with the optionKey and a valid optionValue
      * Currently it notifies only if there is element with type object (parentOption) and
diff --git a/src/compiler/factory/utilities.ts b/src/compiler/factory/utilities.ts
index 010b996d7a..b6c97f8f3b 100644
--- a/src/compiler/factory/utilities.ts
+++ b/src/compiler/factory/utilities.ts
@@ -2,11 +2,12 @@ import {
     AccessorDeclaration, addEmitFlags, AdditiveOperator, AdditiveOperatorOrHigher, AssertionLevel,
     AssignmentOperatorOrHigher, BinaryExpression, BinaryOperator, BinaryOperatorToken, BindingOrAssignmentElement,
     BindingOrAssignmentElementRestIndicator, BindingOrAssignmentElementTarget, BindingOrAssignmentPattern,
-    BitwiseOperator, BitwiseOperatorOrHigher, BooleanLiteral, CharacterCodes, CommaListExpression,
+    BitwiseOperator, BitwiseOperatorOrHigher, Block, BooleanLiteral, CharacterCodes, CommaListExpression,
     compareStringsCaseSensitive, CompilerOptions, Debug, Declaration, EmitFlags, EmitHelperFactory, EmitHost,
     EmitResolver, EntityName, EqualityOperator, EqualityOperatorOrHigher, ExclamationToken, ExponentiationOperator,
     ExportDeclaration, Expression, ExpressionStatement, externalHelpersModuleNameText, first, firstOrUndefined,
     ForInitializer, GeneratedIdentifier, GeneratedIdentifierFlags, GeneratedNamePart, GeneratedPrivateIdentifier,
+    GetAccessorDeclaration,
     getAllAccessorDeclarations, getEmitFlags, getEmitHelpers, getEmitModuleKind, getESModuleInterop,
     getExternalModuleName, getExternalModuleNameFromPath, getJSDocType, getJSDocTypeTag, getModifiers,
     getNamespaceDeclarationNode, getOrCreateEmitNode, getOriginalNode, getParseTreeNode,
@@ -26,7 +27,7 @@ import {
     NumericLiteral, ObjectLiteralElementLike, ObjectLiteralExpression, or, OuterExpression, OuterExpressionKinds,
     outFile, parseNodeFactory, PlusToken, PostfixUnaryExpression, PrefixUnaryExpression, PrivateIdentifier,
     PropertyAssignment, PropertyDeclaration, PropertyName, pushIfUnique, QuestionToken, ReadonlyKeyword,
-    RelationalOperator, RelationalOperatorOrHigher, setOriginalNode, setParent, setStartsOnNewLine, setTextRange,
+    RelationalOperator, RelationalOperatorOrHigher, SetAccessorDeclaration, setOriginalNode, setParent, setStartsOnNewLine, setTextRange,
     ShiftOperator, ShiftOperatorOrHigher, ShorthandPropertyAssignment, some, SourceFile, Statement, StringLiteral,
     SyntaxKind, TextRange, ThisTypeNode, Token, TypeNode, TypeParameterDeclaration,
 } from "../_namespaces/ts";
@@ -185,7 +186,7 @@ export function createForOfBindingStatement(factory: NodeFactory, node: ForIniti
 }
 
 /** @internal */
-export function insertLeadingStatement(factory: NodeFactory, dest: Statement, source: Statement) {
+export function insertLeadingStatement(factory: NodeFactory, dest: Statement, source: Statement): Block {
     if (isBlock(dest)) {
         return factory.updateBlock(dest, setTextRange(factory.createNodeArray([source, ...dest.statements]), dest.statements));
     }
@@ -1456,7 +1457,7 @@ export function createAccessorPropertyBackingField(factory: NodeFactory, node: P
  *
  * @internal
  */
-export function createAccessorPropertyGetRedirector(factory: NodeFactory, node: PropertyDeclaration, modifiers: ModifiersArray | undefined, name: PropertyName) {
+export function createAccessorPropertyGetRedirector(factory: NodeFactory, node: PropertyDeclaration, modifiers: ModifiersArray | undefined, name: PropertyName): GetAccessorDeclaration {
     return factory.createGetAccessorDeclaration(
         modifiers,
         name,
@@ -1478,7 +1479,7 @@ export function createAccessorPropertyGetRedirector(factory: NodeFactory, node:
  *
  * @internal
  */
-export function createAccessorPropertySetRedirector(factory: NodeFactory, node: PropertyDeclaration, modifiers: ModifiersArray | undefined, name: PropertyName) {
+export function createAccessorPropertySetRedirector(factory: NodeFactory, node: PropertyDeclaration, modifiers: ModifiersArray | undefined, name: PropertyName): SetAccessorDeclaration {
     return factory.createSetAccessorDeclaration(
         modifiers,
         name,
diff --git a/src/compiler/moduleNameResolver.ts b/src/compiler/moduleNameResolver.ts
index f13d60743e..9e62af0806 100644
--- a/src/compiler/moduleNameResolver.ts
+++ b/src/compiler/moduleNameResolver.ts
@@ -128,7 +128,7 @@ function createResolvedModuleWithFailedLookupLocations(
 }
 
 /** @internal */
-interface ModuleResolutionState {
+export interface ModuleResolutionState {
     host: ModuleResolutionHost;
     compilerOptions: CompilerOptions;
     traceEnabled: boolean;
@@ -146,7 +146,7 @@ interface ModuleResolutionState {
  *
  * @internal
  */
-interface PackageJsonPathFields {
+export interface PackageJsonPathFields {
     typings?: string;
     types?: string;
     typesVersions?: MapLike<MapLike<string[]>>;
@@ -226,7 +226,7 @@ function readPackageJsonTypesVersionsField(jsonContent: PackageJson, state: Modu
 }
 
 /** @internal */
-interface VersionPaths {
+export interface VersionPaths {
     version: string;
     paths: MapLike<string[]>;
 }
@@ -1281,7 +1281,7 @@ export function resolveJSModule(moduleName: string, initialDir: string, host: Mo
 }
 
 /** @internal */
-enum NodeResolutionFeatures {
+export enum NodeResolutionFeatures {
     None = 0,
     // resolving `#local` names in your own package.json
     Imports = 1 << 1,
diff --git a/src/compiler/parser.ts b/src/compiler/parser.ts
index 24c32f7d24..804c65a975 100644
--- a/src/compiler/parser.ts
+++ b/src/compiler/parser.ts
@@ -9831,7 +9831,7 @@ export function processCommentPragmas(context: PragmaContext, sourceText: string
 }
 
 /** @internal */
-type PragmaDiagnosticReporter = (pos: number, length: number, message: DiagnosticMessage) => void;
+export type PragmaDiagnosticReporter = (pos: number, length: number, message: DiagnosticMessage) => void;
 
 /** @internal */
 export function processPragmasIntoFields(context: PragmaContext, reportDiagnostic: PragmaDiagnosticReporter): void {
diff --git a/src/compiler/perfLogger.ts b/src/compiler/perfLogger.ts
index 34a59208d6..41f33e0e2a 100644
--- a/src/compiler/perfLogger.ts
+++ b/src/compiler/perfLogger.ts
@@ -1,6 +1,38 @@
 import { noop } from "./_namespaces/ts";
 
-type PerfLogger = typeof import("@microsoft/typescript-etw");
+/** @internal */
+export interface PerfLogger {
+    logEvent(msg: string): void;
+    logErrEvent(msg: string): void;
+    logPerfEvent(msg: string): void;
+    logInfoEvent(msg: string): void;
+    logStartCommand(command: string, msg: string): void;
+    logStopCommand(command: string, msg: string): void;
+    logStartUpdateProgram(msg: string): void;
+    logStopUpdateProgram(msg: string): void;
+    logStartUpdateGraph(): void;
+    logStopUpdateGraph(): void;
+    logStartResolveModule(name: string): void;
+    logStopResolveModule(success: string): void;
+    logStartParseSourceFile(filename: string): void;
+    logStopParseSourceFile(): void;
+    logStartReadFile(filename: string): void;
+    logStopReadFile(): void;
+    logStartBindFile(filename: string): void;
+    logStopBindFile(): void;
+    logStartScheduledOperation(operationId: string): void;
+    logStopScheduledOperation(): void;
+}
+
+type ImportedPerfLogger = typeof import("@microsoft/typescript-etw");
+
+// Assert that our PerfLogger type is compatible with the library.
+// Doing this keeps the above import expression out of our emitted d.ts file.
+const _perfLoggerCorrectType: PerfLogger extends ImportedPerfLogger ? true : false = true;
+
+// eslint-disable-next-line @typescript-eslint/no-unused-expressions
+_perfLoggerCorrectType;
+
 const nullLogger: PerfLogger = {
     logEvent: noop,
     logErrEvent: noop,
diff --git a/src/compiler/program.ts b/src/compiler/program.ts
index 30a15b258d..bf6af85b0f 100644
--- a/src/compiler/program.ts
+++ b/src/compiler/program.ts
@@ -210,7 +210,7 @@ export function createCompilerHostWorker(options: CompilerOptions, setParentNode
 }
 
 /** @internal */
-interface CompilerHostLikeForCache {
+export interface CompilerHostLikeForCache {
     fileExists(fileName: string): boolean;
     readFile(fileName: string, encoding?: string): string | undefined;
     directoryExists?(directory: string): boolean;
@@ -570,7 +570,7 @@ export interface SourceFileImportsList {
  * Calculates the resulting resolution mode for some reference in some file - this is generally the explicitly
  * provided resolution mode in the reference, unless one is not present, in which case it is the mode of the containing file.
  */
-export function getModeForFileReference(ref: FileReference | string, containingFileMode: SourceFile["impliedNodeFormat"]) {
+export function getModeForFileReference(ref: FileReference | string, containingFileMode: SourceFile["impliedNodeFormat"]): ModuleKind.CommonJS | ModuleKind.ESNext | undefined {
     return (isString(ref) ? containingFileMode : ref.resolutionMode) || containingFileMode;
 }
 
@@ -612,7 +612,7 @@ export function isExclusivelyTypeOnlyImportOrExport(decl: ImportDeclaration | Ex
  * @param usage The module reference string
  * @returns The final resolution mode of the import
  */
-export function getModeForUsageLocation(file: {impliedNodeFormat?: SourceFile["impliedNodeFormat"]}, usage: StringLiteralLike) {
+export function getModeForUsageLocation(file: {impliedNodeFormat?: SourceFile["impliedNodeFormat"]}, usage: StringLiteralLike): ModuleKind.CommonJS | ModuleKind.ESNext | undefined {
     if (file.impliedNodeFormat === undefined) return undefined;
     if ((isImportDeclaration(usage.parent) || isExportDeclaration(usage.parent))) {
         const isTypeOnly = isExclusivelyTypeOnlyImportOrExport(usage.parent);
@@ -4318,7 +4318,7 @@ export function filterSemanticDiagnostics(diagnostic: readonly Diagnostic[], opt
 }
 
 /** @internal */
-interface CompilerHostLike {
+export interface CompilerHostLike {
     useCaseSensitiveFileNames(): boolean;
     getCurrentDirectory(): string;
     fileExists(fileName: string): boolean;
diff --git a/src/compiler/resolutionCache.ts b/src/compiler/resolutionCache.ts
index a6cce70e78..103676d271 100644
--- a/src/compiler/resolutionCache.ts
+++ b/src/compiler/resolutionCache.ts
@@ -51,7 +51,8 @@ export interface ResolutionCache {
     clear(): void;
 }
 
-interface ResolutionWithFailedLookupLocations {
+/** @internal */
+export interface ResolutionWithFailedLookupLocations {
     readonly failedLookupLocations: string[];
     readonly affectingLocations: string[];
     isInvalidated?: boolean;
@@ -65,7 +66,8 @@ interface ResolutionWithResolvedFileName {
     packagetId?: PackageId;
 }
 
-interface CachedResolvedModuleWithFailedLookupLocations extends ResolvedModuleWithFailedLookupLocations, ResolutionWithFailedLookupLocations {
+/** @internal */
+export interface CachedResolvedModuleWithFailedLookupLocations extends ResolvedModuleWithFailedLookupLocations, ResolutionWithFailedLookupLocations {
 }
 
 interface CachedResolvedTypeReferenceDirectiveWithFailedLookupLocations extends ResolvedTypeReferenceDirectiveWithFailedLookupLocations, ResolutionWithFailedLookupLocations {
diff --git a/src/compiler/sys.ts b/src/compiler/sys.ts
index 7f463fd88b..fce13ef242 100644
--- a/src/compiler/sys.ts
+++ b/src/compiler/sys.ts
@@ -1262,7 +1262,7 @@ export function patchWriteFileEnsuringDirectory(sys: System) {
 export type BufferEncoding = "ascii" | "utf8" | "utf-8" | "utf16le" | "ucs2" | "ucs-2" | "base64" | "latin1" | "binary" | "hex";
 
 /** @internal */
-interface NodeBuffer extends Uint8Array {
+export interface NodeBuffer extends Uint8Array {
     constructor: any;
     write(str: string, encoding?: BufferEncoding): number;
     write(str: string, offset: number, encoding?: BufferEncoding): number;
@@ -1338,7 +1338,7 @@ interface NodeBuffer extends Uint8Array {
 }
 
 /** @internal */
-interface Buffer extends NodeBuffer { }
+export interface Buffer extends NodeBuffer { }
 
 // TODO: GH#18217 Methods on System are often used as if they are certainly defined
 export interface System {
diff --git a/src/compiler/tracing.ts b/src/compiler/tracing.ts
index 087a86cf18..3ddf6e3470 100644
--- a/src/compiler/tracing.ts
+++ b/src/compiler/tracing.ts
@@ -13,8 +13,13 @@ import {
 export let tracing: typeof tracingEnabled | undefined;
 // enable the above using startTracing()
 
-// `tracingEnabled` should never be used directly, only through the above
-namespace tracingEnabled { // eslint-disable-line local/one-namespace-per-file
+
+/**
+ * `tracingEnabled` should never be used directly, only through the above
+ *
+ * @internal
+ */
+export namespace tracingEnabled { // eslint-disable-line local/one-namespace-per-file
     type Mode = "project" | "build" | "server";
 
     let fs: typeof import("fs");
diff --git a/src/compiler/transformers/classFields.ts b/src/compiler/transformers/classFields.ts
index 5141d77afc..28be1f5f87 100644
--- a/src/compiler/transformers/classFields.ts
+++ b/src/compiler/transformers/classFields.ts
@@ -33,7 +33,7 @@ import {
     startOnNewLine, Statement, SuperProperty, SyntaxKind, TaggedTemplateExpression, ThisExpression,
     TransformationContext, TransformFlags, tryGetTextOfPropertyName, UnderscoreEscapedMap, unescapeLeadingUnderscores,
     VariableStatement, visitArray, visitEachChild, visitFunctionBody, visitIterationBody, visitNode, visitNodes,
-    visitParameterList, VisitResult,
+    visitParameterList, VisitResult, Bundle,
 } from "../_namespaces/ts";
 
 const enum ClassPropertySubstitutionFlags {
@@ -168,7 +168,7 @@ const enum ClassFacts {
  *
  * @internal
  */
-export function transformClassFields(context: TransformationContext) {
+export function transformClassFields(context: TransformationContext): (x: SourceFile | Bundle) => SourceFile | Bundle {
     const {
         factory,
         hoistVariableDeclaration,
diff --git a/src/compiler/transformers/es2015.ts b/src/compiler/transformers/es2015.ts
index a9d33f2d4c..db01bdeec4 100644
--- a/src/compiler/transformers/es2015.ts
+++ b/src/compiler/transformers/es2015.ts
@@ -33,7 +33,7 @@ import {
     SyntaxKind, TaggedTemplateExpression, takeWhile, TemplateExpression, TextRange, TokenFlags, TransformationContext,
     TransformFlags, tryCast, unescapeLeadingUnderscores, unwrapInnermostStatementOfLabel, VariableDeclaration,
     VariableDeclarationList, VariableStatement, visitEachChild, visitNode, visitNodes, visitParameterList, VisitResult,
-    VoidExpression, WhileStatement, YieldExpression,
+    VoidExpression, WhileStatement, YieldExpression, Bundle,
 } from "../_namespaces/ts";
 
 const enum ES2015SubstitutionFlags {
@@ -299,7 +299,7 @@ function createSpreadSegment(kind: SpreadSegmentKind, expression: Expression): S
 }
 
 /** @internal */
-export function transformES2015(context: TransformationContext) {
+export function transformES2015(context: TransformationContext): (x: SourceFile | Bundle) => SourceFile | Bundle {
     const {
         factory,
         getEmitHelperFactory: emitHelpers,
diff --git a/src/compiler/transformers/es2016.ts b/src/compiler/transformers/es2016.ts
index 0d4b95afa8..ca3bbbb980 100644
--- a/src/compiler/transformers/es2016.ts
+++ b/src/compiler/transformers/es2016.ts
@@ -1,11 +1,11 @@
 import {
-    BinaryExpression, chainBundle, Expression, isElementAccessExpression, isExpression, isPropertyAccessExpression,
+    BinaryExpression, Bundle, chainBundle, Expression, isElementAccessExpression, isExpression, isPropertyAccessExpression,
     Node, setTextRange, SourceFile, SyntaxKind, TransformationContext, TransformFlags, visitEachChild, visitNode,
     VisitResult,
 } from "../_namespaces/ts";
 
 /** @internal */
-export function transformES2016(context: TransformationContext) {
+export function transformES2016(context: TransformationContext): (x: SourceFile | Bundle) => SourceFile | Bundle {
     const {
         factory,
         hoistVariableDeclaration
diff --git a/src/compiler/transformers/es2017.ts b/src/compiler/transformers/es2017.ts
index 193eea75be..3f36d8c450 100644
--- a/src/compiler/transformers/es2017.ts
+++ b/src/compiler/transformers/es2017.ts
@@ -15,6 +15,7 @@ import {
     TypeReferenceSerializationKind, unescapeLeadingUnderscores, VariableDeclaration, VariableDeclarationList,
     VariableStatement, visitEachChild, visitFunctionBody, visitIterationBody, visitNode, visitNodes, visitParameterList,
     VisitResult,
+    Bundle,
 } from "../_namespaces/ts";
 
 type SuperContainer = ClassDeclaration | MethodDeclaration | GetAccessorDeclaration | SetAccessorDeclaration | ConstructorDeclaration;
@@ -30,7 +31,7 @@ const enum ContextFlags {
 }
 
 /** @internal */
-export function transformES2017(context: TransformationContext) {
+export function transformES2017(context: TransformationContext): (x: SourceFile | Bundle) => SourceFile | Bundle {
     const {
         factory,
         getEmitHelperFactory: emitHelpers,
diff --git a/src/compiler/transformers/es2018.ts b/src/compiler/transformers/es2018.ts
index ee7f2cbc93..d45f5a37b4 100644
--- a/src/compiler/transformers/es2018.ts
+++ b/src/compiler/transformers/es2018.ts
@@ -17,7 +17,7 @@ import {
     SourceFile, startOnNewLine, Statement, SyntaxKind, TaggedTemplateExpression, TextRange, Token,
     TransformationContext, TransformFlags, unwrapInnermostStatementOfLabel, VariableDeclaration, VariableStatement,
     visitEachChild, visitIterationBody, visitLexicalEnvironment, visitNode, visitNodes, visitParameterList, VisitResult,
-    VoidExpression, YieldExpression,
+    VoidExpression, YieldExpression, Bundle,
 } from "../_namespaces/ts";
 
 const enum ESNextSubstitutionFlags {
@@ -58,7 +58,7 @@ const enum HierarchyFacts {
 }
 
 /** @internal */
-export function transformES2018(context: TransformationContext) {
+export function transformES2018(context: TransformationContext): (x: SourceFile | Bundle) => SourceFile | Bundle {
     const {
         factory,
         getEmitHelperFactory: emitHelpers,
diff --git a/src/compiler/transformers/es2019.ts b/src/compiler/transformers/es2019.ts
index 921a2ea33d..eaeb2f19d5 100644
--- a/src/compiler/transformers/es2019.ts
+++ b/src/compiler/transformers/es2019.ts
@@ -1,10 +1,11 @@
 import {
+    Bundle,
     CatchClause, chainBundle, isBlock, Node, SourceFile, SyntaxKind, TransformationContext, TransformFlags,
     visitEachChild, visitNode, VisitResult,
 } from "../_namespaces/ts";
 
 /** @internal */
-export function transformES2019(context: TransformationContext) {
+export function transformES2019(context: TransformationContext): (x: SourceFile | Bundle) => SourceFile | Bundle {
     const factory = context.factory;
     return chainBundle(context, transformSourceFile);
 
diff --git a/src/compiler/transformers/es2020.ts b/src/compiler/transformers/es2020.ts
index 79be9cae32..ec48ca9433 100644
--- a/src/compiler/transformers/es2020.ts
+++ b/src/compiler/transformers/es2020.ts
@@ -1,5 +1,5 @@
 import {
-    AccessExpression, addEmitFlags, BinaryExpression, CallExpression, cast, chainBundle, Debug, DeleteExpression,
+    AccessExpression, addEmitFlags, BinaryExpression, Bundle, CallExpression, cast, chainBundle, Debug, DeleteExpression,
     EmitFlags, Expression, isCallChain, isExpression, isGeneratedIdentifier, isIdentifier, isNonNullChain,
     isOptionalChain, isParenthesizedExpression, isSimpleCopiableExpression, isSyntheticReference,
     isTaggedTemplateExpression, Node, OptionalChain, OuterExpressionKinds, ParenthesizedExpression, setOriginalNode,
@@ -8,7 +8,7 @@ import {
 } from "../_namespaces/ts";
 
 /** @internal */
-export function transformES2020(context: TransformationContext) {
+export function transformES2020(context: TransformationContext): (x: SourceFile | Bundle) => SourceFile | Bundle {
     const {
         factory,
         hoistVariableDeclaration,
diff --git a/src/compiler/transformers/es2021.ts b/src/compiler/transformers/es2021.ts
index 68ce3c81c4..a63e4688a7 100644
--- a/src/compiler/transformers/es2021.ts
+++ b/src/compiler/transformers/es2021.ts
@@ -1,5 +1,5 @@
 import {
-    AssignmentExpression, BinaryExpression, chainBundle, getNonAssignmentOperatorForCompoundAssignment,
+    AssignmentExpression, BinaryExpression, Bundle, chainBundle, getNonAssignmentOperatorForCompoundAssignment,
     isAccessExpression, isExpression, isLeftHandSideExpression, isLogicalOrCoalescingAssignmentExpression,
     isPropertyAccessExpression, isSimpleCopiableExpression, LogicalOrCoalescingAssignmentOperator, Node,
     skipParentheses, SourceFile, SyntaxKind, Token, TransformationContext, TransformFlags, visitEachChild, visitNode,
@@ -7,7 +7,7 @@ import {
 } from "../_namespaces/ts";
 
 /** @internal */
-export function transformES2021(context: TransformationContext) {
+export function transformES2021(context: TransformationContext): (x: SourceFile | Bundle) => SourceFile | Bundle {
     const {
         hoistVariableDeclaration,
         factory
diff --git a/src/compiler/transformers/es5.ts b/src/compiler/transformers/es5.ts
index cd7eb47d1e..8dd340255a 100644
--- a/src/compiler/transformers/es5.ts
+++ b/src/compiler/transformers/es5.ts
@@ -1,4 +1,5 @@
 import {
+    Bundle,
     chainBundle, EmitHint, Expression, getOriginalNodeId, Identifier, idText, isIdentifier, isPrivateIdentifier,
     isPropertyAccessExpression, isPropertyAssignment, JsxClosingElement, JsxEmit, JsxOpeningElement,
     JsxSelfClosingElement, Node, nodeIsSynthesized, PropertyAccessExpression, PropertyAssignment, setTextRange,
@@ -12,7 +13,7 @@ import {
  *
  * @internal
  */
-export function transformES5(context: TransformationContext) {
+export function transformES5(context: TransformationContext): (x: SourceFile | Bundle) => SourceFile | Bundle {
     const { factory } = context;
     const compilerOptions = context.getCompilerOptions();
 
diff --git a/src/compiler/transformers/esnext.ts b/src/compiler/transformers/esnext.ts
index 9cc1b5e739..770153e4e6 100644
--- a/src/compiler/transformers/esnext.ts
+++ b/src/compiler/transformers/esnext.ts
@@ -1,9 +1,10 @@
 import {
+    Bundle,
     chainBundle, Node, SourceFile, TransformationContext, TransformFlags, visitEachChild, VisitResult,
 } from "../_namespaces/ts";
 
 /** @internal */
-export function transformESNext(context: TransformationContext) {
+export function transformESNext(context: TransformationContext): (x: SourceFile | Bundle) => SourceFile | Bundle {
   return chainBundle(context, transformSourceFile);
 
   function transformSourceFile(node: SourceFile) {
diff --git a/src/compiler/transformers/generators.ts b/src/compiler/transformers/generators.ts
index 9c62a751da..ef5550a83a 100644
--- a/src/compiler/transformers/generators.ts
+++ b/src/compiler/transformers/generators.ts
@@ -1,6 +1,6 @@
 import {
     AccessorDeclaration, addEmitHelpers, addSyntheticTrailingComment, ArrayLiteralExpression, Associativity,
-    BinaryExpression, Block, BreakStatement, CallExpression, CaseClause, chainBundle, CommaListExpression,
+    BinaryExpression, Block, BreakStatement, Bundle, CallExpression, CaseClause, chainBundle, CommaListExpression,
     ConditionalExpression, ContinueStatement, createExpressionForObjectLiteralElementLike, Debug, DoStatement,
     ElementAccessExpression, EmitFlags, EmitHint, ESMap, Expression, ExpressionStatement, forEach, ForInStatement,
     ForStatement, FunctionDeclaration, FunctionExpression, getEmitFlags, getEmitScriptTarget,
@@ -247,7 +247,7 @@ function getInstructionName(instruction: Instruction): string {
 }
 
 /** @internal */
-export function transformGenerators(context: TransformationContext) {
+export function transformGenerators(context: TransformationContext): (x: SourceFile | Bundle) => SourceFile | Bundle {
     const {
         factory,
         getEmitHelperFactory: emitHelpers,
diff --git a/src/compiler/transformers/jsx.ts b/src/compiler/transformers/jsx.ts
index 5e02c2ce92..37152cfe6a 100644
--- a/src/compiler/transformers/jsx.ts
+++ b/src/compiler/transformers/jsx.ts
@@ -1,5 +1,5 @@
 import {
-    addEmitHelpers, arrayFrom, chainBundle, createExpressionForJsxElement, createExpressionForJsxFragment,
+    addEmitHelpers, arrayFrom, Bundle, chainBundle, createExpressionForJsxElement, createExpressionForJsxFragment,
     createExpressionFromEntityName, createJsxFactoryExpression, Debug, emptyArray, Expression, filter, find, flatten,
     GeneratedIdentifierFlags, getEmitScriptTarget, getEntries, getJSXImplicitImportBase, getJSXRuntimeImport,
     getLineAndCharacterOfPosition, getOriginalNode, getSemanticJsxChildren, Identifier, idText, ImportSpecifier,
@@ -14,7 +14,7 @@ import {
 } from "../_namespaces/ts";
 
 /** @internal */
-export function transformJsx(context: TransformationContext) {
+export function transformJsx(context: TransformationContext): (x: SourceFile | Bundle) => SourceFile | Bundle {
     interface PerFileState {
         importSpecifier?: string;
         filenameDeclaration?: VariableDeclaration & { name: Identifier; };
diff --git a/src/compiler/transformers/legacyDecorators.ts b/src/compiler/transformers/legacyDecorators.ts
index 52ddcf5a62..be6c0615ee 100644
--- a/src/compiler/transformers/legacyDecorators.ts
+++ b/src/compiler/transformers/legacyDecorators.ts
@@ -1,5 +1,5 @@
 import {
-    addEmitHelpers, addRange, AllDecorators, append, canHaveDecorators, chainBundle, childIsDecorated, ClassDeclaration,
+    addEmitHelpers, addRange, AllDecorators, append, Bundle, canHaveDecorators, chainBundle, childIsDecorated, ClassDeclaration,
     ClassElement, ClassExpression, ClassLikeDeclaration, classOrConstructorParameterIsDecorated, ConstructorDeclaration,
     Decorator, elideNodes, EmitFlags, EmitHint, EnumMember, Expression, filter, flatMap, GetAccessorDeclaration,
     getAllDecoratorsOfClass, getAllDecoratorsOfClassElement, getEmitFlags, getEmitScriptTarget, getOriginalNodeId,
@@ -14,7 +14,7 @@ import {
 } from "../_namespaces/ts";
 
 /** @internal */
-export function transformLegacyDecorators(context: TransformationContext) {
+export function transformLegacyDecorators(context: TransformationContext): (x: SourceFile | Bundle) => SourceFile | Bundle {
     const {
         factory,
         getEmitHelperFactory: emitHelpers,
diff --git a/src/compiler/transformers/module/esnextAnd2015.ts b/src/compiler/transformers/module/esnextAnd2015.ts
index ead5ee8eea..ec9d36cc2e 100644
--- a/src/compiler/transformers/module/esnextAnd2015.ts
+++ b/src/compiler/transformers/module/esnextAnd2015.ts
@@ -1,5 +1,5 @@
 import {
-    addRange, append, chainBundle, createEmptyExports, createExternalHelpersImportDeclarationIfNeeded, Debug, EmitFlags,
+    addRange, append, Bundle, chainBundle, createEmptyExports, createExternalHelpersImportDeclarationIfNeeded, Debug, EmitFlags,
     EmitHint, ESMap, ExportAssignment, ExportDeclaration, Expression, GeneratedIdentifierFlags, getEmitFlags,
     getEmitModuleKind, getEmitScriptTarget, getExternalModuleNameLiteral, hasSyntacticModifier, Identifier, idText,
     ImportDeclaration, ImportEqualsDeclaration, insertStatementsAfterCustomPrologue,
@@ -10,7 +10,7 @@ import {
 } from "../../_namespaces/ts";
 
 /** @internal */
-export function transformECMAScriptModule(context: TransformationContext) {
+export function transformECMAScriptModule(context: TransformationContext): (x: SourceFile | Bundle) => SourceFile | Bundle {
     const {
         factory,
         getEmitHelperFactory: emitHelpers,
diff --git a/src/compiler/transformers/module/module.ts b/src/compiler/transformers/module/module.ts
index 0b9c5ad57b..cb3b73b777 100644
--- a/src/compiler/transformers/module/module.ts
+++ b/src/compiler/transformers/module/module.ts
@@ -1,5 +1,6 @@
 import {
     addEmitFlags, addEmitHelper, addEmitHelpers, addRange, append, ArrowFunction, BinaryExpression, BindingElement,
+    Bundle,
     CallExpression, chainBundle, ClassDeclaration, collectExternalModuleInfo, Debug, Declaration,
     DestructuringAssignment, EmitFlags, EmitHelper, EmitHint, emptyArray, EndOfDeclarationMarker, ExportAssignment,
     ExportDeclaration, Expression, ExpressionStatement, ExternalModuleInfo, firstOrUndefined,
@@ -27,7 +28,7 @@ import {
 } from "../../_namespaces/ts";
 
 /** @internal */
-export function transformModule(context: TransformationContext) {
+export function transformModule(context: TransformationContext): (x: SourceFile | Bundle) => SourceFile | Bundle {
     interface AsynchronousDependencies {
         aliasedModuleNames: Expression[];
         unaliasedModuleNames: Expression[];
diff --git a/src/compiler/transformers/module/system.ts b/src/compiler/transformers/module/system.ts
index 977d7efdfa..a6e9e90d2b 100644
--- a/src/compiler/transformers/module/system.ts
+++ b/src/compiler/transformers/module/system.ts
@@ -1,5 +1,5 @@
 import {
-    addRange, append, BinaryExpression, BindingElement, Block, CaseBlock, CaseClause, CaseOrDefaultClause, CatchClause,
+    addRange, append, BinaryExpression, BindingElement, Block, Bundle, CaseBlock, CaseClause, CaseOrDefaultClause, CatchClause,
     chainBundle, ClassDeclaration, collectExternalModuleInfo, Debug, Declaration, DefaultClause,
     DestructuringAssignment, DoStatement, EmitFlags, EmitHint, EndOfDeclarationMarker, ExportAssignment,
     ExportDeclaration, Expression, ExpressionStatement, ExternalModuleInfo, firstOrUndefined,
@@ -25,7 +25,7 @@ import {
 } from "../../_namespaces/ts";
 
 /** @internal */
-export function transformSystemModule(context: TransformationContext) {
+export function transformSystemModule(context: TransformationContext): (x: SourceFile | Bundle) => SourceFile | Bundle {
     interface DependencyGroup {
         name: StringLiteral;
         externalImports: (ImportDeclaration | ImportEqualsDeclaration | ExportDeclaration)[];
diff --git a/src/compiler/transformers/taggedTemplate.ts b/src/compiler/transformers/taggedTemplate.ts
index ffce659146..dddd501043 100644
--- a/src/compiler/transformers/taggedTemplate.ts
+++ b/src/compiler/transformers/taggedTemplate.ts
@@ -1,4 +1,5 @@
 import {
+    CallExpression,
     Debug, Expression, factory, getSourceTextOfNodeFromSourceFile, hasInvalidEscape, Identifier, isExpression,
     isExternalModule, isNoSubstitutionTemplateLiteral, NoSubstitutionTemplateLiteral, setTextRange, SourceFile,
     SyntaxKind, TaggedTemplateExpression, TemplateHead, TemplateLiteralLikeNode, TemplateMiddle, TemplateTail,
@@ -18,7 +19,7 @@ export function processTaggedTemplateExpression(
     visitor: Visitor,
     currentSourceFile: SourceFile,
     recordTaggedTemplateString: (temp: Identifier) => void,
-    level: ProcessLevel) {
+    level: ProcessLevel): TaggedTemplateExpression | CallExpression {
 
     // Visit the tag expression
     const tag = visitNode(node.tag, visitor, isExpression);
diff --git a/src/compiler/transformers/typeSerializer.ts b/src/compiler/transformers/typeSerializer.ts
index 7548d159c5..98a97b54bb 100644
--- a/src/compiler/transformers/typeSerializer.ts
+++ b/src/compiler/transformers/typeSerializer.ts
@@ -14,14 +14,16 @@ import {
     VoidExpression,
 } from "../_namespaces/ts";
 
-type SerializedEntityName =
+/** @internal */
+export type SerializedEntityName =
     | Identifier // Globals (i.e., `String`, `Number`, etc.)
  // Globals (i.e., `String`, `Number`, etc.)
     | PropertyAccessEntityNameExpression // `A.B`
  // `A.B`
     ;
 
-type SerializedTypeNode =
+/** @internal */
+export type SerializedTypeNode =
     | SerializedEntityName
     | ConditionalExpression // Type Reference or Global fallback
  // Type Reference or Global fallback
diff --git a/src/compiler/transformers/utilities.ts b/src/compiler/transformers/utilities.ts
index 4460f4fc45..862bdf7c8b 100644
--- a/src/compiler/transformers/utilities.ts
+++ b/src/compiler/transformers/utilities.ts
@@ -12,7 +12,7 @@ import {
     isPrivateIdentifier, isPropertyDeclaration, isStatic, isStringLiteralLike, isSuperCall, LogicalOperatorOrHigher,
     map, Map, MethodDeclaration, ModifierFlags, NamedImportBindings, NamespaceExport, Node, NodeArray,
     parameterIsThisKeyword, PrivateIdentifierAccessorDeclaration, PrivateIdentifierAutoAccessorPropertyDeclaration,
-    PrivateIdentifierMethodDeclaration, PropertyDeclaration, skipParentheses, some, SourceFile, Statement, SyntaxKind,
+    PrivateIdentifierMethodDeclaration, PropertyDeclaration, skipParentheses, some, SourceFile, Statement, SuperCall, SyntaxKind,
     TransformationContext, VariableDeclaration, VariableStatement,
 } from "../_namespaces/ts";
 
@@ -332,7 +332,7 @@ export function getNonAssignmentOperatorForCompoundAssignment(kind: CompoundAssi
  *
  * @internal
  */
-export function getSuperCallFromStatement(statement: Statement) {
+export function getSuperCallFromStatement(statement: Statement): SuperCall | undefined {
     if (!isExpressionStatement(statement)) {
         return undefined;
     }
diff --git a/src/compiler/tsbuildPublic.ts b/src/compiler/tsbuildPublic.ts
index 3bdfe22993..463a9a217a 100644
--- a/src/compiler/tsbuildPublic.ts
+++ b/src/compiler/tsbuildPublic.ts
@@ -194,7 +194,7 @@ export function createBuilderStatusReporter(system: System, pretty?: boolean): D
     };
 }
 
-function createSolutionBuilderHostBase<T extends BuilderProgram>(system: System, createProgram: CreateProgram<T> | undefined, reportDiagnostic?: DiagnosticReporter, reportSolutionBuilderStatus?: DiagnosticReporter) {
+function createSolutionBuilderHostBase<T extends BuilderProgram>(system: System, createProgram: CreateProgram<T> | undefined, reportDiagnostic?: DiagnosticReporter, reportSolutionBuilderStatus?: DiagnosticReporter): SolutionBuilderHostBase<T> {
     const host = createProgramHost(system, createProgram) as SolutionBuilderHostBase<T>;
     host.getModifiedTime = system.getModifiedTime ? path => system.getModifiedTime!(path) : returnUndefined;
     host.setModifiedTime = system.setModifiedTime ? (path, date) => system.setModifiedTime!(path, date) : noop;
@@ -205,13 +205,13 @@ function createSolutionBuilderHostBase<T extends BuilderProgram>(system: System,
     return host;
 }
 
-export function createSolutionBuilderHost<T extends BuilderProgram = EmitAndSemanticDiagnosticsBuilderProgram>(system = sys, createProgram?: CreateProgram<T>, reportDiagnostic?: DiagnosticReporter, reportSolutionBuilderStatus?: DiagnosticReporter, reportErrorSummary?: ReportEmitErrorSummary) {
+export function createSolutionBuilderHost<T extends BuilderProgram = EmitAndSemanticDiagnosticsBuilderProgram>(system: System = sys, createProgram?: CreateProgram<T>, reportDiagnostic?: DiagnosticReporter, reportSolutionBuilderStatus?: DiagnosticReporter, reportErrorSummary?: ReportEmitErrorSummary): SolutionBuilderHost<T> {
     const host = createSolutionBuilderHostBase(system, createProgram, reportDiagnostic, reportSolutionBuilderStatus) as SolutionBuilderHost<T>;
     host.reportErrorSummary = reportErrorSummary;
     return host;
 }
 
-export function createSolutionBuilderWithWatchHost<T extends BuilderProgram = EmitAndSemanticDiagnosticsBuilderProgram>(system = sys, createProgram?: CreateProgram<T>, reportDiagnostic?: DiagnosticReporter, reportSolutionBuilderStatus?: DiagnosticReporter, reportWatchStatus?: WatchStatusReporter) {
+export function createSolutionBuilderWithWatchHost<T extends BuilderProgram = EmitAndSemanticDiagnosticsBuilderProgram>(system: System = sys, createProgram?: CreateProgram<T>, reportDiagnostic?: DiagnosticReporter, reportSolutionBuilderStatus?: DiagnosticReporter, reportWatchStatus?: WatchStatusReporter): SolutionBuilderWithWatchHost<T> {
     const host = createSolutionBuilderHostBase(system, createProgram, reportDiagnostic, reportSolutionBuilderStatus) as SolutionBuilderWithWatchHost<T>;
     const watchHost = createWatchHost(system, reportWatchStatus);
     copyProperties(host, watchHost);
diff --git a/src/compiler/types.ts b/src/compiler/types.ts
index 638abe01cc..c67350b23f 100644
--- a/src/compiler/types.ts
+++ b/src/compiler/types.ts
@@ -5085,7 +5085,7 @@ export interface SymbolWalker {
 
 // This was previously deprecated in our public API, but is still used internally
 /** @internal */
-interface SymbolWriter extends SymbolTracker {
+export interface SymbolWriter extends SymbolTracker {
     writeKeyword(text: string): void;
     writeOperator(text: string): void;
     writePunctuation(text: string): void;
@@ -9234,7 +9234,7 @@ export const enum PragmaKindFlags {
 }
 
 /** @internal */
-interface PragmaArgumentSpecification<TName extends string> {
+export interface PragmaArgumentSpecification<TName extends string> {
     name: TName; // Determines the name of the key in the resulting parsed type, type parameter to cause literal type inference
     optional?: boolean;
     captureSpan?: boolean;
@@ -9298,20 +9298,20 @@ export const commentPragmas = {
 } as const;
 
 /** @internal */
-type PragmaArgTypeMaybeCapture<TDesc> = TDesc extends {captureSpan: true} ? {value: string, pos: number, end: number} : string;
+export type PragmaArgTypeMaybeCapture<TDesc> = TDesc extends {captureSpan: true} ? {value: string, pos: number, end: number} : string;
 
 /** @internal */
-type PragmaArgTypeOptional<TDesc, TName extends string> =
+export type PragmaArgTypeOptional<TDesc, TName extends string> =
     TDesc extends {optional: true}
         ? {[K in TName]?: PragmaArgTypeMaybeCapture<TDesc>}
         : {[K in TName]: PragmaArgTypeMaybeCapture<TDesc>};
 
 /** @internal */
-type UnionToIntersection<U> =
+export type UnionToIntersection<U> =
         (U extends any ? (k: U) => void : never) extends ((k: infer I) => void) ? I : never;
 
 /** @internal */
-type ArgumentDefinitionToFieldUnion<T extends readonly PragmaArgumentSpecification<any>[]> = {
+export type ArgumentDefinitionToFieldUnion<T extends readonly PragmaArgumentSpecification<any>[]> = {
     [K in keyof T]: PragmaArgTypeOptional<T[K], T[K] extends {name: infer TName} ? TName extends string ? TName : never : never>
 }[Extract<keyof T, number>]; // The mapped type maps over only the tuple members, but this reindex gets _all_ members - by extracting only `number` keys, we get only the tuple members
 
@@ -9320,13 +9320,13 @@ type ArgumentDefinitionToFieldUnion<T extends readonly PragmaArgumentSpecificati
  *
  * @internal
  */
-type PragmaArgumentType<KPrag extends keyof ConcretePragmaSpecs> =
+ export type PragmaArgumentType<KPrag extends keyof ConcretePragmaSpecs> =
     ConcretePragmaSpecs[KPrag] extends { args: readonly PragmaArgumentSpecification<any>[] }
         ? UnionToIntersection<ArgumentDefinitionToFieldUnion<ConcretePragmaSpecs[KPrag]["args"]>>
         : never;
 
 /** @internal */
-type ConcretePragmaSpecs = typeof commentPragmas;
+export type ConcretePragmaSpecs = typeof commentPragmas;
 
 /** @internal */
 export type PragmaPseudoMap = {[K in keyof ConcretePragmaSpecs]: {arguments: PragmaArgumentType<K>, range: CommentRange}};
diff --git a/src/compiler/utilities.ts b/src/compiler/utilities.ts
index 560a78a818..97620b9c89 100644
--- a/src/compiler/utilities.ts
+++ b/src/compiler/utilities.ts
@@ -721,7 +721,8 @@ export function getEmitFlags(node: Node): EmitFlags {
     return emitNode && emitNode.flags || 0;
 }
 
-interface ScriptTargetFeatures {
+/** @internal */
+export interface ScriptTargetFeatures {
     [key: string]: { [key: string]: string[] | undefined };
 }
 
@@ -6743,14 +6744,14 @@ export function formatStringFromArgs(text: string, args: ArrayLike<string | numb
 let localizedDiagnosticMessages: MapLike<string> | undefined;
 
 /** @internal */
-export function setLocalizedDiagnosticMessages(messages: typeof localizedDiagnosticMessages) {
+export function setLocalizedDiagnosticMessages(messages: MapLike<string> | undefined) {
     localizedDiagnosticMessages = messages;
 }
 
 /** @internal */
 // If the localized messages json is unset, and if given function use it to set the json
 
-export function maybeSetLocalizedDiagnosticMessages(getMessages: undefined | (() => typeof localizedDiagnosticMessages)) {
+export function maybeSetLocalizedDiagnosticMessages(getMessages: undefined | (() => MapLike<string> | undefined)) {
     if (!localizedDiagnosticMessages && getMessages) {
         localizedDiagnosticMessages = getMessages();
     }
diff --git a/src/compiler/watchPublic.ts b/src/compiler/watchPublic.ts
index c54d14e0b0..b183c3415c 100644
--- a/src/compiler/watchPublic.ts
+++ b/src/compiler/watchPublic.ts
@@ -28,7 +28,7 @@ export interface ReadBuildProgramHost {
     /** @internal */
     getBuildInfo?(fileName: string, configFilePath: string | undefined): BuildInfo | undefined;
 }
-export function readBuilderProgram(compilerOptions: CompilerOptions, host: ReadBuildProgramHost) {
+export function readBuilderProgram(compilerOptions: CompilerOptions, host: ReadBuildProgramHost): EmitAndSemanticDiagnosticsBuilderProgram | undefined {
     const buildInfoPath = getTsBuildInfoEmitOutputFilePath(compilerOptions);
     if (!buildInfoPath) return undefined;
     let buildInfo;
@@ -45,7 +45,7 @@ export function readBuilderProgram(compilerOptions: CompilerOptions, host: ReadB
     return createBuilderProgramUsingProgramBuildInfo(buildInfo.program, buildInfoPath, host);
 }
 
-export function createIncrementalCompilerHost(options: CompilerOptions, system = sys): CompilerHost {
+export function createIncrementalCompilerHost(options: CompilerOptions, system: System = sys): CompilerHost {
     const host = createCompilerHostWorker(options, /*setParentNodes*/ undefined, system);
     host.createHash = maybeBind(system, system.createHash);
     host.disableUseFileVersionAsSignature = system.disableUseFileVersionAsSignature;
diff --git a/src/compiler/watchUtilities.ts b/src/compiler/watchUtilities.ts
index 5dce173af6..0a06364c12 100644
--- a/src/compiler/watchUtilities.ts
+++ b/src/compiler/watchUtilities.ts
@@ -30,7 +30,8 @@ export interface DirectoryStructureHost {
     writeFile?(path: string, data: string, writeByteOrderMark?: boolean): void;
 }
 
-interface FileAndDirectoryExistence {
+/** @internal */
+export interface FileAndDirectoryExistence {
     fileExists: boolean;
     directoryExists: boolean;
 }
diff --git a/src/deprecatedCompat/4.0/nodeFactoryTopLevelExports.ts b/src/deprecatedCompat/4.0/nodeFactoryTopLevelExports.ts
index db5f894683..b3ec867dab 100644
--- a/src/deprecatedCompat/4.0/nodeFactoryTopLevelExports.ts
+++ b/src/deprecatedCompat/4.0/nodeFactoryTopLevelExports.ts
@@ -20,148 +20,148 @@ import {
 const factoryDeprecation: DeprecationOptions = { since: "4.0", warnAfter: "4.1", message: "Use the appropriate method on 'ts.factory' or the 'factory' supplied by your transformation context instead." };
 
 /** @deprecated Use `factory.createNodeArray` or the factory supplied by your transformation context instead. */
-export const createNodeArray = Debug.deprecate(factory.createNodeArray, factoryDeprecation);
+export const createNodeArray: typeof factory.createNodeArray = Debug.deprecate(factory.createNodeArray, factoryDeprecation);
 
 /** @deprecated Use `factory.createNumericLiteral` or the factory supplied by your transformation context instead. */
-export const createNumericLiteral = Debug.deprecate(factory.createNumericLiteral, factoryDeprecation);
+export const createNumericLiteral: typeof factory.createNumericLiteral = Debug.deprecate(factory.createNumericLiteral, factoryDeprecation);
 
 /** @deprecated Use `factory.createBigIntLiteral` or the factory supplied by your transformation context instead. */
-export const createBigIntLiteral = Debug.deprecate(factory.createBigIntLiteral, factoryDeprecation);
+export const createBigIntLiteral: typeof factory.createBigIntLiteral = Debug.deprecate(factory.createBigIntLiteral, factoryDeprecation);
 
 /** @deprecated Use `factory.createStringLiteral` or the factory supplied by your transformation context instead. */
-export const createStringLiteral = Debug.deprecate(factory.createStringLiteral, factoryDeprecation);
+export const createStringLiteral: typeof factory.createStringLiteral = Debug.deprecate(factory.createStringLiteral, factoryDeprecation);
 
 /** @deprecated Use `factory.createStringLiteralFromNode` or the factory supplied by your transformation context instead. */
-export const createStringLiteralFromNode = Debug.deprecate(factory.createStringLiteralFromNode, factoryDeprecation);
+export const createStringLiteralFromNode: typeof factory.createStringLiteralFromNode = Debug.deprecate(factory.createStringLiteralFromNode, factoryDeprecation);
 
 /** @deprecated Use `factory.createRegularExpressionLiteral` or the factory supplied by your transformation context instead. */
-export const createRegularExpressionLiteral = Debug.deprecate(factory.createRegularExpressionLiteral, factoryDeprecation);
+export const createRegularExpressionLiteral: typeof factory.createRegularExpressionLiteral = Debug.deprecate(factory.createRegularExpressionLiteral, factoryDeprecation);
 
 /** @deprecated Use `factory.createLoopVariable` or the factory supplied by your transformation context instead. */
-export const createLoopVariable = Debug.deprecate(factory.createLoopVariable, factoryDeprecation);
+export const createLoopVariable: typeof factory.createLoopVariable = Debug.deprecate(factory.createLoopVariable, factoryDeprecation);
 
 /** @deprecated Use `factory.createUniqueName` or the factory supplied by your transformation context instead. */
-export const createUniqueName: (text: string, flags?: GeneratedIdentifierFlags | undefined) => Identifier = Debug.deprecate(factory.createUniqueName, factoryDeprecation);
+export const createUniqueName: typeof factory.createUniqueName = Debug.deprecate(factory.createUniqueName, factoryDeprecation);
 
 /** @deprecated Use `factory.createPrivateIdentifier` or the factory supplied by your transformation context instead. */
-export const createPrivateIdentifier = Debug.deprecate(factory.createPrivateIdentifier, factoryDeprecation);
+export const createPrivateIdentifier: typeof factory.createPrivateIdentifier = Debug.deprecate(factory.createPrivateIdentifier, factoryDeprecation);
 
 /** @deprecated Use `factory.createSuper` or the factory supplied by your transformation context instead. */
-export const createSuper = Debug.deprecate(factory.createSuper, factoryDeprecation);
+export const createSuper: typeof factory.createSuper = Debug.deprecate(factory.createSuper, factoryDeprecation);
 
 /** @deprecated Use `factory.createThis` or the factory supplied by your transformation context instead. */
-export const createThis = Debug.deprecate(factory.createThis, factoryDeprecation);
+export const createThis: typeof factory.createThis = Debug.deprecate(factory.createThis, factoryDeprecation);
 
 /** @deprecated Use `factory.createNull` or the factory supplied by your transformation context instead. */
-export const createNull = Debug.deprecate(factory.createNull, factoryDeprecation);
+export const createNull: typeof factory.createNull = Debug.deprecate(factory.createNull, factoryDeprecation);
 
 /** @deprecated Use `factory.createTrue` or the factory supplied by your transformation context instead. */
-export const createTrue = Debug.deprecate(factory.createTrue, factoryDeprecation);
+export const createTrue: typeof factory.createTrue = Debug.deprecate(factory.createTrue, factoryDeprecation);
 
 /** @deprecated Use `factory.createFalse` or the factory supplied by your transformation context instead. */
-export const createFalse = Debug.deprecate(factory.createFalse, factoryDeprecation);
+export const createFalse: typeof factory.createFalse = Debug.deprecate(factory.createFalse, factoryDeprecation);
 
 /** @deprecated Use `factory.createModifier` or the factory supplied by your transformation context instead. */
-export const createModifier = Debug.deprecate(factory.createModifier, factoryDeprecation);
+export const createModifier: typeof factory.createModifier = Debug.deprecate(factory.createModifier, factoryDeprecation);
 
 /** @deprecated Use `factory.createModifiersFromModifierFlags` or the factory supplied by your transformation context instead. */
-export const createModifiersFromModifierFlags = Debug.deprecate(factory.createModifiersFromModifierFlags, factoryDeprecation);
+export const createModifiersFromModifierFlags: typeof factory.createModifiersFromModifierFlags = Debug.deprecate(factory.createModifiersFromModifierFlags, factoryDeprecation);
 
 /** @deprecated Use `factory.createQualifiedName` or the factory supplied by your transformation context instead. */
-export const createQualifiedName = Debug.deprecate(factory.createQualifiedName, factoryDeprecation);
+export const createQualifiedName: typeof factory.createQualifiedName = Debug.deprecate(factory.createQualifiedName, factoryDeprecation);
 
 /** @deprecated Use `factory.updateQualifiedName` or the factory supplied by your transformation context instead. */
-export const updateQualifiedName = Debug.deprecate(factory.updateQualifiedName, factoryDeprecation);
+export const updateQualifiedName: typeof factory.updateQualifiedName = Debug.deprecate(factory.updateQualifiedName, factoryDeprecation);
 
 /** @deprecated Use `factory.createComputedPropertyName` or the factory supplied by your transformation context instead. */
-export const createComputedPropertyName = Debug.deprecate(factory.createComputedPropertyName, factoryDeprecation);
+export const createComputedPropertyName: typeof factory.createComputedPropertyName = Debug.deprecate(factory.createComputedPropertyName, factoryDeprecation);
 
 /** @deprecated Use `factory.updateComputedPropertyName` or the factory supplied by your transformation context instead. */
-export const updateComputedPropertyName = Debug.deprecate(factory.updateComputedPropertyName, factoryDeprecation);
+export const updateComputedPropertyName: typeof factory.updateComputedPropertyName = Debug.deprecate(factory.updateComputedPropertyName, factoryDeprecation);
 
 /** @deprecated Use `factory.createTypeParameterDeclaration` or the factory supplied by your transformation context instead. */
-export const createTypeParameterDeclaration = Debug.deprecate(factory.createTypeParameterDeclaration, factoryDeprecation);
+export const createTypeParameterDeclaration: typeof factory.createTypeParameterDeclaration = Debug.deprecate(factory.createTypeParameterDeclaration, factoryDeprecation);
 
 /** @deprecated Use `factory.updateTypeParameterDeclaration` or the factory supplied by your transformation context instead. */
-export const updateTypeParameterDeclaration = Debug.deprecate(factory.updateTypeParameterDeclaration, factoryDeprecation);
+export const updateTypeParameterDeclaration: typeof factory.updateTypeParameterDeclaration = Debug.deprecate(factory.updateTypeParameterDeclaration, factoryDeprecation);
 
 /** @deprecated Use `factory.createParameterDeclaration` or the factory supplied by your transformation context instead. */
-export const createParameter = Debug.deprecate(factory.createParameterDeclaration, factoryDeprecation);
+export const createParameter: typeof factory.createParameterDeclaration = Debug.deprecate(factory.createParameterDeclaration, factoryDeprecation);
 
 /** @deprecated Use `factory.updateParameterDeclaration` or the factory supplied by your transformation context instead. */
-export const updateParameter = Debug.deprecate(factory.updateParameterDeclaration, factoryDeprecation);
+export const updateParameter: typeof factory.updateParameterDeclaration = Debug.deprecate(factory.updateParameterDeclaration, factoryDeprecation);
 
 /** @deprecated Use `factory.createDecorator` or the factory supplied by your transformation context instead. */
-export const createDecorator = Debug.deprecate(factory.createDecorator, factoryDeprecation);
+export const createDecorator: typeof factory.createDecorator = Debug.deprecate(factory.createDecorator, factoryDeprecation);
 
 /** @deprecated Use `factory.updateDecorator` or the factory supplied by your transformation context instead. */
-export const updateDecorator = Debug.deprecate(factory.updateDecorator, factoryDeprecation);
+export const updateDecorator: typeof factory.updateDecorator = Debug.deprecate(factory.updateDecorator, factoryDeprecation);
 
 /** @deprecated Use `factory.createPropertyDeclaration` or the factory supplied by your transformation context instead. */
-export const createProperty = Debug.deprecate(factory.createPropertyDeclaration, factoryDeprecation);
+export const createProperty: typeof factory.createPropertyDeclaration = Debug.deprecate(factory.createPropertyDeclaration, factoryDeprecation);
 
 /** @deprecated Use `factory.updatePropertyDeclaration` or the factory supplied by your transformation context instead. */
-export const updateProperty = Debug.deprecate(factory.updatePropertyDeclaration, factoryDeprecation);
+export const updateProperty: typeof factory.updatePropertyDeclaration = Debug.deprecate(factory.updatePropertyDeclaration, factoryDeprecation);
 
 /** @deprecated Use `factory.createMethodDeclaration` or the factory supplied by your transformation context instead. */
-export const createMethod = Debug.deprecate(factory.createMethodDeclaration, factoryDeprecation);
+export const createMethod: typeof factory.createMethodDeclaration = Debug.deprecate(factory.createMethodDeclaration, factoryDeprecation);
 
 /** @deprecated Use `factory.updateMethodDeclaration` or the factory supplied by your transformation context instead. */
-export const updateMethod = Debug.deprecate(factory.updateMethodDeclaration, factoryDeprecation);
+export const updateMethod: typeof factory.updateMethodDeclaration = Debug.deprecate(factory.updateMethodDeclaration, factoryDeprecation);
 
 /** @deprecated Use `factory.createConstructorDeclaration` or the factory supplied by your transformation context instead. */
-export const createConstructor = Debug.deprecate(factory.createConstructorDeclaration, factoryDeprecation);
+export const createConstructor: typeof factory.createConstructorDeclaration = Debug.deprecate(factory.createConstructorDeclaration, factoryDeprecation);
 
 /** @deprecated Use `factory.updateConstructorDeclaration` or the factory supplied by your transformation context instead. */
-export const updateConstructor = Debug.deprecate(factory.updateConstructorDeclaration, factoryDeprecation);
+export const updateConstructor: typeof factory.updateConstructorDeclaration = Debug.deprecate(factory.updateConstructorDeclaration, factoryDeprecation);
 
 /** @deprecated Use `factory.createGetAccessorDeclaration` or the factory supplied by your transformation context instead. */
-export const createGetAccessor = Debug.deprecate(factory.createGetAccessorDeclaration, factoryDeprecation);
+export const createGetAccessor: typeof factory.createGetAccessorDeclaration = Debug.deprecate(factory.createGetAccessorDeclaration, factoryDeprecation);
 
 /** @deprecated Use `factory.updateGetAccessorDeclaration` or the factory supplied by your transformation context instead. */
-export const updateGetAccessor = Debug.deprecate(factory.updateGetAccessorDeclaration, factoryDeprecation);
+export const updateGetAccessor: typeof factory.updateGetAccessorDeclaration = Debug.deprecate(factory.updateGetAccessorDeclaration, factoryDeprecation);
 
 /** @deprecated Use `factory.createSetAccessorDeclaration` or the factory supplied by your transformation context instead. */
-export const createSetAccessor = Debug.deprecate(factory.createSetAccessorDeclaration, factoryDeprecation);
+export const createSetAccessor: typeof factory.createSetAccessorDeclaration = Debug.deprecate(factory.createSetAccessorDeclaration, factoryDeprecation);
 
 /** @deprecated Use `factory.updateSetAccessorDeclaration` or the factory supplied by your transformation context instead. */
-export const updateSetAccessor = Debug.deprecate(factory.updateSetAccessorDeclaration, factoryDeprecation);
+export const updateSetAccessor: typeof factory.updateSetAccessorDeclaration = Debug.deprecate(factory.updateSetAccessorDeclaration, factoryDeprecation);
 
 /** @deprecated Use `factory.createCallSignature` or the factory supplied by your transformation context instead. */
-export const createCallSignature = Debug.deprecate(factory.createCallSignature, factoryDeprecation);
+export const createCallSignature: typeof factory.createCallSignature = Debug.deprecate(factory.createCallSignature, factoryDeprecation);
 
 /** @deprecated Use `factory.updateCallSignature` or the factory supplied by your transformation context instead. */
-export const updateCallSignature = Debug.deprecate(factory.updateCallSignature, factoryDeprecation);
+export const updateCallSignature: typeof factory.updateCallSignature = Debug.deprecate(factory.updateCallSignature, factoryDeprecation);
 
 /** @deprecated Use `factory.createConstructSignature` or the factory supplied by your transformation context instead. */
-export const createConstructSignature = Debug.deprecate(factory.createConstructSignature, factoryDeprecation);
+export const createConstructSignature: typeof factory.createConstructSignature = Debug.deprecate(factory.createConstructSignature, factoryDeprecation);
 
 /** @deprecated Use `factory.updateConstructSignature` or the factory supplied by your transformation context instead. */
-export const updateConstructSignature = Debug.deprecate(factory.updateConstructSignature, factoryDeprecation);
+export const updateConstructSignature: typeof factory.updateConstructSignature = Debug.deprecate(factory.updateConstructSignature, factoryDeprecation);
 
 /** @deprecated Use `factory.updateIndexSignature` or the factory supplied by your transformation context instead. */
-export const updateIndexSignature = Debug.deprecate(factory.updateIndexSignature, factoryDeprecation);
+export const updateIndexSignature: typeof factory.updateIndexSignature = Debug.deprecate(factory.updateIndexSignature, factoryDeprecation);
 
 /** @deprecated Use `factory.createKeywordTypeNode` or the factory supplied by your transformation context instead. */
-export const createKeywordTypeNode = Debug.deprecate(factory.createKeywordTypeNode, factoryDeprecation);
+export const createKeywordTypeNode: typeof factory.createKeywordTypeNode = Debug.deprecate(factory.createKeywordTypeNode, factoryDeprecation);
 
 /** @deprecated Use `factory.createTypePredicateNode` or the factory supplied by your transformation context instead. */
-export const createTypePredicateNodeWithModifier = Debug.deprecate(factory.createTypePredicateNode, factoryDeprecation);
+export const createTypePredicateNodeWithModifier: typeof factory.createTypePredicateNode = Debug.deprecate(factory.createTypePredicateNode, factoryDeprecation);
 
 /** @deprecated Use `factory.updateTypePredicateNode` or the factory supplied by your transformation context instead. */
-export const updateTypePredicateNodeWithModifier = Debug.deprecate(factory.updateTypePredicateNode, factoryDeprecation);
+export const updateTypePredicateNodeWithModifier: typeof factory.updateTypePredicateNode = Debug.deprecate(factory.updateTypePredicateNode, factoryDeprecation);
 
 /** @deprecated Use `factory.createTypeReferenceNode` or the factory supplied by your transformation context instead. */
-export const createTypeReferenceNode = Debug.deprecate(factory.createTypeReferenceNode, factoryDeprecation);
+export const createTypeReferenceNode: typeof factory.createTypeReferenceNode = Debug.deprecate(factory.createTypeReferenceNode, factoryDeprecation);
 
 /** @deprecated Use `factory.updateTypeReferenceNode` or the factory supplied by your transformation context instead. */
-export const updateTypeReferenceNode = Debug.deprecate(factory.updateTypeReferenceNode, factoryDeprecation);
+export const updateTypeReferenceNode: typeof factory.updateTypeReferenceNode = Debug.deprecate(factory.updateTypeReferenceNode, factoryDeprecation);
 
 /** @deprecated Use `factory.createFunctionTypeNode` or the factory supplied by your transformation context instead. */
-export const createFunctionTypeNode = Debug.deprecate(factory.createFunctionTypeNode, factoryDeprecation);
+export const createFunctionTypeNode: typeof factory.createFunctionTypeNode = Debug.deprecate(factory.createFunctionTypeNode, factoryDeprecation);
 
 /** @deprecated Use `factory.updateFunctionTypeNode` or the factory supplied by your transformation context instead. */
-export const updateFunctionTypeNode = Debug.deprecate(factory.updateFunctionTypeNode, factoryDeprecation);
+export const updateFunctionTypeNode: typeof factory.updateFunctionTypeNode = Debug.deprecate(factory.updateFunctionTypeNode, factoryDeprecation);
 
 /** @deprecated Use `factory.createConstructorTypeNode` or the factory supplied by your transformation context instead. */
 export const createConstructorTypeNode = Debug.deprecate((
@@ -183,748 +183,748 @@ export const updateConstructorTypeNode = Debug.deprecate((
 }, factoryDeprecation);
 
 /** @deprecated Use `factory.createTypeQueryNode` or the factory supplied by your transformation context instead. */
-export const createTypeQueryNode = Debug.deprecate(factory.createTypeQueryNode, factoryDeprecation);
+export const createTypeQueryNode: typeof factory.createTypeQueryNode = Debug.deprecate(factory.createTypeQueryNode, factoryDeprecation);
 
 /** @deprecated Use `factory.updateTypeQueryNode` or the factory supplied by your transformation context instead. */
-export const updateTypeQueryNode = Debug.deprecate(factory.updateTypeQueryNode, factoryDeprecation);
+export const updateTypeQueryNode: typeof factory.updateTypeQueryNode = Debug.deprecate(factory.updateTypeQueryNode, factoryDeprecation);
 
 /** @deprecated Use `factory.createTypeLiteralNode` or the factory supplied by your transformation context instead. */
-export const createTypeLiteralNode = Debug.deprecate(factory.createTypeLiteralNode, factoryDeprecation);
+export const createTypeLiteralNode: typeof factory.createTypeLiteralNode = Debug.deprecate(factory.createTypeLiteralNode, factoryDeprecation);
 
 /** @deprecated Use `factory.updateTypeLiteralNode` or the factory supplied by your transformation context instead. */
-export const updateTypeLiteralNode = Debug.deprecate(factory.updateTypeLiteralNode, factoryDeprecation);
+export const updateTypeLiteralNode: typeof factory.updateTypeLiteralNode = Debug.deprecate(factory.updateTypeLiteralNode, factoryDeprecation);
 
 /** @deprecated Use `factory.createArrayTypeNode` or the factory supplied by your transformation context instead. */
-export const createArrayTypeNode = Debug.deprecate(factory.createArrayTypeNode, factoryDeprecation);
+export const createArrayTypeNode: typeof factory.createArrayTypeNode = Debug.deprecate(factory.createArrayTypeNode, factoryDeprecation);
 
 /** @deprecated Use `factory.updateArrayTypeNode` or the factory supplied by your transformation context instead. */
-export const updateArrayTypeNode = Debug.deprecate(factory.updateArrayTypeNode, factoryDeprecation);
+export const updateArrayTypeNode: typeof factory.updateArrayTypeNode = Debug.deprecate(factory.updateArrayTypeNode, factoryDeprecation);
 
 /** @deprecated Use `factory.createTupleTypeNode` or the factory supplied by your transformation context instead. */
-export const createTupleTypeNode = Debug.deprecate(factory.createTupleTypeNode, factoryDeprecation);
+export const createTupleTypeNode: typeof factory.createTupleTypeNode = Debug.deprecate(factory.createTupleTypeNode, factoryDeprecation);
 
 /** @deprecated Use `factory.updateTupleTypeNode` or the factory supplied by your transformation context instead. */
-export const updateTupleTypeNode = Debug.deprecate(factory.updateTupleTypeNode, factoryDeprecation);
+export const updateTupleTypeNode: typeof factory.updateTupleTypeNode = Debug.deprecate(factory.updateTupleTypeNode, factoryDeprecation);
 
 /** @deprecated Use `factory.createOptionalTypeNode` or the factory supplied by your transformation context instead. */
-export const createOptionalTypeNode = Debug.deprecate(factory.createOptionalTypeNode, factoryDeprecation);
+export const createOptionalTypeNode: typeof factory.createOptionalTypeNode = Debug.deprecate(factory.createOptionalTypeNode, factoryDeprecation);
 
 /** @deprecated Use `factory.updateOptionalTypeNode` or the factory supplied by your transformation context instead. */
-export const updateOptionalTypeNode = Debug.deprecate(factory.updateOptionalTypeNode, factoryDeprecation);
+export const updateOptionalTypeNode: typeof factory.updateOptionalTypeNode = Debug.deprecate(factory.updateOptionalTypeNode, factoryDeprecation);
 
 /** @deprecated Use `factory.createRestTypeNode` or the factory supplied by your transformation context instead. */
-export const createRestTypeNode = Debug.deprecate(factory.createRestTypeNode, factoryDeprecation);
+export const createRestTypeNode: typeof factory.createRestTypeNode = Debug.deprecate(factory.createRestTypeNode, factoryDeprecation);
 
 /** @deprecated Use `factory.updateRestTypeNode` or the factory supplied by your transformation context instead. */
-export const updateRestTypeNode = Debug.deprecate(factory.updateRestTypeNode, factoryDeprecation);
+export const updateRestTypeNode: typeof factory.updateRestTypeNode = Debug.deprecate(factory.updateRestTypeNode, factoryDeprecation);
 
 /** @deprecated Use `factory.createUnionTypeNode` or the factory supplied by your transformation context instead. */
-export const createUnionTypeNode = Debug.deprecate(factory.createUnionTypeNode, factoryDeprecation);
+export const createUnionTypeNode: typeof factory.createUnionTypeNode = Debug.deprecate(factory.createUnionTypeNode, factoryDeprecation);
 
 /** @deprecated Use `factory.updateUnionTypeNode` or the factory supplied by your transformation context instead. */
-export const updateUnionTypeNode = Debug.deprecate(factory.updateUnionTypeNode, factoryDeprecation);
+export const updateUnionTypeNode: typeof factory.updateUnionTypeNode = Debug.deprecate(factory.updateUnionTypeNode, factoryDeprecation);
 
 /** @deprecated Use `factory.createIntersectionTypeNode` or the factory supplied by your transformation context instead. */
-export const createIntersectionTypeNode = Debug.deprecate(factory.createIntersectionTypeNode, factoryDeprecation);
+export const createIntersectionTypeNode: typeof factory.createIntersectionTypeNode = Debug.deprecate(factory.createIntersectionTypeNode, factoryDeprecation);
 
 /** @deprecated Use `factory.updateIntersectionTypeNode` or the factory supplied by your transformation context instead. */
-export const updateIntersectionTypeNode = Debug.deprecate(factory.updateIntersectionTypeNode, factoryDeprecation);
+export const updateIntersectionTypeNode: typeof factory.updateIntersectionTypeNode = Debug.deprecate(factory.updateIntersectionTypeNode, factoryDeprecation);
 
 /** @deprecated Use `factory.createConditionalTypeNode` or the factory supplied by your transformation context instead. */
-export const createConditionalTypeNode = Debug.deprecate(factory.createConditionalTypeNode, factoryDeprecation);
+export const createConditionalTypeNode: typeof factory.createConditionalTypeNode = Debug.deprecate(factory.createConditionalTypeNode, factoryDeprecation);
 
 /** @deprecated Use `factory.updateConditionalTypeNode` or the factory supplied by your transformation context instead. */
-export const updateConditionalTypeNode = Debug.deprecate(factory.updateConditionalTypeNode, factoryDeprecation);
+export const updateConditionalTypeNode: typeof factory.updateConditionalTypeNode = Debug.deprecate(factory.updateConditionalTypeNode, factoryDeprecation);
 
 /** @deprecated Use `factory.createInferTypeNode` or the factory supplied by your transformation context instead. */
-export const createInferTypeNode = Debug.deprecate(factory.createInferTypeNode, factoryDeprecation);
+export const createInferTypeNode: typeof factory.createInferTypeNode = Debug.deprecate(factory.createInferTypeNode, factoryDeprecation);
 
 /** @deprecated Use `factory.updateInferTypeNode` or the factory supplied by your transformation context instead. */
-export const updateInferTypeNode = Debug.deprecate(factory.updateInferTypeNode, factoryDeprecation);
+export const updateInferTypeNode: typeof factory.updateInferTypeNode = Debug.deprecate(factory.updateInferTypeNode, factoryDeprecation);
 
 /** @deprecated Use `factory.createImportTypeNode` or the factory supplied by your transformation context instead. */
-export const createImportTypeNode = Debug.deprecate(factory.createImportTypeNode, factoryDeprecation);
+export const createImportTypeNode: typeof factory.createImportTypeNode = Debug.deprecate(factory.createImportTypeNode, factoryDeprecation);
 
 /** @deprecated Use `factory.updateImportTypeNode` or the factory supplied by your transformation context instead. */
-export const updateImportTypeNode = Debug.deprecate(factory.updateImportTypeNode, factoryDeprecation);
+export const updateImportTypeNode: typeof factory.updateImportTypeNode = Debug.deprecate(factory.updateImportTypeNode, factoryDeprecation);
 
 /** @deprecated Use `factory.createParenthesizedType` or the factory supplied by your transformation context instead. */
-export const createParenthesizedType = Debug.deprecate(factory.createParenthesizedType, factoryDeprecation);
+export const createParenthesizedType: typeof factory.createParenthesizedType = Debug.deprecate(factory.createParenthesizedType, factoryDeprecation);
 
 /** @deprecated Use `factory.updateParenthesizedType` or the factory supplied by your transformation context instead. */
-export const updateParenthesizedType = Debug.deprecate(factory.updateParenthesizedType, factoryDeprecation);
+export const updateParenthesizedType: typeof factory.updateParenthesizedType = Debug.deprecate(factory.updateParenthesizedType, factoryDeprecation);
 
 /** @deprecated Use `factory.createThisTypeNode` or the factory supplied by your transformation context instead. */
-export const createThisTypeNode = Debug.deprecate(factory.createThisTypeNode, factoryDeprecation);
+export const createThisTypeNode: typeof factory.createThisTypeNode = Debug.deprecate(factory.createThisTypeNode, factoryDeprecation);
 
 /** @deprecated Use `factory.updateTypeOperatorNode` or the factory supplied by your transformation context instead. */
-export const updateTypeOperatorNode = Debug.deprecate(factory.updateTypeOperatorNode, factoryDeprecation);
+export const updateTypeOperatorNode: typeof factory.updateTypeOperatorNode = Debug.deprecate(factory.updateTypeOperatorNode, factoryDeprecation);
 
 /** @deprecated Use `factory.createIndexedAccessTypeNode` or the factory supplied by your transformation context instead. */
-export const createIndexedAccessTypeNode = Debug.deprecate(factory.createIndexedAccessTypeNode, factoryDeprecation);
+export const createIndexedAccessTypeNode: typeof factory.createIndexedAccessTypeNode = Debug.deprecate(factory.createIndexedAccessTypeNode, factoryDeprecation);
 
 /** @deprecated Use `factory.updateIndexedAccessTypeNode` or the factory supplied by your transformation context instead. */
-export const updateIndexedAccessTypeNode = Debug.deprecate(factory.updateIndexedAccessTypeNode, factoryDeprecation);
+export const updateIndexedAccessTypeNode: typeof factory.updateIndexedAccessTypeNode = Debug.deprecate(factory.updateIndexedAccessTypeNode, factoryDeprecation);
 
 /** @deprecated Use `factory.createMappedTypeNode` or the factory supplied by your transformation context instead. */
-export const createMappedTypeNode = Debug.deprecate(factory.createMappedTypeNode, factoryDeprecation);
+export const createMappedTypeNode: typeof factory.createMappedTypeNode = Debug.deprecate(factory.createMappedTypeNode, factoryDeprecation);
 
 /** @deprecated Use `factory.updateMappedTypeNode` or the factory supplied by your transformation context instead. */
-export const updateMappedTypeNode = Debug.deprecate(factory.updateMappedTypeNode, factoryDeprecation);
+export const updateMappedTypeNode: typeof factory.updateMappedTypeNode = Debug.deprecate(factory.updateMappedTypeNode, factoryDeprecation);
 
 /** @deprecated Use `factory.createLiteralTypeNode` or the factory supplied by your transformation context instead. */
-export const createLiteralTypeNode = Debug.deprecate(factory.createLiteralTypeNode, factoryDeprecation);
+export const createLiteralTypeNode: typeof factory.createLiteralTypeNode = Debug.deprecate(factory.createLiteralTypeNode, factoryDeprecation);
 
 /** @deprecated Use `factory.updateLiteralTypeNode` or the factory supplied by your transformation context instead. */
-export const updateLiteralTypeNode = Debug.deprecate(factory.updateLiteralTypeNode, factoryDeprecation);
+export const updateLiteralTypeNode: typeof factory.updateLiteralTypeNode = Debug.deprecate(factory.updateLiteralTypeNode, factoryDeprecation);
 
 /** @deprecated Use `factory.createObjectBindingPattern` or the factory supplied by your transformation context instead. */
-export const createObjectBindingPattern = Debug.deprecate(factory.createObjectBindingPattern, factoryDeprecation);
+export const createObjectBindingPattern: typeof factory.createObjectBindingPattern = Debug.deprecate(factory.createObjectBindingPattern, factoryDeprecation);
 
 /** @deprecated Use `factory.updateObjectBindingPattern` or the factory supplied by your transformation context instead. */
-export const updateObjectBindingPattern = Debug.deprecate(factory.updateObjectBindingPattern, factoryDeprecation);
+export const updateObjectBindingPattern: typeof factory.updateObjectBindingPattern = Debug.deprecate(factory.updateObjectBindingPattern, factoryDeprecation);
 
 /** @deprecated Use `factory.createArrayBindingPattern` or the factory supplied by your transformation context instead. */
-export const createArrayBindingPattern = Debug.deprecate(factory.createArrayBindingPattern, factoryDeprecation);
+export const createArrayBindingPattern: typeof factory.createArrayBindingPattern = Debug.deprecate(factory.createArrayBindingPattern, factoryDeprecation);
 
 /** @deprecated Use `factory.updateArrayBindingPattern` or the factory supplied by your transformation context instead. */
-export const updateArrayBindingPattern = Debug.deprecate(factory.updateArrayBindingPattern, factoryDeprecation);
+export const updateArrayBindingPattern: typeof factory.updateArrayBindingPattern = Debug.deprecate(factory.updateArrayBindingPattern, factoryDeprecation);
 
 /** @deprecated Use `factory.createBindingElement` or the factory supplied by your transformation context instead. */
-export const createBindingElement = Debug.deprecate(factory.createBindingElement, factoryDeprecation);
+export const createBindingElement: typeof factory.createBindingElement = Debug.deprecate(factory.createBindingElement, factoryDeprecation);
 
 /** @deprecated Use `factory.updateBindingElement` or the factory supplied by your transformation context instead. */
-export const updateBindingElement = Debug.deprecate(factory.updateBindingElement, factoryDeprecation);
+export const updateBindingElement: typeof factory.updateBindingElement = Debug.deprecate(factory.updateBindingElement, factoryDeprecation);
 
 /** @deprecated Use `factory.createArrayLiteralExpression` or the factory supplied by your transformation context instead. */
-export const createArrayLiteral = Debug.deprecate(factory.createArrayLiteralExpression, factoryDeprecation);
+export const createArrayLiteral: typeof factory.createArrayLiteralExpression = Debug.deprecate(factory.createArrayLiteralExpression, factoryDeprecation);
 
 /** @deprecated Use `factory.updateArrayLiteralExpression` or the factory supplied by your transformation context instead. */
-export const updateArrayLiteral = Debug.deprecate(factory.updateArrayLiteralExpression, factoryDeprecation);
+export const updateArrayLiteral: typeof factory.updateArrayLiteralExpression = Debug.deprecate(factory.updateArrayLiteralExpression, factoryDeprecation);
 
 /** @deprecated Use `factory.createObjectLiteralExpression` or the factory supplied by your transformation context instead. */
-export const createObjectLiteral = Debug.deprecate(factory.createObjectLiteralExpression, factoryDeprecation);
+export const createObjectLiteral: typeof factory.createObjectLiteralExpression = Debug.deprecate(factory.createObjectLiteralExpression, factoryDeprecation);
 
 /** @deprecated Use `factory.updateObjectLiteralExpression` or the factory supplied by your transformation context instead. */
-export const updateObjectLiteral = Debug.deprecate(factory.updateObjectLiteralExpression, factoryDeprecation);
+export const updateObjectLiteral: typeof factory.updateObjectLiteralExpression = Debug.deprecate(factory.updateObjectLiteralExpression, factoryDeprecation);
 
 /** @deprecated Use `factory.createPropertyAccessExpression` or the factory supplied by your transformation context instead. */
-export const createPropertyAccess = Debug.deprecate(factory.createPropertyAccessExpression, factoryDeprecation);
+export const createPropertyAccess: typeof factory.createPropertyAccessExpression = Debug.deprecate(factory.createPropertyAccessExpression, factoryDeprecation);
 
 /** @deprecated Use `factory.updatePropertyAccessExpression` or the factory supplied by your transformation context instead. */
-export const updatePropertyAccess = Debug.deprecate(factory.updatePropertyAccessExpression, factoryDeprecation);
+export const updatePropertyAccess: typeof factory.updatePropertyAccessExpression = Debug.deprecate(factory.updatePropertyAccessExpression, factoryDeprecation);
 
 /** @deprecated Use `factory.createPropertyAccessChain` or the factory supplied by your transformation context instead. */
-export const createPropertyAccessChain = Debug.deprecate(factory.createPropertyAccessChain, factoryDeprecation);
+export const createPropertyAccessChain: typeof factory.createPropertyAccessChain = Debug.deprecate(factory.createPropertyAccessChain, factoryDeprecation);
 
 /** @deprecated Use `factory.updatePropertyAccessChain` or the factory supplied by your transformation context instead. */
-export const updatePropertyAccessChain = Debug.deprecate(factory.updatePropertyAccessChain, factoryDeprecation);
+export const updatePropertyAccessChain: typeof factory.updatePropertyAccessChain = Debug.deprecate(factory.updatePropertyAccessChain, factoryDeprecation);
 
 /** @deprecated Use `factory.createElementAccessExpression` or the factory supplied by your transformation context instead. */
-export const createElementAccess = Debug.deprecate(factory.createElementAccessExpression, factoryDeprecation);
+export const createElementAccess: typeof factory.createElementAccessExpression = Debug.deprecate(factory.createElementAccessExpression, factoryDeprecation);
 
 /** @deprecated Use `factory.updateElementAccessExpression` or the factory supplied by your transformation context instead. */
-export const updateElementAccess = Debug.deprecate(factory.updateElementAccessExpression, factoryDeprecation);
+export const updateElementAccess: typeof factory.updateElementAccessExpression = Debug.deprecate(factory.updateElementAccessExpression, factoryDeprecation);
 
 /** @deprecated Use `factory.createElementAccessChain` or the factory supplied by your transformation context instead. */
-export const createElementAccessChain = Debug.deprecate(factory.createElementAccessChain, factoryDeprecation);
+export const createElementAccessChain: typeof factory.createElementAccessChain = Debug.deprecate(factory.createElementAccessChain, factoryDeprecation);
 
 /** @deprecated Use `factory.updateElementAccessChain` or the factory supplied by your transformation context instead. */
-export const updateElementAccessChain = Debug.deprecate(factory.updateElementAccessChain, factoryDeprecation);
+export const updateElementAccessChain: typeof factory.updateElementAccessChain = Debug.deprecate(factory.updateElementAccessChain, factoryDeprecation);
 
 /** @deprecated Use `factory.createCallExpression` or the factory supplied by your transformation context instead. */
-export const createCall = Debug.deprecate(factory.createCallExpression, factoryDeprecation);
+export const createCall: typeof factory.createCallExpression = Debug.deprecate(factory.createCallExpression, factoryDeprecation);
 
 /** @deprecated Use `factory.updateCallExpression` or the factory supplied by your transformation context instead. */
-export const updateCall = Debug.deprecate(factory.updateCallExpression, factoryDeprecation);
+export const updateCall: typeof factory.updateCallExpression = Debug.deprecate(factory.updateCallExpression, factoryDeprecation);
 
 /** @deprecated Use `factory.createCallChain` or the factory supplied by your transformation context instead. */
-export const createCallChain = Debug.deprecate(factory.createCallChain, factoryDeprecation);
+export const createCallChain: typeof factory.createCallChain = Debug.deprecate(factory.createCallChain, factoryDeprecation);
 
 /** @deprecated Use `factory.updateCallChain` or the factory supplied by your transformation context instead. */
-export const updateCallChain = Debug.deprecate(factory.updateCallChain, factoryDeprecation);
+export const updateCallChain: typeof factory.updateCallChain = Debug.deprecate(factory.updateCallChain, factoryDeprecation);
 
 /** @deprecated Use `factory.createNewExpression` or the factory supplied by your transformation context instead. */
-export const createNew = Debug.deprecate(factory.createNewExpression, factoryDeprecation);
+export const createNew: typeof factory.createNewExpression = Debug.deprecate(factory.createNewExpression, factoryDeprecation);
 
 /** @deprecated Use `factory.updateNewExpression` or the factory supplied by your transformation context instead. */
-export const updateNew = Debug.deprecate(factory.updateNewExpression, factoryDeprecation);
+export const updateNew: typeof factory.updateNewExpression = Debug.deprecate(factory.updateNewExpression, factoryDeprecation);
 
 /** @deprecated Use `factory.createTypeAssertion` or the factory supplied by your transformation context instead. */
-export const createTypeAssertion = Debug.deprecate(factory.createTypeAssertion, factoryDeprecation);
+export const createTypeAssertion: typeof factory.createTypeAssertion = Debug.deprecate(factory.createTypeAssertion, factoryDeprecation);
 
 /** @deprecated Use `factory.updateTypeAssertion` or the factory supplied by your transformation context instead. */
-export const updateTypeAssertion = Debug.deprecate(factory.updateTypeAssertion, factoryDeprecation);
+export const updateTypeAssertion: typeof factory.updateTypeAssertion = Debug.deprecate(factory.updateTypeAssertion, factoryDeprecation);
 
 /** @deprecated Use `factory.createParenthesizedExpression` or the factory supplied by your transformation context instead. */
-export const createParen = Debug.deprecate(factory.createParenthesizedExpression, factoryDeprecation);
+export const createParen: typeof factory.createParenthesizedExpression = Debug.deprecate(factory.createParenthesizedExpression, factoryDeprecation);
 
 /** @deprecated Use `factory.updateParenthesizedExpression` or the factory supplied by your transformation context instead. */
-export const updateParen = Debug.deprecate(factory.updateParenthesizedExpression, factoryDeprecation);
+export const updateParen: typeof factory.updateParenthesizedExpression = Debug.deprecate(factory.updateParenthesizedExpression, factoryDeprecation);
 
 /** @deprecated Use `factory.createFunctionExpression` or the factory supplied by your transformation context instead. */
-export const createFunctionExpression = Debug.deprecate(factory.createFunctionExpression, factoryDeprecation);
+export const createFunctionExpression: typeof factory.createFunctionExpression = Debug.deprecate(factory.createFunctionExpression, factoryDeprecation);
 
 /** @deprecated Use `factory.updateFunctionExpression` or the factory supplied by your transformation context instead. */
-export const updateFunctionExpression = Debug.deprecate(factory.updateFunctionExpression, factoryDeprecation);
+export const updateFunctionExpression: typeof factory.updateFunctionExpression = Debug.deprecate(factory.updateFunctionExpression, factoryDeprecation);
 
 /** @deprecated Use `factory.createDeleteExpression` or the factory supplied by your transformation context instead. */
-export const createDelete = Debug.deprecate(factory.createDeleteExpression, factoryDeprecation);
+export const createDelete: typeof factory.createDeleteExpression = Debug.deprecate(factory.createDeleteExpression, factoryDeprecation);
 
 /** @deprecated Use `factory.updateDeleteExpression` or the factory supplied by your transformation context instead. */
-export const updateDelete = Debug.deprecate(factory.updateDeleteExpression, factoryDeprecation);
+export const updateDelete: typeof factory.updateDeleteExpression = Debug.deprecate(factory.updateDeleteExpression, factoryDeprecation);
 
 /** @deprecated Use `factory.createTypeOfExpression` or the factory supplied by your transformation context instead. */
-export const createTypeOf = Debug.deprecate(factory.createTypeOfExpression, factoryDeprecation);
+export const createTypeOf: typeof factory.createTypeOfExpression = Debug.deprecate(factory.createTypeOfExpression, factoryDeprecation);
 
 /** @deprecated Use `factory.updateTypeOfExpression` or the factory supplied by your transformation context instead. */
-export const updateTypeOf = Debug.deprecate(factory.updateTypeOfExpression, factoryDeprecation);
+export const updateTypeOf: typeof factory.updateTypeOfExpression = Debug.deprecate(factory.updateTypeOfExpression, factoryDeprecation);
 
 /** @deprecated Use `factory.createVoidExpression` or the factory supplied by your transformation context instead. */
-export const createVoid = Debug.deprecate(factory.createVoidExpression, factoryDeprecation);
+export const createVoid: typeof factory.createVoidExpression = Debug.deprecate(factory.createVoidExpression, factoryDeprecation);
 
 /** @deprecated Use `factory.updateVoidExpression` or the factory supplied by your transformation context instead. */
-export const updateVoid = Debug.deprecate(factory.updateVoidExpression, factoryDeprecation);
+export const updateVoid: typeof factory.updateVoidExpression = Debug.deprecate(factory.updateVoidExpression, factoryDeprecation);
 
 /** @deprecated Use `factory.createAwaitExpression` or the factory supplied by your transformation context instead. */
-export const createAwait = Debug.deprecate(factory.createAwaitExpression, factoryDeprecation);
+export const createAwait: typeof factory.createAwaitExpression = Debug.deprecate(factory.createAwaitExpression, factoryDeprecation);
 
 /** @deprecated Use `factory.updateAwaitExpression` or the factory supplied by your transformation context instead. */
-export const updateAwait = Debug.deprecate(factory.updateAwaitExpression, factoryDeprecation);
+export const updateAwait: typeof factory.updateAwaitExpression = Debug.deprecate(factory.updateAwaitExpression, factoryDeprecation);
 
 /** @deprecated Use `factory.createPrefixExpression` or the factory supplied by your transformation context instead. */
-export const createPrefix = Debug.deprecate(factory.createPrefixUnaryExpression, factoryDeprecation);
+export const createPrefix: typeof factory.createPrefixUnaryExpression = Debug.deprecate(factory.createPrefixUnaryExpression, factoryDeprecation);
 
 /** @deprecated Use `factory.updatePrefixExpression` or the factory supplied by your transformation context instead. */
-export const updatePrefix = Debug.deprecate(factory.updatePrefixUnaryExpression, factoryDeprecation);
+export const updatePrefix: typeof factory.updatePrefixUnaryExpression = Debug.deprecate(factory.updatePrefixUnaryExpression, factoryDeprecation);
 
 /** @deprecated Use `factory.createPostfixUnaryExpression` or the factory supplied by your transformation context instead. */
-export const createPostfix = Debug.deprecate(factory.createPostfixUnaryExpression, factoryDeprecation);
+export const createPostfix: typeof factory.createPostfixUnaryExpression = Debug.deprecate(factory.createPostfixUnaryExpression, factoryDeprecation);
 
 /** @deprecated Use `factory.updatePostfixUnaryExpression` or the factory supplied by your transformation context instead. */
-export const updatePostfix = Debug.deprecate(factory.updatePostfixUnaryExpression, factoryDeprecation);
+export const updatePostfix: typeof factory.updatePostfixUnaryExpression = Debug.deprecate(factory.updatePostfixUnaryExpression, factoryDeprecation);
 
 /** @deprecated Use `factory.createBinaryExpression` or the factory supplied by your transformation context instead. */
-export const createBinary = Debug.deprecate(factory.createBinaryExpression, factoryDeprecation);
+export const createBinary: typeof factory.createBinaryExpression = Debug.deprecate(factory.createBinaryExpression, factoryDeprecation);
 
 /** @deprecated Use `factory.updateConditionalExpression` or the factory supplied by your transformation context instead. */
-export const updateConditional = Debug.deprecate(factory.updateConditionalExpression, factoryDeprecation);
+export const updateConditional: typeof factory.updateConditionalExpression = Debug.deprecate(factory.updateConditionalExpression, factoryDeprecation);
 
 /** @deprecated Use `factory.createTemplateExpression` or the factory supplied by your transformation context instead. */
-export const createTemplateExpression = Debug.deprecate(factory.createTemplateExpression, factoryDeprecation);
+export const createTemplateExpression: typeof factory.createTemplateExpression = Debug.deprecate(factory.createTemplateExpression, factoryDeprecation);
 
 /** @deprecated Use `factory.updateTemplateExpression` or the factory supplied by your transformation context instead. */
-export const updateTemplateExpression = Debug.deprecate(factory.updateTemplateExpression, factoryDeprecation);
+export const updateTemplateExpression: typeof factory.updateTemplateExpression = Debug.deprecate(factory.updateTemplateExpression, factoryDeprecation);
 
 /** @deprecated Use `factory.createTemplateHead` or the factory supplied by your transformation context instead. */
-export const createTemplateHead = Debug.deprecate(factory.createTemplateHead, factoryDeprecation);
+export const createTemplateHead: typeof factory.createTemplateHead = Debug.deprecate(factory.createTemplateHead, factoryDeprecation);
 
 /** @deprecated Use `factory.createTemplateMiddle` or the factory supplied by your transformation context instead. */
-export const createTemplateMiddle = Debug.deprecate(factory.createTemplateMiddle, factoryDeprecation);
+export const createTemplateMiddle: typeof factory.createTemplateMiddle = Debug.deprecate(factory.createTemplateMiddle, factoryDeprecation);
 
 /** @deprecated Use `factory.createTemplateTail` or the factory supplied by your transformation context instead. */
-export const createTemplateTail = Debug.deprecate(factory.createTemplateTail, factoryDeprecation);
+export const createTemplateTail: typeof factory.createTemplateTail = Debug.deprecate(factory.createTemplateTail, factoryDeprecation);
 
 /** @deprecated Use `factory.createNoSubstitutionTemplateLiteral` or the factory supplied by your transformation context instead. */
-export const createNoSubstitutionTemplateLiteral = Debug.deprecate(factory.createNoSubstitutionTemplateLiteral, factoryDeprecation);
+export const createNoSubstitutionTemplateLiteral: typeof factory.createNoSubstitutionTemplateLiteral = Debug.deprecate(factory.createNoSubstitutionTemplateLiteral, factoryDeprecation);
 
 /** @deprecated Use `factory.updateYieldExpression` or the factory supplied by your transformation context instead. */
-export const updateYield = Debug.deprecate(factory.updateYieldExpression, factoryDeprecation);
+export const updateYield: typeof factory.updateYieldExpression = Debug.deprecate(factory.updateYieldExpression, factoryDeprecation);
 
 /** @deprecated Use `factory.createSpreadExpression` or the factory supplied by your transformation context instead. */
-export const createSpread = Debug.deprecate(factory.createSpreadElement, factoryDeprecation);
+export const createSpread: typeof factory.createSpreadElement = Debug.deprecate(factory.createSpreadElement, factoryDeprecation);
 
 /** @deprecated Use `factory.updateSpreadExpression` or the factory supplied by your transformation context instead. */
-export const updateSpread = Debug.deprecate(factory.updateSpreadElement, factoryDeprecation);
+export const updateSpread: typeof factory.updateSpreadElement = Debug.deprecate(factory.updateSpreadElement, factoryDeprecation);
 
 /** @deprecated Use `factory.createOmittedExpression` or the factory supplied by your transformation context instead. */
-export const createOmittedExpression = Debug.deprecate(factory.createOmittedExpression, factoryDeprecation);
+export const createOmittedExpression: typeof factory.createOmittedExpression = Debug.deprecate(factory.createOmittedExpression, factoryDeprecation);
 
 /** @deprecated Use `factory.createAsExpression` or the factory supplied by your transformation context instead. */
-export const createAsExpression = Debug.deprecate(factory.createAsExpression, factoryDeprecation);
+export const createAsExpression: typeof factory.createAsExpression = Debug.deprecate(factory.createAsExpression, factoryDeprecation);
 
 /** @deprecated Use `factory.updateAsExpression` or the factory supplied by your transformation context instead. */
-export const updateAsExpression = Debug.deprecate(factory.updateAsExpression, factoryDeprecation);
+export const updateAsExpression: typeof factory.updateAsExpression = Debug.deprecate(factory.updateAsExpression, factoryDeprecation);
 
 /** @deprecated Use `factory.createNonNullExpression` or the factory supplied by your transformation context instead. */
-export const createNonNullExpression = Debug.deprecate(factory.createNonNullExpression, factoryDeprecation);
+export const createNonNullExpression: typeof factory.createNonNullExpression = Debug.deprecate(factory.createNonNullExpression, factoryDeprecation);
 
 /** @deprecated Use `factory.updateNonNullExpression` or the factory supplied by your transformation context instead. */
-export const updateNonNullExpression = Debug.deprecate(factory.updateNonNullExpression, factoryDeprecation);
+export const updateNonNullExpression: typeof factory.updateNonNullExpression = Debug.deprecate(factory.updateNonNullExpression, factoryDeprecation);
 
 /** @deprecated Use `factory.createNonNullChain` or the factory supplied by your transformation context instead. */
-export const createNonNullChain = Debug.deprecate(factory.createNonNullChain, factoryDeprecation);
+export const createNonNullChain: typeof factory.createNonNullChain = Debug.deprecate(factory.createNonNullChain, factoryDeprecation);
 
 /** @deprecated Use `factory.updateNonNullChain` or the factory supplied by your transformation context instead. */
-export const updateNonNullChain = Debug.deprecate(factory.updateNonNullChain, factoryDeprecation);
+export const updateNonNullChain: typeof factory.updateNonNullChain = Debug.deprecate(factory.updateNonNullChain, factoryDeprecation);
 
 /** @deprecated Use `factory.createMetaProperty` or the factory supplied by your transformation context instead. */
-export const createMetaProperty = Debug.deprecate(factory.createMetaProperty, factoryDeprecation);
+export const createMetaProperty: typeof factory.createMetaProperty = Debug.deprecate(factory.createMetaProperty, factoryDeprecation);
 
 /** @deprecated Use `factory.updateMetaProperty` or the factory supplied by your transformation context instead. */
-export const updateMetaProperty = Debug.deprecate(factory.updateMetaProperty, factoryDeprecation);
+export const updateMetaProperty: typeof factory.updateMetaProperty = Debug.deprecate(factory.updateMetaProperty, factoryDeprecation);
 
 /** @deprecated Use `factory.createTemplateSpan` or the factory supplied by your transformation context instead. */
-export const createTemplateSpan = Debug.deprecate(factory.createTemplateSpan, factoryDeprecation);
+export const createTemplateSpan: typeof factory.createTemplateSpan = Debug.deprecate(factory.createTemplateSpan, factoryDeprecation);
 
 /** @deprecated Use `factory.updateTemplateSpan` or the factory supplied by your transformation context instead. */
-export const updateTemplateSpan = Debug.deprecate(factory.updateTemplateSpan, factoryDeprecation);
+export const updateTemplateSpan: typeof factory.updateTemplateSpan = Debug.deprecate(factory.updateTemplateSpan, factoryDeprecation);
 
 /** @deprecated Use `factory.createSemicolonClassElement` or the factory supplied by your transformation context instead. */
-export const createSemicolonClassElement = Debug.deprecate(factory.createSemicolonClassElement, factoryDeprecation);
+export const createSemicolonClassElement: typeof factory.createSemicolonClassElement = Debug.deprecate(factory.createSemicolonClassElement, factoryDeprecation);
 
 /** @deprecated Use `factory.createBlock` or the factory supplied by your transformation context instead. */
-export const createBlock = Debug.deprecate(factory.createBlock, factoryDeprecation);
+export const createBlock: typeof factory.createBlock = Debug.deprecate(factory.createBlock, factoryDeprecation);
 
 /** @deprecated Use `factory.updateBlock` or the factory supplied by your transformation context instead. */
-export const updateBlock = Debug.deprecate(factory.updateBlock, factoryDeprecation);
+export const updateBlock: typeof factory.updateBlock = Debug.deprecate(factory.updateBlock, factoryDeprecation);
 
 /** @deprecated Use `factory.createVariableStatement` or the factory supplied by your transformation context instead. */
-export const createVariableStatement = Debug.deprecate(factory.createVariableStatement, factoryDeprecation);
+export const createVariableStatement: typeof factory.createVariableStatement = Debug.deprecate(factory.createVariableStatement, factoryDeprecation);
 
 /** @deprecated Use `factory.updateVariableStatement` or the factory supplied by your transformation context instead. */
-export const updateVariableStatement = Debug.deprecate(factory.updateVariableStatement, factoryDeprecation);
+export const updateVariableStatement: typeof factory.updateVariableStatement = Debug.deprecate(factory.updateVariableStatement, factoryDeprecation);
 
 /** @deprecated Use `factory.createEmptyStatement` or the factory supplied by your transformation context instead. */
-export const createEmptyStatement = Debug.deprecate(factory.createEmptyStatement, factoryDeprecation);
+export const createEmptyStatement: typeof factory.createEmptyStatement = Debug.deprecate(factory.createEmptyStatement, factoryDeprecation);
 
 /** @deprecated Use `factory.createExpressionStatement` or the factory supplied by your transformation context instead. */
-export const createExpressionStatement = Debug.deprecate(factory.createExpressionStatement, factoryDeprecation);
+export const createExpressionStatement: typeof factory.createExpressionStatement = Debug.deprecate(factory.createExpressionStatement, factoryDeprecation);
 
 /** @deprecated Use `factory.updateExpressionStatement` or the factory supplied by your transformation context instead. */
-export const updateExpressionStatement = Debug.deprecate(factory.updateExpressionStatement, factoryDeprecation);
+export const updateExpressionStatement: typeof factory.updateExpressionStatement = Debug.deprecate(factory.updateExpressionStatement, factoryDeprecation);
 
 /** @deprecated Use `factory.createExpressionStatement` or the factory supplied by your transformation context instead. */
-export const createStatement = Debug.deprecate(factory.createExpressionStatement, factoryDeprecation);
+export const createStatement: typeof factory.createExpressionStatement = Debug.deprecate(factory.createExpressionStatement, factoryDeprecation);
 
 /** @deprecated Use `factory.updateExpressionStatement` or the factory supplied by your transformation context instead. */
-export const updateStatement = Debug.deprecate(factory.updateExpressionStatement, factoryDeprecation);
+export const updateStatement: typeof factory.updateExpressionStatement = Debug.deprecate(factory.updateExpressionStatement, factoryDeprecation);
 
 /** @deprecated Use `factory.createIfStatement` or the factory supplied by your transformation context instead. */
-export const createIf = Debug.deprecate(factory.createIfStatement, factoryDeprecation);
+export const createIf: typeof factory.createIfStatement = Debug.deprecate(factory.createIfStatement, factoryDeprecation);
 
 /** @deprecated Use `factory.updateIfStatement` or the factory supplied by your transformation context instead. */
-export const updateIf = Debug.deprecate(factory.updateIfStatement, factoryDeprecation);
+export const updateIf: typeof factory.updateIfStatement = Debug.deprecate(factory.updateIfStatement, factoryDeprecation);
 
 /** @deprecated Use `factory.createDoStatement` or the factory supplied by your transformation context instead. */
-export const createDo = Debug.deprecate(factory.createDoStatement, factoryDeprecation);
+export const createDo: typeof factory.createDoStatement = Debug.deprecate(factory.createDoStatement, factoryDeprecation);
 
 /** @deprecated Use `factory.updateDoStatement` or the factory supplied by your transformation context instead. */
-export const updateDo = Debug.deprecate(factory.updateDoStatement, factoryDeprecation);
+export const updateDo: typeof factory.updateDoStatement = Debug.deprecate(factory.updateDoStatement, factoryDeprecation);
 
 /** @deprecated Use `factory.createWhileStatement` or the factory supplied by your transformation context instead. */
-export const createWhile = Debug.deprecate(factory.createWhileStatement, factoryDeprecation);
+export const createWhile: typeof factory.createWhileStatement = Debug.deprecate(factory.createWhileStatement, factoryDeprecation);
 
 /** @deprecated Use `factory.updateWhileStatement` or the factory supplied by your transformation context instead. */
-export const updateWhile = Debug.deprecate(factory.updateWhileStatement, factoryDeprecation);
+export const updateWhile: typeof factory.updateWhileStatement = Debug.deprecate(factory.updateWhileStatement, factoryDeprecation);
 
 /** @deprecated Use `factory.createForStatement` or the factory supplied by your transformation context instead. */
-export const createFor = Debug.deprecate(factory.createForStatement, factoryDeprecation);
+export const createFor: typeof factory.createForStatement = Debug.deprecate(factory.createForStatement, factoryDeprecation);
 
 /** @deprecated Use `factory.updateForStatement` or the factory supplied by your transformation context instead. */
-export const updateFor = Debug.deprecate(factory.updateForStatement, factoryDeprecation);
+export const updateFor: typeof factory.updateForStatement = Debug.deprecate(factory.updateForStatement, factoryDeprecation);
 
 /** @deprecated Use `factory.createForInStatement` or the factory supplied by your transformation context instead. */
-export const createForIn = Debug.deprecate(factory.createForInStatement, factoryDeprecation);
+export const createForIn: typeof factory.createForInStatement = Debug.deprecate(factory.createForInStatement, factoryDeprecation);
 
 /** @deprecated Use `factory.updateForInStatement` or the factory supplied by your transformation context instead. */
-export const updateForIn = Debug.deprecate(factory.updateForInStatement, factoryDeprecation);
+export const updateForIn: typeof factory.updateForInStatement = Debug.deprecate(factory.updateForInStatement, factoryDeprecation);
 
 /** @deprecated Use `factory.createForOfStatement` or the factory supplied by your transformation context instead. */
-export const createForOf = Debug.deprecate(factory.createForOfStatement, factoryDeprecation);
+export const createForOf: typeof factory.createForOfStatement = Debug.deprecate(factory.createForOfStatement, factoryDeprecation);
 
 /** @deprecated Use `factory.updateForOfStatement` or the factory supplied by your transformation context instead. */
-export const updateForOf = Debug.deprecate(factory.updateForOfStatement, factoryDeprecation);
+export const updateForOf: typeof factory.updateForOfStatement = Debug.deprecate(factory.updateForOfStatement, factoryDeprecation);
 
 /** @deprecated Use `factory.createContinueStatement` or the factory supplied by your transformation context instead. */
-export const createContinue = Debug.deprecate(factory.createContinueStatement, factoryDeprecation);
+export const createContinue: typeof factory.createContinueStatement = Debug.deprecate(factory.createContinueStatement, factoryDeprecation);
 
 /** @deprecated Use `factory.updateContinueStatement` or the factory supplied by your transformation context instead. */
-export const updateContinue = Debug.deprecate(factory.updateContinueStatement, factoryDeprecation);
+export const updateContinue: typeof factory.updateContinueStatement = Debug.deprecate(factory.updateContinueStatement, factoryDeprecation);
 
 /** @deprecated Use `factory.createBreakStatement` or the factory supplied by your transformation context instead. */
-export const createBreak = Debug.deprecate(factory.createBreakStatement, factoryDeprecation);
+export const createBreak: typeof factory.createBreakStatement = Debug.deprecate(factory.createBreakStatement, factoryDeprecation);
 
 /** @deprecated Use `factory.updateBreakStatement` or the factory supplied by your transformation context instead. */
-export const updateBreak = Debug.deprecate(factory.updateBreakStatement, factoryDeprecation);
+export const updateBreak: typeof factory.updateBreakStatement = Debug.deprecate(factory.updateBreakStatement, factoryDeprecation);
 
 /** @deprecated Use `factory.createReturnStatement` or the factory supplied by your transformation context instead. */
-export const createReturn = Debug.deprecate(factory.createReturnStatement, factoryDeprecation);
+export const createReturn: typeof factory.createReturnStatement = Debug.deprecate(factory.createReturnStatement, factoryDeprecation);
 
 /** @deprecated Use `factory.updateReturnStatement` or the factory supplied by your transformation context instead. */
-export const updateReturn = Debug.deprecate(factory.updateReturnStatement, factoryDeprecation);
+export const updateReturn: typeof factory.updateReturnStatement = Debug.deprecate(factory.updateReturnStatement, factoryDeprecation);
 
 /** @deprecated Use `factory.createWithStatement` or the factory supplied by your transformation context instead. */
-export const createWith = Debug.deprecate(factory.createWithStatement, factoryDeprecation);
+export const createWith: typeof factory.createWithStatement = Debug.deprecate(factory.createWithStatement, factoryDeprecation);
 
 /** @deprecated Use `factory.updateWithStatement` or the factory supplied by your transformation context instead. */
-export const updateWith = Debug.deprecate(factory.updateWithStatement, factoryDeprecation);
+export const updateWith: typeof factory.updateWithStatement = Debug.deprecate(factory.updateWithStatement, factoryDeprecation);
 
 /** @deprecated Use `factory.createSwitchStatement` or the factory supplied by your transformation context instead. */
-export const createSwitch = Debug.deprecate(factory.createSwitchStatement, factoryDeprecation);
+export const createSwitch: typeof factory.createSwitchStatement = Debug.deprecate(factory.createSwitchStatement, factoryDeprecation);
 
 /** @deprecated Use `factory.updateSwitchStatement` or the factory supplied by your transformation context instead. */
-export const updateSwitch = Debug.deprecate(factory.updateSwitchStatement, factoryDeprecation);
+export const updateSwitch: typeof factory.updateSwitchStatement = Debug.deprecate(factory.updateSwitchStatement, factoryDeprecation);
 
 /** @deprecated Use `factory.createLabelStatement` or the factory supplied by your transformation context instead. */
-export const createLabel = Debug.deprecate(factory.createLabeledStatement, factoryDeprecation);
+export const createLabel: typeof factory.createLabeledStatement = Debug.deprecate(factory.createLabeledStatement, factoryDeprecation);
 
 /** @deprecated Use `factory.updateLabelStatement` or the factory supplied by your transformation context instead. */
-export const updateLabel = Debug.deprecate(factory.updateLabeledStatement, factoryDeprecation);
+export const updateLabel: typeof factory.updateLabeledStatement = Debug.deprecate(factory.updateLabeledStatement, factoryDeprecation);
 
 /** @deprecated Use `factory.createThrowStatement` or the factory supplied by your transformation context instead. */
-export const createThrow = Debug.deprecate(factory.createThrowStatement, factoryDeprecation);
+export const createThrow: typeof factory.createThrowStatement = Debug.deprecate(factory.createThrowStatement, factoryDeprecation);
 
 /** @deprecated Use `factory.updateThrowStatement` or the factory supplied by your transformation context instead. */
-export const updateThrow = Debug.deprecate(factory.updateThrowStatement, factoryDeprecation);
+export const updateThrow: typeof factory.updateThrowStatement = Debug.deprecate(factory.updateThrowStatement, factoryDeprecation);
 
 /** @deprecated Use `factory.createTryStatement` or the factory supplied by your transformation context instead. */
-export const createTry = Debug.deprecate(factory.createTryStatement, factoryDeprecation);
+export const createTry: typeof factory.createTryStatement = Debug.deprecate(factory.createTryStatement, factoryDeprecation);
 
 /** @deprecated Use `factory.updateTryStatement` or the factory supplied by your transformation context instead. */
-export const updateTry = Debug.deprecate(factory.updateTryStatement, factoryDeprecation);
+export const updateTry: typeof factory.updateTryStatement = Debug.deprecate(factory.updateTryStatement, factoryDeprecation);
 
 /** @deprecated Use `factory.createDebuggerStatement` or the factory supplied by your transformation context instead. */
-export const createDebuggerStatement = Debug.deprecate(factory.createDebuggerStatement, factoryDeprecation);
+export const createDebuggerStatement: typeof factory.createDebuggerStatement = Debug.deprecate(factory.createDebuggerStatement, factoryDeprecation);
 
 /** @deprecated Use `factory.createVariableDeclarationList` or the factory supplied by your transformation context instead. */
-export const createVariableDeclarationList = Debug.deprecate(factory.createVariableDeclarationList, factoryDeprecation);
+export const createVariableDeclarationList: typeof factory.createVariableDeclarationList = Debug.deprecate(factory.createVariableDeclarationList, factoryDeprecation);
 
 /** @deprecated Use `factory.updateVariableDeclarationList` or the factory supplied by your transformation context instead. */
-export const updateVariableDeclarationList = Debug.deprecate(factory.updateVariableDeclarationList, factoryDeprecation);
+export const updateVariableDeclarationList: typeof factory.updateVariableDeclarationList = Debug.deprecate(factory.updateVariableDeclarationList, factoryDeprecation);
 
 /** @deprecated Use `factory.createFunctionDeclaration` or the factory supplied by your transformation context instead. */
-export const createFunctionDeclaration = Debug.deprecate(factory.createFunctionDeclaration, factoryDeprecation);
+export const createFunctionDeclaration: typeof factory.createFunctionDeclaration = Debug.deprecate(factory.createFunctionDeclaration, factoryDeprecation);
 
 /** @deprecated Use `factory.updateFunctionDeclaration` or the factory supplied by your transformation context instead. */
-export const updateFunctionDeclaration = Debug.deprecate(factory.updateFunctionDeclaration, factoryDeprecation);
+export const updateFunctionDeclaration: typeof factory.updateFunctionDeclaration = Debug.deprecate(factory.updateFunctionDeclaration, factoryDeprecation);
 
 /** @deprecated Use `factory.createClassDeclaration` or the factory supplied by your transformation context instead. */
-export const createClassDeclaration = Debug.deprecate(factory.createClassDeclaration, factoryDeprecation);
+export const createClassDeclaration: typeof factory.createClassDeclaration = Debug.deprecate(factory.createClassDeclaration, factoryDeprecation);
 
 /** @deprecated Use `factory.updateClassDeclaration` or the factory supplied by your transformation context instead. */
-export const updateClassDeclaration = Debug.deprecate(factory.updateClassDeclaration, factoryDeprecation);
+export const updateClassDeclaration: typeof factory.updateClassDeclaration = Debug.deprecate(factory.updateClassDeclaration, factoryDeprecation);
 
 /** @deprecated Use `factory.createInterfaceDeclaration` or the factory supplied by your transformation context instead. */
-export const createInterfaceDeclaration = Debug.deprecate(factory.createInterfaceDeclaration, factoryDeprecation);
+export const createInterfaceDeclaration: typeof factory.createInterfaceDeclaration = Debug.deprecate(factory.createInterfaceDeclaration, factoryDeprecation);
 
 /** @deprecated Use `factory.updateInterfaceDeclaration` or the factory supplied by your transformation context instead. */
-export const updateInterfaceDeclaration = Debug.deprecate(factory.updateInterfaceDeclaration, factoryDeprecation);
+export const updateInterfaceDeclaration: typeof factory.updateInterfaceDeclaration = Debug.deprecate(factory.updateInterfaceDeclaration, factoryDeprecation);
 
 /** @deprecated Use `factory.createTypeAliasDeclaration` or the factory supplied by your transformation context instead. */
-export const createTypeAliasDeclaration = Debug.deprecate(factory.createTypeAliasDeclaration, factoryDeprecation);
+export const createTypeAliasDeclaration: typeof factory.createTypeAliasDeclaration = Debug.deprecate(factory.createTypeAliasDeclaration, factoryDeprecation);
 
 /** @deprecated Use `factory.updateTypeAliasDeclaration` or the factory supplied by your transformation context instead. */
-export const updateTypeAliasDeclaration = Debug.deprecate(factory.updateTypeAliasDeclaration, factoryDeprecation);
+export const updateTypeAliasDeclaration: typeof factory.updateTypeAliasDeclaration = Debug.deprecate(factory.updateTypeAliasDeclaration, factoryDeprecation);
 
 /** @deprecated Use `factory.createEnumDeclaration` or the factory supplied by your transformation context instead. */
-export const createEnumDeclaration = Debug.deprecate(factory.createEnumDeclaration, factoryDeprecation);
+export const createEnumDeclaration: typeof factory.createEnumDeclaration = Debug.deprecate(factory.createEnumDeclaration, factoryDeprecation);
 
 /** @deprecated Use `factory.updateEnumDeclaration` or the factory supplied by your transformation context instead. */
-export const updateEnumDeclaration = Debug.deprecate(factory.updateEnumDeclaration, factoryDeprecation);
+export const updateEnumDeclaration: typeof factory.updateEnumDeclaration = Debug.deprecate(factory.updateEnumDeclaration, factoryDeprecation);
 
 /** @deprecated Use `factory.createModuleDeclaration` or the factory supplied by your transformation context instead. */
-export const createModuleDeclaration = Debug.deprecate(factory.createModuleDeclaration, factoryDeprecation);
+export const createModuleDeclaration: typeof factory.createModuleDeclaration = Debug.deprecate(factory.createModuleDeclaration, factoryDeprecation);
 
 /** @deprecated Use `factory.updateModuleDeclaration` or the factory supplied by your transformation context instead. */
-export const updateModuleDeclaration = Debug.deprecate(factory.updateModuleDeclaration, factoryDeprecation);
+export const updateModuleDeclaration: typeof factory.updateModuleDeclaration = Debug.deprecate(factory.updateModuleDeclaration, factoryDeprecation);
 
 /** @deprecated Use `factory.createModuleBlock` or the factory supplied by your transformation context instead. */
-export const createModuleBlock = Debug.deprecate(factory.createModuleBlock, factoryDeprecation);
+export const createModuleBlock: typeof factory.createModuleBlock = Debug.deprecate(factory.createModuleBlock, factoryDeprecation);
 
 /** @deprecated Use `factory.updateModuleBlock` or the factory supplied by your transformation context instead. */
-export const updateModuleBlock = Debug.deprecate(factory.updateModuleBlock, factoryDeprecation);
+export const updateModuleBlock: typeof factory.updateModuleBlock = Debug.deprecate(factory.updateModuleBlock, factoryDeprecation);
 
 /** @deprecated Use `factory.createCaseBlock` or the factory supplied by your transformation context instead. */
-export const createCaseBlock = Debug.deprecate(factory.createCaseBlock, factoryDeprecation);
+export const createCaseBlock: typeof factory.createCaseBlock = Debug.deprecate(factory.createCaseBlock, factoryDeprecation);
 
 /** @deprecated Use `factory.updateCaseBlock` or the factory supplied by your transformation context instead. */
-export const updateCaseBlock = Debug.deprecate(factory.updateCaseBlock, factoryDeprecation);
+export const updateCaseBlock: typeof factory.updateCaseBlock = Debug.deprecate(factory.updateCaseBlock, factoryDeprecation);
 
 /** @deprecated Use `factory.createNamespaceExportDeclaration` or the factory supplied by your transformation context instead. */
-export const createNamespaceExportDeclaration = Debug.deprecate(factory.createNamespaceExportDeclaration, factoryDeprecation);
+export const createNamespaceExportDeclaration: typeof factory.createNamespaceExportDeclaration = Debug.deprecate(factory.createNamespaceExportDeclaration, factoryDeprecation);
 
 /** @deprecated Use `factory.updateNamespaceExportDeclaration` or the factory supplied by your transformation context instead. */
-export const updateNamespaceExportDeclaration = Debug.deprecate(factory.updateNamespaceExportDeclaration, factoryDeprecation);
+export const updateNamespaceExportDeclaration: typeof factory.updateNamespaceExportDeclaration = Debug.deprecate(factory.updateNamespaceExportDeclaration, factoryDeprecation);
 
 /** @deprecated Use `factory.createImportEqualsDeclaration` or the factory supplied by your transformation context instead. */
-export const createImportEqualsDeclaration = Debug.deprecate(factory.createImportEqualsDeclaration, factoryDeprecation);
+export const createImportEqualsDeclaration: typeof factory.createImportEqualsDeclaration = Debug.deprecate(factory.createImportEqualsDeclaration, factoryDeprecation);
 
 /** @deprecated Use `factory.updateImportEqualsDeclaration` or the factory supplied by your transformation context instead. */
-export const updateImportEqualsDeclaration = Debug.deprecate(factory.updateImportEqualsDeclaration, factoryDeprecation);
+export const updateImportEqualsDeclaration: typeof factory.updateImportEqualsDeclaration = Debug.deprecate(factory.updateImportEqualsDeclaration, factoryDeprecation);
 
 /** @deprecated Use `factory.createImportDeclaration` or the factory supplied by your transformation context instead. */
-export const createImportDeclaration = Debug.deprecate(factory.createImportDeclaration, factoryDeprecation);
+export const createImportDeclaration: typeof factory.createImportDeclaration = Debug.deprecate(factory.createImportDeclaration, factoryDeprecation);
 
 /** @deprecated Use `factory.updateImportDeclaration` or the factory supplied by your transformation context instead. */
-export const updateImportDeclaration = Debug.deprecate(factory.updateImportDeclaration, factoryDeprecation);
+export const updateImportDeclaration: typeof factory.updateImportDeclaration = Debug.deprecate(factory.updateImportDeclaration, factoryDeprecation);
 
 /** @deprecated Use `factory.createNamespaceImport` or the factory supplied by your transformation context instead. */
-export const createNamespaceImport = Debug.deprecate(factory.createNamespaceImport, factoryDeprecation);
+export const createNamespaceImport: typeof factory.createNamespaceImport = Debug.deprecate(factory.createNamespaceImport, factoryDeprecation);
 
 /** @deprecated Use `factory.updateNamespaceImport` or the factory supplied by your transformation context instead. */
-export const updateNamespaceImport = Debug.deprecate(factory.updateNamespaceImport, factoryDeprecation);
+export const updateNamespaceImport: typeof factory.updateNamespaceImport = Debug.deprecate(factory.updateNamespaceImport, factoryDeprecation);
 
 /** @deprecated Use `factory.createNamedImports` or the factory supplied by your transformation context instead. */
-export const createNamedImports = Debug.deprecate(factory.createNamedImports, factoryDeprecation);
+export const createNamedImports: typeof factory.createNamedImports = Debug.deprecate(factory.createNamedImports, factoryDeprecation);
 
 /** @deprecated Use `factory.updateNamedImports` or the factory supplied by your transformation context instead. */
-export const updateNamedImports = Debug.deprecate(factory.updateNamedImports, factoryDeprecation);
+export const updateNamedImports: typeof factory.updateNamedImports = Debug.deprecate(factory.updateNamedImports, factoryDeprecation);
 
 /** @deprecated Use `factory.createImportSpecifier` or the factory supplied by your transformation context instead. */
-export const createImportSpecifier = Debug.deprecate(factory.createImportSpecifier, factoryDeprecation);
+export const createImportSpecifier: typeof factory.createImportSpecifier = Debug.deprecate(factory.createImportSpecifier, factoryDeprecation);
 
 /** @deprecated Use `factory.updateImportSpecifier` or the factory supplied by your transformation context instead. */
-export const updateImportSpecifier = Debug.deprecate(factory.updateImportSpecifier, factoryDeprecation);
+export const updateImportSpecifier: typeof factory.updateImportSpecifier = Debug.deprecate(factory.updateImportSpecifier, factoryDeprecation);
 
 /** @deprecated Use `factory.createExportAssignment` or the factory supplied by your transformation context instead. */
-export const createExportAssignment = Debug.deprecate(factory.createExportAssignment, factoryDeprecation);
+export const createExportAssignment: typeof factory.createExportAssignment = Debug.deprecate(factory.createExportAssignment, factoryDeprecation);
 
 /** @deprecated Use `factory.updateExportAssignment` or the factory supplied by your transformation context instead. */
-export const updateExportAssignment = Debug.deprecate(factory.updateExportAssignment, factoryDeprecation);
+export const updateExportAssignment: typeof factory.updateExportAssignment = Debug.deprecate(factory.updateExportAssignment, factoryDeprecation);
 
 /** @deprecated Use `factory.createNamedExports` or the factory supplied by your transformation context instead. */
-export const createNamedExports = Debug.deprecate(factory.createNamedExports, factoryDeprecation);
+export const createNamedExports: typeof factory.createNamedExports = Debug.deprecate(factory.createNamedExports, factoryDeprecation);
 
 /** @deprecated Use `factory.updateNamedExports` or the factory supplied by your transformation context instead. */
-export const updateNamedExports = Debug.deprecate(factory.updateNamedExports, factoryDeprecation);
+export const updateNamedExports: typeof factory.updateNamedExports = Debug.deprecate(factory.updateNamedExports, factoryDeprecation);
 
 /** @deprecated Use `factory.createExportSpecifier` or the factory supplied by your transformation context instead. */
-export const createExportSpecifier = Debug.deprecate(factory.createExportSpecifier, factoryDeprecation);
+export const createExportSpecifier: typeof factory.createExportSpecifier = Debug.deprecate(factory.createExportSpecifier, factoryDeprecation);
 
 /** @deprecated Use `factory.updateExportSpecifier` or the factory supplied by your transformation context instead. */
-export const updateExportSpecifier = Debug.deprecate(factory.updateExportSpecifier, factoryDeprecation);
+export const updateExportSpecifier: typeof factory.updateExportSpecifier = Debug.deprecate(factory.updateExportSpecifier, factoryDeprecation);
 
 /** @deprecated Use `factory.createExternalModuleReference` or the factory supplied by your transformation context instead. */
-export const createExternalModuleReference = Debug.deprecate(factory.createExternalModuleReference, factoryDeprecation);
+export const createExternalModuleReference: typeof factory.createExternalModuleReference = Debug.deprecate(factory.createExternalModuleReference, factoryDeprecation);
 
 /** @deprecated Use `factory.updateExternalModuleReference` or the factory supplied by your transformation context instead. */
-export const updateExternalModuleReference = Debug.deprecate(factory.updateExternalModuleReference, factoryDeprecation);
+export const updateExternalModuleReference: typeof factory.updateExternalModuleReference = Debug.deprecate(factory.updateExternalModuleReference, factoryDeprecation);
 
 /** @deprecated Use `factory.createJSDocTypeExpression` or the factory supplied by your transformation context instead. */
-export const createJSDocTypeExpression = Debug.deprecate(factory.createJSDocTypeExpression, factoryDeprecation);
+export const createJSDocTypeExpression: typeof factory.createJSDocTypeExpression = Debug.deprecate(factory.createJSDocTypeExpression, factoryDeprecation);
 
 /** @deprecated Use `factory.createJSDocTypeTag` or the factory supplied by your transformation context instead. */
-export const createJSDocTypeTag = Debug.deprecate(factory.createJSDocTypeTag, factoryDeprecation);
+export const createJSDocTypeTag: typeof factory.createJSDocTypeTag = Debug.deprecate(factory.createJSDocTypeTag, factoryDeprecation);
 
 /** @deprecated Use `factory.createJSDocReturnTag` or the factory supplied by your transformation context instead. */
-export const createJSDocReturnTag = Debug.deprecate(factory.createJSDocReturnTag, factoryDeprecation);
+export const createJSDocReturnTag: typeof factory.createJSDocReturnTag = Debug.deprecate(factory.createJSDocReturnTag, factoryDeprecation);
 
 /** @deprecated Use `factory.createJSDocThisTag` or the factory supplied by your transformation context instead. */
-export const createJSDocThisTag = Debug.deprecate(factory.createJSDocThisTag, factoryDeprecation);
+export const createJSDocThisTag: typeof factory.createJSDocThisTag = Debug.deprecate(factory.createJSDocThisTag, factoryDeprecation);
 
 /** @deprecated Use `factory.createJSDocComment` or the factory supplied by your transformation context instead. */
-export const createJSDocComment = Debug.deprecate(factory.createJSDocComment, factoryDeprecation);
+export const createJSDocComment: typeof factory.createJSDocComment = Debug.deprecate(factory.createJSDocComment, factoryDeprecation);
 
 /** @deprecated Use `factory.createJSDocParameterTag` or the factory supplied by your transformation context instead. */
-export const createJSDocParameterTag = Debug.deprecate(factory.createJSDocParameterTag, factoryDeprecation);
+export const createJSDocParameterTag: typeof factory.createJSDocParameterTag = Debug.deprecate(factory.createJSDocParameterTag, factoryDeprecation);
 
 /** @deprecated Use `factory.createJSDocClassTag` or the factory supplied by your transformation context instead. */
-export const createJSDocClassTag = Debug.deprecate(factory.createJSDocClassTag, factoryDeprecation);
+export const createJSDocClassTag: typeof factory.createJSDocClassTag = Debug.deprecate(factory.createJSDocClassTag, factoryDeprecation);
 
 /** @deprecated Use `factory.createJSDocAugmentsTag` or the factory supplied by your transformation context instead. */
-export const createJSDocAugmentsTag = Debug.deprecate(factory.createJSDocAugmentsTag, factoryDeprecation);
+export const createJSDocAugmentsTag: typeof factory.createJSDocAugmentsTag = Debug.deprecate(factory.createJSDocAugmentsTag, factoryDeprecation);
 
 /** @deprecated Use `factory.createJSDocEnumTag` or the factory supplied by your transformation context instead. */
-export const createJSDocEnumTag = Debug.deprecate(factory.createJSDocEnumTag, factoryDeprecation);
+export const createJSDocEnumTag: typeof factory.createJSDocEnumTag = Debug.deprecate(factory.createJSDocEnumTag, factoryDeprecation);
 
 /** @deprecated Use `factory.createJSDocTemplateTag` or the factory supplied by your transformation context instead. */
-export const createJSDocTemplateTag = Debug.deprecate(factory.createJSDocTemplateTag, factoryDeprecation);
+export const createJSDocTemplateTag: typeof factory.createJSDocTemplateTag = Debug.deprecate(factory.createJSDocTemplateTag, factoryDeprecation);
 
 /** @deprecated Use `factory.createJSDocTypedefTag` or the factory supplied by your transformation context instead. */
-export const createJSDocTypedefTag = Debug.deprecate(factory.createJSDocTypedefTag, factoryDeprecation);
+export const createJSDocTypedefTag: typeof factory.createJSDocTypedefTag = Debug.deprecate(factory.createJSDocTypedefTag, factoryDeprecation);
 
 /** @deprecated Use `factory.createJSDocCallbackTag` or the factory supplied by your transformation context instead. */
-export const createJSDocCallbackTag = Debug.deprecate(factory.createJSDocCallbackTag, factoryDeprecation);
+export const createJSDocCallbackTag: typeof factory.createJSDocCallbackTag = Debug.deprecate(factory.createJSDocCallbackTag, factoryDeprecation);
 
 /** @deprecated Use `factory.createJSDocSignature` or the factory supplied by your transformation context instead. */
-export const createJSDocSignature = Debug.deprecate(factory.createJSDocSignature, factoryDeprecation);
+export const createJSDocSignature: typeof factory.createJSDocSignature = Debug.deprecate(factory.createJSDocSignature, factoryDeprecation);
 
 /** @deprecated Use `factory.createJSDocPropertyTag` or the factory supplied by your transformation context instead. */
-export const createJSDocPropertyTag = Debug.deprecate(factory.createJSDocPropertyTag, factoryDeprecation);
+export const createJSDocPropertyTag: typeof factory.createJSDocPropertyTag = Debug.deprecate(factory.createJSDocPropertyTag, factoryDeprecation);
 
 /** @deprecated Use `factory.createJSDocTypeLiteral` or the factory supplied by your transformation context instead. */
-export const createJSDocTypeLiteral = Debug.deprecate(factory.createJSDocTypeLiteral, factoryDeprecation);
+export const createJSDocTypeLiteral: typeof factory.createJSDocTypeLiteral = Debug.deprecate(factory.createJSDocTypeLiteral, factoryDeprecation);
 
 /** @deprecated Use `factory.createJSDocImplementsTag` or the factory supplied by your transformation context instead. */
-export const createJSDocImplementsTag = Debug.deprecate(factory.createJSDocImplementsTag, factoryDeprecation);
+export const createJSDocImplementsTag: typeof factory.createJSDocImplementsTag = Debug.deprecate(factory.createJSDocImplementsTag, factoryDeprecation);
 
 /** @deprecated Use `factory.createJSDocAuthorTag` or the factory supplied by your transformation context instead. */
-export const createJSDocAuthorTag = Debug.deprecate(factory.createJSDocAuthorTag, factoryDeprecation);
+export const createJSDocAuthorTag: typeof factory.createJSDocAuthorTag = Debug.deprecate(factory.createJSDocAuthorTag, factoryDeprecation);
 
 /** @deprecated Use `factory.createJSDocPublicTag` or the factory supplied by your transformation context instead. */
-export const createJSDocPublicTag = Debug.deprecate(factory.createJSDocPublicTag, factoryDeprecation);
+export const createJSDocPublicTag: typeof factory.createJSDocPublicTag = Debug.deprecate(factory.createJSDocPublicTag, factoryDeprecation);
 
 /** @deprecated Use `factory.createJSDocPrivateTag` or the factory supplied by your transformation context instead. */
-export const createJSDocPrivateTag = Debug.deprecate(factory.createJSDocPrivateTag, factoryDeprecation);
+export const createJSDocPrivateTag: typeof factory.createJSDocPrivateTag = Debug.deprecate(factory.createJSDocPrivateTag, factoryDeprecation);
 
 /** @deprecated Use `factory.createJSDocProtectedTag` or the factory supplied by your transformation context instead. */
-export const createJSDocProtectedTag = Debug.deprecate(factory.createJSDocProtectedTag, factoryDeprecation);
+export const createJSDocProtectedTag: typeof factory.createJSDocProtectedTag = Debug.deprecate(factory.createJSDocProtectedTag, factoryDeprecation);
 
 /** @deprecated Use `factory.createJSDocReadonlyTag` or the factory supplied by your transformation context instead. */
-export const createJSDocReadonlyTag = Debug.deprecate(factory.createJSDocReadonlyTag, factoryDeprecation);
+export const createJSDocReadonlyTag: typeof factory.createJSDocReadonlyTag = Debug.deprecate(factory.createJSDocReadonlyTag, factoryDeprecation);
 
 /** @deprecated Use `factory.createJSDocUnknownTag` or the factory supplied by your transformation context instead. */
-export const createJSDocTag = Debug.deprecate(factory.createJSDocUnknownTag, factoryDeprecation);
+export const createJSDocTag: typeof factory.createJSDocUnknownTag = Debug.deprecate(factory.createJSDocUnknownTag, factoryDeprecation);
 
 /** @deprecated Use `factory.createJsxElement` or the factory supplied by your transformation context instead. */
-export const createJsxElement = Debug.deprecate(factory.createJsxElement, factoryDeprecation);
+export const createJsxElement: typeof factory.createJsxElement = Debug.deprecate(factory.createJsxElement, factoryDeprecation);
 
 /** @deprecated Use `factory.updateJsxElement` or the factory supplied by your transformation context instead. */
-export const updateJsxElement = Debug.deprecate(factory.updateJsxElement, factoryDeprecation);
+export const updateJsxElement: typeof factory.updateJsxElement = Debug.deprecate(factory.updateJsxElement, factoryDeprecation);
 
 /** @deprecated Use `factory.createJsxSelfClosingElement` or the factory supplied by your transformation context instead. */
-export const createJsxSelfClosingElement = Debug.deprecate(factory.createJsxSelfClosingElement, factoryDeprecation);
+export const createJsxSelfClosingElement: typeof factory.createJsxSelfClosingElement = Debug.deprecate(factory.createJsxSelfClosingElement, factoryDeprecation);
 
 /** @deprecated Use `factory.updateJsxSelfClosingElement` or the factory supplied by your transformation context instead. */
-export const updateJsxSelfClosingElement = Debug.deprecate(factory.updateJsxSelfClosingElement, factoryDeprecation);
+export const updateJsxSelfClosingElement: typeof factory.updateJsxSelfClosingElement = Debug.deprecate(factory.updateJsxSelfClosingElement, factoryDeprecation);
 
 /** @deprecated Use `factory.createJsxOpeningElement` or the factory supplied by your transformation context instead. */
-export const createJsxOpeningElement = Debug.deprecate(factory.createJsxOpeningElement, factoryDeprecation);
+export const createJsxOpeningElement: typeof factory.createJsxOpeningElement = Debug.deprecate(factory.createJsxOpeningElement, factoryDeprecation);
 
 /** @deprecated Use `factory.updateJsxOpeningElement` or the factory supplied by your transformation context instead. */
-export const updateJsxOpeningElement = Debug.deprecate(factory.updateJsxOpeningElement, factoryDeprecation);
+export const updateJsxOpeningElement: typeof factory.updateJsxOpeningElement = Debug.deprecate(factory.updateJsxOpeningElement, factoryDeprecation);
 
 /** @deprecated Use `factory.createJsxClosingElement` or the factory supplied by your transformation context instead. */
-export const createJsxClosingElement = Debug.deprecate(factory.createJsxClosingElement, factoryDeprecation);
+export const createJsxClosingElement: typeof factory.createJsxClosingElement = Debug.deprecate(factory.createJsxClosingElement, factoryDeprecation);
 
 /** @deprecated Use `factory.updateJsxClosingElement` or the factory supplied by your transformation context instead. */
-export const updateJsxClosingElement = Debug.deprecate(factory.updateJsxClosingElement, factoryDeprecation);
+export const updateJsxClosingElement: typeof factory.updateJsxClosingElement = Debug.deprecate(factory.updateJsxClosingElement, factoryDeprecation);
 
 /** @deprecated Use `factory.createJsxFragment` or the factory supplied by your transformation context instead. */
-export const createJsxFragment = Debug.deprecate(factory.createJsxFragment, factoryDeprecation);
+export const createJsxFragment: typeof factory.createJsxFragment = Debug.deprecate(factory.createJsxFragment, factoryDeprecation);
 
 /** @deprecated Use `factory.createJsxText` or the factory supplied by your transformation context instead. */
-export const createJsxText = Debug.deprecate(factory.createJsxText, factoryDeprecation);
+export const createJsxText: typeof factory.createJsxText = Debug.deprecate(factory.createJsxText, factoryDeprecation);
 
 /** @deprecated Use `factory.updateJsxText` or the factory supplied by your transformation context instead. */
-export const updateJsxText = Debug.deprecate(factory.updateJsxText, factoryDeprecation);
+export const updateJsxText: typeof factory.updateJsxText = Debug.deprecate(factory.updateJsxText, factoryDeprecation);
 
 /** @deprecated Use `factory.createJsxOpeningFragment` or the factory supplied by your transformation context instead. */
-export const createJsxOpeningFragment = Debug.deprecate(factory.createJsxOpeningFragment, factoryDeprecation);
+export const createJsxOpeningFragment: typeof factory.createJsxOpeningFragment = Debug.deprecate(factory.createJsxOpeningFragment, factoryDeprecation);
 
 /** @deprecated Use `factory.createJsxJsxClosingFragment` or the factory supplied by your transformation context instead. */
-export const createJsxJsxClosingFragment = Debug.deprecate(factory.createJsxJsxClosingFragment, factoryDeprecation);
+export const createJsxJsxClosingFragment: typeof factory.createJsxJsxClosingFragment = Debug.deprecate(factory.createJsxJsxClosingFragment, factoryDeprecation);
 
 /** @deprecated Use `factory.updateJsxFragment` or the factory supplied by your transformation context instead. */
-export const updateJsxFragment = Debug.deprecate(factory.updateJsxFragment, factoryDeprecation);
+export const updateJsxFragment: typeof factory.updateJsxFragment = Debug.deprecate(factory.updateJsxFragment, factoryDeprecation);
 
 /** @deprecated Use `factory.createJsxAttribute` or the factory supplied by your transformation context instead. */
-export const createJsxAttribute = Debug.deprecate(factory.createJsxAttribute, factoryDeprecation);
+export const createJsxAttribute: typeof factory.createJsxAttribute = Debug.deprecate(factory.createJsxAttribute, factoryDeprecation);
 
 /** @deprecated Use `factory.updateJsxAttribute` or the factory supplied by your transformation context instead. */
-export const updateJsxAttribute = Debug.deprecate(factory.updateJsxAttribute, factoryDeprecation);
+export const updateJsxAttribute: typeof factory.updateJsxAttribute = Debug.deprecate(factory.updateJsxAttribute, factoryDeprecation);
 
 /** @deprecated Use `factory.createJsxAttributes` or the factory supplied by your transformation context instead. */
-export const createJsxAttributes = Debug.deprecate(factory.createJsxAttributes, factoryDeprecation);
+export const createJsxAttributes: typeof factory.createJsxAttributes = Debug.deprecate(factory.createJsxAttributes, factoryDeprecation);
 
 /** @deprecated Use `factory.updateJsxAttributes` or the factory supplied by your transformation context instead. */
-export const updateJsxAttributes = Debug.deprecate(factory.updateJsxAttributes, factoryDeprecation);
+export const updateJsxAttributes: typeof factory.updateJsxAttributes = Debug.deprecate(factory.updateJsxAttributes, factoryDeprecation);
 
 /** @deprecated Use `factory.createJsxSpreadAttribute` or the factory supplied by your transformation context instead. */
-export const createJsxSpreadAttribute = Debug.deprecate(factory.createJsxSpreadAttribute, factoryDeprecation);
+export const createJsxSpreadAttribute: typeof factory.createJsxSpreadAttribute = Debug.deprecate(factory.createJsxSpreadAttribute, factoryDeprecation);
 
 /** @deprecated Use `factory.updateJsxSpreadAttribute` or the factory supplied by your transformation context instead. */
-export const updateJsxSpreadAttribute = Debug.deprecate(factory.updateJsxSpreadAttribute, factoryDeprecation);
+export const updateJsxSpreadAttribute: typeof factory.updateJsxSpreadAttribute = Debug.deprecate(factory.updateJsxSpreadAttribute, factoryDeprecation);
 
 /** @deprecated Use `factory.createJsxExpression` or the factory supplied by your transformation context instead. */
-export const createJsxExpression = Debug.deprecate(factory.createJsxExpression, factoryDeprecation);
+export const createJsxExpression: typeof factory.createJsxExpression = Debug.deprecate(factory.createJsxExpression, factoryDeprecation);
 
 /** @deprecated Use `factory.updateJsxExpression` or the factory supplied by your transformation context instead. */
-export const updateJsxExpression = Debug.deprecate(factory.updateJsxExpression, factoryDeprecation);
+export const updateJsxExpression: typeof factory.updateJsxExpression = Debug.deprecate(factory.updateJsxExpression, factoryDeprecation);
 
 /** @deprecated Use `factory.createCaseClause` or the factory supplied by your transformation context instead. */
-export const createCaseClause = Debug.deprecate(factory.createCaseClause, factoryDeprecation);
+export const createCaseClause: typeof factory.createCaseClause = Debug.deprecate(factory.createCaseClause, factoryDeprecation);
 
 /** @deprecated Use `factory.updateCaseClause` or the factory supplied by your transformation context instead. */
-export const updateCaseClause = Debug.deprecate(factory.updateCaseClause, factoryDeprecation);
+export const updateCaseClause: typeof factory.updateCaseClause = Debug.deprecate(factory.updateCaseClause, factoryDeprecation);
 
 /** @deprecated Use `factory.createDefaultClause` or the factory supplied by your transformation context instead. */
-export const createDefaultClause = Debug.deprecate(factory.createDefaultClause, factoryDeprecation);
+export const createDefaultClause: typeof factory.createDefaultClause = Debug.deprecate(factory.createDefaultClause, factoryDeprecation);
 
 /** @deprecated Use `factory.updateDefaultClause` or the factory supplied by your transformation context instead. */
-export const updateDefaultClause = Debug.deprecate(factory.updateDefaultClause, factoryDeprecation);
+export const updateDefaultClause: typeof factory.updateDefaultClause = Debug.deprecate(factory.updateDefaultClause, factoryDeprecation);
 
 /** @deprecated Use `factory.createHeritageClause` or the factory supplied by your transformation context instead. */
-export const createHeritageClause = Debug.deprecate(factory.createHeritageClause, factoryDeprecation);
+export const createHeritageClause: typeof factory.createHeritageClause = Debug.deprecate(factory.createHeritageClause, factoryDeprecation);
 
 /** @deprecated Use `factory.updateHeritageClause` or the factory supplied by your transformation context instead. */
-export const updateHeritageClause = Debug.deprecate(factory.updateHeritageClause, factoryDeprecation);
+export const updateHeritageClause: typeof factory.updateHeritageClause = Debug.deprecate(factory.updateHeritageClause, factoryDeprecation);
 
 /** @deprecated Use `factory.createCatchClause` or the factory supplied by your transformation context instead. */
-export const createCatchClause = Debug.deprecate(factory.createCatchClause, factoryDeprecation);
+export const createCatchClause: typeof factory.createCatchClause = Debug.deprecate(factory.createCatchClause, factoryDeprecation);
 
 /** @deprecated Use `factory.updateCatchClause` or the factory supplied by your transformation context instead. */
-export const updateCatchClause = Debug.deprecate(factory.updateCatchClause, factoryDeprecation);
+export const updateCatchClause: typeof factory.updateCatchClause = Debug.deprecate(factory.updateCatchClause, factoryDeprecation);
 
 /** @deprecated Use `factory.createPropertyAssignment` or the factory supplied by your transformation context instead. */
-export const createPropertyAssignment = Debug.deprecate(factory.createPropertyAssignment, factoryDeprecation);
+export const createPropertyAssignment: typeof factory.createPropertyAssignment = Debug.deprecate(factory.createPropertyAssignment, factoryDeprecation);
 
 /** @deprecated Use `factory.updatePropertyAssignment` or the factory supplied by your transformation context instead. */
-export const updatePropertyAssignment = Debug.deprecate(factory.updatePropertyAssignment, factoryDeprecation);
+export const updatePropertyAssignment: typeof factory.updatePropertyAssignment = Debug.deprecate(factory.updatePropertyAssignment, factoryDeprecation);
 
 /** @deprecated Use `factory.createShorthandPropertyAssignment` or the factory supplied by your transformation context instead. */
-export const createShorthandPropertyAssignment = Debug.deprecate(factory.createShorthandPropertyAssignment, factoryDeprecation);
+export const createShorthandPropertyAssignment: typeof factory.createShorthandPropertyAssignment = Debug.deprecate(factory.createShorthandPropertyAssignment, factoryDeprecation);
 
 /** @deprecated Use `factory.updateShorthandPropertyAssignment` or the factory supplied by your transformation context instead. */
-export const updateShorthandPropertyAssignment = Debug.deprecate(factory.updateShorthandPropertyAssignment, factoryDeprecation);
+export const updateShorthandPropertyAssignment: typeof factory.updateShorthandPropertyAssignment = Debug.deprecate(factory.updateShorthandPropertyAssignment, factoryDeprecation);
 
 /** @deprecated Use `factory.createSpreadAssignment` or the factory supplied by your transformation context instead. */
-export const createSpreadAssignment = Debug.deprecate(factory.createSpreadAssignment, factoryDeprecation);
+export const createSpreadAssignment: typeof factory.createSpreadAssignment = Debug.deprecate(factory.createSpreadAssignment, factoryDeprecation);
 
 /** @deprecated Use `factory.updateSpreadAssignment` or the factory supplied by your transformation context instead. */
-export const updateSpreadAssignment = Debug.deprecate(factory.updateSpreadAssignment, factoryDeprecation);
+export const updateSpreadAssignment: typeof factory.updateSpreadAssignment = Debug.deprecate(factory.updateSpreadAssignment, factoryDeprecation);
 
 /** @deprecated Use `factory.createEnumMember` or the factory supplied by your transformation context instead. */
-export const createEnumMember = Debug.deprecate(factory.createEnumMember, factoryDeprecation);
+export const createEnumMember: typeof factory.createEnumMember = Debug.deprecate(factory.createEnumMember, factoryDeprecation);
 
 /** @deprecated Use `factory.updateEnumMember` or the factory supplied by your transformation context instead. */
-export const updateEnumMember = Debug.deprecate(factory.updateEnumMember, factoryDeprecation);
+export const updateEnumMember: typeof factory.updateEnumMember = Debug.deprecate(factory.updateEnumMember, factoryDeprecation);
 
 /** @deprecated Use `factory.updateSourceFile` or the factory supplied by your transformation context instead. */
-export const updateSourceFileNode = Debug.deprecate(factory.updateSourceFile, factoryDeprecation);
+export const updateSourceFileNode: typeof factory.updateSourceFile = Debug.deprecate(factory.updateSourceFile, factoryDeprecation);
 
 /** @deprecated Use `factory.createNotEmittedStatement` or the factory supplied by your transformation context instead. */
-export const createNotEmittedStatement = Debug.deprecate(factory.createNotEmittedStatement, factoryDeprecation);
+export const createNotEmittedStatement: typeof factory.createNotEmittedStatement = Debug.deprecate(factory.createNotEmittedStatement, factoryDeprecation);
 
 /** @deprecated Use `factory.createPartiallyEmittedExpression` or the factory supplied by your transformation context instead. */
-export const createPartiallyEmittedExpression = Debug.deprecate(factory.createPartiallyEmittedExpression, factoryDeprecation);
+export const createPartiallyEmittedExpression: typeof factory.createPartiallyEmittedExpression = Debug.deprecate(factory.createPartiallyEmittedExpression, factoryDeprecation);
 
 /** @deprecated Use `factory.updatePartiallyEmittedExpression` or the factory supplied by your transformation context instead. */
-export const updatePartiallyEmittedExpression = Debug.deprecate(factory.updatePartiallyEmittedExpression, factoryDeprecation);
+export const updatePartiallyEmittedExpression: typeof factory.updatePartiallyEmittedExpression = Debug.deprecate(factory.updatePartiallyEmittedExpression, factoryDeprecation);
 
 /** @deprecated Use `factory.createCommaListExpression` or the factory supplied by your transformation context instead. */
-export const createCommaList = Debug.deprecate(factory.createCommaListExpression, factoryDeprecation);
+export const createCommaList: typeof factory.createCommaListExpression = Debug.deprecate(factory.createCommaListExpression, factoryDeprecation);
 
 /** @deprecated Use `factory.updateCommaListExpression` or the factory supplied by your transformation context instead. */
-export const updateCommaList = Debug.deprecate(factory.updateCommaListExpression, factoryDeprecation);
+export const updateCommaList: typeof factory.updateCommaListExpression = Debug.deprecate(factory.updateCommaListExpression, factoryDeprecation);
 
 /** @deprecated Use `factory.createBundle` or the factory supplied by your transformation context instead. */
-export const createBundle = Debug.deprecate(factory.createBundle, factoryDeprecation);
+export const createBundle: typeof factory.createBundle = Debug.deprecate(factory.createBundle, factoryDeprecation);
 
 /** @deprecated Use `factory.updateBundle` or the factory supplied by your transformation context instead. */
-export const updateBundle = Debug.deprecate(factory.updateBundle, factoryDeprecation);
+export const updateBundle: typeof factory.updateBundle = Debug.deprecate(factory.updateBundle, factoryDeprecation);
 
 /** @deprecated Use `factory.createImmediatelyInvokedFunctionExpression` or the factory supplied by your transformation context instead. */
-export const createImmediatelyInvokedFunctionExpression = Debug.deprecate(factory.createImmediatelyInvokedFunctionExpression, factoryDeprecation);
+export const createImmediatelyInvokedFunctionExpression: typeof factory.createImmediatelyInvokedFunctionExpression = Debug.deprecate(factory.createImmediatelyInvokedFunctionExpression, factoryDeprecation);
 
 /** @deprecated Use `factory.createImmediatelyInvokedArrowFunction` or the factory supplied by your transformation context instead. */
-export const createImmediatelyInvokedArrowFunction = Debug.deprecate(factory.createImmediatelyInvokedArrowFunction, factoryDeprecation);
+export const createImmediatelyInvokedArrowFunction: typeof factory.createImmediatelyInvokedArrowFunction = Debug.deprecate(factory.createImmediatelyInvokedArrowFunction, factoryDeprecation);
 
 /** @deprecated Use `factory.createVoidZero` or the factory supplied by your transformation context instead. */
-export const createVoidZero = Debug.deprecate(factory.createVoidZero, factoryDeprecation);
+export const createVoidZero: typeof factory.createVoidZero = Debug.deprecate(factory.createVoidZero, factoryDeprecation);
 
 /** @deprecated Use `factory.createExportDefault` or the factory supplied by your transformation context instead. */
-export const createExportDefault = Debug.deprecate(factory.createExportDefault, factoryDeprecation);
+export const createExportDefault: typeof factory.createExportDefault = Debug.deprecate(factory.createExportDefault, factoryDeprecation);
 
 /** @deprecated Use `factory.createExternalModuleExport` or the factory supplied by your transformation context instead. */
-export const createExternalModuleExport = Debug.deprecate(factory.createExternalModuleExport, factoryDeprecation);
+export const createExternalModuleExport: typeof factory.createExternalModuleExport = Debug.deprecate(factory.createExternalModuleExport, factoryDeprecation);
 
 /** @deprecated Use `factory.createNamespaceExport` or the factory supplied by your transformation context instead. */
-export const createNamespaceExport = Debug.deprecate(factory.createNamespaceExport, factoryDeprecation);
+export const createNamespaceExport: typeof factory.createNamespaceExport = Debug.deprecate(factory.createNamespaceExport, factoryDeprecation);
 
 /** @deprecated Use `factory.updateNamespaceExport` or the factory supplied by your transformation context instead. */
-export const updateNamespaceExport = Debug.deprecate(factory.updateNamespaceExport, factoryDeprecation);
+export const updateNamespaceExport: typeof factory.updateNamespaceExport = Debug.deprecate(factory.updateNamespaceExport, factoryDeprecation);
 
 /** @deprecated Use `factory.createToken` or the factory supplied by your transformation context instead. */
 export const createToken = Debug.deprecate(function createToken<TKind extends SyntaxKind>(kind: TKind): Token<TKind> {
diff --git a/src/deprecatedCompat/deprecations.ts b/src/deprecatedCompat/deprecations.ts
index d85748d14d..20ac933563 100644
--- a/src/deprecatedCompat/deprecations.ts
+++ b/src/deprecatedCompat/deprecations.ts
@@ -1,4 +1,4 @@
-import { Debug, DeprecationOptions, hasProperty } from "./_namespaces/ts";
+import { Debug, DeprecationOptions, hasProperty, UnionToIntersection } from "./_namespaces/ts";
 
 // The following are deprecations for the public API. Deprecated exports are removed from the compiler itself
 // and compatible implementations are added here, along with an appropriate deprecation warning using
@@ -12,31 +12,58 @@ import { Debug, DeprecationOptions, hasProperty } from "./_namespaces/ts";
 //
 // Once we have determined enough time has passed after a deprecation has been marked as `"warn"` or `"error"`, it will be removed from the public API.
 
-/** Defines a list of overloads by ordinal */
-type OverloadDefinitions = { readonly [P in number]: (...args: any[]) => any; };
-
-/** A function that returns the ordinal of the overload that matches the provided arguments */
-type OverloadBinder<T extends OverloadDefinitions> = (args: OverloadParameters<T>) => OverloadKeys<T> | undefined;
-
-/** Extracts the ordinals from an set of overload definitions. */
-type OverloadKeys<T extends OverloadDefinitions> = Extract<keyof T, number>;
-
-/** Extracts a union of the potential parameter lists for each overload. */
-type OverloadParameters<T extends OverloadDefinitions> = Parameters<{ [P in OverloadKeys<T>]: T[P]; }[OverloadKeys<T>]>;
+/**
+ * Defines a list of overloads by ordinal
+ *
+ * @internal
+ */
+export type OverloadDefinitions = { readonly [P in number]: (...args: any[]) => any; };
+
+/**
+ * A function that returns the ordinal of the overload that matches the provided arguments
+ *
+ * @internal
+ */
+export type OverloadBinder<T extends OverloadDefinitions> = (args: OverloadParameters<T>) => OverloadKeys<T> | undefined;
+
+/**
+ * Extracts the ordinals from an set of overload definitions.
+ *
+ * @internal
+ */
+export type OverloadKeys<T extends OverloadDefinitions> = Extract<keyof T, number>;
+
+/**
+ * Extracts a union of the potential parameter lists for each overload.
+ *
+ * @internal
+ */
+export type OverloadParameters<T extends OverloadDefinitions> = Parameters<{ [P in OverloadKeys<T>]: T[P]; }[OverloadKeys<T>]>;
 
 // NOTE: the following doesn't work in TS 4.4 (the current LKG in main), so we have to use UnionToIntersection for now
-/** Constructs an intersection of each overload in a set of overload definitions. */
 // type OverloadFunction<T extends OverloadDefinitions, R extends ((...args: any[]) => any)[] = [], O = unknown> =
 //     R["length"] extends keyof T ? OverloadFunction<T, [...R, T[R["length"]]], O & T[R["length"]]> :
 //     unknown extends O ? never : O;
-type UnionToIntersection<T> = (T extends any ? (x: T) => any : never) extends (x: infer R) => any ? R : never;
-type OverloadFunction<T extends OverloadDefinitions> = UnionToIntersection<T[keyof T]>;
-
-/** Maps each ordinal in a set of overload definitions to a function that can be used to bind its arguments. */
-type OverloadBinders<T extends OverloadDefinitions> = { [P in OverloadKeys<T>]: (args: OverloadParameters<T>) => boolean | undefined; };
-
-/** Defines deprecations for specific overloads by ordinal. */
-type OverloadDeprecations<T extends OverloadDefinitions> = { [P in OverloadKeys<T>]?: DeprecationOptions; };
+/**
+ * Constructs an intersection of each overload in a set of overload definitions.
+ *
+ * @internal
+ */
+export type OverloadFunction<T extends OverloadDefinitions> = UnionToIntersection<T[keyof T]>;
+
+/**
+ * Maps each ordinal in a set of overload definitions to a function that can be used to bind its arguments.
+ *
+ * @internal
+ */
+export type OverloadBinders<T extends OverloadDefinitions> = { [P in OverloadKeys<T>]: (args: OverloadParameters<T>) => boolean | undefined; };
+
+/**
+ * Defines deprecations for specific overloads by ordinal.
+ *
+ * @internal
+ */
+export type OverloadDeprecations<T extends OverloadDefinitions> = { [P in OverloadKeys<T>]?: DeprecationOptions; };
 
 /** @internal */
 export function createOverload<T extends OverloadDefinitions>(name: string, overloads: T, binder: OverloadBinders<T>, deprecations?: OverloadDeprecations<T>) {
@@ -75,19 +102,23 @@ function createBinder<T extends OverloadDefinitions>(overloads: T, binder: Overl
     };
 }
 
-interface OverloadBuilder {
+/** @internal */
+export interface OverloadBuilder {
     overload<T extends OverloadDefinitions>(overloads: T): BindableOverloadBuilder<T>;
 }
 
-interface BindableOverloadBuilder<T extends OverloadDefinitions> {
+/** @internal */
+export interface BindableOverloadBuilder<T extends OverloadDefinitions> {
     bind(binder: OverloadBinders<T>): BoundOverloadBuilder<T>;
 }
 
-interface FinishableOverloadBuilder<T extends OverloadDefinitions> {
+/** @internal */
+export interface FinishableOverloadBuilder<T extends OverloadDefinitions> {
     finish(): OverloadFunction<T>;
 }
 
-interface BoundOverloadBuilder<T extends OverloadDefinitions> extends FinishableOverloadBuilder<T> {
+/** @internal */
+export interface BoundOverloadBuilder<T extends OverloadDefinitions> extends FinishableOverloadBuilder<T> {
     deprecate(deprecations: OverloadDeprecations<T>): FinishableOverloadBuilder<T>;
 }
 
diff --git a/src/server/editorServices.ts b/src/server/editorServices.ts
index 1ae9921a3c..b3e91f685e 100644
--- a/src/server/editorServices.ts
+++ b/src/server/editorServices.ts
@@ -28,7 +28,7 @@ import {
     parseJsonSourceFileConfigFileContent, parseJsonText, parsePackageName, Path, PerformanceEvent, PluginImport,
     PollingInterval, ProjectPackageJsonInfo, ProjectReference, ReadMapFile, ReadonlyCollection, removeFileExtension,
     removeIgnoredPath, removeMinAndVersionNumbers, ResolvedProjectReference, resolveProjectReferencePath,
-    returnNoopFileWatcher, returnTrue, ScriptKind, Set, SharedExtendedConfigFileWatcher, some, SourceFile, startsWith,
+    returnNoopFileWatcher, returnTrue, ScriptKind, Set, SharedExtendedConfigFileWatcher, some, SourceFile, SourceFileLike, startsWith,
     Ternary, TextChange, toFileNameLowerCase, toPath, tracing, tryAddToSet, tryReadFile, TsConfigSourceFile,
     TypeAcquisition, typeAcquisitionDeclarations, unorderedRemoveItem, updateSharedExtendedConfigFileWatcher,
     updateWatchingWildcardDirectories, UserPreferences, version, WatchDirectoryFlags, WatchFactory, WatchLogLevel,
@@ -397,7 +397,7 @@ function findProjectByName<T extends Project>(projectName: string, projects: T[]
 const noopConfigFileWatcher: FileWatcher = { close: noop };
 
 /** @internal */
-interface ConfigFileExistenceInfo {
+export interface ConfigFileExistenceInfo {
     /**
      * Cached value of existence of config file
      * It is true if there is configured project open for this file.
@@ -2984,7 +2984,7 @@ export class ProjectService {
     }
 
     /** @internal */
-    getSourceFileLike(fileName: string, projectNameOrProject: string | Project, declarationInfo?: ScriptInfo) {
+    getSourceFileLike(fileName: string, projectNameOrProject: string | Project, declarationInfo?: ScriptInfo): SourceFileLike | undefined {
         const project = (projectNameOrProject as Project).projectName ? projectNameOrProject as Project : this.findProject(projectNameOrProject as string);
         if (project) {
             const path = project.toPath(fileName);
diff --git a/src/server/scriptVersionCache.ts b/src/server/scriptVersionCache.ts
index 13a2fbe6a0..fc828b3f8c 100644
--- a/src/server/scriptVersionCache.ts
+++ b/src/server/scriptVersionCache.ts
@@ -6,7 +6,8 @@ import { emptyArray, protocol } from "./_namespaces/ts.server";
 
 const lineCollectionCapacity = 4;
 
-interface LineCollection {
+/** @internal */
+export interface LineCollection {
     charCount(): number;
     lineCount(): number;
     isLeaf(): this is LineLeaf;
@@ -19,7 +20,8 @@ export interface AbsolutePositionAndLineText {
     lineText: string | undefined;
 }
 
-const enum CharRangeSection {
+/** @internal */
+export const enum CharRangeSection {
     PreStart,
     Start,
     Entire,
@@ -28,7 +30,8 @@ const enum CharRangeSection {
     PostEnd
 }
 
-interface LineIndexWalker {
+/** @internal */
+export interface LineIndexWalker {
     goSubtree: boolean;
     done: boolean;
     leaf(relativeStart: number, relativeLength: number, lineCollection: LineLeaf): void;
@@ -568,7 +571,8 @@ export class LineIndex {
     }
 }
 
-class LineNode implements LineCollection {
+/** @internal */
+export class LineNode implements LineCollection {
     totalChars = 0;
     totalLines = 0;
 
@@ -819,7 +823,8 @@ class LineNode implements LineCollection {
     }
 }
 
-class LineLeaf implements LineCollection {
+/** @internal */
+export class LineLeaf implements LineCollection {
     constructor(public text: string) {
     }
 
diff --git a/src/services/codefixes/annotateWithTypeFromJSDoc.ts b/src/services/codefixes/annotateWithTypeFromJSDoc.ts
index 8003b4a713..8220c43714 100644
--- a/src/services/codefixes/annotateWithTypeFromJSDoc.ts
+++ b/src/services/codefixes/annotateWithTypeFromJSDoc.ts
@@ -32,7 +32,8 @@ function getDeclaration(file: SourceFile, pos: number): DeclarationWithType | un
     return tryCast(isParameter(name.parent) ? name.parent.parent : name.parent, parameterShouldGetTypeFromJSDoc);
 }
 
-type DeclarationWithType =
+/** @internal */
+export type DeclarationWithType =
     | FunctionLikeDeclaration
     | VariableDeclaration
     | PropertySignature
diff --git a/src/services/codefixes/generateAccessors.ts b/src/services/codefixes/generateAccessors.ts
index 1ae126ddfa..50366542a9 100644
--- a/src/services/codefixes/generateAccessors.ts
+++ b/src/services/codefixes/generateAccessors.ts
@@ -11,12 +11,19 @@ import {
     SymbolFlags, SyntaxKind, textChanges, TypeChecker, TypeNode,
 } from "../_namespaces/ts";
 
-type AcceptedDeclaration = ParameterPropertyDeclaration | PropertyDeclaration | PropertyAssignment;
-type AcceptedNameType = Identifier | StringLiteral;
-type ContainerDeclaration = ClassLikeDeclaration | ObjectLiteralExpression;
 
-type Info = AccessorInfo | refactor.RefactorErrorInfo;
-interface AccessorInfo {
+/** @internal */
+export type AcceptedDeclaration = ParameterPropertyDeclaration | PropertyDeclaration | PropertyAssignment;
+/** @internal */
+export type AcceptedNameType = Identifier | StringLiteral;
+/** @internal */
+export type ContainerDeclaration = ClassLikeDeclaration | ObjectLiteralExpression;
+
+/** @internal */
+export type AccessorOrRefactorErrorInfo = AccessorInfo | refactor.RefactorErrorInfo;
+
+/** @internal */
+export interface AccessorInfo {
     readonly container: ContainerDeclaration;
     readonly isStatic: boolean;
     readonly isReadonly: boolean;
@@ -117,7 +124,7 @@ function prepareModifierFlagsForField(modifierFlags: ModifierFlags): ModifierFla
 }
 
 /** @internal */
-export function getAccessorConvertiblePropertyAtPosition(file: SourceFile, program: Program, start: number, end: number, considerEmptySpans = true): Info | undefined {
+export function getAccessorConvertiblePropertyAtPosition(file: SourceFile, program: Program, start: number, end: number, considerEmptySpans = true): AccessorOrRefactorErrorInfo | undefined {
     const node = getTokenAtPosition(file, start);
     const cursorRequest = start === end && considerEmptySpans;
     const declaration = findAncestor(node.parent, isAcceptedDeclaration);
diff --git a/src/services/codefixes/helpers.ts b/src/services/codefixes/helpers.ts
index c54f6da012..d523d8567b 100644
--- a/src/services/codefixes/helpers.ts
+++ b/src/services/codefixes/helpers.ts
@@ -8,7 +8,7 @@ import {
     IntersectionType, isArrowFunction, isAutoAccessorPropertyDeclaration, isFunctionDeclaration, isFunctionExpression,
     isGetAccessorDeclaration, isIdentifier, isImportTypeNode, isInJSFile, isLiteralImportTypeNode, isMethodDeclaration,
     isObjectLiteralExpression, isPropertyAccessExpression, isPropertyAssignment, isSetAccessorDeclaration,
-    isStringLiteral, isYieldExpression, LanguageServiceHost, length, map, Map, MethodDeclaration, Modifier,
+    isStringLiteral, isYieldExpression, LanguageServiceHost, length, map, Map, MethodDeclaration, MethodSignature, Modifier,
     ModifierFlags, Node, NodeArray, NodeBuilderFlags, NodeFlags, nullTransformationContext, ObjectFlags,
     ObjectLiteralExpression, ObjectType, ParameterDeclaration, Program, PropertyAssignment, PropertyDeclaration,
     PropertyName, QuotePreference, sameMap, ScriptTarget, Set, SetAccessorDeclaration, setTextRange, Signature,
@@ -57,7 +57,8 @@ export interface TypeConstructionContext {
     host: LanguageServiceHost;
 }
 
-type AddNode = PropertyDeclaration | GetAccessorDeclaration | SetAccessorDeclaration | MethodDeclaration | FunctionExpression | ArrowFunction;
+/** @internal */
+export type AddNode = PropertyDeclaration | GetAccessorDeclaration | SetAccessorDeclaration | MethodDeclaration | FunctionExpression | ArrowFunction;
 
 /** @internal */
 export const enum PreserveOptionalFlags {
@@ -353,7 +354,7 @@ export function createSignatureDeclarationFromCallExpression(
     name: Identifier | string,
     modifierFlags: ModifierFlags,
     contextNode: Node
-) {
+): MethodDeclaration | MethodSignature | FunctionDeclaration {
     const quotePreference = getQuotePreference(context.sourceFile, context.preferences);
     const scriptTarget = getEmitScriptTarget(context.program.getCompilerOptions());
     const tracker = getNoopSymbolTrackerWithResolver(context);
@@ -417,7 +418,8 @@ export function createSignatureDeclarationFromCallExpression(
     }
 }
 
-interface ArgumentTypeParameterAndConstraint {
+/** @internal */
+export interface ArgumentTypeParameterAndConstraint {
     argumentType: Type;
     constraint?: TypeNode;
 }
diff --git a/src/services/completions.ts b/src/services/completions.ts
index 86de7d17e3..f3e4f3f2ec 100644
--- a/src/services/completions.ts
+++ b/src/services/completions.ts
@@ -124,7 +124,8 @@ export enum CompletionSource {
     ObjectLiteralMethodSnippet = "ObjectLiteralMethodSnippet/",
 }
 
-const enum SymbolOriginInfoKind {
+/** @internal */
+export const enum SymbolOriginInfoKind {
     ThisType            = 1 << 0,
     SymbolMember        = 1 << 1,
     Export              = 1 << 2,
@@ -138,7 +139,8 @@ const enum SymbolOriginInfoKind {
     SymbolMemberExport   = SymbolMember | Export,
 }
 
-interface SymbolOriginInfo {
+/** @internal */
+export interface SymbolOriginInfo {
     kind: SymbolOriginInfoKind;
     isDefaultExport?: boolean;
     isFromPackageJson?: boolean;
@@ -210,18 +212,25 @@ function originIsObjectLiteralMethod(origin: SymbolOriginInfo | undefined): orig
     return !!(origin && origin.kind & SymbolOriginInfoKind.ObjectLiteralMethod);
 }
 
-interface UniqueNameSet {
+/** @internal */
+export interface UniqueNameSet {
     add(name: string): void;
     has(name: string): boolean;
 }
 
 /**
  * Map from symbol index in `symbols` -> SymbolOriginInfo.
+ *
+ * @internal
  */
-type SymbolOriginInfoMap = Record<number, SymbolOriginInfo>;
+export type SymbolOriginInfoMap = Record<number, SymbolOriginInfo>;
 
-/** Map from symbol id -> SortText. */
-type SymbolSortTextMap = (SortText | undefined)[];
+/**
+ * Map from symbol id -> SortText.
+ *
+ * @internal
+ */
+export type SymbolSortTextMap = (SortText | undefined)[];
 
 const enum KeywordCompletionFilters {
     None,                           // No keywords
@@ -1881,8 +1890,12 @@ export function getCompletionEntrySymbol(
 }
 
 const enum CompletionDataKind { Data, JsDocTagName, JsDocTag, JsDocParameterName, Keywords }
-/** true: after the `=` sign but no identifier has been typed yet. Else is the Identifier after the initializer. */
-type IsJsxInitializer = boolean | Identifier;
+/**
+ * true: after the `=` sign but no identifier has been typed yet. Else is the Identifier after the initializer.
+ *
+ * @internal
+ */
+export type IsJsxInitializer = boolean | Identifier;
 interface CompletionData {
     readonly kind: CompletionDataKind.Data;
     readonly symbols: readonly Symbol[];
@@ -4319,7 +4332,8 @@ function tryGetObjectLiteralContextualType(node: ObjectLiteralExpression, typeCh
     return undefined;
 }
 
-interface ImportStatementCompletionInfo {
+/** @internal */
+export interface ImportStatementCompletionInfo {
     isKeywordOnlyCompletion: boolean;
     keywordCompletion: TokenSyntaxKind | undefined;
     isNewIdentifierLocation: boolean;
diff --git a/src/services/getEditsForFileRename.ts b/src/services/getEditsForFileRename.ts
index bdd1ac357d..2c2096a860 100644
--- a/src/services/getEditsForFileRename.ts
+++ b/src/services/getEditsForFileRename.ts
@@ -30,8 +30,12 @@ export function getEditsForFileRename(
     });
 }
 
-/** If 'path' refers to an old directory, returns path in the new directory. */
-type PathUpdater = (path: string) => string | undefined;
+/**
+ * If 'path' refers to an old directory, returns path in the new directory.
+ *
+ * @internal
+ */
+export type PathUpdater = (path: string) => string | undefined;
 // exported for tests
 /** @internal */
 export function getPathUpdater(oldFileOrDirPath: string, newFileOrDirPath: string, getCanonicalFileName: GetCanonicalFileName, sourceMapper: SourceMapper | undefined): PathUpdater {
diff --git a/src/services/organizeImports.ts b/src/services/organizeImports.ts
index 8dd382f0e9..d2643e23ea 100644
--- a/src/services/organizeImports.ts
+++ b/src/services/organizeImports.ts
@@ -1,6 +1,7 @@
 import {
     AnyImportOrRequireStatement, arrayIsSorted, binarySearch, compareBooleans, compareStringsCaseInsensitive,
-    compareValues, createScanner, emptyArray, ExportDeclaration, ExportSpecifier, Expression, factory,
+    compareValues, Comparison, createScanner, emptyArray, ExportDeclaration, ExportSpecifier, Expression, factory,
+    FileTextChanges,
     FindAllReferences, flatMap, formatting, getNewLineOrDefaultFromHost, group, Identifier, identity, ImportDeclaration,
     ImportOrExportSpecifier, ImportSpecifier, isAmbientModule, isExportDeclaration, isExternalModuleNameRelative,
     isExternalModuleReference, isImportDeclaration, isNamedExports, isNamedImports, isNamespaceImport, isString,
@@ -24,7 +25,7 @@ export function organizeImports(
     program: Program,
     preferences: UserPreferences,
     skipDestructiveCodeActions?: boolean
-) {
+): FileTextChanges[] {
     const changeTracker = textChanges.ChangeTracker.fromContext({ host, formatContext, preferences });
 
     const coalesceAndOrganizeImports = (importGroup: readonly ImportDeclaration[]) => stableSort(
@@ -468,7 +469,7 @@ function sortSpecifiers<T extends ImportOrExportSpecifier>(specifiers: readonly
 }
 
 /** @internal */
-export function compareImportOrExportSpecifiers<T extends ImportOrExportSpecifier>(s1: T, s2: T) {
+export function compareImportOrExportSpecifiers<T extends ImportOrExportSpecifier>(s1: T, s2: T): Comparison {
     return compareBooleans(s1.isTypeOnly, s2.isTypeOnly)
         || compareIdentifiers(s1.propertyName || s1.name, s2.propertyName || s2.name)
         || compareIdentifiers(s1.name, s2.name);
@@ -525,7 +526,7 @@ export function getImportSpecifierInsertionIndex(sortedImports: SortedReadonlyAr
 }
 
 /** @internal */
-export function compareImportsOrRequireStatements(s1: AnyImportOrRequireStatement, s2: AnyImportOrRequireStatement) {
+export function compareImportsOrRequireStatements(s1: AnyImportOrRequireStatement, s2: AnyImportOrRequireStatement): Comparison {
     return compareModuleSpecifiers(getModuleSpecifierExpression(s1), getModuleSpecifierExpression(s2)) || compareImportKind(s1, s2);
 }
 
diff --git a/src/services/refactors/extractSymbol.ts b/src/services/refactors/extractSymbol.ts
index a49c9f248d..9a702aa1a7 100644
--- a/src/services/refactors/extractSymbol.ts
+++ b/src/services/refactors/extractSymbol.ts
@@ -255,7 +255,8 @@ export namespace Messages {
     export const cannotExtractFunctionsContainingThisToMethod = createMessage("Cannot extract functions containing this to method");
 }
 
-enum RangeFacts {
+/** @internal */
+export enum RangeFacts {
     None = 0,
     HasReturn = 1 << 0,
     IsGenerator = 1 << 1,
@@ -270,8 +271,10 @@ enum RangeFacts {
 
 /**
  * Represents an expression or a list of statements that should be extracted with some extra information
+ *
+ * @internal
  */
-interface TargetRange {
+export interface TargetRange {
     readonly range: Expression | Statement[];
     readonly facts: RangeFacts;
     /**
@@ -287,8 +290,10 @@ interface TargetRange {
 
 /**
  * Result of 'getRangeToExtract' operation: contains either a range or a list of errors
+ *
+ * @internal
  */
-type RangeToExtract = {
+export type RangeToExtract = {
     readonly targetRange?: never;
     readonly errors: readonly Diagnostic[];
 } | {
diff --git a/src/services/sourcemaps.ts b/src/services/sourcemaps.ts
index 73079ef532..8a80b02ffb 100644
--- a/src/services/sourcemaps.ts
+++ b/src/services/sourcemaps.ts
@@ -155,7 +155,7 @@ export function getDocumentPositionMapper(
     host: DocumentPositionMapperHost,
     generatedFileName: string,
     generatedFileLineInfo: LineInfo,
-    readMapFile: ReadMapFile) {
+    readMapFile: ReadMapFile): DocumentPositionMapper | undefined {
     let mapFileName = tryGetSourceMappingURL(generatedFileLineInfo);
     if (mapFileName) {
         const match = base64UrlRegExp.exec(mapFileName);
diff --git a/src/services/symbolDisplay.ts b/src/services/symbolDisplay.ts
index 78d07e625d..ce70ddb0dc 100644
--- a/src/services/symbolDisplay.ts
+++ b/src/services/symbolDisplay.ts
@@ -149,7 +149,8 @@ export function getSymbolModifiers(typeChecker: TypeChecker, symbol: Symbol): st
     return modifiers.size > 0 ? arrayFrom(modifiers.values()).join(",") : ScriptElementKindModifier.none;
 }
 
-interface SymbolDisplayPartsDocumentationAndSymbolKind {
+/** @internal */
+export interface SymbolDisplayPartsDocumentationAndSymbolKind {
     displayParts: SymbolDisplayPart[];
     documentation: SymbolDisplayPart[];
     symbolKind: ScriptElementKind;
diff --git a/src/services/textChanges.ts b/src/services/textChanges.ts
index 2ddc725e83..4673304be2 100644
--- a/src/services/textChanges.ts
+++ b/src/services/textChanges.ts
@@ -1192,7 +1192,8 @@ function assignPositionsToNodeArray(nodes: NodeArray<any>, visitor: Visitor, tes
     return nodeArray;
 }
 
-interface TextChangesWriter extends EmitTextWriter, PrintHandlers {}
+/** @internal */
+export interface TextChangesWriter extends EmitTextWriter, PrintHandlers {}
 
 /** @internal */
 export function createWriter(newLine: string): TextChangesWriter {
diff --git a/src/services/transform.ts b/src/services/transform.ts
index f6fb9314ac..04ad279c73 100644
--- a/src/services/transform.ts
+++ b/src/services/transform.ts
@@ -1,5 +1,6 @@
 import {
     CompilerOptions, concatenate, DiagnosticWithLocation, factory, fixupCompilerOptions, isArray, Node,
+    TransformationResult,
     TransformerFactory, transformNodes,
 } from "./_namespaces/ts";
 
@@ -9,11 +10,11 @@ import {
  * @param transformers An array of `TransformerFactory` callbacks used to process the transformation.
  * @param compilerOptions Optional compiler options.
  */
-export function transform<T extends Node>(source: T | T[], transformers: TransformerFactory<T>[], compilerOptions?: CompilerOptions) {
+export function transform<T extends Node>(source: T | T[], transformers: TransformerFactory<T>[], compilerOptions?: CompilerOptions): TransformationResult<T> {
     const diagnostics: DiagnosticWithLocation[] = [];
     compilerOptions = fixupCompilerOptions(compilerOptions!, diagnostics); // TODO: GH#18217
     const nodes = isArray(source) ? source : [source];
     const result = transformNodes(/*resolver*/ undefined, /*emitHost*/ undefined, factory, compilerOptions, nodes, transformers, /*allowDtsFiles*/ true);
     result.diagnostics = concatenate(result.diagnostics, diagnostics);
     return result;
-}
\ No newline at end of file
+}
diff --git a/src/tsserverlibrary/tsserverlibrary.ts b/src/tsserverlibrary/tsserverlibrary.ts
index bd73794b37..caa2e6b1db 100644
--- a/src/tsserverlibrary/tsserverlibrary.ts
+++ b/src/tsserverlibrary/tsserverlibrary.ts
@@ -1,5 +1 @@
-import * as ts from "./_namespaces/ts";
-
-// TODO(jakebailey): replace const enum with enum in d.ts
-
-export = ts;
+export * from "./_namespaces/ts";
diff --git a/src/typescript/typescript.ts b/src/typescript/typescript.ts
index c9862f6a73..8a5136a1eb 100644
--- a/src/typescript/typescript.ts
+++ b/src/typescript/typescript.ts
@@ -1,8 +1,5 @@
-import * as ts from "./_namespaces/ts";
 import { Debug, LogLevel } from "./_namespaces/ts";
 
-// TODO(jakebailey): replace const enum with enum in d.ts
-
 // enable deprecation logging
 declare const console: any;
 if (typeof console !== "undefined") {
@@ -18,4 +15,4 @@ if (typeof console !== "undefined") {
     };
 }
 
-export = ts;
+export * from "./_namespaces/ts";
diff --git a/tests/baselines/reference/APISample_compile.js b/tests/baselines/reference/APISample_compile.js
index 2f4cb4c89b..3dfec01fc8 100644
--- a/tests/baselines/reference/APISample_compile.js
+++ b/tests/baselines/reference/APISample_compile.js
@@ -76,5 +76,5 @@ function compile(fileNames, options) {
 exports.compile = compile;
 compile(process.argv.slice(2), {
     noEmitOnError: true, noImplicitAny: true,
-    target: 1 /* ts.ScriptTarget.ES5 */, module: ts.ModuleKind.CommonJS
+    target: ts.ScriptTarget.ES5, module: ts.ModuleKind.CommonJS
 });
diff --git a/tests/baselines/reference/APISample_jsdoc.js b/tests/baselines/reference/APISample_jsdoc.js
index a525771c5f..4763a59736 100644
--- a/tests/baselines/reference/APISample_jsdoc.js
+++ b/tests/baselines/reference/APISample_jsdoc.js
@@ -178,10 +178,10 @@ function getAnnotations(node) {
 }
 // these examples are artificial and mostly nonsensical
 function parseSpecificTags(node) {
-    if (node.kind === 166 /* ts.SyntaxKind.Parameter */) {
+    if (node.kind === ts.SyntaxKind.Parameter) {
         return ts.getJSDocParameterTags(node);
     }
-    if (node.kind === 259 /* ts.SyntaxKind.FunctionDeclaration */) {
+    if (node.kind === ts.SyntaxKind.FunctionDeclaration) {
         var func = node;
         if (ts.hasJSDocParameterTags(func)) {
             var flat = [];
@@ -195,11 +195,11 @@ function parseSpecificTags(node) {
     }
 }
 function getReturnTypeFromJSDoc(node) {
-    if (node.kind === 259 /* ts.SyntaxKind.FunctionDeclaration */) {
+    if (node.kind === ts.SyntaxKind.FunctionDeclaration) {
         return ts.getJSDocReturnType(node);
     }
     var type = ts.getJSDocType(node);
-    if (type && type.kind === 181 /* ts.SyntaxKind.FunctionType */) {
+    if (type && type.kind === ts.SyntaxKind.FunctionType) {
         return type.type;
     }
 }
diff --git a/tests/baselines/reference/APISample_linter.js b/tests/baselines/reference/APISample_linter.js
index 69eab7271e..185a346d3a 100644
--- a/tests/baselines/reference/APISample_linter.js
+++ b/tests/baselines/reference/APISample_linter.js
@@ -86,28 +86,28 @@ function delint(sourceFile) {
     delintNode(sourceFile);
     function delintNode(node) {
         switch (node.kind) {
-            case 245 /* ts.SyntaxKind.ForStatement */:
-            case 246 /* ts.SyntaxKind.ForInStatement */:
-            case 244 /* ts.SyntaxKind.WhileStatement */:
-            case 243 /* ts.SyntaxKind.DoStatement */:
-                if (node.statement.kind !== 238 /* ts.SyntaxKind.Block */) {
+            case ts.SyntaxKind.ForStatement:
+            case ts.SyntaxKind.ForInStatement:
+            case ts.SyntaxKind.WhileStatement:
+            case ts.SyntaxKind.DoStatement:
+                if (node.statement.kind !== ts.SyntaxKind.Block) {
                     report(node, "A looping statement's contents should be wrapped in a block body.");
                 }
                 break;
-            case 242 /* ts.SyntaxKind.IfStatement */:
+            case ts.SyntaxKind.IfStatement:
                 var ifStatement = node;
-                if (ifStatement.thenStatement.kind !== 238 /* ts.SyntaxKind.Block */) {
+                if (ifStatement.thenStatement.kind !== ts.SyntaxKind.Block) {
                     report(ifStatement.thenStatement, "An if statement's contents should be wrapped in a block body.");
                 }
                 if (ifStatement.elseStatement &&
-                    ifStatement.elseStatement.kind !== 238 /* ts.SyntaxKind.Block */ &&
-                    ifStatement.elseStatement.kind !== 242 /* ts.SyntaxKind.IfStatement */) {
+                    ifStatement.elseStatement.kind !== ts.SyntaxKind.Block &&
+                    ifStatement.elseStatement.kind !== ts.SyntaxKind.IfStatement) {
                     report(ifStatement.elseStatement, "An else statement's contents should be wrapped in a block body.");
                 }
                 break;
-            case 223 /* ts.SyntaxKind.BinaryExpression */:
+            case ts.SyntaxKind.BinaryExpression:
                 var op = node.operatorToken.kind;
-                if (op === 34 /* ts.SyntaxKind.EqualsEqualsToken */ || op == 35 /* ts.SyntaxKind.ExclamationEqualsToken */) {
+                if (op === ts.SyntaxKind.EqualsEqualsToken || op == ts.SyntaxKind.ExclamationEqualsToken) {
                     report(node, "Use '===' and '!=='.");
                 }
                 break;
@@ -123,7 +123,7 @@ exports.delint = delint;
 var fileNames = process.argv.slice(2);
 fileNames.forEach(function (fileName) {
     // Parse a file
-    var sourceFile = ts.createSourceFile(fileName, readFileSync(fileName).toString(), 2 /* ts.ScriptTarget.ES2015 */, /*setParentNodes */ true);
+    var sourceFile = ts.createSourceFile(fileName, readFileSync(fileName).toString(), ts.ScriptTarget.ES2015, /*setParentNodes */ true);
     // delint it
     delint(sourceFile);
 });
-- 
2.37.3

