From 0000000000000000000000000000000000000000 Mon Sep 17 00:00:00 2001
From: Jake Bailey <5341706+jakebailey@users.noreply.github.com>
Date: Fri, 2 Sep 2022 16:39:54 -0700
Subject: [PATCH] Add dts bundling

---
 .gitignore                                    |     1 +
 Gulpfile.js                                   |    38 +-
 scripts/dtsBundler.ts                         |   210 +
 src/compiler/commandLineParser.ts             |     2 +-
 src/compiler/factory/utilities.ts             |    11 +-
 src/compiler/moduleNameResolver.ts            |     8 +-
 src/compiler/parser.ts                        |     2 +-
 src/compiler/perfLogger.ts                    |    34 +-
 src/compiler/program.ts                       |     8 +-
 src/compiler/resolutionCache.ts               |     6 +-
 src/compiler/sys.ts                           |     4 +-
 src/compiler/tracing.ts                       |     9 +-
 src/compiler/transformers/classFields.ts      |     4 +-
 src/compiler/transformers/es2015.ts           |     4 +-
 src/compiler/transformers/es2016.ts           |     4 +-
 src/compiler/transformers/es2017.ts           |     3 +-
 src/compiler/transformers/es2018.ts           |     4 +-
 src/compiler/transformers/es2019.ts           |     3 +-
 src/compiler/transformers/es2020.ts           |     4 +-
 src/compiler/transformers/es2021.ts           |     4 +-
 src/compiler/transformers/es5.ts              |     3 +-
 src/compiler/transformers/esnext.ts           |     3 +-
 src/compiler/transformers/generators.ts       |     4 +-
 src/compiler/transformers/jsx.ts              |     4 +-
 src/compiler/transformers/legacyDecorators.ts |     4 +-
 .../transformers/module/esnextAnd2015.ts      |     4 +-
 src/compiler/transformers/module/module.ts    |     3 +-
 src/compiler/transformers/module/system.ts    |     4 +-
 src/compiler/transformers/taggedTemplate.ts   |     3 +-
 src/compiler/transformers/typeSerializer.ts   |     6 +-
 src/compiler/transformers/utilities.ts        |     4 +-
 src/compiler/tsbuildPublic.ts                 |     6 +-
 src/compiler/types.ts                         |    16 +-
 src/compiler/utilities.ts                     |     7 +-
 src/compiler/watchPublic.ts                   |     4 +-
 src/compiler/watchUtilities.ts                |     3 +-
 .../4.0/nodeFactoryTopLevelExports.ts         |   592 +-
 src/deprecatedCompat/deprecations.ts          |    81 +-
 src/server/editorServices.ts                  |     6 +-
 src/server/scriptVersionCache.ts              |    15 +-
 .../codefixes/annotateWithTypeFromJSDoc.ts    |     3 +-
 src/services/codefixes/generateAccessors.ts   |    19 +-
 src/services/codefixes/helpers.ts             |    10 +-
 src/services/completions.ts                   |    32 +-
 src/services/getEditsForFileRename.ts         |     8 +-
 src/services/organizeImports.ts               |     9 +-
 src/services/refactors/extractSymbol.ts       |    11 +-
 src/services/sourcemaps.ts                    |     2 +-
 src/services/symbolDisplay.ts                 |     3 +-
 src/services/textChanges.ts                   |     3 +-
 src/services/transform.ts                     |     5 +-
 src/tsserverlibrary/tsserverlibrary.ts        |     6 +-
 src/typescript/typescript.ts                  |     5 +-
 .../baselines/reference/APISample_compile.js  |     2 +-
 tests/baselines/reference/APISample_jsdoc.js  |     8 +-
 tests/baselines/reference/APISample_linter.js |    24 +-
 .../reference/api/tsserverlibrary.d.ts        | 10874 ++++++++--------
 tests/baselines/reference/api/typescript.d.ts |  3195 +++--
 58 files changed, 7649 insertions(+), 7705 deletions(-)
 create mode 100644 scripts/dtsBundler.ts

diff --git a/.gitignore b/.gitignore
index cdf20ba5a2..4ba9e15206 100644
--- a/.gitignore
+++ b/.gitignore
@@ -47,6 +47,7 @@ scripts/configurePrerelease.js
 scripts/configureLanguageServiceBuild.js
 scripts/open-user-pr.js
 scripts/open-cherry-pick-pr.js
+scripts/dtsBundler.js
 scripts/processDiagnosticMessages.d.ts
 scripts/processDiagnosticMessages.js
 scripts/produceLKG.js
diff --git a/Gulpfile.js b/Gulpfile.js
index 79939b403e..09494f331a 100644
--- a/Gulpfile.js
+++ b/Gulpfile.js
@@ -127,6 +127,15 @@ const buildSrc = () => buildProject("src");
 // But, if we are bundling, we are running only d.ts emit, so maybe this is fast?
 task("build-src", series(preSrc, buildSrc));
 
+/**
+ * @param {string} projectPath
+ * @param {string} entrypoint
+ * @param {string} output
+ */
+async function runDtsBundler(projectPath, entrypoint, output) {
+    await exec(process.execPath, ["./scripts/dtsBundler.js", projectPath, entrypoint, output]);
+}
+
 /** @type {string | undefined} */
 let copyrightHeader;
 function getCopyrightHeader() {
@@ -143,6 +152,7 @@ function getCopyrightHeader() {
  * @param {boolean} performanceMatters True if this is a bundle where performance matters, so should be optimized at the cost of build time.
  */
 function esbuildTask(entrypoint, outfile, exportIsTsObject = false, performanceMatters = false) {
+    performanceMatters = false;
     const preBabel = `${outfile}.tmp.js`;
 
     /** @type {esbuild.BuildOptions} */
@@ -251,10 +261,13 @@ const preBuild = cmdLineOptions.lkg ? lkgPreBuild : localPreBuild;
 const esbuildServices = esbuildTask("./src/typescript/typescript.ts", "./built/local/typescript.js", /* exportIsTsObject */ true, /* performanceMatters */ true);
 
 // TODO(jakebailey): rename this; no longer "services".
+
+const buildServicesProject = () => buildProject("src/typescript");
+
 const buildServices = () => {
     if (cmdLineOptions.bundle) return esbuildServices.build();
     writeCJSReexport("./built/local/typescript/typescript.js", "./built/local/typescript.js");
-    return buildProject("src/typescript");
+    return buildServicesProject();
 };
 
 task("services", series(preBuild, buildServices));
@@ -277,6 +290,9 @@ task("watch-services").flags = {
     "   --built": "Compile using the built version of the compiler."
 };
 
+const dtsServices = () => runDtsBundler("./src/typescript/tsconfig.json", "./built/local/typescript/typescript.d.ts", "./built/local/typescript.d.ts");
+task("dts-services", series(preBuild, buildServicesProject, dtsServices));
+task("dts-services").description = "Builds typescript.d.ts";
 
 const esbuildServer = esbuildTask("./src/tsserver/server.ts", "./built/local/tsserver.js", /* exportIsTsObject */ true, /* performanceMatters */ true);
 
@@ -323,10 +339,11 @@ task("watch-min").flags = {
 
 const esbuildLssl = esbuildTask("./src/tsserverlibrary/tsserverlibrary.ts", "./built/local/tsserverlibrary.js", /* exportIsTsObject */ true, /* performanceMatters */ true);
 
+const buildLsslProject = () => buildProject("src/tsserverlibrary");
 const buildLssl = () => {
     if (cmdLineOptions.bundle) return esbuildLssl.build();
     writeCJSReexport("./built/local/tsserverlibrary/tsserverlibrary.js", "./built/local/tsserverlibrary.js");
-    return buildProject("src/tsserverlibrary");
+    return buildLsslProject();
 };
 task("lssl", series(preBuild, buildLssl));
 task("lssl").description = "Builds language service server library";
@@ -348,6 +365,14 @@ task("watch-lssl").flags = {
     "   --built": "Compile using the built version of the compiler."
 };
 
+const dtsLssl = () => runDtsBundler("./src/tsserverlibrary/tsconfig.json", "./built/local/tsserverlibrary/tsserverlibrary.d.ts", "./built/local/tsserverlibrary.d.ts");
+task("dts-lssl", series(preBuild, buildLsslProject, dtsLssl));
+task("dts-lssl").description = "Builds tsserverlibrary.d.ts";
+
+// TODO(jakebailey): this is probably not efficient, but, gulp.
+const dts = series(preBuild, parallel(dtsServices, dtsLssl));
+task("dts", dts);
+
 const testRunner = "./built/local/run.js";
 const esbuildTests = esbuildTask("./src/testRunner/_namespaces/Harness.ts", testRunner);
 
@@ -458,7 +483,7 @@ const buildOtherOutputs = parallel(buildCancellationToken, buildTypingsInstaller
 task("other-outputs", series(preBuild, buildOtherOutputs));
 task("other-outputs").description = "Builds miscelaneous scripts and documents distributed with the LKG";
 
-task("local", series(preBuild, parallel(localize, buildTsc, buildServer, buildServices, buildLssl, buildOtherOutputs)));
+task("local", series(preBuild, parallel(localize, buildTsc, buildServer, buildServices, buildLssl, buildOtherOutputs, dts)));
 task("local").description = "Builds the full compiler and services";
 task("local").flags = {
     "   --built": "Compile using the built version of the compiler."
@@ -474,7 +499,7 @@ const preTest = parallel(buildTsc, buildTests, buildServices, buildLssl);
 preTest.displayName = "preTest";
 
 const runTests = () => runConsoleTests(testRunner, "mocha-fivemat-progress-reporter", /*runInParallel*/ false, /*watchMode*/ false);
-task("runtests", series(preBuild, preTest, runTests));
+task("runtests", series(preBuild, preTest, dts, runTests));
 task("runtests").description = "Runs the tests using the built run.js file.";
 task("runtests").flags = {
     "-t --tests=<regex>": "Pattern for tests to run.",
@@ -493,7 +518,7 @@ task("runtests").flags = {
 };
 
 const runTestsParallel = () => runConsoleTests(testRunner, "min", /*runInParallel*/ cmdLineOptions.workers > 1, /*watchMode*/ false);
-task("runtests-parallel", series(preBuild, preTest, runTestsParallel));
+task("runtests-parallel", series(preBuild, preTest, dts, runTestsParallel));
 task("runtests-parallel").description = "Runs all the tests in parallel using the built run.js file.";
 task("runtests-parallel").flags = {
     "   --light": "Run tests in light mode (fewer verifications, but tests run faster).",
@@ -597,8 +622,7 @@ const produceLKG = async () => {
     }
 };
 
-// TODO(jakebailey): dependencies on dts
-task("LKG", series(lkgPreBuild, parallel(localize, buildTsc, buildServer, buildServices, buildLssl, buildOtherOutputs), produceLKG));
+task("LKG", series(lkgPreBuild, parallel(localize, buildTsc, buildServer, buildServices, buildLssl, buildOtherOutputs, dts), produceLKG));
 task("LKG").description = "Makes a new LKG out of the built js files";
 task("LKG").flags = {
     "   --built": "Compile using the built version of the compiler.",
diff --git a/scripts/dtsBundler.ts b/scripts/dtsBundler.ts
new file mode 100644
index 0000000000..8c581b0fa1
--- /dev/null
+++ b/scripts/dtsBundler.ts
@@ -0,0 +1,210 @@
+/**
+ * WARNING: this is a very, very rudimentary d.ts bundler; it only works
+ * in the TS project thanks to our history using namespaces, which has
+ * prevented us from duplicating names across files, and allows us to
+ * bundle as namespaces again, even though the project is modules.
+ */
+
+import * as assert from "assert";
+import * as fs from "fs";
+import * as path from "path";
+import * as ts from "../lib/typescript";
+
+const [
+    projectPath,
+    entrypoint,
+    output,
+] = process.argv.slice(2);
+
+assert(projectPath);
+assert(entrypoint);
+assert(output);
+
+console.log(`Bundling ${entrypoint} to ${output}, using project ${projectPath}`);
+
+const newLineKind = ts.NewLineKind.LineFeed;
+const newLine = newLineKind === ts.NewLineKind.LineFeed ? "\n" : "\r\n";
+
+function isDeclarationStatement(node: ts.Node): node is ts.DeclarationStatement {
+    return (ts as any).isDeclarationStatement(node);
+}
+
+function isInternalDeclaration(node: ts.Node): boolean {
+    return (ts as any).isInternalDeclaration(node, node.getSourceFile());
+}
+
+function getParentVariableStatement(node: ts.VariableDeclaration): ts.VariableStatement {
+    const declarationList = node.parent as ts.VariableDeclarationList;
+    assert(ts.isVariableDeclarationList(declarationList), `expected VariableDeclarationList at ${nodeToLocation(node)}`);
+    assert(declarationList.declarations.length === 1, `expected VariableDeclarationList of length 1 at ${nodeToLocation(node)}`);
+    const variableStatement = declarationList.parent;
+    assert(ts.isVariableStatement(variableStatement), `expected VariableStatement at ${nodeToLocation(node)}`);
+    return variableStatement;
+}
+
+function getDeclarationStatement(node: ts.Declaration): ts.Statement | undefined {
+    if (ts.isVariableDeclaration(node)) {
+        return getParentVariableStatement(node);
+    }
+    else if (isDeclarationStatement(node)) {
+        return node;
+    }
+    return undefined;
+}
+
+const nullTransformationContext: ts.TransformationContext = (ts as any).nullTransformationContext;
+
+const tsconfigContents = ts.readJsonConfigFile(path.join(projectPath, "tsconfig.json"), ts.sys.readFile);
+const tsconfig = ts.parseJsonConfigFileContent(tsconfigContents, ts.sys, projectPath);
+const program = ts.createProgram([entrypoint], tsconfig.options);
+
+const typeChecker = program.getTypeChecker();
+
+const sourceFile = program.getSourceFile(entrypoint);
+assert(sourceFile);
+const moduleSymbol = typeChecker.getSymbolAtLocation(sourceFile);
+assert(moduleSymbol);
+
+const printer = ts.createPrinter({ newLine: newLineKind });
+
+
+const lines: string[] = [];
+const indent = "    ";
+let currentIndent = "";
+
+function increaseIndent() {
+    currentIndent += indent;
+}
+
+function decreaseIndent() {
+    currentIndent = currentIndent.slice(indent.length);
+}
+
+function write(s: string) {
+    if (!s) {
+        lines.push("");
+    }
+    else {
+        lines.push(...s.split(/\r?\n/).filter(line => line).map(line => (currentIndent + line).trimEnd()));
+    }
+}
+
+const containsPublicAPICache = new Map<ts.Symbol, boolean>();
+
+function containsPublicAPI(symbol: ts.Symbol): boolean {
+    const cached = containsPublicAPICache.get(symbol);
+    if (cached !== undefined) {
+        return cached;
+    }
+
+    const result = containsPublicAPIWorker();
+    containsPublicAPICache.set(symbol, result);
+    return result;
+
+    function containsPublicAPIWorker(): boolean {
+        if (!symbol.declarations?.length) {
+            return false;
+        }
+
+        if (symbol.flags & ts.SymbolFlags.Alias) {
+            const resolved = typeChecker.getAliasedSymbol(symbol);
+            return containsPublicAPI(resolved);
+        }
+
+        if (symbol.flags & ts.SymbolFlags.ValueModule) {
+            for (const me of typeChecker.getExportsOfModule(symbol)) {
+                if (containsPublicAPI(me)) {
+                    return true;
+                }
+            }
+            return false;
+        }
+
+        for (const decl of symbol.declarations) {
+            const statement = getDeclarationStatement(decl);
+            if (statement && !isInternalDeclaration(statement)) {
+                return true;
+            }
+        }
+
+        return false;
+    }
+}
+
+function nodeToLocation(decl: ts.Node): string {
+    const sourceFile = decl.getSourceFile();
+    const lc = sourceFile.getLineAndCharacterOfPosition(decl.pos);
+    return `${sourceFile.fileName}:${lc.line}:${lc.character}`;
+}
+
+function emitAsNamespace(name: string, moduleSymbol: ts.Symbol) {
+    assert(moduleSymbol.flags & ts.SymbolFlags.ValueModule);
+
+    if (name === "ts") {
+        // We will write `export = ts` at the end.
+        write(`declare namespace ${name} {`);
+    }
+    else {
+        write(`export namespace ${name} {`);
+    }
+    increaseIndent();
+
+    const moduleExports = typeChecker.getExportsOfModule(moduleSymbol);
+    for (const me of moduleExports) {
+        if (!containsPublicAPI(me)) {
+            continue;
+        }
+
+        assert(me.declarations?.length);
+
+        if (me.flags & ts.SymbolFlags.Alias) {
+            const resolved = typeChecker.getAliasedSymbol(me);
+            emitAsNamespace(me.name, resolved);
+            continue;
+        }
+
+        for (const decl of me.declarations) {
+            let statement = getDeclarationStatement(decl);
+
+            if (!statement) {
+                throw new Error(`Unhandled declaration for ${me.name} at ${nodeToLocation(decl)}`);
+            }
+
+            // Ignore an internal declaration.
+            if (isInternalDeclaration(statement)) {
+                continue;
+            }
+
+            // Remove internal components and declare/const keywords.
+            statement = ts.visitEachChild(statement, (node) => {
+                if (isInternalDeclaration(node)) {
+                    return undefined;
+                }
+
+                if (node.kind === ts.SyntaxKind.DeclareKeyword || node.kind === ts.SyntaxKind.ConstKeyword) {
+                    return undefined;
+                }
+
+                return node;
+            }, nullTransformationContext);
+
+            write(printer.printNode(ts.EmitHint.Unspecified, statement, decl.getSourceFile()));
+        }
+    }
+
+    decreaseIndent();
+    write(`}`);
+}
+
+emitAsNamespace("ts", moduleSymbol);
+
+write("export = ts;");
+
+const copyrightNotice = fs.readFileSync(path.join(__dirname, "..", "CopyrightNotice.txt"), "utf-8");
+const outputContents = copyrightNotice + lines.join(newLine);
+
+if (outputContents.includes("@internal")) {
+    console.error("Output includes untrimmed @internal nodes!");
+}
+
+fs.writeFileSync(output, outputContents);
diff --git a/src/compiler/commandLineParser.ts b/src/compiler/commandLineParser.ts
index 31dd774182..2ed978e2d6 100644
--- a/src/compiler/commandLineParser.ts
+++ b/src/compiler/commandLineParser.ts
@@ -2081,7 +2081,7 @@ function getTsconfigRootOptionsMap() {
 }
 
 /** @internal */
-interface JsonConversionNotifier {
+export interface JsonConversionNotifier {
     /**
      * Notifies parent option object is being set with the optionKey and a valid optionValue
      * Currently it notifies only if there is element with type object (parentOption) and
diff --git a/src/compiler/factory/utilities.ts b/src/compiler/factory/utilities.ts
index 010b996d7a..b6c97f8f3b 100644
--- a/src/compiler/factory/utilities.ts
+++ b/src/compiler/factory/utilities.ts
@@ -2,11 +2,12 @@ import {
     AccessorDeclaration, addEmitFlags, AdditiveOperator, AdditiveOperatorOrHigher, AssertionLevel,
     AssignmentOperatorOrHigher, BinaryExpression, BinaryOperator, BinaryOperatorToken, BindingOrAssignmentElement,
     BindingOrAssignmentElementRestIndicator, BindingOrAssignmentElementTarget, BindingOrAssignmentPattern,
-    BitwiseOperator, BitwiseOperatorOrHigher, BooleanLiteral, CharacterCodes, CommaListExpression,
+    BitwiseOperator, BitwiseOperatorOrHigher, Block, BooleanLiteral, CharacterCodes, CommaListExpression,
     compareStringsCaseSensitive, CompilerOptions, Debug, Declaration, EmitFlags, EmitHelperFactory, EmitHost,
     EmitResolver, EntityName, EqualityOperator, EqualityOperatorOrHigher, ExclamationToken, ExponentiationOperator,
     ExportDeclaration, Expression, ExpressionStatement, externalHelpersModuleNameText, first, firstOrUndefined,
     ForInitializer, GeneratedIdentifier, GeneratedIdentifierFlags, GeneratedNamePart, GeneratedPrivateIdentifier,
+    GetAccessorDeclaration,
     getAllAccessorDeclarations, getEmitFlags, getEmitHelpers, getEmitModuleKind, getESModuleInterop,
     getExternalModuleName, getExternalModuleNameFromPath, getJSDocType, getJSDocTypeTag, getModifiers,
     getNamespaceDeclarationNode, getOrCreateEmitNode, getOriginalNode, getParseTreeNode,
@@ -26,7 +27,7 @@ import {
     NumericLiteral, ObjectLiteralElementLike, ObjectLiteralExpression, or, OuterExpression, OuterExpressionKinds,
     outFile, parseNodeFactory, PlusToken, PostfixUnaryExpression, PrefixUnaryExpression, PrivateIdentifier,
     PropertyAssignment, PropertyDeclaration, PropertyName, pushIfUnique, QuestionToken, ReadonlyKeyword,
-    RelationalOperator, RelationalOperatorOrHigher, setOriginalNode, setParent, setStartsOnNewLine, setTextRange,
+    RelationalOperator, RelationalOperatorOrHigher, SetAccessorDeclaration, setOriginalNode, setParent, setStartsOnNewLine, setTextRange,
     ShiftOperator, ShiftOperatorOrHigher, ShorthandPropertyAssignment, some, SourceFile, Statement, StringLiteral,
     SyntaxKind, TextRange, ThisTypeNode, Token, TypeNode, TypeParameterDeclaration,
 } from "../_namespaces/ts";
@@ -185,7 +186,7 @@ export function createForOfBindingStatement(factory: NodeFactory, node: ForIniti
 }
 
 /** @internal */
-export function insertLeadingStatement(factory: NodeFactory, dest: Statement, source: Statement) {
+export function insertLeadingStatement(factory: NodeFactory, dest: Statement, source: Statement): Block {
     if (isBlock(dest)) {
         return factory.updateBlock(dest, setTextRange(factory.createNodeArray([source, ...dest.statements]), dest.statements));
     }
@@ -1456,7 +1457,7 @@ export function createAccessorPropertyBackingField(factory: NodeFactory, node: P
  *
  * @internal
  */
-export function createAccessorPropertyGetRedirector(factory: NodeFactory, node: PropertyDeclaration, modifiers: ModifiersArray | undefined, name: PropertyName) {
+export function createAccessorPropertyGetRedirector(factory: NodeFactory, node: PropertyDeclaration, modifiers: ModifiersArray | undefined, name: PropertyName): GetAccessorDeclaration {
     return factory.createGetAccessorDeclaration(
         modifiers,
         name,
@@ -1478,7 +1479,7 @@ export function createAccessorPropertyGetRedirector(factory: NodeFactory, node:
  *
  * @internal
  */
-export function createAccessorPropertySetRedirector(factory: NodeFactory, node: PropertyDeclaration, modifiers: ModifiersArray | undefined, name: PropertyName) {
+export function createAccessorPropertySetRedirector(factory: NodeFactory, node: PropertyDeclaration, modifiers: ModifiersArray | undefined, name: PropertyName): SetAccessorDeclaration {
     return factory.createSetAccessorDeclaration(
         modifiers,
         name,
diff --git a/src/compiler/moduleNameResolver.ts b/src/compiler/moduleNameResolver.ts
index f13d60743e..9e62af0806 100644
--- a/src/compiler/moduleNameResolver.ts
+++ b/src/compiler/moduleNameResolver.ts
@@ -128,7 +128,7 @@ function createResolvedModuleWithFailedLookupLocations(
 }
 
 /** @internal */
-interface ModuleResolutionState {
+export interface ModuleResolutionState {
     host: ModuleResolutionHost;
     compilerOptions: CompilerOptions;
     traceEnabled: boolean;
@@ -146,7 +146,7 @@ interface ModuleResolutionState {
  *
  * @internal
  */
-interface PackageJsonPathFields {
+export interface PackageJsonPathFields {
     typings?: string;
     types?: string;
     typesVersions?: MapLike<MapLike<string[]>>;
@@ -226,7 +226,7 @@ function readPackageJsonTypesVersionsField(jsonContent: PackageJson, state: Modu
 }
 
 /** @internal */
-interface VersionPaths {
+export interface VersionPaths {
     version: string;
     paths: MapLike<string[]>;
 }
@@ -1281,7 +1281,7 @@ export function resolveJSModule(moduleName: string, initialDir: string, host: Mo
 }
 
 /** @internal */
-enum NodeResolutionFeatures {
+export enum NodeResolutionFeatures {
     None = 0,
     // resolving `#local` names in your own package.json
     Imports = 1 << 1,
diff --git a/src/compiler/parser.ts b/src/compiler/parser.ts
index 24c32f7d24..804c65a975 100644
--- a/src/compiler/parser.ts
+++ b/src/compiler/parser.ts
@@ -9831,7 +9831,7 @@ export function processCommentPragmas(context: PragmaContext, sourceText: string
 }
 
 /** @internal */
-type PragmaDiagnosticReporter = (pos: number, length: number, message: DiagnosticMessage) => void;
+export type PragmaDiagnosticReporter = (pos: number, length: number, message: DiagnosticMessage) => void;
 
 /** @internal */
 export function processPragmasIntoFields(context: PragmaContext, reportDiagnostic: PragmaDiagnosticReporter): void {
diff --git a/src/compiler/perfLogger.ts b/src/compiler/perfLogger.ts
index 34a59208d6..41f33e0e2a 100644
--- a/src/compiler/perfLogger.ts
+++ b/src/compiler/perfLogger.ts
@@ -1,6 +1,38 @@
 import { noop } from "./_namespaces/ts";
 
-type PerfLogger = typeof import("@microsoft/typescript-etw");
+/** @internal */
+export interface PerfLogger {
+    logEvent(msg: string): void;
+    logErrEvent(msg: string): void;
+    logPerfEvent(msg: string): void;
+    logInfoEvent(msg: string): void;
+    logStartCommand(command: string, msg: string): void;
+    logStopCommand(command: string, msg: string): void;
+    logStartUpdateProgram(msg: string): void;
+    logStopUpdateProgram(msg: string): void;
+    logStartUpdateGraph(): void;
+    logStopUpdateGraph(): void;
+    logStartResolveModule(name: string): void;
+    logStopResolveModule(success: string): void;
+    logStartParseSourceFile(filename: string): void;
+    logStopParseSourceFile(): void;
+    logStartReadFile(filename: string): void;
+    logStopReadFile(): void;
+    logStartBindFile(filename: string): void;
+    logStopBindFile(): void;
+    logStartScheduledOperation(operationId: string): void;
+    logStopScheduledOperation(): void;
+}
+
+type ImportedPerfLogger = typeof import("@microsoft/typescript-etw");
+
+// Assert that our PerfLogger type is compatible with the library.
+// Doing this keeps the above import expression out of our emitted d.ts file.
+const _perfLoggerCorrectType: PerfLogger extends ImportedPerfLogger ? true : false = true;
+
+// eslint-disable-next-line @typescript-eslint/no-unused-expressions
+_perfLoggerCorrectType;
+
 const nullLogger: PerfLogger = {
     logEvent: noop,
     logErrEvent: noop,
diff --git a/src/compiler/program.ts b/src/compiler/program.ts
index 30a15b258d..bf6af85b0f 100644
--- a/src/compiler/program.ts
+++ b/src/compiler/program.ts
@@ -210,7 +210,7 @@ export function createCompilerHostWorker(options: CompilerOptions, setParentNode
 }
 
 /** @internal */
-interface CompilerHostLikeForCache {
+export interface CompilerHostLikeForCache {
     fileExists(fileName: string): boolean;
     readFile(fileName: string, encoding?: string): string | undefined;
     directoryExists?(directory: string): boolean;
@@ -570,7 +570,7 @@ export interface SourceFileImportsList {
  * Calculates the resulting resolution mode for some reference in some file - this is generally the explicitly
  * provided resolution mode in the reference, unless one is not present, in which case it is the mode of the containing file.
  */
-export function getModeForFileReference(ref: FileReference | string, containingFileMode: SourceFile["impliedNodeFormat"]) {
+export function getModeForFileReference(ref: FileReference | string, containingFileMode: SourceFile["impliedNodeFormat"]): ModuleKind.CommonJS | ModuleKind.ESNext | undefined {
     return (isString(ref) ? containingFileMode : ref.resolutionMode) || containingFileMode;
 }
 
@@ -612,7 +612,7 @@ export function isExclusivelyTypeOnlyImportOrExport(decl: ImportDeclaration | Ex
  * @param usage The module reference string
  * @returns The final resolution mode of the import
  */
-export function getModeForUsageLocation(file: {impliedNodeFormat?: SourceFile["impliedNodeFormat"]}, usage: StringLiteralLike) {
+export function getModeForUsageLocation(file: {impliedNodeFormat?: SourceFile["impliedNodeFormat"]}, usage: StringLiteralLike): ModuleKind.CommonJS | ModuleKind.ESNext | undefined {
     if (file.impliedNodeFormat === undefined) return undefined;
     if ((isImportDeclaration(usage.parent) || isExportDeclaration(usage.parent))) {
         const isTypeOnly = isExclusivelyTypeOnlyImportOrExport(usage.parent);
@@ -4318,7 +4318,7 @@ export function filterSemanticDiagnostics(diagnostic: readonly Diagnostic[], opt
 }
 
 /** @internal */
-interface CompilerHostLike {
+export interface CompilerHostLike {
     useCaseSensitiveFileNames(): boolean;
     getCurrentDirectory(): string;
     fileExists(fileName: string): boolean;
diff --git a/src/compiler/resolutionCache.ts b/src/compiler/resolutionCache.ts
index a6cce70e78..103676d271 100644
--- a/src/compiler/resolutionCache.ts
+++ b/src/compiler/resolutionCache.ts
@@ -51,7 +51,8 @@ export interface ResolutionCache {
     clear(): void;
 }
 
-interface ResolutionWithFailedLookupLocations {
+/** @internal */
+export interface ResolutionWithFailedLookupLocations {
     readonly failedLookupLocations: string[];
     readonly affectingLocations: string[];
     isInvalidated?: boolean;
@@ -65,7 +66,8 @@ interface ResolutionWithResolvedFileName {
     packagetId?: PackageId;
 }
 
-interface CachedResolvedModuleWithFailedLookupLocations extends ResolvedModuleWithFailedLookupLocations, ResolutionWithFailedLookupLocations {
+/** @internal */
+export interface CachedResolvedModuleWithFailedLookupLocations extends ResolvedModuleWithFailedLookupLocations, ResolutionWithFailedLookupLocations {
 }
 
 interface CachedResolvedTypeReferenceDirectiveWithFailedLookupLocations extends ResolvedTypeReferenceDirectiveWithFailedLookupLocations, ResolutionWithFailedLookupLocations {
diff --git a/src/compiler/sys.ts b/src/compiler/sys.ts
index 7f463fd88b..fce13ef242 100644
--- a/src/compiler/sys.ts
+++ b/src/compiler/sys.ts
@@ -1262,7 +1262,7 @@ export function patchWriteFileEnsuringDirectory(sys: System) {
 export type BufferEncoding = "ascii" | "utf8" | "utf-8" | "utf16le" | "ucs2" | "ucs-2" | "base64" | "latin1" | "binary" | "hex";
 
 /** @internal */
-interface NodeBuffer extends Uint8Array {
+export interface NodeBuffer extends Uint8Array {
     constructor: any;
     write(str: string, encoding?: BufferEncoding): number;
     write(str: string, offset: number, encoding?: BufferEncoding): number;
@@ -1338,7 +1338,7 @@ interface NodeBuffer extends Uint8Array {
 }
 
 /** @internal */
-interface Buffer extends NodeBuffer { }
+export interface Buffer extends NodeBuffer { }
 
 // TODO: GH#18217 Methods on System are often used as if they are certainly defined
 export interface System {
diff --git a/src/compiler/tracing.ts b/src/compiler/tracing.ts
index 087a86cf18..3ddf6e3470 100644
--- a/src/compiler/tracing.ts
+++ b/src/compiler/tracing.ts
@@ -13,8 +13,13 @@ import {
 export let tracing: typeof tracingEnabled | undefined;
 // enable the above using startTracing()
 
-// `tracingEnabled` should never be used directly, only through the above
-namespace tracingEnabled { // eslint-disable-line local/one-namespace-per-file
+
+/**
+ * `tracingEnabled` should never be used directly, only through the above
+ *
+ * @internal
+ */
+export namespace tracingEnabled { // eslint-disable-line local/one-namespace-per-file
     type Mode = "project" | "build" | "server";
 
     let fs: typeof import("fs");
diff --git a/src/compiler/transformers/classFields.ts b/src/compiler/transformers/classFields.ts
index 5141d77afc..28be1f5f87 100644
--- a/src/compiler/transformers/classFields.ts
+++ b/src/compiler/transformers/classFields.ts
@@ -33,7 +33,7 @@ import {
     startOnNewLine, Statement, SuperProperty, SyntaxKind, TaggedTemplateExpression, ThisExpression,
     TransformationContext, TransformFlags, tryGetTextOfPropertyName, UnderscoreEscapedMap, unescapeLeadingUnderscores,
     VariableStatement, visitArray, visitEachChild, visitFunctionBody, visitIterationBody, visitNode, visitNodes,
-    visitParameterList, VisitResult,
+    visitParameterList, VisitResult, Bundle,
 } from "../_namespaces/ts";
 
 const enum ClassPropertySubstitutionFlags {
@@ -168,7 +168,7 @@ const enum ClassFacts {
  *
  * @internal
  */
-export function transformClassFields(context: TransformationContext) {
+export function transformClassFields(context: TransformationContext): (x: SourceFile | Bundle) => SourceFile | Bundle {
     const {
         factory,
         hoistVariableDeclaration,
diff --git a/src/compiler/transformers/es2015.ts b/src/compiler/transformers/es2015.ts
index a9d33f2d4c..db01bdeec4 100644
--- a/src/compiler/transformers/es2015.ts
+++ b/src/compiler/transformers/es2015.ts
@@ -33,7 +33,7 @@ import {
     SyntaxKind, TaggedTemplateExpression, takeWhile, TemplateExpression, TextRange, TokenFlags, TransformationContext,
     TransformFlags, tryCast, unescapeLeadingUnderscores, unwrapInnermostStatementOfLabel, VariableDeclaration,
     VariableDeclarationList, VariableStatement, visitEachChild, visitNode, visitNodes, visitParameterList, VisitResult,
-    VoidExpression, WhileStatement, YieldExpression,
+    VoidExpression, WhileStatement, YieldExpression, Bundle,
 } from "../_namespaces/ts";
 
 const enum ES2015SubstitutionFlags {
@@ -299,7 +299,7 @@ function createSpreadSegment(kind: SpreadSegmentKind, expression: Expression): S
 }
 
 /** @internal */
-export function transformES2015(context: TransformationContext) {
+export function transformES2015(context: TransformationContext): (x: SourceFile | Bundle) => SourceFile | Bundle {
     const {
         factory,
         getEmitHelperFactory: emitHelpers,
diff --git a/src/compiler/transformers/es2016.ts b/src/compiler/transformers/es2016.ts
index 0d4b95afa8..ca3bbbb980 100644
--- a/src/compiler/transformers/es2016.ts
+++ b/src/compiler/transformers/es2016.ts
@@ -1,11 +1,11 @@
 import {
-    BinaryExpression, chainBundle, Expression, isElementAccessExpression, isExpression, isPropertyAccessExpression,
+    BinaryExpression, Bundle, chainBundle, Expression, isElementAccessExpression, isExpression, isPropertyAccessExpression,
     Node, setTextRange, SourceFile, SyntaxKind, TransformationContext, TransformFlags, visitEachChild, visitNode,
     VisitResult,
 } from "../_namespaces/ts";
 
 /** @internal */
-export function transformES2016(context: TransformationContext) {
+export function transformES2016(context: TransformationContext): (x: SourceFile | Bundle) => SourceFile | Bundle {
     const {
         factory,
         hoistVariableDeclaration
diff --git a/src/compiler/transformers/es2017.ts b/src/compiler/transformers/es2017.ts
index 193eea75be..3f36d8c450 100644
--- a/src/compiler/transformers/es2017.ts
+++ b/src/compiler/transformers/es2017.ts
@@ -15,6 +15,7 @@ import {
     TypeReferenceSerializationKind, unescapeLeadingUnderscores, VariableDeclaration, VariableDeclarationList,
     VariableStatement, visitEachChild, visitFunctionBody, visitIterationBody, visitNode, visitNodes, visitParameterList,
     VisitResult,
+    Bundle,
 } from "../_namespaces/ts";
 
 type SuperContainer = ClassDeclaration | MethodDeclaration | GetAccessorDeclaration | SetAccessorDeclaration | ConstructorDeclaration;
@@ -30,7 +31,7 @@ const enum ContextFlags {
 }
 
 /** @internal */
-export function transformES2017(context: TransformationContext) {
+export function transformES2017(context: TransformationContext): (x: SourceFile | Bundle) => SourceFile | Bundle {
     const {
         factory,
         getEmitHelperFactory: emitHelpers,
diff --git a/src/compiler/transformers/es2018.ts b/src/compiler/transformers/es2018.ts
index ee7f2cbc93..d45f5a37b4 100644
--- a/src/compiler/transformers/es2018.ts
+++ b/src/compiler/transformers/es2018.ts
@@ -17,7 +17,7 @@ import {
     SourceFile, startOnNewLine, Statement, SyntaxKind, TaggedTemplateExpression, TextRange, Token,
     TransformationContext, TransformFlags, unwrapInnermostStatementOfLabel, VariableDeclaration, VariableStatement,
     visitEachChild, visitIterationBody, visitLexicalEnvironment, visitNode, visitNodes, visitParameterList, VisitResult,
-    VoidExpression, YieldExpression,
+    VoidExpression, YieldExpression, Bundle,
 } from "../_namespaces/ts";
 
 const enum ESNextSubstitutionFlags {
@@ -58,7 +58,7 @@ const enum HierarchyFacts {
 }
 
 /** @internal */
-export function transformES2018(context: TransformationContext) {
+export function transformES2018(context: TransformationContext): (x: SourceFile | Bundle) => SourceFile | Bundle {
     const {
         factory,
         getEmitHelperFactory: emitHelpers,
diff --git a/src/compiler/transformers/es2019.ts b/src/compiler/transformers/es2019.ts
index 921a2ea33d..eaeb2f19d5 100644
--- a/src/compiler/transformers/es2019.ts
+++ b/src/compiler/transformers/es2019.ts
@@ -1,10 +1,11 @@
 import {
+    Bundle,
     CatchClause, chainBundle, isBlock, Node, SourceFile, SyntaxKind, TransformationContext, TransformFlags,
     visitEachChild, visitNode, VisitResult,
 } from "../_namespaces/ts";
 
 /** @internal */
-export function transformES2019(context: TransformationContext) {
+export function transformES2019(context: TransformationContext): (x: SourceFile | Bundle) => SourceFile | Bundle {
     const factory = context.factory;
     return chainBundle(context, transformSourceFile);
 
diff --git a/src/compiler/transformers/es2020.ts b/src/compiler/transformers/es2020.ts
index 79be9cae32..ec48ca9433 100644
--- a/src/compiler/transformers/es2020.ts
+++ b/src/compiler/transformers/es2020.ts
@@ -1,5 +1,5 @@
 import {
-    AccessExpression, addEmitFlags, BinaryExpression, CallExpression, cast, chainBundle, Debug, DeleteExpression,
+    AccessExpression, addEmitFlags, BinaryExpression, Bundle, CallExpression, cast, chainBundle, Debug, DeleteExpression,
     EmitFlags, Expression, isCallChain, isExpression, isGeneratedIdentifier, isIdentifier, isNonNullChain,
     isOptionalChain, isParenthesizedExpression, isSimpleCopiableExpression, isSyntheticReference,
     isTaggedTemplateExpression, Node, OptionalChain, OuterExpressionKinds, ParenthesizedExpression, setOriginalNode,
@@ -8,7 +8,7 @@ import {
 } from "../_namespaces/ts";
 
 /** @internal */
-export function transformES2020(context: TransformationContext) {
+export function transformES2020(context: TransformationContext): (x: SourceFile | Bundle) => SourceFile | Bundle {
     const {
         factory,
         hoistVariableDeclaration,
diff --git a/src/compiler/transformers/es2021.ts b/src/compiler/transformers/es2021.ts
index 68ce3c81c4..a63e4688a7 100644
--- a/src/compiler/transformers/es2021.ts
+++ b/src/compiler/transformers/es2021.ts
@@ -1,5 +1,5 @@
 import {
-    AssignmentExpression, BinaryExpression, chainBundle, getNonAssignmentOperatorForCompoundAssignment,
+    AssignmentExpression, BinaryExpression, Bundle, chainBundle, getNonAssignmentOperatorForCompoundAssignment,
     isAccessExpression, isExpression, isLeftHandSideExpression, isLogicalOrCoalescingAssignmentExpression,
     isPropertyAccessExpression, isSimpleCopiableExpression, LogicalOrCoalescingAssignmentOperator, Node,
     skipParentheses, SourceFile, SyntaxKind, Token, TransformationContext, TransformFlags, visitEachChild, visitNode,
@@ -7,7 +7,7 @@ import {
 } from "../_namespaces/ts";
 
 /** @internal */
-export function transformES2021(context: TransformationContext) {
+export function transformES2021(context: TransformationContext): (x: SourceFile | Bundle) => SourceFile | Bundle {
     const {
         hoistVariableDeclaration,
         factory
diff --git a/src/compiler/transformers/es5.ts b/src/compiler/transformers/es5.ts
index cd7eb47d1e..8dd340255a 100644
--- a/src/compiler/transformers/es5.ts
+++ b/src/compiler/transformers/es5.ts
@@ -1,4 +1,5 @@
 import {
+    Bundle,
     chainBundle, EmitHint, Expression, getOriginalNodeId, Identifier, idText, isIdentifier, isPrivateIdentifier,
     isPropertyAccessExpression, isPropertyAssignment, JsxClosingElement, JsxEmit, JsxOpeningElement,
     JsxSelfClosingElement, Node, nodeIsSynthesized, PropertyAccessExpression, PropertyAssignment, setTextRange,
@@ -12,7 +13,7 @@ import {
  *
  * @internal
  */
-export function transformES5(context: TransformationContext) {
+export function transformES5(context: TransformationContext): (x: SourceFile | Bundle) => SourceFile | Bundle {
     const { factory } = context;
     const compilerOptions = context.getCompilerOptions();
 
diff --git a/src/compiler/transformers/esnext.ts b/src/compiler/transformers/esnext.ts
index 9cc1b5e739..770153e4e6 100644
--- a/src/compiler/transformers/esnext.ts
+++ b/src/compiler/transformers/esnext.ts
@@ -1,9 +1,10 @@
 import {
+    Bundle,
     chainBundle, Node, SourceFile, TransformationContext, TransformFlags, visitEachChild, VisitResult,
 } from "../_namespaces/ts";
 
 /** @internal */
-export function transformESNext(context: TransformationContext) {
+export function transformESNext(context: TransformationContext): (x: SourceFile | Bundle) => SourceFile | Bundle {
   return chainBundle(context, transformSourceFile);
 
   function transformSourceFile(node: SourceFile) {
diff --git a/src/compiler/transformers/generators.ts b/src/compiler/transformers/generators.ts
index 9c62a751da..ef5550a83a 100644
--- a/src/compiler/transformers/generators.ts
+++ b/src/compiler/transformers/generators.ts
@@ -1,6 +1,6 @@
 import {
     AccessorDeclaration, addEmitHelpers, addSyntheticTrailingComment, ArrayLiteralExpression, Associativity,
-    BinaryExpression, Block, BreakStatement, CallExpression, CaseClause, chainBundle, CommaListExpression,
+    BinaryExpression, Block, BreakStatement, Bundle, CallExpression, CaseClause, chainBundle, CommaListExpression,
     ConditionalExpression, ContinueStatement, createExpressionForObjectLiteralElementLike, Debug, DoStatement,
     ElementAccessExpression, EmitFlags, EmitHint, ESMap, Expression, ExpressionStatement, forEach, ForInStatement,
     ForStatement, FunctionDeclaration, FunctionExpression, getEmitFlags, getEmitScriptTarget,
@@ -247,7 +247,7 @@ function getInstructionName(instruction: Instruction): string {
 }
 
 /** @internal */
-export function transformGenerators(context: TransformationContext) {
+export function transformGenerators(context: TransformationContext): (x: SourceFile | Bundle) => SourceFile | Bundle {
     const {
         factory,
         getEmitHelperFactory: emitHelpers,
diff --git a/src/compiler/transformers/jsx.ts b/src/compiler/transformers/jsx.ts
index 5e02c2ce92..37152cfe6a 100644
--- a/src/compiler/transformers/jsx.ts
+++ b/src/compiler/transformers/jsx.ts
@@ -1,5 +1,5 @@
 import {
-    addEmitHelpers, arrayFrom, chainBundle, createExpressionForJsxElement, createExpressionForJsxFragment,
+    addEmitHelpers, arrayFrom, Bundle, chainBundle, createExpressionForJsxElement, createExpressionForJsxFragment,
     createExpressionFromEntityName, createJsxFactoryExpression, Debug, emptyArray, Expression, filter, find, flatten,
     GeneratedIdentifierFlags, getEmitScriptTarget, getEntries, getJSXImplicitImportBase, getJSXRuntimeImport,
     getLineAndCharacterOfPosition, getOriginalNode, getSemanticJsxChildren, Identifier, idText, ImportSpecifier,
@@ -14,7 +14,7 @@ import {
 } from "../_namespaces/ts";
 
 /** @internal */
-export function transformJsx(context: TransformationContext) {
+export function transformJsx(context: TransformationContext): (x: SourceFile | Bundle) => SourceFile | Bundle {
     interface PerFileState {
         importSpecifier?: string;
         filenameDeclaration?: VariableDeclaration & { name: Identifier; };
diff --git a/src/compiler/transformers/legacyDecorators.ts b/src/compiler/transformers/legacyDecorators.ts
index 52ddcf5a62..be6c0615ee 100644
--- a/src/compiler/transformers/legacyDecorators.ts
+++ b/src/compiler/transformers/legacyDecorators.ts
@@ -1,5 +1,5 @@
 import {
-    addEmitHelpers, addRange, AllDecorators, append, canHaveDecorators, chainBundle, childIsDecorated, ClassDeclaration,
+    addEmitHelpers, addRange, AllDecorators, append, Bundle, canHaveDecorators, chainBundle, childIsDecorated, ClassDeclaration,
     ClassElement, ClassExpression, ClassLikeDeclaration, classOrConstructorParameterIsDecorated, ConstructorDeclaration,
     Decorator, elideNodes, EmitFlags, EmitHint, EnumMember, Expression, filter, flatMap, GetAccessorDeclaration,
     getAllDecoratorsOfClass, getAllDecoratorsOfClassElement, getEmitFlags, getEmitScriptTarget, getOriginalNodeId,
@@ -14,7 +14,7 @@ import {
 } from "../_namespaces/ts";
 
 /** @internal */
-export function transformLegacyDecorators(context: TransformationContext) {
+export function transformLegacyDecorators(context: TransformationContext): (x: SourceFile | Bundle) => SourceFile | Bundle {
     const {
         factory,
         getEmitHelperFactory: emitHelpers,
diff --git a/src/compiler/transformers/module/esnextAnd2015.ts b/src/compiler/transformers/module/esnextAnd2015.ts
index ead5ee8eea..ec9d36cc2e 100644
--- a/src/compiler/transformers/module/esnextAnd2015.ts
+++ b/src/compiler/transformers/module/esnextAnd2015.ts
@@ -1,5 +1,5 @@
 import {
-    addRange, append, chainBundle, createEmptyExports, createExternalHelpersImportDeclarationIfNeeded, Debug, EmitFlags,
+    addRange, append, Bundle, chainBundle, createEmptyExports, createExternalHelpersImportDeclarationIfNeeded, Debug, EmitFlags,
     EmitHint, ESMap, ExportAssignment, ExportDeclaration, Expression, GeneratedIdentifierFlags, getEmitFlags,
     getEmitModuleKind, getEmitScriptTarget, getExternalModuleNameLiteral, hasSyntacticModifier, Identifier, idText,
     ImportDeclaration, ImportEqualsDeclaration, insertStatementsAfterCustomPrologue,
@@ -10,7 +10,7 @@ import {
 } from "../../_namespaces/ts";
 
 /** @internal */
-export function transformECMAScriptModule(context: TransformationContext) {
+export function transformECMAScriptModule(context: TransformationContext): (x: SourceFile | Bundle) => SourceFile | Bundle {
     const {
         factory,
         getEmitHelperFactory: emitHelpers,
diff --git a/src/compiler/transformers/module/module.ts b/src/compiler/transformers/module/module.ts
index 0b9c5ad57b..cb3b73b777 100644
--- a/src/compiler/transformers/module/module.ts
+++ b/src/compiler/transformers/module/module.ts
@@ -1,5 +1,6 @@
 import {
     addEmitFlags, addEmitHelper, addEmitHelpers, addRange, append, ArrowFunction, BinaryExpression, BindingElement,
+    Bundle,
     CallExpression, chainBundle, ClassDeclaration, collectExternalModuleInfo, Debug, Declaration,
     DestructuringAssignment, EmitFlags, EmitHelper, EmitHint, emptyArray, EndOfDeclarationMarker, ExportAssignment,
     ExportDeclaration, Expression, ExpressionStatement, ExternalModuleInfo, firstOrUndefined,
@@ -27,7 +28,7 @@ import {
 } from "../../_namespaces/ts";
 
 /** @internal */
-export function transformModule(context: TransformationContext) {
+export function transformModule(context: TransformationContext): (x: SourceFile | Bundle) => SourceFile | Bundle {
     interface AsynchronousDependencies {
         aliasedModuleNames: Expression[];
         unaliasedModuleNames: Expression[];
diff --git a/src/compiler/transformers/module/system.ts b/src/compiler/transformers/module/system.ts
index 977d7efdfa..a6e9e90d2b 100644
--- a/src/compiler/transformers/module/system.ts
+++ b/src/compiler/transformers/module/system.ts
@@ -1,5 +1,5 @@
 import {
-    addRange, append, BinaryExpression, BindingElement, Block, CaseBlock, CaseClause, CaseOrDefaultClause, CatchClause,
+    addRange, append, BinaryExpression, BindingElement, Block, Bundle, CaseBlock, CaseClause, CaseOrDefaultClause, CatchClause,
     chainBundle, ClassDeclaration, collectExternalModuleInfo, Debug, Declaration, DefaultClause,
     DestructuringAssignment, DoStatement, EmitFlags, EmitHint, EndOfDeclarationMarker, ExportAssignment,
     ExportDeclaration, Expression, ExpressionStatement, ExternalModuleInfo, firstOrUndefined,
@@ -25,7 +25,7 @@ import {
 } from "../../_namespaces/ts";
 
 /** @internal */
-export function transformSystemModule(context: TransformationContext) {
+export function transformSystemModule(context: TransformationContext): (x: SourceFile | Bundle) => SourceFile | Bundle {
     interface DependencyGroup {
         name: StringLiteral;
         externalImports: (ImportDeclaration | ImportEqualsDeclaration | ExportDeclaration)[];
diff --git a/src/compiler/transformers/taggedTemplate.ts b/src/compiler/transformers/taggedTemplate.ts
index ffce659146..dddd501043 100644
--- a/src/compiler/transformers/taggedTemplate.ts
+++ b/src/compiler/transformers/taggedTemplate.ts
@@ -1,4 +1,5 @@
 import {
+    CallExpression,
     Debug, Expression, factory, getSourceTextOfNodeFromSourceFile, hasInvalidEscape, Identifier, isExpression,
     isExternalModule, isNoSubstitutionTemplateLiteral, NoSubstitutionTemplateLiteral, setTextRange, SourceFile,
     SyntaxKind, TaggedTemplateExpression, TemplateHead, TemplateLiteralLikeNode, TemplateMiddle, TemplateTail,
@@ -18,7 +19,7 @@ export function processTaggedTemplateExpression(
     visitor: Visitor,
     currentSourceFile: SourceFile,
     recordTaggedTemplateString: (temp: Identifier) => void,
-    level: ProcessLevel) {
+    level: ProcessLevel): TaggedTemplateExpression | CallExpression {
 
     // Visit the tag expression
     const tag = visitNode(node.tag, visitor, isExpression);
diff --git a/src/compiler/transformers/typeSerializer.ts b/src/compiler/transformers/typeSerializer.ts
index 7548d159c5..98a97b54bb 100644
--- a/src/compiler/transformers/typeSerializer.ts
+++ b/src/compiler/transformers/typeSerializer.ts
@@ -14,14 +14,16 @@ import {
     VoidExpression,
 } from "../_namespaces/ts";
 
-type SerializedEntityName =
+/** @internal */
+export type SerializedEntityName =
     | Identifier // Globals (i.e., `String`, `Number`, etc.)
  // Globals (i.e., `String`, `Number`, etc.)
     | PropertyAccessEntityNameExpression // `A.B`
  // `A.B`
     ;
 
-type SerializedTypeNode =
+/** @internal */
+export type SerializedTypeNode =
     | SerializedEntityName
     | ConditionalExpression // Type Reference or Global fallback
  // Type Reference or Global fallback
diff --git a/src/compiler/transformers/utilities.ts b/src/compiler/transformers/utilities.ts
index 4460f4fc45..862bdf7c8b 100644
--- a/src/compiler/transformers/utilities.ts
+++ b/src/compiler/transformers/utilities.ts
@@ -12,7 +12,7 @@ import {
     isPrivateIdentifier, isPropertyDeclaration, isStatic, isStringLiteralLike, isSuperCall, LogicalOperatorOrHigher,
     map, Map, MethodDeclaration, ModifierFlags, NamedImportBindings, NamespaceExport, Node, NodeArray,
     parameterIsThisKeyword, PrivateIdentifierAccessorDeclaration, PrivateIdentifierAutoAccessorPropertyDeclaration,
-    PrivateIdentifierMethodDeclaration, PropertyDeclaration, skipParentheses, some, SourceFile, Statement, SyntaxKind,
+    PrivateIdentifierMethodDeclaration, PropertyDeclaration, skipParentheses, some, SourceFile, Statement, SuperCall, SyntaxKind,
     TransformationContext, VariableDeclaration, VariableStatement,
 } from "../_namespaces/ts";
 
@@ -332,7 +332,7 @@ export function getNonAssignmentOperatorForCompoundAssignment(kind: CompoundAssi
  *
  * @internal
  */
-export function getSuperCallFromStatement(statement: Statement) {
+export function getSuperCallFromStatement(statement: Statement): SuperCall | undefined {
     if (!isExpressionStatement(statement)) {
         return undefined;
     }
diff --git a/src/compiler/tsbuildPublic.ts b/src/compiler/tsbuildPublic.ts
index 3bdfe22993..463a9a217a 100644
--- a/src/compiler/tsbuildPublic.ts
+++ b/src/compiler/tsbuildPublic.ts
@@ -194,7 +194,7 @@ export function createBuilderStatusReporter(system: System, pretty?: boolean): D
     };
 }
 
-function createSolutionBuilderHostBase<T extends BuilderProgram>(system: System, createProgram: CreateProgram<T> | undefined, reportDiagnostic?: DiagnosticReporter, reportSolutionBuilderStatus?: DiagnosticReporter) {
+function createSolutionBuilderHostBase<T extends BuilderProgram>(system: System, createProgram: CreateProgram<T> | undefined, reportDiagnostic?: DiagnosticReporter, reportSolutionBuilderStatus?: DiagnosticReporter): SolutionBuilderHostBase<T> {
     const host = createProgramHost(system, createProgram) as SolutionBuilderHostBase<T>;
     host.getModifiedTime = system.getModifiedTime ? path => system.getModifiedTime!(path) : returnUndefined;
     host.setModifiedTime = system.setModifiedTime ? (path, date) => system.setModifiedTime!(path, date) : noop;
@@ -205,13 +205,13 @@ function createSolutionBuilderHostBase<T extends BuilderProgram>(system: System,
     return host;
 }
 
-export function createSolutionBuilderHost<T extends BuilderProgram = EmitAndSemanticDiagnosticsBuilderProgram>(system = sys, createProgram?: CreateProgram<T>, reportDiagnostic?: DiagnosticReporter, reportSolutionBuilderStatus?: DiagnosticReporter, reportErrorSummary?: ReportEmitErrorSummary) {
+export function createSolutionBuilderHost<T extends BuilderProgram = EmitAndSemanticDiagnosticsBuilderProgram>(system: System = sys, createProgram?: CreateProgram<T>, reportDiagnostic?: DiagnosticReporter, reportSolutionBuilderStatus?: DiagnosticReporter, reportErrorSummary?: ReportEmitErrorSummary): SolutionBuilderHost<T> {
     const host = createSolutionBuilderHostBase(system, createProgram, reportDiagnostic, reportSolutionBuilderStatus) as SolutionBuilderHost<T>;
     host.reportErrorSummary = reportErrorSummary;
     return host;
 }
 
-export function createSolutionBuilderWithWatchHost<T extends BuilderProgram = EmitAndSemanticDiagnosticsBuilderProgram>(system = sys, createProgram?: CreateProgram<T>, reportDiagnostic?: DiagnosticReporter, reportSolutionBuilderStatus?: DiagnosticReporter, reportWatchStatus?: WatchStatusReporter) {
+export function createSolutionBuilderWithWatchHost<T extends BuilderProgram = EmitAndSemanticDiagnosticsBuilderProgram>(system: System = sys, createProgram?: CreateProgram<T>, reportDiagnostic?: DiagnosticReporter, reportSolutionBuilderStatus?: DiagnosticReporter, reportWatchStatus?: WatchStatusReporter): SolutionBuilderWithWatchHost<T> {
     const host = createSolutionBuilderHostBase(system, createProgram, reportDiagnostic, reportSolutionBuilderStatus) as SolutionBuilderWithWatchHost<T>;
     const watchHost = createWatchHost(system, reportWatchStatus);
     copyProperties(host, watchHost);
diff --git a/src/compiler/types.ts b/src/compiler/types.ts
index 638abe01cc..c67350b23f 100644
--- a/src/compiler/types.ts
+++ b/src/compiler/types.ts
@@ -5085,7 +5085,7 @@ export interface SymbolWalker {
 
 // This was previously deprecated in our public API, but is still used internally
 /** @internal */
-interface SymbolWriter extends SymbolTracker {
+export interface SymbolWriter extends SymbolTracker {
     writeKeyword(text: string): void;
     writeOperator(text: string): void;
     writePunctuation(text: string): void;
@@ -9234,7 +9234,7 @@ export const enum PragmaKindFlags {
 }
 
 /** @internal */
-interface PragmaArgumentSpecification<TName extends string> {
+export interface PragmaArgumentSpecification<TName extends string> {
     name: TName; // Determines the name of the key in the resulting parsed type, type parameter to cause literal type inference
     optional?: boolean;
     captureSpan?: boolean;
@@ -9298,20 +9298,20 @@ export const commentPragmas = {
 } as const;
 
 /** @internal */
-type PragmaArgTypeMaybeCapture<TDesc> = TDesc extends {captureSpan: true} ? {value: string, pos: number, end: number} : string;
+export type PragmaArgTypeMaybeCapture<TDesc> = TDesc extends {captureSpan: true} ? {value: string, pos: number, end: number} : string;
 
 /** @internal */
-type PragmaArgTypeOptional<TDesc, TName extends string> =
+export type PragmaArgTypeOptional<TDesc, TName extends string> =
     TDesc extends {optional: true}
         ? {[K in TName]?: PragmaArgTypeMaybeCapture<TDesc>}
         : {[K in TName]: PragmaArgTypeMaybeCapture<TDesc>};
 
 /** @internal */
-type UnionToIntersection<U> =
+export type UnionToIntersection<U> =
         (U extends any ? (k: U) => void : never) extends ((k: infer I) => void) ? I : never;
 
 /** @internal */
-type ArgumentDefinitionToFieldUnion<T extends readonly PragmaArgumentSpecification<any>[]> = {
+export type ArgumentDefinitionToFieldUnion<T extends readonly PragmaArgumentSpecification<any>[]> = {
     [K in keyof T]: PragmaArgTypeOptional<T[K], T[K] extends {name: infer TName} ? TName extends string ? TName : never : never>
 }[Extract<keyof T, number>]; // The mapped type maps over only the tuple members, but this reindex gets _all_ members - by extracting only `number` keys, we get only the tuple members
 
@@ -9320,13 +9320,13 @@ type ArgumentDefinitionToFieldUnion<T extends readonly PragmaArgumentSpecificati
  *
  * @internal
  */
-type PragmaArgumentType<KPrag extends keyof ConcretePragmaSpecs> =
+ export type PragmaArgumentType<KPrag extends keyof ConcretePragmaSpecs> =
     ConcretePragmaSpecs[KPrag] extends { args: readonly PragmaArgumentSpecification<any>[] }
         ? UnionToIntersection<ArgumentDefinitionToFieldUnion<ConcretePragmaSpecs[KPrag]["args"]>>
         : never;
 
 /** @internal */
-type ConcretePragmaSpecs = typeof commentPragmas;
+export type ConcretePragmaSpecs = typeof commentPragmas;
 
 /** @internal */
 export type PragmaPseudoMap = {[K in keyof ConcretePragmaSpecs]: {arguments: PragmaArgumentType<K>, range: CommentRange}};
diff --git a/src/compiler/utilities.ts b/src/compiler/utilities.ts
index 560a78a818..97620b9c89 100644
--- a/src/compiler/utilities.ts
+++ b/src/compiler/utilities.ts
@@ -721,7 +721,8 @@ export function getEmitFlags(node: Node): EmitFlags {
     return emitNode && emitNode.flags || 0;
 }
 
-interface ScriptTargetFeatures {
+/** @internal */
+export interface ScriptTargetFeatures {
     [key: string]: { [key: string]: string[] | undefined };
 }
 
@@ -6743,14 +6744,14 @@ export function formatStringFromArgs(text: string, args: ArrayLike<string | numb
 let localizedDiagnosticMessages: MapLike<string> | undefined;
 
 /** @internal */
-export function setLocalizedDiagnosticMessages(messages: typeof localizedDiagnosticMessages) {
+export function setLocalizedDiagnosticMessages(messages: MapLike<string> | undefined) {
     localizedDiagnosticMessages = messages;
 }
 
 /** @internal */
 // If the localized messages json is unset, and if given function use it to set the json
 
-export function maybeSetLocalizedDiagnosticMessages(getMessages: undefined | (() => typeof localizedDiagnosticMessages)) {
+export function maybeSetLocalizedDiagnosticMessages(getMessages: undefined | (() => MapLike<string> | undefined)) {
     if (!localizedDiagnosticMessages && getMessages) {
         localizedDiagnosticMessages = getMessages();
     }
diff --git a/src/compiler/watchPublic.ts b/src/compiler/watchPublic.ts
index c54d14e0b0..b183c3415c 100644
--- a/src/compiler/watchPublic.ts
+++ b/src/compiler/watchPublic.ts
@@ -28,7 +28,7 @@ export interface ReadBuildProgramHost {
     /** @internal */
     getBuildInfo?(fileName: string, configFilePath: string | undefined): BuildInfo | undefined;
 }
-export function readBuilderProgram(compilerOptions: CompilerOptions, host: ReadBuildProgramHost) {
+export function readBuilderProgram(compilerOptions: CompilerOptions, host: ReadBuildProgramHost): EmitAndSemanticDiagnosticsBuilderProgram | undefined {
     const buildInfoPath = getTsBuildInfoEmitOutputFilePath(compilerOptions);
     if (!buildInfoPath) return undefined;
     let buildInfo;
@@ -45,7 +45,7 @@ export function readBuilderProgram(compilerOptions: CompilerOptions, host: ReadB
     return createBuilderProgramUsingProgramBuildInfo(buildInfo.program, buildInfoPath, host);
 }
 
-export function createIncrementalCompilerHost(options: CompilerOptions, system = sys): CompilerHost {
+export function createIncrementalCompilerHost(options: CompilerOptions, system: System = sys): CompilerHost {
     const host = createCompilerHostWorker(options, /*setParentNodes*/ undefined, system);
     host.createHash = maybeBind(system, system.createHash);
     host.disableUseFileVersionAsSignature = system.disableUseFileVersionAsSignature;
diff --git a/src/compiler/watchUtilities.ts b/src/compiler/watchUtilities.ts
index 5dce173af6..0a06364c12 100644
--- a/src/compiler/watchUtilities.ts
+++ b/src/compiler/watchUtilities.ts
@@ -30,7 +30,8 @@ export interface DirectoryStructureHost {
     writeFile?(path: string, data: string, writeByteOrderMark?: boolean): void;
 }
 
-interface FileAndDirectoryExistence {
+/** @internal */
+export interface FileAndDirectoryExistence {
     fileExists: boolean;
     directoryExists: boolean;
 }
diff --git a/src/deprecatedCompat/4.0/nodeFactoryTopLevelExports.ts b/src/deprecatedCompat/4.0/nodeFactoryTopLevelExports.ts
index db5f894683..b3ec867dab 100644
--- a/src/deprecatedCompat/4.0/nodeFactoryTopLevelExports.ts
+++ b/src/deprecatedCompat/4.0/nodeFactoryTopLevelExports.ts
@@ -20,148 +20,148 @@ import {
 const factoryDeprecation: DeprecationOptions = { since: "4.0", warnAfter: "4.1", message: "Use the appropriate method on 'ts.factory' or the 'factory' supplied by your transformation context instead." };
 
 /** @deprecated Use `factory.createNodeArray` or the factory supplied by your transformation context instead. */
-export const createNodeArray = Debug.deprecate(factory.createNodeArray, factoryDeprecation);
+export const createNodeArray: typeof factory.createNodeArray = Debug.deprecate(factory.createNodeArray, factoryDeprecation);
 
 /** @deprecated Use `factory.createNumericLiteral` or the factory supplied by your transformation context instead. */
-export const createNumericLiteral = Debug.deprecate(factory.createNumericLiteral, factoryDeprecation);
+export const createNumericLiteral: typeof factory.createNumericLiteral = Debug.deprecate(factory.createNumericLiteral, factoryDeprecation);
 
 /** @deprecated Use `factory.createBigIntLiteral` or the factory supplied by your transformation context instead. */
-export const createBigIntLiteral = Debug.deprecate(factory.createBigIntLiteral, factoryDeprecation);
+export const createBigIntLiteral: typeof factory.createBigIntLiteral = Debug.deprecate(factory.createBigIntLiteral, factoryDeprecation);
 
 /** @deprecated Use `factory.createStringLiteral` or the factory supplied by your transformation context instead. */
-export const createStringLiteral = Debug.deprecate(factory.createStringLiteral, factoryDeprecation);
+export const createStringLiteral: typeof factory.createStringLiteral = Debug.deprecate(factory.createStringLiteral, factoryDeprecation);
 
 /** @deprecated Use `factory.createStringLiteralFromNode` or the factory supplied by your transformation context instead. */
-export const createStringLiteralFromNode = Debug.deprecate(factory.createStringLiteralFromNode, factoryDeprecation);
+export const createStringLiteralFromNode: typeof factory.createStringLiteralFromNode = Debug.deprecate(factory.createStringLiteralFromNode, factoryDeprecation);
 
 /** @deprecated Use `factory.createRegularExpressionLiteral` or the factory supplied by your transformation context instead. */
-export const createRegularExpressionLiteral = Debug.deprecate(factory.createRegularExpressionLiteral, factoryDeprecation);
+export const createRegularExpressionLiteral: typeof factory.createRegularExpressionLiteral = Debug.deprecate(factory.createRegularExpressionLiteral, factoryDeprecation);
 
 /** @deprecated Use `factory.createLoopVariable` or the factory supplied by your transformation context instead. */
-export const createLoopVariable = Debug.deprecate(factory.createLoopVariable, factoryDeprecation);
+export const createLoopVariable: typeof factory.createLoopVariable = Debug.deprecate(factory.createLoopVariable, factoryDeprecation);
 
 /** @deprecated Use `factory.createUniqueName` or the factory supplied by your transformation context instead. */
-export const createUniqueName: (text: string, flags?: GeneratedIdentifierFlags | undefined) => Identifier = Debug.deprecate(factory.createUniqueName, factoryDeprecation);
+export const createUniqueName: typeof factory.createUniqueName = Debug.deprecate(factory.createUniqueName, factoryDeprecation);
 
 /** @deprecated Use `factory.createPrivateIdentifier` or the factory supplied by your transformation context instead. */
-export const createPrivateIdentifier = Debug.deprecate(factory.createPrivateIdentifier, factoryDeprecation);
+export const createPrivateIdentifier: typeof factory.createPrivateIdentifier = Debug.deprecate(factory.createPrivateIdentifier, factoryDeprecation);
 
 /** @deprecated Use `factory.createSuper` or the factory supplied by your transformation context instead. */
-export const createSuper = Debug.deprecate(factory.createSuper, factoryDeprecation);
+export const createSuper: typeof factory.createSuper = Debug.deprecate(factory.createSuper, factoryDeprecation);
 
 /** @deprecated Use `factory.createThis` or the factory supplied by your transformation context instead. */
-export const createThis = Debug.deprecate(factory.createThis, factoryDeprecation);
+export const createThis: typeof factory.createThis = Debug.deprecate(factory.createThis, factoryDeprecation);
 
 /** @deprecated Use `factory.createNull` or the factory supplied by your transformation context instead. */
-export const createNull = Debug.deprecate(factory.createNull, factoryDeprecation);
+export const createNull: typeof factory.createNull = Debug.deprecate(factory.createNull, factoryDeprecation);
 
 /** @deprecated Use `factory.createTrue` or the factory supplied by your transformation context instead. */
-export const createTrue = Debug.deprecate(factory.createTrue, factoryDeprecation);
+export const createTrue: typeof factory.createTrue = Debug.deprecate(factory.createTrue, factoryDeprecation);
 
 /** @deprecated Use `factory.createFalse` or the factory supplied by your transformation context instead. */
-export const createFalse = Debug.deprecate(factory.createFalse, factoryDeprecation);
+export const createFalse: typeof factory.createFalse = Debug.deprecate(factory.createFalse, factoryDeprecation);
 
 /** @deprecated Use `factory.createModifier` or the factory supplied by your transformation context instead. */
-export const createModifier = Debug.deprecate(factory.createModifier, factoryDeprecation);
+export const createModifier: typeof factory.createModifier = Debug.deprecate(factory.createModifier, factoryDeprecation);
 
 /** @deprecated Use `factory.createModifiersFromModifierFlags` or the factory supplied by your transformation context instead. */
-export const createModifiersFromModifierFlags = Debug.deprecate(factory.createModifiersFromModifierFlags, factoryDeprecation);
+export const createModifiersFromModifierFlags: typeof factory.createModifiersFromModifierFlags = Debug.deprecate(factory.createModifiersFromModifierFlags, factoryDeprecation);
 
 /** @deprecated Use `factory.createQualifiedName` or the factory supplied by your transformation context instead. */
-export const createQualifiedName = Debug.deprecate(factory.createQualifiedName, factoryDeprecation);
+export const createQualifiedName: typeof factory.createQualifiedName = Debug.deprecate(factory.createQualifiedName, factoryDeprecation);
 
 /** @deprecated Use `factory.updateQualifiedName` or the factory supplied by your transformation context instead. */
-export const updateQualifiedName = Debug.deprecate(factory.updateQualifiedName, factoryDeprecation);
+export const updateQualifiedName: typeof factory.updateQualifiedName = Debug.deprecate(factory.updateQualifiedName, factoryDeprecation);
 
 /** @deprecated Use `factory.createComputedPropertyName` or the factory supplied by your transformation context instead. */
-export const createComputedPropertyName = Debug.deprecate(factory.createComputedPropertyName, factoryDeprecation);
+export const createComputedPropertyName: typeof factory.createComputedPropertyName = Debug.deprecate(factory.createComputedPropertyName, factoryDeprecation);
 
 /** @deprecated Use `factory.updateComputedPropertyName` or the factory supplied by your transformation context instead. */
-export const updateComputedPropertyName = Debug.deprecate(factory.updateComputedPropertyName, factoryDeprecation);
+export const updateComputedPropertyName: typeof factory.updateComputedPropertyName = Debug.deprecate(factory.updateComputedPropertyName, factoryDeprecation);
 
 /** @deprecated Use `factory.createTypeParameterDeclaration` or the factory supplied by your transformation context instead. */
-export const createTypeParameterDeclaration = Debug.deprecate(factory.createTypeParameterDeclaration, factoryDeprecation);
+export const createTypeParameterDeclaration: typeof factory.createTypeParameterDeclaration = Debug.deprecate(factory.createTypeParameterDeclaration, factoryDeprecation);
 
 /** @deprecated Use `factory.updateTypeParameterDeclaration` or the factory supplied by your transformation context instead. */
-export const updateTypeParameterDeclaration = Debug.deprecate(factory.updateTypeParameterDeclaration, factoryDeprecation);
+export const updateTypeParameterDeclaration: typeof factory.updateTypeParameterDeclaration = Debug.deprecate(factory.updateTypeParameterDeclaration, factoryDeprecation);
 
 /** @deprecated Use `factory.createParameterDeclaration` or the factory supplied by your transformation context instead. */
-export const createParameter = Debug.deprecate(factory.createParameterDeclaration, factoryDeprecation);
+export const createParameter: typeof factory.createParameterDeclaration = Debug.deprecate(factory.createParameterDeclaration, factoryDeprecation);
 
 /** @deprecated Use `factory.updateParameterDeclaration` or the factory supplied by your transformation context instead. */
-export const updateParameter = Debug.deprecate(factory.updateParameterDeclaration, factoryDeprecation);
+export const updateParameter: typeof factory.updateParameterDeclaration = Debug.deprecate(factory.updateParameterDeclaration, factoryDeprecation);
 
 /** @deprecated Use `factory.createDecorator` or the factory supplied by your transformation context instead. */
-export const createDecorator = Debug.deprecate(factory.createDecorator, factoryDeprecation);
+export const createDecorator: typeof factory.createDecorator = Debug.deprecate(factory.createDecorator, factoryDeprecation);
 
 /** @deprecated Use `factory.updateDecorator` or the factory supplied by your transformation context instead. */
-export const updateDecorator = Debug.deprecate(factory.updateDecorator, factoryDeprecation);
+export const updateDecorator: typeof factory.updateDecorator = Debug.deprecate(factory.updateDecorator, factoryDeprecation);
 
 /** @deprecated Use `factory.createPropertyDeclaration` or the factory supplied by your transformation context instead. */
-export const createProperty = Debug.deprecate(factory.createPropertyDeclaration, factoryDeprecation);
+export const createProperty: typeof factory.createPropertyDeclaration = Debug.deprecate(factory.createPropertyDeclaration, factoryDeprecation);
 
 /** @deprecated Use `factory.updatePropertyDeclaration` or the factory supplied by your transformation context instead. */
-export const updateProperty = Debug.deprecate(factory.updatePropertyDeclaration, factoryDeprecation);
+export const updateProperty: typeof factory.updatePropertyDeclaration = Debug.deprecate(factory.updatePropertyDeclaration, factoryDeprecation);
 
 /** @deprecated Use `factory.createMethodDeclaration` or the factory supplied by your transformation context instead. */
-export const createMethod = Debug.deprecate(factory.createMethodDeclaration, factoryDeprecation);
+export const createMethod: typeof factory.createMethodDeclaration = Debug.deprecate(factory.createMethodDeclaration, factoryDeprecation);
 
 /** @deprecated Use `factory.updateMethodDeclaration` or the factory supplied by your transformation context instead. */
-export const updateMethod = Debug.deprecate(factory.updateMethodDeclaration, factoryDeprecation);
+export const updateMethod: typeof factory.updateMethodDeclaration = Debug.deprecate(factory.updateMethodDeclaration, factoryDeprecation);
 
 /** @deprecated Use `factory.createConstructorDeclaration` or the factory supplied by your transformation context instead. */
-export const createConstructor = Debug.deprecate(factory.createConstructorDeclaration, factoryDeprecation);
+export const createConstructor: typeof factory.createConstructorDeclaration = Debug.deprecate(factory.createConstructorDeclaration, factoryDeprecation);
 
 /** @deprecated Use `factory.updateConstructorDeclaration` or the factory supplied by your transformation context instead. */
-export const updateConstructor = Debug.deprecate(factory.updateConstructorDeclaration, factoryDeprecation);
+export const updateConstructor: typeof factory.updateConstructorDeclaration = Debug.deprecate(factory.updateConstructorDeclaration, factoryDeprecation);
 
 /** @deprecated Use `factory.createGetAccessorDeclaration` or the factory supplied by your transformation context instead. */
-export const createGetAccessor = Debug.deprecate(factory.createGetAccessorDeclaration, factoryDeprecation);
+export const createGetAccessor: typeof factory.createGetAccessorDeclaration = Debug.deprecate(factory.createGetAccessorDeclaration, factoryDeprecation);
 
 /** @deprecated Use `factory.updateGetAccessorDeclaration` or the factory supplied by your transformation context instead. */
-export const updateGetAccessor = Debug.deprecate(factory.updateGetAccessorDeclaration, factoryDeprecation);
+export const updateGetAccessor: typeof factory.updateGetAccessorDeclaration = Debug.deprecate(factory.updateGetAccessorDeclaration, factoryDeprecation);
 
 /** @deprecated Use `factory.createSetAccessorDeclaration` or the factory supplied by your transformation context instead. */
-export const createSetAccessor = Debug.deprecate(factory.createSetAccessorDeclaration, factoryDeprecation);
+export const createSetAccessor: typeof factory.createSetAccessorDeclaration = Debug.deprecate(factory.createSetAccessorDeclaration, factoryDeprecation);
 
 /** @deprecated Use `factory.updateSetAccessorDeclaration` or the factory supplied by your transformation context instead. */
-export const updateSetAccessor = Debug.deprecate(factory.updateSetAccessorDeclaration, factoryDeprecation);
+export const updateSetAccessor: typeof factory.updateSetAccessorDeclaration = Debug.deprecate(factory.updateSetAccessorDeclaration, factoryDeprecation);
 
 /** @deprecated Use `factory.createCallSignature` or the factory supplied by your transformation context instead. */
-export const createCallSignature = Debug.deprecate(factory.createCallSignature, factoryDeprecation);
+export const createCallSignature: typeof factory.createCallSignature = Debug.deprecate(factory.createCallSignature, factoryDeprecation);
 
 /** @deprecated Use `factory.updateCallSignature` or the factory supplied by your transformation context instead. */
-export const updateCallSignature = Debug.deprecate(factory.updateCallSignature, factoryDeprecation);
+export const updateCallSignature: typeof factory.updateCallSignature = Debug.deprecate(factory.updateCallSignature, factoryDeprecation);
 
 /** @deprecated Use `factory.createConstructSignature` or the factory supplied by your transformation context instead. */
-export const createConstructSignature = Debug.deprecate(factory.createConstructSignature, factoryDeprecation);
+export const createConstructSignature: typeof factory.createConstructSignature = Debug.deprecate(factory.createConstructSignature, factoryDeprecation);
 
 /** @deprecated Use `factory.updateConstructSignature` or the factory supplied by your transformation context instead. */
-export const updateConstructSignature = Debug.deprecate(factory.updateConstructSignature, factoryDeprecation);
+export const updateConstructSignature: typeof factory.updateConstructSignature = Debug.deprecate(factory.updateConstructSignature, factoryDeprecation);
 
 /** @deprecated Use `factory.updateIndexSignature` or the factory supplied by your transformation context instead. */
-export const updateIndexSignature = Debug.deprecate(factory.updateIndexSignature, factoryDeprecation);
+export const updateIndexSignature: typeof factory.updateIndexSignature = Debug.deprecate(factory.updateIndexSignature, factoryDeprecation);
 
 /** @deprecated Use `factory.createKeywordTypeNode` or the factory supplied by your transformation context instead. */
-export const createKeywordTypeNode = Debug.deprecate(factory.createKeywordTypeNode, factoryDeprecation);
+export const createKeywordTypeNode: typeof factory.createKeywordTypeNode = Debug.deprecate(factory.createKeywordTypeNode, factoryDeprecation);
 
 /** @deprecated Use `factory.createTypePredicateNode` or the factory supplied by your transformation context instead. */
-export const createTypePredicateNodeWithModifier = Debug.deprecate(factory.createTypePredicateNode, factoryDeprecation);
+export const createTypePredicateNodeWithModifier: typeof factory.createTypePredicateNode = Debug.deprecate(factory.createTypePredicateNode, factoryDeprecation);
 
 /** @deprecated Use `factory.updateTypePredicateNode` or the factory supplied by your transformation context instead. */
-export const updateTypePredicateNodeWithModifier = Debug.deprecate(factory.updateTypePredicateNode, factoryDeprecation);
+export const updateTypePredicateNodeWithModifier: typeof factory.updateTypePredicateNode = Debug.deprecate(factory.updateTypePredicateNode, factoryDeprecation);
 
 /** @deprecated Use `factory.createTypeReferenceNode` or the factory supplied by your transformation context instead. */
-export const createTypeReferenceNode = Debug.deprecate(factory.createTypeReferenceNode, factoryDeprecation);
+export const createTypeReferenceNode: typeof factory.createTypeReferenceNode = Debug.deprecate(factory.createTypeReferenceNode, factoryDeprecation);
 
 /** @deprecated Use `factory.updateTypeReferenceNode` or the factory supplied by your transformation context instead. */
-export const updateTypeReferenceNode = Debug.deprecate(factory.updateTypeReferenceNode, factoryDeprecation);
+export const updateTypeReferenceNode: typeof factory.updateTypeReferenceNode = Debug.deprecate(factory.updateTypeReferenceNode, factoryDeprecation);
 
 /** @deprecated Use `factory.createFunctionTypeNode` or the factory supplied by your transformation context instead. */
-export const createFunctionTypeNode = Debug.deprecate(factory.createFunctionTypeNode, factoryDeprecation);
+export const createFunctionTypeNode: typeof factory.createFunctionTypeNode = Debug.deprecate(factory.createFunctionTypeNode, factoryDeprecation);
 
 /** @deprecated Use `factory.updateFunctionTypeNode` or the factory supplied by your transformation context instead. */
-export const updateFunctionTypeNode = Debug.deprecate(factory.updateFunctionTypeNode, factoryDeprecation);
+export const updateFunctionTypeNode: typeof factory.updateFunctionTypeNode = Debug.deprecate(factory.updateFunctionTypeNode, factoryDeprecation);
 
 /** @deprecated Use `factory.createConstructorTypeNode` or the factory supplied by your transformation context instead. */
 export const createConstructorTypeNode = Debug.deprecate((
@@ -183,748 +183,748 @@ export const updateConstructorTypeNode = Debug.deprecate((
 }, factoryDeprecation);
 
 /** @deprecated Use `factory.createTypeQueryNode` or the factory supplied by your transformation context instead. */
-export const createTypeQueryNode = Debug.deprecate(factory.createTypeQueryNode, factoryDeprecation);
+export const createTypeQueryNode: typeof factory.createTypeQueryNode = Debug.deprecate(factory.createTypeQueryNode, factoryDeprecation);
 
 /** @deprecated Use `factory.updateTypeQueryNode` or the factory supplied by your transformation context instead. */
-export const updateTypeQueryNode = Debug.deprecate(factory.updateTypeQueryNode, factoryDeprecation);
+export const updateTypeQueryNode: typeof factory.updateTypeQueryNode = Debug.deprecate(factory.updateTypeQueryNode, factoryDeprecation);
 
 /** @deprecated Use `factory.createTypeLiteralNode` or the factory supplied by your transformation context instead. */
-export const createTypeLiteralNode = Debug.deprecate(factory.createTypeLiteralNode, factoryDeprecation);
+export const createTypeLiteralNode: typeof factory.createTypeLiteralNode = Debug.deprecate(factory.createTypeLiteralNode, factoryDeprecation);
 
 /** @deprecated Use `factory.updateTypeLiteralNode` or the factory supplied by your transformation context instead. */
-export const updateTypeLiteralNode = Debug.deprecate(factory.updateTypeLiteralNode, factoryDeprecation);
+export const updateTypeLiteralNode: typeof factory.updateTypeLiteralNode = Debug.deprecate(factory.updateTypeLiteralNode, factoryDeprecation);
 
 /** @deprecated Use `factory.createArrayTypeNode` or the factory supplied by your transformation context instead. */
-export const createArrayTypeNode = Debug.deprecate(factory.createArrayTypeNode, factoryDeprecation);
+export const createArrayTypeNode: typeof factory.createArrayTypeNode = Debug.deprecate(factory.createArrayTypeNode, factoryDeprecation);
 
 /** @deprecated Use `factory.updateArrayTypeNode` or the factory supplied by your transformation context instead. */
-export const updateArrayTypeNode = Debug.deprecate(factory.updateArrayTypeNode, factoryDeprecation);
+export const updateArrayTypeNode: typeof factory.updateArrayTypeNode = Debug.deprecate(factory.updateArrayTypeNode, factoryDeprecation);
 
 /** @deprecated Use `factory.createTupleTypeNode` or the factory supplied by your transformation context instead. */
-export const createTupleTypeNode = Debug.deprecate(factory.createTupleTypeNode, factoryDeprecation);
+export const createTupleTypeNode: typeof factory.createTupleTypeNode = Debug.deprecate(factory.createTupleTypeNode, factoryDeprecation);
 
 /** @deprecated Use `factory.updateTupleTypeNode` or the factory supplied by your transformation context instead. */
-export const updateTupleTypeNode = Debug.deprecate(factory.updateTupleTypeNode, factoryDeprecation);
+export const updateTupleTypeNode: typeof factory.updateTupleTypeNode = Debug.deprecate(factory.updateTupleTypeNode, factoryDeprecation);
 
 /** @deprecated Use `factory.createOptionalTypeNode` or the factory supplied by your transformation context instead. */
-export const createOptionalTypeNode = Debug.deprecate(factory.createOptionalTypeNode, factoryDeprecation);
+export const createOptionalTypeNode: typeof factory.createOptionalTypeNode = Debug.deprecate(factory.createOptionalTypeNode, factoryDeprecation);
 
 /** @deprecated Use `factory.updateOptionalTypeNode` or the factory supplied by your transformation context instead. */
-export const updateOptionalTypeNode = Debug.deprecate(factory.updateOptionalTypeNode, factoryDeprecation);
+export const updateOptionalTypeNode: typeof factory.updateOptionalTypeNode = Debug.deprecate(factory.updateOptionalTypeNode, factoryDeprecation);
 
 /** @deprecated Use `factory.createRestTypeNode` or the factory supplied by your transformation context instead. */
-export const createRestTypeNode = Debug.deprecate(factory.createRestTypeNode, factoryDeprecation);
+export const createRestTypeNode: typeof factory.createRestTypeNode = Debug.deprecate(factory.createRestTypeNode, factoryDeprecation);
 
 /** @deprecated Use `factory.updateRestTypeNode` or the factory supplied by your transformation context instead. */
-export const updateRestTypeNode = Debug.deprecate(factory.updateRestTypeNode, factoryDeprecation);
+export const updateRestTypeNode: typeof factory.updateRestTypeNode = Debug.deprecate(factory.updateRestTypeNode, factoryDeprecation);
 
 /** @deprecated Use `factory.createUnionTypeNode` or the factory supplied by your transformation context instead. */
-export const createUnionTypeNode = Debug.deprecate(factory.createUnionTypeNode, factoryDeprecation);
+export const createUnionTypeNode: typeof factory.createUnionTypeNode = Debug.deprecate(factory.createUnionTypeNode, factoryDeprecation);
 
 /** @deprecated Use `factory.updateUnionTypeNode` or the factory supplied by your transformation context instead. */
-export const updateUnionTypeNode = Debug.deprecate(factory.updateUnionTypeNode, factoryDeprecation);
+export const updateUnionTypeNode: typeof factory.updateUnionTypeNode = Debug.deprecate(factory.updateUnionTypeNode, factoryDeprecation);
 
 /** @deprecated Use `factory.createIntersectionTypeNode` or the factory supplied by your transformation context instead. */
-export const createIntersectionTypeNode = Debug.deprecate(factory.createIntersectionTypeNode, factoryDeprecation);
+export const createIntersectionTypeNode: typeof factory.createIntersectionTypeNode = Debug.deprecate(factory.createIntersectionTypeNode, factoryDeprecation);
 
 /** @deprecated Use `factory.updateIntersectionTypeNode` or the factory supplied by your transformation context instead. */
-export const updateIntersectionTypeNode = Debug.deprecate(factory.updateIntersectionTypeNode, factoryDeprecation);
+export const updateIntersectionTypeNode: typeof factory.updateIntersectionTypeNode = Debug.deprecate(factory.updateIntersectionTypeNode, factoryDeprecation);
 
 /** @deprecated Use `factory.createConditionalTypeNode` or the factory supplied by your transformation context instead. */
-export const createConditionalTypeNode = Debug.deprecate(factory.createConditionalTypeNode, factoryDeprecation);
+export const createConditionalTypeNode: typeof factory.createConditionalTypeNode = Debug.deprecate(factory.createConditionalTypeNode, factoryDeprecation);
 
 /** @deprecated Use `factory.updateConditionalTypeNode` or the factory supplied by your transformation context instead. */
-export const updateConditionalTypeNode = Debug.deprecate(factory.updateConditionalTypeNode, factoryDeprecation);
+export const updateConditionalTypeNode: typeof factory.updateConditionalTypeNode = Debug.deprecate(factory.updateConditionalTypeNode, factoryDeprecation);
 
 /** @deprecated Use `factory.createInferTypeNode` or the factory supplied by your transformation context instead. */
-export const createInferTypeNode = Debug.deprecate(factory.createInferTypeNode, factoryDeprecation);
+export const createInferTypeNode: typeof factory.createInferTypeNode = Debug.deprecate(factory.createInferTypeNode, factoryDeprecation);
 
 /** @deprecated Use `factory.updateInferTypeNode` or the factory supplied by your transformation context instead. */
-export const updateInferTypeNode = Debug.deprecate(factory.updateInferTypeNode, factoryDeprecation);
+export const updateInferTypeNode: typeof factory.updateInferTypeNode = Debug.deprecate(factory.updateInferTypeNode, factoryDeprecation);
 
 /** @deprecated Use `factory.createImportTypeNode` or the factory supplied by your transformation context instead. */
-export const createImportTypeNode = Debug.deprecate(factory.createImportTypeNode, factoryDeprecation);
+export const createImportTypeNode: typeof factory.createImportTypeNode = Debug.deprecate(factory.createImportTypeNode, factoryDeprecation);
 
 /** @deprecated Use `factory.updateImportTypeNode` or the factory supplied by your transformation context instead. */
-export const updateImportTypeNode = Debug.deprecate(factory.updateImportTypeNode, factoryDeprecation);
+export const updateImportTypeNode: typeof factory.updateImportTypeNode = Debug.deprecate(factory.updateImportTypeNode, factoryDeprecation);
 
 /** @deprecated Use `factory.createParenthesizedType` or the factory supplied by your transformation context instead. */
-export const createParenthesizedType = Debug.deprecate(factory.createParenthesizedType, factoryDeprecation);
+export const createParenthesizedType: typeof factory.createParenthesizedType = Debug.deprecate(factory.createParenthesizedType, factoryDeprecation);
 
 /** @deprecated Use `factory.updateParenthesizedType` or the factory supplied by your transformation context instead. */
-export const updateParenthesizedType = Debug.deprecate(factory.updateParenthesizedType, factoryDeprecation);
+export const updateParenthesizedType: typeof factory.updateParenthesizedType = Debug.deprecate(factory.updateParenthesizedType, factoryDeprecation);
 
 /** @deprecated Use `factory.createThisTypeNode` or the factory supplied by your transformation context instead. */
-export const createThisTypeNode = Debug.deprecate(factory.createThisTypeNode, factoryDeprecation);
+export const createThisTypeNode: typeof factory.createThisTypeNode = Debug.deprecate(factory.createThisTypeNode, factoryDeprecation);
 
 /** @deprecated Use `factory.updateTypeOperatorNode` or the factory supplied by your transformation context instead. */
-export const updateTypeOperatorNode = Debug.deprecate(factory.updateTypeOperatorNode, factoryDeprecation);
+export const updateTypeOperatorNode: typeof factory.updateTypeOperatorNode = Debug.deprecate(factory.updateTypeOperatorNode, factoryDeprecation);
 
 /** @deprecated Use `factory.createIndexedAccessTypeNode` or the factory supplied by your transformation context instead. */
-export const createIndexedAccessTypeNode = Debug.deprecate(factory.createIndexedAccessTypeNode, factoryDeprecation);
+export const createIndexedAccessTypeNode: typeof factory.createIndexedAccessTypeNode = Debug.deprecate(factory.createIndexedAccessTypeNode, factoryDeprecation);
 
 /** @deprecated Use `factory.updateIndexedAccessTypeNode` or the factory supplied by your transformation context instead. */
-export const updateIndexedAccessTypeNode = Debug.deprecate(factory.updateIndexedAccessTypeNode, factoryDeprecation);
+export const updateIndexedAccessTypeNode: typeof factory.updateIndexedAccessTypeNode = Debug.deprecate(factory.updateIndexedAccessTypeNode, factoryDeprecation);
 
 /** @deprecated Use `factory.createMappedTypeNode` or the factory supplied by your transformation context instead. */
-export const createMappedTypeNode = Debug.deprecate(factory.createMappedTypeNode, factoryDeprecation);
+export const createMappedTypeNode: typeof factory.createMappedTypeNode = Debug.deprecate(factory.createMappedTypeNode, factoryDeprecation);
 
 /** @deprecated Use `factory.updateMappedTypeNode` or the factory supplied by your transformation context instead. */
-export const updateMappedTypeNode = Debug.deprecate(factory.updateMappedTypeNode, factoryDeprecation);
+export const updateMappedTypeNode: typeof factory.updateMappedTypeNode = Debug.deprecate(factory.updateMappedTypeNode, factoryDeprecation);
 
 /** @deprecated Use `factory.createLiteralTypeNode` or the factory supplied by your transformation context instead. */
-export const createLiteralTypeNode = Debug.deprecate(factory.createLiteralTypeNode, factoryDeprecation);
+export const createLiteralTypeNode: typeof factory.createLiteralTypeNode = Debug.deprecate(factory.createLiteralTypeNode, factoryDeprecation);
 
 /** @deprecated Use `factory.updateLiteralTypeNode` or the factory supplied by your transformation context instead. */
-export const updateLiteralTypeNode = Debug.deprecate(factory.updateLiteralTypeNode, factoryDeprecation);
+export const updateLiteralTypeNode: typeof factory.updateLiteralTypeNode = Debug.deprecate(factory.updateLiteralTypeNode, factoryDeprecation);
 
 /** @deprecated Use `factory.createObjectBindingPattern` or the factory supplied by your transformation context instead. */
-export const createObjectBindingPattern = Debug.deprecate(factory.createObjectBindingPattern, factoryDeprecation);
+export const createObjectBindingPattern: typeof factory.createObjectBindingPattern = Debug.deprecate(factory.createObjectBindingPattern, factoryDeprecation);
 
 /** @deprecated Use `factory.updateObjectBindingPattern` or the factory supplied by your transformation context instead. */
-export const updateObjectBindingPattern = Debug.deprecate(factory.updateObjectBindingPattern, factoryDeprecation);
+export const updateObjectBindingPattern: typeof factory.updateObjectBindingPattern = Debug.deprecate(factory.updateObjectBindingPattern, factoryDeprecation);
 
 /** @deprecated Use `factory.createArrayBindingPattern` or the factory supplied by your transformation context instead. */
-export const createArrayBindingPattern = Debug.deprecate(factory.createArrayBindingPattern, factoryDeprecation);
+export const createArrayBindingPattern: typeof factory.createArrayBindingPattern = Debug.deprecate(factory.createArrayBindingPattern, factoryDeprecation);
 
 /** @deprecated Use `factory.updateArrayBindingPattern` or the factory supplied by your transformation context instead. */
-export const updateArrayBindingPattern = Debug.deprecate(factory.updateArrayBindingPattern, factoryDeprecation);
+export const updateArrayBindingPattern: typeof factory.updateArrayBindingPattern = Debug.deprecate(factory.updateArrayBindingPattern, factoryDeprecation);
 
 /** @deprecated Use `factory.createBindingElement` or the factory supplied by your transformation context instead. */
-export const createBindingElement = Debug.deprecate(factory.createBindingElement, factoryDeprecation);
+export const createBindingElement: typeof factory.createBindingElement = Debug.deprecate(factory.createBindingElement, factoryDeprecation);
 
 /** @deprecated Use `factory.updateBindingElement` or the factory supplied by your transformation context instead. */
-export const updateBindingElement = Debug.deprecate(factory.updateBindingElement, factoryDeprecation);
+export const updateBindingElement: typeof factory.updateBindingElement = Debug.deprecate(factory.updateBindingElement, factoryDeprecation);
 
 /** @deprecated Use `factory.createArrayLiteralExpression` or the factory supplied by your transformation context instead. */
-export const createArrayLiteral = Debug.deprecate(factory.createArrayLiteralExpression, factoryDeprecation);
+export const createArrayLiteral: typeof factory.createArrayLiteralExpression = Debug.deprecate(factory.createArrayLiteralExpression, factoryDeprecation);
 
 /** @deprecated Use `factory.updateArrayLiteralExpression` or the factory supplied by your transformation context instead. */
-export const updateArrayLiteral = Debug.deprecate(factory.updateArrayLiteralExpression, factoryDeprecation);
+export const updateArrayLiteral: typeof factory.updateArrayLiteralExpression = Debug.deprecate(factory.updateArrayLiteralExpression, factoryDeprecation);
 
 /** @deprecated Use `factory.createObjectLiteralExpression` or the factory supplied by your transformation context instead. */
-export const createObjectLiteral = Debug.deprecate(factory.createObjectLiteralExpression, factoryDeprecation);
+export const createObjectLiteral: typeof factory.createObjectLiteralExpression = Debug.deprecate(factory.createObjectLiteralExpression, factoryDeprecation);
 
 /** @deprecated Use `factory.updateObjectLiteralExpression` or the factory supplied by your transformation context instead. */
-export const updateObjectLiteral = Debug.deprecate(factory.updateObjectLiteralExpression, factoryDeprecation);
+export const updateObjectLiteral: typeof factory.updateObjectLiteralExpression = Debug.deprecate(factory.updateObjectLiteralExpression, factoryDeprecation);
 
 /** @deprecated Use `factory.createPropertyAccessExpression` or the factory supplied by your transformation context instead. */
-export const createPropertyAccess = Debug.deprecate(factory.createPropertyAccessExpression, factoryDeprecation);
+export const createPropertyAccess: typeof factory.createPropertyAccessExpression = Debug.deprecate(factory.createPropertyAccessExpression, factoryDeprecation);
 
 /** @deprecated Use `factory.updatePropertyAccessExpression` or the factory supplied by your transformation context instead. */
-export const updatePropertyAccess = Debug.deprecate(factory.updatePropertyAccessExpression, factoryDeprecation);
+export const updatePropertyAccess: typeof factory.updatePropertyAccessExpression = Debug.deprecate(factory.updatePropertyAccessExpression, factoryDeprecation);
 
 /** @deprecated Use `factory.createPropertyAccessChain` or the factory supplied by your transformation context instead. */
-export const createPropertyAccessChain = Debug.deprecate(factory.createPropertyAccessChain, factoryDeprecation);
+export const createPropertyAccessChain: typeof factory.createPropertyAccessChain = Debug.deprecate(factory.createPropertyAccessChain, factoryDeprecation);
 
 /** @deprecated Use `factory.updatePropertyAccessChain` or the factory supplied by your transformation context instead. */
-export const updatePropertyAccessChain = Debug.deprecate(factory.updatePropertyAccessChain, factoryDeprecation);
+export const updatePropertyAccessChain: typeof factory.updatePropertyAccessChain = Debug.deprecate(factory.updatePropertyAccessChain, factoryDeprecation);
 
 /** @deprecated Use `factory.createElementAccessExpression` or the factory supplied by your transformation context instead. */
-export const createElementAccess = Debug.deprecate(factory.createElementAccessExpression, factoryDeprecation);
+export const createElementAccess: typeof factory.createElementAccessExpression = Debug.deprecate(factory.createElementAccessExpression, factoryDeprecation);
 
 /** @deprecated Use `factory.updateElementAccessExpression` or the factory supplied by your transformation context instead. */
-export const updateElementAccess = Debug.deprecate(factory.updateElementAccessExpression, factoryDeprecation);
+export const updateElementAccess: typeof factory.updateElementAccessExpression = Debug.deprecate(factory.updateElementAccessExpression, factoryDeprecation);
 
 /** @deprecated Use `factory.createElementAccessChain` or the factory supplied by your transformation context instead. */
-export const createElementAccessChain = Debug.deprecate(factory.createElementAccessChain, factoryDeprecation);
+export const createElementAccessChain: typeof factory.createElementAccessChain = Debug.deprecate(factory.createElementAccessChain, factoryDeprecation);
 
 /** @deprecated Use `factory.updateElementAccessChain` or the factory supplied by your transformation context instead. */
-export const updateElementAccessChain = Debug.deprecate(factory.updateElementAccessChain, factoryDeprecation);
+export const updateElementAccessChain: typeof factory.updateElementAccessChain = Debug.deprecate(factory.updateElementAccessChain, factoryDeprecation);
 
 /** @deprecated Use `factory.createCallExpression` or the factory supplied by your transformation context instead. */
-export const createCall = Debug.deprecate(factory.createCallExpression, factoryDeprecation);
+export const createCall: typeof factory.createCallExpression = Debug.deprecate(factory.createCallExpression, factoryDeprecation);
 
 /** @deprecated Use `factory.updateCallExpression` or the factory supplied by your transformation context instead. */
-export const updateCall = Debug.deprecate(factory.updateCallExpression, factoryDeprecation);
+export const updateCall: typeof factory.updateCallExpression = Debug.deprecate(factory.updateCallExpression, factoryDeprecation);
 
 /** @deprecated Use `factory.createCallChain` or the factory supplied by your transformation context instead. */
-export const createCallChain = Debug.deprecate(factory.createCallChain, factoryDeprecation);
+export const createCallChain: typeof factory.createCallChain = Debug.deprecate(factory.createCallChain, factoryDeprecation);
 
 /** @deprecated Use `factory.updateCallChain` or the factory supplied by your transformation context instead. */
-export const updateCallChain = Debug.deprecate(factory.updateCallChain, factoryDeprecation);
+export const updateCallChain: typeof factory.updateCallChain = Debug.deprecate(factory.updateCallChain, factoryDeprecation);
 
 /** @deprecated Use `factory.createNewExpression` or the factory supplied by your transformation context instead. */
-export const createNew = Debug.deprecate(factory.createNewExpression, factoryDeprecation);
+export const createNew: typeof factory.createNewExpression = Debug.deprecate(factory.createNewExpression, factoryDeprecation);
 
 /** @deprecated Use `factory.updateNewExpression` or the factory supplied by your transformation context instead. */
-export const updateNew = Debug.deprecate(factory.updateNewExpression, factoryDeprecation);
+export const updateNew: typeof factory.updateNewExpression = Debug.deprecate(factory.updateNewExpression, factoryDeprecation);
 
 /** @deprecated Use `factory.createTypeAssertion` or the factory supplied by your transformation context instead. */
-export const createTypeAssertion = Debug.deprecate(factory.createTypeAssertion, factoryDeprecation);
+export const createTypeAssertion: typeof factory.createTypeAssertion = Debug.deprecate(factory.createTypeAssertion, factoryDeprecation);
 
 /** @deprecated Use `factory.updateTypeAssertion` or the factory supplied by your transformation context instead. */
-export const updateTypeAssertion = Debug.deprecate(factory.updateTypeAssertion, factoryDeprecation);
+export const updateTypeAssertion: typeof factory.updateTypeAssertion = Debug.deprecate(factory.updateTypeAssertion, factoryDeprecation);
 
 /** @deprecated Use `factory.createParenthesizedExpression` or the factory supplied by your transformation context instead. */
-export const createParen = Debug.deprecate(factory.createParenthesizedExpression, factoryDeprecation);
+export const createParen: typeof factory.createParenthesizedExpression = Debug.deprecate(factory.createParenthesizedExpression, factoryDeprecation);
 
 /** @deprecated Use `factory.updateParenthesizedExpression` or the factory supplied by your transformation context instead. */
-export const updateParen = Debug.deprecate(factory.updateParenthesizedExpression, factoryDeprecation);
+export const updateParen: typeof factory.updateParenthesizedExpression = Debug.deprecate(factory.updateParenthesizedExpression, factoryDeprecation);
 
 /** @deprecated Use `factory.createFunctionExpression` or the factory supplied by your transformation context instead. */
-export const createFunctionExpression = Debug.deprecate(factory.createFunctionExpression, factoryDeprecation);
+export const createFunctionExpression: typeof factory.createFunctionExpression = Debug.deprecate(factory.createFunctionExpression, factoryDeprecation);
 
 /** @deprecated Use `factory.updateFunctionExpression` or the factory supplied by your transformation context instead. */
-export const updateFunctionExpression = Debug.deprecate(factory.updateFunctionExpression, factoryDeprecation);
+export const updateFunctionExpression: typeof factory.updateFunctionExpression = Debug.deprecate(factory.updateFunctionExpression, factoryDeprecation);
 
 /** @deprecated Use `factory.createDeleteExpression` or the factory supplied by your transformation context instead. */
-export const createDelete = Debug.deprecate(factory.createDeleteExpression, factoryDeprecation);
+export const createDelete: typeof factory.createDeleteExpression = Debug.deprecate(factory.createDeleteExpression, factoryDeprecation);
 
 /** @deprecated Use `factory.updateDeleteExpression` or the factory supplied by your transformation context instead. */
-export const updateDelete = Debug.deprecate(factory.updateDeleteExpression, factoryDeprecation);
+export const updateDelete: typeof factory.updateDeleteExpression = Debug.deprecate(factory.updateDeleteExpression, factoryDeprecation);
 
 /** @deprecated Use `factory.createTypeOfExpression` or the factory supplied by your transformation context instead. */
-export const createTypeOf = Debug.deprecate(factory.createTypeOfExpression, factoryDeprecation);
+export const createTypeOf: typeof factory.createTypeOfExpression = Debug.deprecate(factory.createTypeOfExpression, factoryDeprecation);
 
 /** @deprecated Use `factory.updateTypeOfExpression` or the factory supplied by your transformation context instead. */
-export const updateTypeOf = Debug.deprecate(factory.updateTypeOfExpression, factoryDeprecation);
+export const updateTypeOf: typeof factory.updateTypeOfExpression = Debug.deprecate(factory.updateTypeOfExpression, factoryDeprecation);
 
 /** @deprecated Use `factory.createVoidExpression` or the factory supplied by your transformation context instead. */
-export const createVoid = Debug.deprecate(factory.createVoidExpression, factoryDeprecation);
+export const createVoid: typeof factory.createVoidExpression = Debug.deprecate(factory.createVoidExpression, factoryDeprecation);
 
 /** @deprecated Use `factory.updateVoidExpression` or the factory supplied by your transformation context instead. */
-export const updateVoid = Debug.deprecate(factory.updateVoidExpression, factoryDeprecation);
+export const updateVoid: typeof factory.updateVoidExpression = Debug.deprecate(factory.updateVoidExpression, factoryDeprecation);
 
 /** @deprecated Use `factory.createAwaitExpression` or the factory supplied by your transformation context instead. */
-export const createAwait = Debug.deprecate(factory.createAwaitExpression, factoryDeprecation);
+export const createAwait: typeof factory.createAwaitExpression = Debug.deprecate(factory.createAwaitExpression, factoryDeprecation);
 
 /** @deprecated Use `factory.updateAwaitExpression` or the factory supplied by your transformation context instead. */
-export const updateAwait = Debug.deprecate(factory.updateAwaitExpression, factoryDeprecation);
+export const updateAwait: typeof factory.updateAwaitExpression = Debug.deprecate(factory.updateAwaitExpression, factoryDeprecation);
 
 /** @deprecated Use `factory.createPrefixExpression` or the factory supplied by your transformation context instead. */
-export const createPrefix = Debug.deprecate(factory.createPrefixUnaryExpression, factoryDeprecation);
+export const createPrefix: typeof factory.createPrefixUnaryExpression = Debug.deprecate(factory.createPrefixUnaryExpression, factoryDeprecation);
 
 /** @deprecated Use `factory.updatePrefixExpression` or the factory supplied by your transformation context instead. */
-export const updatePrefix = Debug.deprecate(factory.updatePrefixUnaryExpression, factoryDeprecation);
+export const updatePrefix: typeof factory.updatePrefixUnaryExpression = Debug.deprecate(factory.updatePrefixUnaryExpression, factoryDeprecation);
 
 /** @deprecated Use `factory.createPostfixUnaryExpression` or the factory supplied by your transformation context instead. */
-export const createPostfix = Debug.deprecate(factory.createPostfixUnaryExpression, factoryDeprecation);
+export const createPostfix: typeof factory.createPostfixUnaryExpression = Debug.deprecate(factory.createPostfixUnaryExpression, factoryDeprecation);
 
 /** @deprecated Use `factory.updatePostfixUnaryExpression` or the factory supplied by your transformation context instead. */
-export const updatePostfix = Debug.deprecate(factory.updatePostfixUnaryExpression, factoryDeprecation);
+export const updatePostfix: typeof factory.updatePostfixUnaryExpression = Debug.deprecate(factory.updatePostfixUnaryExpression, factoryDeprecation);
 
 /** @deprecated Use `factory.createBinaryExpression` or the factory supplied by your transformation context instead. */
-export const createBinary = Debug.deprecate(factory.createBinaryExpression, factoryDeprecation);
+export const createBinary: typeof factory.createBinaryExpression = Debug.deprecate(factory.createBinaryExpression, factoryDeprecation);
 
 /** @deprecated Use `factory.updateConditionalExpression` or the factory supplied by your transformation context instead. */
-export const updateConditional = Debug.deprecate(factory.updateConditionalExpression, factoryDeprecation);
+export const updateConditional: typeof factory.updateConditionalExpression = Debug.deprecate(factory.updateConditionalExpression, factoryDeprecation);
 
 /** @deprecated Use `factory.createTemplateExpression` or the factory supplied by your transformation context instead. */
-export const createTemplateExpression = Debug.deprecate(factory.createTemplateExpression, factoryDeprecation);
+export const createTemplateExpression: typeof factory.createTemplateExpression = Debug.deprecate(factory.createTemplateExpression, factoryDeprecation);
 
 /** @deprecated Use `factory.updateTemplateExpression` or the factory supplied by your transformation context instead. */
-export const updateTemplateExpression = Debug.deprecate(factory.updateTemplateExpression, factoryDeprecation);
+export const updateTemplateExpression: typeof factory.updateTemplateExpression = Debug.deprecate(factory.updateTemplateExpression, factoryDeprecation);
 
 /** @deprecated Use `factory.createTemplateHead` or the factory supplied by your transformation context instead. */
-export const createTemplateHead = Debug.deprecate(factory.createTemplateHead, factoryDeprecation);
+export const createTemplateHead: typeof factory.createTemplateHead = Debug.deprecate(factory.createTemplateHead, factoryDeprecation);
 
 /** @deprecated Use `factory.createTemplateMiddle` or the factory supplied by your transformation context instead. */
-export const createTemplateMiddle = Debug.deprecate(factory.createTemplateMiddle, factoryDeprecation);
+export const createTemplateMiddle: typeof factory.createTemplateMiddle = Debug.deprecate(factory.createTemplateMiddle, factoryDeprecation);
 
 /** @deprecated Use `factory.createTemplateTail` or the factory supplied by your transformation context instead. */
-export const createTemplateTail = Debug.deprecate(factory.createTemplateTail, factoryDeprecation);
+export const createTemplateTail: typeof factory.createTemplateTail = Debug.deprecate(factory.createTemplateTail, factoryDeprecation);
 
 /** @deprecated Use `factory.createNoSubstitutionTemplateLiteral` or the factory supplied by your transformation context instead. */
-export const createNoSubstitutionTemplateLiteral = Debug.deprecate(factory.createNoSubstitutionTemplateLiteral, factoryDeprecation);
+export const createNoSubstitutionTemplateLiteral: typeof factory.createNoSubstitutionTemplateLiteral = Debug.deprecate(factory.createNoSubstitutionTemplateLiteral, factoryDeprecation);
 
 /** @deprecated Use `factory.updateYieldExpression` or the factory supplied by your transformation context instead. */
-export const updateYield = Debug.deprecate(factory.updateYieldExpression, factoryDeprecation);
+export const updateYield: typeof factory.updateYieldExpression = Debug.deprecate(factory.updateYieldExpression, factoryDeprecation);
 
 /** @deprecated Use `factory.createSpreadExpression` or the factory supplied by your transformation context instead. */
-export const createSpread = Debug.deprecate(factory.createSpreadElement, factoryDeprecation);
+export const createSpread: typeof factory.createSpreadElement = Debug.deprecate(factory.createSpreadElement, factoryDeprecation);
 
 /** @deprecated Use `factory.updateSpreadExpression` or the factory supplied by your transformation context instead. */
-export const updateSpread = Debug.deprecate(factory.updateSpreadElement, factoryDeprecation);
+export const updateSpread: typeof factory.updateSpreadElement = Debug.deprecate(factory.updateSpreadElement, factoryDeprecation);
 
 /** @deprecated Use `factory.createOmittedExpression` or the factory supplied by your transformation context instead. */
-export const createOmittedExpression = Debug.deprecate(factory.createOmittedExpression, factoryDeprecation);
+export const createOmittedExpression: typeof factory.createOmittedExpression = Debug.deprecate(factory.createOmittedExpression, factoryDeprecation);
 
 /** @deprecated Use `factory.createAsExpression` or the factory supplied by your transformation context instead. */
-export const createAsExpression = Debug.deprecate(factory.createAsExpression, factoryDeprecation);
+export const createAsExpression: typeof factory.createAsExpression = Debug.deprecate(factory.createAsExpression, factoryDeprecation);
 
 /** @deprecated Use `factory.updateAsExpression` or the factory supplied by your transformation context instead. */
-export const updateAsExpression = Debug.deprecate(factory.updateAsExpression, factoryDeprecation);
+export const updateAsExpression: typeof factory.updateAsExpression = Debug.deprecate(factory.updateAsExpression, factoryDeprecation);
 
 /** @deprecated Use `factory.createNonNullExpression` or the factory supplied by your transformation context instead. */
-export const createNonNullExpression = Debug.deprecate(factory.createNonNullExpression, factoryDeprecation);
+export const createNonNullExpression: typeof factory.createNonNullExpression = Debug.deprecate(factory.createNonNullExpression, factoryDeprecation);
 
 /** @deprecated Use `factory.updateNonNullExpression` or the factory supplied by your transformation context instead. */
-export const updateNonNullExpression = Debug.deprecate(factory.updateNonNullExpression, factoryDeprecation);
+export const updateNonNullExpression: typeof factory.updateNonNullExpression = Debug.deprecate(factory.updateNonNullExpression, factoryDeprecation);
 
 /** @deprecated Use `factory.createNonNullChain` or the factory supplied by your transformation context instead. */
-export const createNonNullChain = Debug.deprecate(factory.createNonNullChain, factoryDeprecation);
+export const createNonNullChain: typeof factory.createNonNullChain = Debug.deprecate(factory.createNonNullChain, factoryDeprecation);
 
 /** @deprecated Use `factory.updateNonNullChain` or the factory supplied by your transformation context instead. */
-export const updateNonNullChain = Debug.deprecate(factory.updateNonNullChain, factoryDeprecation);
+export const updateNonNullChain: typeof factory.updateNonNullChain = Debug.deprecate(factory.updateNonNullChain, factoryDeprecation);
 
 /** @deprecated Use `factory.createMetaProperty` or the factory supplied by your transformation context instead. */
-export const createMetaProperty = Debug.deprecate(factory.createMetaProperty, factoryDeprecation);
+export const createMetaProperty: typeof factory.createMetaProperty = Debug.deprecate(factory.createMetaProperty, factoryDeprecation);
 
 /** @deprecated Use `factory.updateMetaProperty` or the factory supplied by your transformation context instead. */
-export const updateMetaProperty = Debug.deprecate(factory.updateMetaProperty, factoryDeprecation);
+export const updateMetaProperty: typeof factory.updateMetaProperty = Debug.deprecate(factory.updateMetaProperty, factoryDeprecation);
 
 /** @deprecated Use `factory.createTemplateSpan` or the factory supplied by your transformation context instead. */
-export const createTemplateSpan = Debug.deprecate(factory.createTemplateSpan, factoryDeprecation);
+export const createTemplateSpan: typeof factory.createTemplateSpan = Debug.deprecate(factory.createTemplateSpan, factoryDeprecation);
 
 /** @deprecated Use `factory.updateTemplateSpan` or the factory supplied by your transformation context instead. */
-export const updateTemplateSpan = Debug.deprecate(factory.updateTemplateSpan, factoryDeprecation);
+export const updateTemplateSpan: typeof factory.updateTemplateSpan = Debug.deprecate(factory.updateTemplateSpan, factoryDeprecation);
 
 /** @deprecated Use `factory.createSemicolonClassElement` or the factory supplied by your transformation context instead. */
-export const createSemicolonClassElement = Debug.deprecate(factory.createSemicolonClassElement, factoryDeprecation);
+export const createSemicolonClassElement: typeof factory.createSemicolonClassElement = Debug.deprecate(factory.createSemicolonClassElement, factoryDeprecation);
 
 /** @deprecated Use `factory.createBlock` or the factory supplied by your transformation context instead. */
-export const createBlock = Debug.deprecate(factory.createBlock, factoryDeprecation);
+export const createBlock: typeof factory.createBlock = Debug.deprecate(factory.createBlock, factoryDeprecation);
 
 /** @deprecated Use `factory.updateBlock` or the factory supplied by your transformation context instead. */
-export const updateBlock = Debug.deprecate(factory.updateBlock, factoryDeprecation);
+export const updateBlock: typeof factory.updateBlock = Debug.deprecate(factory.updateBlock, factoryDeprecation);
 
 /** @deprecated Use `factory.createVariableStatement` or the factory supplied by your transformation context instead. */
-export const createVariableStatement = Debug.deprecate(factory.createVariableStatement, factoryDeprecation);
+export const createVariableStatement: typeof factory.createVariableStatement = Debug.deprecate(factory.createVariableStatement, factoryDeprecation);
 
 /** @deprecated Use `factory.updateVariableStatement` or the factory supplied by your transformation context instead. */
-export const updateVariableStatement = Debug.deprecate(factory.updateVariableStatement, factoryDeprecation);
+export const updateVariableStatement: typeof factory.updateVariableStatement = Debug.deprecate(factory.updateVariableStatement, factoryDeprecation);
 
 /** @deprecated Use `factory.createEmptyStatement` or the factory supplied by your transformation context instead. */
-export const createEmptyStatement = Debug.deprecate(factory.createEmptyStatement, factoryDeprecation);
+export const createEmptyStatement: typeof factory.createEmptyStatement = Debug.deprecate(factory.createEmptyStatement, factoryDeprecation);
 
 /** @deprecated Use `factory.createExpressionStatement` or the factory supplied by your transformation context instead. */
-export const createExpressionStatement = Debug.deprecate(factory.createExpressionStatement, factoryDeprecation);
+export const createExpressionStatement: typeof factory.createExpressionStatement = Debug.deprecate(factory.createExpressionStatement, factoryDeprecation);
 
 /** @deprecated Use `factory.updateExpressionStatement` or the factory supplied by your transformation context instead. */
-export const updateExpressionStatement = Debug.deprecate(factory.updateExpressionStatement, factoryDeprecation);
+export const updateExpressionStatement: typeof factory.updateExpressionStatement = Debug.deprecate(factory.updateExpressionStatement, factoryDeprecation);
 
 /** @deprecated Use `factory.createExpressionStatement` or the factory supplied by your transformation context instead. */
-export const createStatement = Debug.deprecate(factory.createExpressionStatement, factoryDeprecation);
+export const createStatement: typeof factory.createExpressionStatement = Debug.deprecate(factory.createExpressionStatement, factoryDeprecation);
 
 /** @deprecated Use `factory.updateExpressionStatement` or the factory supplied by your transformation context instead. */
-export const updateStatement = Debug.deprecate(factory.updateExpressionStatement, factoryDeprecation);
+export const updateStatement: typeof factory.updateExpressionStatement = Debug.deprecate(factory.updateExpressionStatement, factoryDeprecation);
 
 /** @deprecated Use `factory.createIfStatement` or the factory supplied by your transformation context instead. */
-export const createIf = Debug.deprecate(factory.createIfStatement, factoryDeprecation);
+export const createIf: typeof factory.createIfStatement = Debug.deprecate(factory.createIfStatement, factoryDeprecation);
 
 /** @deprecated Use `factory.updateIfStatement` or the factory supplied by your transformation context instead. */
-export const updateIf = Debug.deprecate(factory.updateIfStatement, factoryDeprecation);
+export const updateIf: typeof factory.updateIfStatement = Debug.deprecate(factory.updateIfStatement, factoryDeprecation);
 
 /** @deprecated Use `factory.createDoStatement` or the factory supplied by your transformation context instead. */
-export const createDo = Debug.deprecate(factory.createDoStatement, factoryDeprecation);
+export const createDo: typeof factory.createDoStatement = Debug.deprecate(factory.createDoStatement, factoryDeprecation);
 
 /** @deprecated Use `factory.updateDoStatement` or the factory supplied by your transformation context instead. */
-export const updateDo = Debug.deprecate(factory.updateDoStatement, factoryDeprecation);
+export const updateDo: typeof factory.updateDoStatement = Debug.deprecate(factory.updateDoStatement, factoryDeprecation);
 
 /** @deprecated Use `factory.createWhileStatement` or the factory supplied by your transformation context instead. */
-export const createWhile = Debug.deprecate(factory.createWhileStatement, factoryDeprecation);
+export const createWhile: typeof factory.createWhileStatement = Debug.deprecate(factory.createWhileStatement, factoryDeprecation);
 
 /** @deprecated Use `factory.updateWhileStatement` or the factory supplied by your transformation context instead. */
-export const updateWhile = Debug.deprecate(factory.updateWhileStatement, factoryDeprecation);
+export const updateWhile: typeof factory.updateWhileStatement = Debug.deprecate(factory.updateWhileStatement, factoryDeprecation);
 
 /** @deprecated Use `factory.createForStatement` or the factory supplied by your transformation context instead. */
-export const createFor = Debug.deprecate(factory.createForStatement, factoryDeprecation);
+export const createFor: typeof factory.createForStatement = Debug.deprecate(factory.createForStatement, factoryDeprecation);
 
 /** @deprecated Use `factory.updateForStatement` or the factory supplied by your transformation context instead. */
-export const updateFor = Debug.deprecate(factory.updateForStatement, factoryDeprecation);
+export const updateFor: typeof factory.updateForStatement = Debug.deprecate(factory.updateForStatement, factoryDeprecation);
 
 /** @deprecated Use `factory.createForInStatement` or the factory supplied by your transformation context instead. */
-export const createForIn = Debug.deprecate(factory.createForInStatement, factoryDeprecation);
+export const createForIn: typeof factory.createForInStatement = Debug.deprecate(factory.createForInStatement, factoryDeprecation);
 
 /** @deprecated Use `factory.updateForInStatement` or the factory supplied by your transformation context instead. */
-export const updateForIn = Debug.deprecate(factory.updateForInStatement, factoryDeprecation);
+export const updateForIn: typeof factory.updateForInStatement = Debug.deprecate(factory.updateForInStatement, factoryDeprecation);
 
 /** @deprecated Use `factory.createForOfStatement` or the factory supplied by your transformation context instead. */
-export const createForOf = Debug.deprecate(factory.createForOfStatement, factoryDeprecation);
+export const createForOf: typeof factory.createForOfStatement = Debug.deprecate(factory.createForOfStatement, factoryDeprecation);
 
 /** @deprecated Use `factory.updateForOfStatement` or the factory supplied by your transformation context instead. */
-export const updateForOf = Debug.deprecate(factory.updateForOfStatement, factoryDeprecation);
+export const updateForOf: typeof factory.updateForOfStatement = Debug.deprecate(factory.updateForOfStatement, factoryDeprecation);
 
 /** @deprecated Use `factory.createContinueStatement` or the factory supplied by your transformation context instead. */
-export const createContinue = Debug.deprecate(factory.createContinueStatement, factoryDeprecation);
+export const createContinue: typeof factory.createContinueStatement = Debug.deprecate(factory.createContinueStatement, factoryDeprecation);
 
 /** @deprecated Use `factory.updateContinueStatement` or the factory supplied by your transformation context instead. */
-export const updateContinue = Debug.deprecate(factory.updateContinueStatement, factoryDeprecation);
+export const updateContinue: typeof factory.updateContinueStatement = Debug.deprecate(factory.updateContinueStatement, factoryDeprecation);
 
 /** @deprecated Use `factory.createBreakStatement` or the factory supplied by your transformation context instead. */
-export const createBreak = Debug.deprecate(factory.createBreakStatement, factoryDeprecation);
+export const createBreak: typeof factory.createBreakStatement = Debug.deprecate(factory.createBreakStatement, factoryDeprecation);
 
 /** @deprecated Use `factory.updateBreakStatement` or the factory supplied by your transformation context instead. */
-export const updateBreak = Debug.deprecate(factory.updateBreakStatement, factoryDeprecation);
+export const updateBreak: typeof factory.updateBreakStatement = Debug.deprecate(factory.updateBreakStatement, factoryDeprecation);
 
 /** @deprecated Use `factory.createReturnStatement` or the factory supplied by your transformation context instead. */
-export const createReturn = Debug.deprecate(factory.createReturnStatement, factoryDeprecation);
+export const createReturn: typeof factory.createReturnStatement = Debug.deprecate(factory.createReturnStatement, factoryDeprecation);
 
 /** @deprecated Use `factory.updateReturnStatement` or the factory supplied by your transformation context instead. */
-export const updateReturn = Debug.deprecate(factory.updateReturnStatement, factoryDeprecation);
+export const updateReturn: typeof factory.updateReturnStatement = Debug.deprecate(factory.updateReturnStatement, factoryDeprecation);
 
 /** @deprecated Use `factory.createWithStatement` or the factory supplied by your transformation context instead. */
-export const createWith = Debug.deprecate(factory.createWithStatement, factoryDeprecation);
+export const createWith: typeof factory.createWithStatement = Debug.deprecate(factory.createWithStatement, factoryDeprecation);
 
 /** @deprecated Use `factory.updateWithStatement` or the factory supplied by your transformation context instead. */
-export const updateWith = Debug.deprecate(factory.updateWithStatement, factoryDeprecation);
+export const updateWith: typeof factory.updateWithStatement = Debug.deprecate(factory.updateWithStatement, factoryDeprecation);
 
 /** @deprecated Use `factory.createSwitchStatement` or the factory supplied by your transformation context instead. */
-export const createSwitch = Debug.deprecate(factory.createSwitchStatement, factoryDeprecation);
+export const createSwitch: typeof factory.createSwitchStatement = Debug.deprecate(factory.createSwitchStatement, factoryDeprecation);
 
 /** @deprecated Use `factory.updateSwitchStatement` or the factory supplied by your transformation context instead. */
-export const updateSwitch = Debug.deprecate(factory.updateSwitchStatement, factoryDeprecation);
+export const updateSwitch: typeof factory.updateSwitchStatement = Debug.deprecate(factory.updateSwitchStatement, factoryDeprecation);
 
 /** @deprecated Use `factory.createLabelStatement` or the factory supplied by your transformation context instead. */
-export const createLabel = Debug.deprecate(factory.createLabeledStatement, factoryDeprecation);
+export const createLabel: typeof factory.createLabeledStatement = Debug.deprecate(factory.createLabeledStatement, factoryDeprecation);
 
 /** @deprecated Use `factory.updateLabelStatement` or the factory supplied by your transformation context instead. */
-export const updateLabel = Debug.deprecate(factory.updateLabeledStatement, factoryDeprecation);
+export const updateLabel: typeof factory.updateLabeledStatement = Debug.deprecate(factory.updateLabeledStatement, factoryDeprecation);
 
 /** @deprecated Use `factory.createThrowStatement` or the factory supplied by your transformation context instead. */
-export const createThrow = Debug.deprecate(factory.createThrowStatement, factoryDeprecation);
+export const createThrow: typeof factory.createThrowStatement = Debug.deprecate(factory.createThrowStatement, factoryDeprecation);
 
 /** @deprecated Use `factory.updateThrowStatement` or the factory supplied by your transformation context instead. */
-export const updateThrow = Debug.deprecate(factory.updateThrowStatement, factoryDeprecation);
+export const updateThrow: typeof factory.updateThrowStatement = Debug.deprecate(factory.updateThrowStatement, factoryDeprecation);
 
 /** @deprecated Use `factory.createTryStatement` or the factory supplied by your transformation context instead. */
-export const createTry = Debug.deprecate(factory.createTryStatement, factoryDeprecation);
+export const createTry: typeof factory.createTryStatement = Debug.deprecate(factory.createTryStatement, factoryDeprecation);
 
 /** @deprecated Use `factory.updateTryStatement` or the factory supplied by your transformation context instead. */
-export const updateTry = Debug.deprecate(factory.updateTryStatement, factoryDeprecation);
+export const updateTry: typeof factory.updateTryStatement = Debug.deprecate(factory.updateTryStatement, factoryDeprecation);
 
 /** @deprecated Use `factory.createDebuggerStatement` or the factory supplied by your transformation context instead. */
-export const createDebuggerStatement = Debug.deprecate(factory.createDebuggerStatement, factoryDeprecation);
+export const createDebuggerStatement: typeof factory.createDebuggerStatement = Debug.deprecate(factory.createDebuggerStatement, factoryDeprecation);
 
 /** @deprecated Use `factory.createVariableDeclarationList` or the factory supplied by your transformation context instead. */
-export const createVariableDeclarationList = Debug.deprecate(factory.createVariableDeclarationList, factoryDeprecation);
+export const createVariableDeclarationList: typeof factory.createVariableDeclarationList = Debug.deprecate(factory.createVariableDeclarationList, factoryDeprecation);
 
 /** @deprecated Use `factory.updateVariableDeclarationList` or the factory supplied by your transformation context instead. */
-export const updateVariableDeclarationList = Debug.deprecate(factory.updateVariableDeclarationList, factoryDeprecation);
+export const updateVariableDeclarationList: typeof factory.updateVariableDeclarationList = Debug.deprecate(factory.updateVariableDeclarationList, factoryDeprecation);
 
 /** @deprecated Use `factory.createFunctionDeclaration` or the factory supplied by your transformation context instead. */
-export const createFunctionDeclaration = Debug.deprecate(factory.createFunctionDeclaration, factoryDeprecation);
+export const createFunctionDeclaration: typeof factory.createFunctionDeclaration = Debug.deprecate(factory.createFunctionDeclaration, factoryDeprecation);
 
 /** @deprecated Use `factory.updateFunctionDeclaration` or the factory supplied by your transformation context instead. */
-export const updateFunctionDeclaration = Debug.deprecate(factory.updateFunctionDeclaration, factoryDeprecation);
+export const updateFunctionDeclaration: typeof factory.updateFunctionDeclaration = Debug.deprecate(factory.updateFunctionDeclaration, factoryDeprecation);
 
 /** @deprecated Use `factory.createClassDeclaration` or the factory supplied by your transformation context instead. */
-export const createClassDeclaration = Debug.deprecate(factory.createClassDeclaration, factoryDeprecation);
+export const createClassDeclaration: typeof factory.createClassDeclaration = Debug.deprecate(factory.createClassDeclaration, factoryDeprecation);
 
 /** @deprecated Use `factory.updateClassDeclaration` or the factory supplied by your transformation context instead. */
-export const updateClassDeclaration = Debug.deprecate(factory.updateClassDeclaration, factoryDeprecation);
+export const updateClassDeclaration: typeof factory.updateClassDeclaration = Debug.deprecate(factory.updateClassDeclaration, factoryDeprecation);
 
 /** @deprecated Use `factory.createInterfaceDeclaration` or the factory supplied by your transformation context instead. */
-export const createInterfaceDeclaration = Debug.deprecate(factory.createInterfaceDeclaration, factoryDeprecation);
+export const createInterfaceDeclaration: typeof factory.createInterfaceDeclaration = Debug.deprecate(factory.createInterfaceDeclaration, factoryDeprecation);
 
 /** @deprecated Use `factory.updateInterfaceDeclaration` or the factory supplied by your transformation context instead. */
-export const updateInterfaceDeclaration = Debug.deprecate(factory.updateInterfaceDeclaration, factoryDeprecation);
+export const updateInterfaceDeclaration: typeof factory.updateInterfaceDeclaration = Debug.deprecate(factory.updateInterfaceDeclaration, factoryDeprecation);
 
 /** @deprecated Use `factory.createTypeAliasDeclaration` or the factory supplied by your transformation context instead. */
-export const createTypeAliasDeclaration = Debug.deprecate(factory.createTypeAliasDeclaration, factoryDeprecation);
+export const createTypeAliasDeclaration: typeof factory.createTypeAliasDeclaration = Debug.deprecate(factory.createTypeAliasDeclaration, factoryDeprecation);
 
 /** @deprecated Use `factory.updateTypeAliasDeclaration` or the factory supplied by your transformation context instead. */
-export const updateTypeAliasDeclaration = Debug.deprecate(factory.updateTypeAliasDeclaration, factoryDeprecation);
+export const updateTypeAliasDeclaration: typeof factory.updateTypeAliasDeclaration = Debug.deprecate(factory.updateTypeAliasDeclaration, factoryDeprecation);
 
 /** @deprecated Use `factory.createEnumDeclaration` or the factory supplied by your transformation context instead. */
-export const createEnumDeclaration = Debug.deprecate(factory.createEnumDeclaration, factoryDeprecation);
+export const createEnumDeclaration: typeof factory.createEnumDeclaration = Debug.deprecate(factory.createEnumDeclaration, factoryDeprecation);
 
 /** @deprecated Use `factory.updateEnumDeclaration` or the factory supplied by your transformation context instead. */
-export const updateEnumDeclaration = Debug.deprecate(factory.updateEnumDeclaration, factoryDeprecation);
+export const updateEnumDeclaration: typeof factory.updateEnumDeclaration = Debug.deprecate(factory.updateEnumDeclaration, factoryDeprecation);
 
 /** @deprecated Use `factory.createModuleDeclaration` or the factory supplied by your transformation context instead. */
-export const createModuleDeclaration = Debug.deprecate(factory.createModuleDeclaration, factoryDeprecation);
+export const createModuleDeclaration: typeof factory.createModuleDeclaration = Debug.deprecate(factory.createModuleDeclaration, factoryDeprecation);
 
 /** @deprecated Use `factory.updateModuleDeclaration` or the factory supplied by your transformation context instead. */
-export const updateModuleDeclaration = Debug.deprecate(factory.updateModuleDeclaration, factoryDeprecation);
+export const updateModuleDeclaration: typeof factory.updateModuleDeclaration = Debug.deprecate(factory.updateModuleDeclaration, factoryDeprecation);
 
 /** @deprecated Use `factory.createModuleBlock` or the factory supplied by your transformation context instead. */
-export const createModuleBlock = Debug.deprecate(factory.createModuleBlock, factoryDeprecation);
+export const createModuleBlock: typeof factory.createModuleBlock = Debug.deprecate(factory.createModuleBlock, factoryDeprecation);
 
 /** @deprecated Use `factory.updateModuleBlock` or the factory supplied by your transformation context instead. */
-export const updateModuleBlock = Debug.deprecate(factory.updateModuleBlock, factoryDeprecation);
+export const updateModuleBlock: typeof factory.updateModuleBlock = Debug.deprecate(factory.updateModuleBlock, factoryDeprecation);
 
 /** @deprecated Use `factory.createCaseBlock` or the factory supplied by your transformation context instead. */
-export const createCaseBlock = Debug.deprecate(factory.createCaseBlock, factoryDeprecation);
+export const createCaseBlock: typeof factory.createCaseBlock = Debug.deprecate(factory.createCaseBlock, factoryDeprecation);
 
 /** @deprecated Use `factory.updateCaseBlock` or the factory supplied by your transformation context instead. */
-export const updateCaseBlock = Debug.deprecate(factory.updateCaseBlock, factoryDeprecation);
+export const updateCaseBlock: typeof factory.updateCaseBlock = Debug.deprecate(factory.updateCaseBlock, factoryDeprecation);
 
 /** @deprecated Use `factory.createNamespaceExportDeclaration` or the factory supplied by your transformation context instead. */
-export const createNamespaceExportDeclaration = Debug.deprecate(factory.createNamespaceExportDeclaration, factoryDeprecation);
+export const createNamespaceExportDeclaration: typeof factory.createNamespaceExportDeclaration = Debug.deprecate(factory.createNamespaceExportDeclaration, factoryDeprecation);
 
 /** @deprecated Use `factory.updateNamespaceExportDeclaration` or the factory supplied by your transformation context instead. */
-export const updateNamespaceExportDeclaration = Debug.deprecate(factory.updateNamespaceExportDeclaration, factoryDeprecation);
+export const updateNamespaceExportDeclaration: typeof factory.updateNamespaceExportDeclaration = Debug.deprecate(factory.updateNamespaceExportDeclaration, factoryDeprecation);
 
 /** @deprecated Use `factory.createImportEqualsDeclaration` or the factory supplied by your transformation context instead. */
-export const createImportEqualsDeclaration = Debug.deprecate(factory.createImportEqualsDeclaration, factoryDeprecation);
+export const createImportEqualsDeclaration: typeof factory.createImportEqualsDeclaration = Debug.deprecate(factory.createImportEqualsDeclaration, factoryDeprecation);
 
 /** @deprecated Use `factory.updateImportEqualsDeclaration` or the factory supplied by your transformation context instead. */
-export const updateImportEqualsDeclaration = Debug.deprecate(factory.updateImportEqualsDeclaration, factoryDeprecation);
+export const updateImportEqualsDeclaration: typeof factory.updateImportEqualsDeclaration = Debug.deprecate(factory.updateImportEqualsDeclaration, factoryDeprecation);
 
 /** @deprecated Use `factory.createImportDeclaration` or the factory supplied by your transformation context instead. */
-export const createImportDeclaration = Debug.deprecate(factory.createImportDeclaration, factoryDeprecation);
+export const createImportDeclaration: typeof factory.createImportDeclaration = Debug.deprecate(factory.createImportDeclaration, factoryDeprecation);
 
 /** @deprecated Use `factory.updateImportDeclaration` or the factory supplied by your transformation context instead. */
-export const updateImportDeclaration = Debug.deprecate(factory.updateImportDeclaration, factoryDeprecation);
+export const updateImportDeclaration: typeof factory.updateImportDeclaration = Debug.deprecate(factory.updateImportDeclaration, factoryDeprecation);
 
 /** @deprecated Use `factory.createNamespaceImport` or the factory supplied by your transformation context instead. */
-export const createNamespaceImport = Debug.deprecate(factory.createNamespaceImport, factoryDeprecation);
+export const createNamespaceImport: typeof factory.createNamespaceImport = Debug.deprecate(factory.createNamespaceImport, factoryDeprecation);
 
 /** @deprecated Use `factory.updateNamespaceImport` or the factory supplied by your transformation context instead. */
-export const updateNamespaceImport = Debug.deprecate(factory.updateNamespaceImport, factoryDeprecation);
+export const updateNamespaceImport: typeof factory.updateNamespaceImport = Debug.deprecate(factory.updateNamespaceImport, factoryDeprecation);
 
 /** @deprecated Use `factory.createNamedImports` or the factory supplied by your transformation context instead. */
-export const createNamedImports = Debug.deprecate(factory.createNamedImports, factoryDeprecation);
+export const createNamedImports: typeof factory.createNamedImports = Debug.deprecate(factory.createNamedImports, factoryDeprecation);
 
 /** @deprecated Use `factory.updateNamedImports` or the factory supplied by your transformation context instead. */
-export const updateNamedImports = Debug.deprecate(factory.updateNamedImports, factoryDeprecation);
+export const updateNamedImports: typeof factory.updateNamedImports = Debug.deprecate(factory.updateNamedImports, factoryDeprecation);
 
 /** @deprecated Use `factory.createImportSpecifier` or the factory supplied by your transformation context instead. */
-export const createImportSpecifier = Debug.deprecate(factory.createImportSpecifier, factoryDeprecation);
+export const createImportSpecifier: typeof factory.createImportSpecifier = Debug.deprecate(factory.createImportSpecifier, factoryDeprecation);
 
 /** @deprecated Use `factory.updateImportSpecifier` or the factory supplied by your transformation context instead. */
-export const updateImportSpecifier = Debug.deprecate(factory.updateImportSpecifier, factoryDeprecation);
+export const updateImportSpecifier: typeof factory.updateImportSpecifier = Debug.deprecate(factory.updateImportSpecifier, factoryDeprecation);
 
 /** @deprecated Use `factory.createExportAssignment` or the factory supplied by your transformation context instead. */
-export const createExportAssignment = Debug.deprecate(factory.createExportAssignment, factoryDeprecation);
+export const createExportAssignment: typeof factory.createExportAssignment = Debug.deprecate(factory.createExportAssignment, factoryDeprecation);
 
 /** @deprecated Use `factory.updateExportAssignment` or the factory supplied by your transformation context instead. */
-export const updateExportAssignment = Debug.deprecate(factory.updateExportAssignment, factoryDeprecation);
+export const updateExportAssignment: typeof factory.updateExportAssignment = Debug.deprecate(factory.updateExportAssignment, factoryDeprecation);
 
 /** @deprecated Use `factory.createNamedExports` or the factory supplied by your transformation context instead. */
-export const createNamedExports = Debug.deprecate(factory.createNamedExports, factoryDeprecation);
+export const createNamedExports: typeof factory.createNamedExports = Debug.deprecate(factory.createNamedExports, factoryDeprecation);
 
 /** @deprecated Use `factory.updateNamedExports` or the factory supplied by your transformation context instead. */
-export const updateNamedExports = Debug.deprecate(factory.updateNamedExports, factoryDeprecation);
+export const updateNamedExports: typeof factory.updateNamedExports = Debug.deprecate(factory.updateNamedExports, factoryDeprecation);
 
 /** @deprecated Use `factory.createExportSpecifier` or the factory supplied by your transformation context instead. */
-export const createExportSpecifier = Debug.deprecate(factory.createExportSpecifier, factoryDeprecation);
+export const createExportSpecifier: typeof factory.createExportSpecifier = Debug.deprecate(factory.createExportSpecifier, factoryDeprecation);
 
 /** @deprecated Use `factory.updateExportSpecifier` or the factory supplied by your transformation context instead. */
-export const updateExportSpecifier = Debug.deprecate(factory.updateExportSpecifier, factoryDeprecation);
+export const updateExportSpecifier: typeof factory.updateExportSpecifier = Debug.deprecate(factory.updateExportSpecifier, factoryDeprecation);
 
 /** @deprecated Use `factory.createExternalModuleReference` or the factory supplied by your transformation context instead. */
-export const createExternalModuleReference = Debug.deprecate(factory.createExternalModuleReference, factoryDeprecation);
+export const createExternalModuleReference: typeof factory.createExternalModuleReference = Debug.deprecate(factory.createExternalModuleReference, factoryDeprecation);
 
 /** @deprecated Use `factory.updateExternalModuleReference` or the factory supplied by your transformation context instead. */
-export const updateExternalModuleReference = Debug.deprecate(factory.updateExternalModuleReference, factoryDeprecation);
+export const updateExternalModuleReference: typeof factory.updateExternalModuleReference = Debug.deprecate(factory.updateExternalModuleReference, factoryDeprecation);
 
 /** @deprecated Use `factory.createJSDocTypeExpression` or the factory supplied by your transformation context instead. */
-export const createJSDocTypeExpression = Debug.deprecate(factory.createJSDocTypeExpression, factoryDeprecation);
+export const createJSDocTypeExpression: typeof factory.createJSDocTypeExpression = Debug.deprecate(factory.createJSDocTypeExpression, factoryDeprecation);
 
 /** @deprecated Use `factory.createJSDocTypeTag` or the factory supplied by your transformation context instead. */
-export const createJSDocTypeTag = Debug.deprecate(factory.createJSDocTypeTag, factoryDeprecation);
+export const createJSDocTypeTag: typeof factory.createJSDocTypeTag = Debug.deprecate(factory.createJSDocTypeTag, factoryDeprecation);
 
 /** @deprecated Use `factory.createJSDocReturnTag` or the factory supplied by your transformation context instead. */
-export const createJSDocReturnTag = Debug.deprecate(factory.createJSDocReturnTag, factoryDeprecation);
+export const createJSDocReturnTag: typeof factory.createJSDocReturnTag = Debug.deprecate(factory.createJSDocReturnTag, factoryDeprecation);
 
 /** @deprecated Use `factory.createJSDocThisTag` or the factory supplied by your transformation context instead. */
-export const createJSDocThisTag = Debug.deprecate(factory.createJSDocThisTag, factoryDeprecation);
+export const createJSDocThisTag: typeof factory.createJSDocThisTag = Debug.deprecate(factory.createJSDocThisTag, factoryDeprecation);
 
 /** @deprecated Use `factory.createJSDocComment` or the factory supplied by your transformation context instead. */
-export const createJSDocComment = Debug.deprecate(factory.createJSDocComment, factoryDeprecation);
+export const createJSDocComment: typeof factory.createJSDocComment = Debug.deprecate(factory.createJSDocComment, factoryDeprecation);
 
 /** @deprecated Use `factory.createJSDocParameterTag` or the factory supplied by your transformation context instead. */
-export const createJSDocParameterTag = Debug.deprecate(factory.createJSDocParameterTag, factoryDeprecation);
+export const createJSDocParameterTag: typeof factory.createJSDocParameterTag = Debug.deprecate(factory.createJSDocParameterTag, factoryDeprecation);
 
 /** @deprecated Use `factory.createJSDocClassTag` or the factory supplied by your transformation context instead. */
-export const createJSDocClassTag = Debug.deprecate(factory.createJSDocClassTag, factoryDeprecation);
+export const createJSDocClassTag: typeof factory.createJSDocClassTag = Debug.deprecate(factory.createJSDocClassTag, factoryDeprecation);
 
 /** @deprecated Use `factory.createJSDocAugmentsTag` or the factory supplied by your transformation context instead. */
-export const createJSDocAugmentsTag = Debug.deprecate(factory.createJSDocAugmentsTag, factoryDeprecation);
+export const createJSDocAugmentsTag: typeof factory.createJSDocAugmentsTag = Debug.deprecate(factory.createJSDocAugmentsTag, factoryDeprecation);
 
 /** @deprecated Use `factory.createJSDocEnumTag` or the factory supplied by your transformation context instead. */
-export const createJSDocEnumTag = Debug.deprecate(factory.createJSDocEnumTag, factoryDeprecation);
+export const createJSDocEnumTag: typeof factory.createJSDocEnumTag = Debug.deprecate(factory.createJSDocEnumTag, factoryDeprecation);
 
 /** @deprecated Use `factory.createJSDocTemplateTag` or the factory supplied by your transformation context instead. */
-export const createJSDocTemplateTag = Debug.deprecate(factory.createJSDocTemplateTag, factoryDeprecation);
+export const createJSDocTemplateTag: typeof factory.createJSDocTemplateTag = Debug.deprecate(factory.createJSDocTemplateTag, factoryDeprecation);
 
 /** @deprecated Use `factory.createJSDocTypedefTag` or the factory supplied by your transformation context instead. */
-export const createJSDocTypedefTag = Debug.deprecate(factory.createJSDocTypedefTag, factoryDeprecation);
+export const createJSDocTypedefTag: typeof factory.createJSDocTypedefTag = Debug.deprecate(factory.createJSDocTypedefTag, factoryDeprecation);
 
 /** @deprecated Use `factory.createJSDocCallbackTag` or the factory supplied by your transformation context instead. */
-export const createJSDocCallbackTag = Debug.deprecate(factory.createJSDocCallbackTag, factoryDeprecation);
+export const createJSDocCallbackTag: typeof factory.createJSDocCallbackTag = Debug.deprecate(factory.createJSDocCallbackTag, factoryDeprecation);
 
 /** @deprecated Use `factory.createJSDocSignature` or the factory supplied by your transformation context instead. */
-export const createJSDocSignature = Debug.deprecate(factory.createJSDocSignature, factoryDeprecation);
+export const createJSDocSignature: typeof factory.createJSDocSignature = Debug.deprecate(factory.createJSDocSignature, factoryDeprecation);
 
 /** @deprecated Use `factory.createJSDocPropertyTag` or the factory supplied by your transformation context instead. */
-export const createJSDocPropertyTag = Debug.deprecate(factory.createJSDocPropertyTag, factoryDeprecation);
+export const createJSDocPropertyTag: typeof factory.createJSDocPropertyTag = Debug.deprecate(factory.createJSDocPropertyTag, factoryDeprecation);
 
 /** @deprecated Use `factory.createJSDocTypeLiteral` or the factory supplied by your transformation context instead. */
-export const createJSDocTypeLiteral = Debug.deprecate(factory.createJSDocTypeLiteral, factoryDeprecation);
+export const createJSDocTypeLiteral: typeof factory.createJSDocTypeLiteral = Debug.deprecate(factory.createJSDocTypeLiteral, factoryDeprecation);
 
 /** @deprecated Use `factory.createJSDocImplementsTag` or the factory supplied by your transformation context instead. */
-export const createJSDocImplementsTag = Debug.deprecate(factory.createJSDocImplementsTag, factoryDeprecation);
+export const createJSDocImplementsTag: typeof factory.createJSDocImplementsTag = Debug.deprecate(factory.createJSDocImplementsTag, factoryDeprecation);
 
 /** @deprecated Use `factory.createJSDocAuthorTag` or the factory supplied by your transformation context instead. */
-export const createJSDocAuthorTag = Debug.deprecate(factory.createJSDocAuthorTag, factoryDeprecation);
+export const createJSDocAuthorTag: typeof factory.createJSDocAuthorTag = Debug.deprecate(factory.createJSDocAuthorTag, factoryDeprecation);
 
 /** @deprecated Use `factory.createJSDocPublicTag` or the factory supplied by your transformation context instead. */
-export const createJSDocPublicTag = Debug.deprecate(factory.createJSDocPublicTag, factoryDeprecation);
+export const createJSDocPublicTag: typeof factory.createJSDocPublicTag = Debug.deprecate(factory.createJSDocPublicTag, factoryDeprecation);
 
 /** @deprecated Use `factory.createJSDocPrivateTag` or the factory supplied by your transformation context instead. */
-export const createJSDocPrivateTag = Debug.deprecate(factory.createJSDocPrivateTag, factoryDeprecation);
+export const createJSDocPrivateTag: typeof factory.createJSDocPrivateTag = Debug.deprecate(factory.createJSDocPrivateTag, factoryDeprecation);
 
 /** @deprecated Use `factory.createJSDocProtectedTag` or the factory supplied by your transformation context instead. */
-export const createJSDocProtectedTag = Debug.deprecate(factory.createJSDocProtectedTag, factoryDeprecation);
+export const createJSDocProtectedTag: typeof factory.createJSDocProtectedTag = Debug.deprecate(factory.createJSDocProtectedTag, factoryDeprecation);
 
 /** @deprecated Use `factory.createJSDocReadonlyTag` or the factory supplied by your transformation context instead. */
-export const createJSDocReadonlyTag = Debug.deprecate(factory.createJSDocReadonlyTag, factoryDeprecation);
+export const createJSDocReadonlyTag: typeof factory.createJSDocReadonlyTag = Debug.deprecate(factory.createJSDocReadonlyTag, factoryDeprecation);
 
 /** @deprecated Use `factory.createJSDocUnknownTag` or the factory supplied by your transformation context instead. */
-export const createJSDocTag = Debug.deprecate(factory.createJSDocUnknownTag, factoryDeprecation);
+export const createJSDocTag: typeof factory.createJSDocUnknownTag = Debug.deprecate(factory.createJSDocUnknownTag, factoryDeprecation);
 
 /** @deprecated Use `factory.createJsxElement` or the factory supplied by your transformation context instead. */
-export const createJsxElement = Debug.deprecate(factory.createJsxElement, factoryDeprecation);
+export const createJsxElement: typeof factory.createJsxElement = Debug.deprecate(factory.createJsxElement, factoryDeprecation);
 
 /** @deprecated Use `factory.updateJsxElement` or the factory supplied by your transformation context instead. */
-export const updateJsxElement = Debug.deprecate(factory.updateJsxElement, factoryDeprecation);
+export const updateJsxElement: typeof factory.updateJsxElement = Debug.deprecate(factory.updateJsxElement, factoryDeprecation);
 
 /** @deprecated Use `factory.createJsxSelfClosingElement` or the factory supplied by your transformation context instead. */
-export const createJsxSelfClosingElement = Debug.deprecate(factory.createJsxSelfClosingElement, factoryDeprecation);
+export const createJsxSelfClosingElement: typeof factory.createJsxSelfClosingElement = Debug.deprecate(factory.createJsxSelfClosingElement, factoryDeprecation);
 
 /** @deprecated Use `factory.updateJsxSelfClosingElement` or the factory supplied by your transformation context instead. */
-export const updateJsxSelfClosingElement = Debug.deprecate(factory.updateJsxSelfClosingElement, factoryDeprecation);
+export const updateJsxSelfClosingElement: typeof factory.updateJsxSelfClosingElement = Debug.deprecate(factory.updateJsxSelfClosingElement, factoryDeprecation);
 
 /** @deprecated Use `factory.createJsxOpeningElement` or the factory supplied by your transformation context instead. */
-export const createJsxOpeningElement = Debug.deprecate(factory.createJsxOpeningElement, factoryDeprecation);
+export const createJsxOpeningElement: typeof factory.createJsxOpeningElement = Debug.deprecate(factory.createJsxOpeningElement, factoryDeprecation);
 
 /** @deprecated Use `factory.updateJsxOpeningElement` or the factory supplied by your transformation context instead. */
-export const updateJsxOpeningElement = Debug.deprecate(factory.updateJsxOpeningElement, factoryDeprecation);
+export const updateJsxOpeningElement: typeof factory.updateJsxOpeningElement = Debug.deprecate(factory.updateJsxOpeningElement, factoryDeprecation);
 
 /** @deprecated Use `factory.createJsxClosingElement` or the factory supplied by your transformation context instead. */
-export const createJsxClosingElement = Debug.deprecate(factory.createJsxClosingElement, factoryDeprecation);
+export const createJsxClosingElement: typeof factory.createJsxClosingElement = Debug.deprecate(factory.createJsxClosingElement, factoryDeprecation);
 
 /** @deprecated Use `factory.updateJsxClosingElement` or the factory supplied by your transformation context instead. */
-export const updateJsxClosingElement = Debug.deprecate(factory.updateJsxClosingElement, factoryDeprecation);
+export const updateJsxClosingElement: typeof factory.updateJsxClosingElement = Debug.deprecate(factory.updateJsxClosingElement, factoryDeprecation);
 
 /** @deprecated Use `factory.createJsxFragment` or the factory supplied by your transformation context instead. */
-export const createJsxFragment = Debug.deprecate(factory.createJsxFragment, factoryDeprecation);
+export const createJsxFragment: typeof factory.createJsxFragment = Debug.deprecate(factory.createJsxFragment, factoryDeprecation);
 
 /** @deprecated Use `factory.createJsxText` or the factory supplied by your transformation context instead. */
-export const createJsxText = Debug.deprecate(factory.createJsxText, factoryDeprecation);
+export const createJsxText: typeof factory.createJsxText = Debug.deprecate(factory.createJsxText, factoryDeprecation);
 
 /** @deprecated Use `factory.updateJsxText` or the factory supplied by your transformation context instead. */
-export const updateJsxText = Debug.deprecate(factory.updateJsxText, factoryDeprecation);
+export const updateJsxText: typeof factory.updateJsxText = Debug.deprecate(factory.updateJsxText, factoryDeprecation);
 
 /** @deprecated Use `factory.createJsxOpeningFragment` or the factory supplied by your transformation context instead. */
-export const createJsxOpeningFragment = Debug.deprecate(factory.createJsxOpeningFragment, factoryDeprecation);
+export const createJsxOpeningFragment: typeof factory.createJsxOpeningFragment = Debug.deprecate(factory.createJsxOpeningFragment, factoryDeprecation);
 
 /** @deprecated Use `factory.createJsxJsxClosingFragment` or the factory supplied by your transformation context instead. */
-export const createJsxJsxClosingFragment = Debug.deprecate(factory.createJsxJsxClosingFragment, factoryDeprecation);
+export const createJsxJsxClosingFragment: typeof factory.createJsxJsxClosingFragment = Debug.deprecate(factory.createJsxJsxClosingFragment, factoryDeprecation);
 
 /** @deprecated Use `factory.updateJsxFragment` or the factory supplied by your transformation context instead. */
-export const updateJsxFragment = Debug.deprecate(factory.updateJsxFragment, factoryDeprecation);
+export const updateJsxFragment: typeof factory.updateJsxFragment = Debug.deprecate(factory.updateJsxFragment, factoryDeprecation);
 
 /** @deprecated Use `factory.createJsxAttribute` or the factory supplied by your transformation context instead. */
-export const createJsxAttribute = Debug.deprecate(factory.createJsxAttribute, factoryDeprecation);
+export const createJsxAttribute: typeof factory.createJsxAttribute = Debug.deprecate(factory.createJsxAttribute, factoryDeprecation);
 
 /** @deprecated Use `factory.updateJsxAttribute` or the factory supplied by your transformation context instead. */
-export const updateJsxAttribute = Debug.deprecate(factory.updateJsxAttribute, factoryDeprecation);
+export const updateJsxAttribute: typeof factory.updateJsxAttribute = Debug.deprecate(factory.updateJsxAttribute, factoryDeprecation);
 
 /** @deprecated Use `factory.createJsxAttributes` or the factory supplied by your transformation context instead. */
-export const createJsxAttributes = Debug.deprecate(factory.createJsxAttributes, factoryDeprecation);
+export const createJsxAttributes: typeof factory.createJsxAttributes = Debug.deprecate(factory.createJsxAttributes, factoryDeprecation);
 
 /** @deprecated Use `factory.updateJsxAttributes` or the factory supplied by your transformation context instead. */
-export const updateJsxAttributes = Debug.deprecate(factory.updateJsxAttributes, factoryDeprecation);
+export const updateJsxAttributes: typeof factory.updateJsxAttributes = Debug.deprecate(factory.updateJsxAttributes, factoryDeprecation);
 
 /** @deprecated Use `factory.createJsxSpreadAttribute` or the factory supplied by your transformation context instead. */
-export const createJsxSpreadAttribute = Debug.deprecate(factory.createJsxSpreadAttribute, factoryDeprecation);
+export const createJsxSpreadAttribute: typeof factory.createJsxSpreadAttribute = Debug.deprecate(factory.createJsxSpreadAttribute, factoryDeprecation);
 
 /** @deprecated Use `factory.updateJsxSpreadAttribute` or the factory supplied by your transformation context instead. */
-export const updateJsxSpreadAttribute = Debug.deprecate(factory.updateJsxSpreadAttribute, factoryDeprecation);
+export const updateJsxSpreadAttribute: typeof factory.updateJsxSpreadAttribute = Debug.deprecate(factory.updateJsxSpreadAttribute, factoryDeprecation);
 
 /** @deprecated Use `factory.createJsxExpression` or the factory supplied by your transformation context instead. */
-export const createJsxExpression = Debug.deprecate(factory.createJsxExpression, factoryDeprecation);
+export const createJsxExpression: typeof factory.createJsxExpression = Debug.deprecate(factory.createJsxExpression, factoryDeprecation);
 
 /** @deprecated Use `factory.updateJsxExpression` or the factory supplied by your transformation context instead. */
-export const updateJsxExpression = Debug.deprecate(factory.updateJsxExpression, factoryDeprecation);
+export const updateJsxExpression: typeof factory.updateJsxExpression = Debug.deprecate(factory.updateJsxExpression, factoryDeprecation);
 
 /** @deprecated Use `factory.createCaseClause` or the factory supplied by your transformation context instead. */
-export const createCaseClause = Debug.deprecate(factory.createCaseClause, factoryDeprecation);
+export const createCaseClause: typeof factory.createCaseClause = Debug.deprecate(factory.createCaseClause, factoryDeprecation);
 
 /** @deprecated Use `factory.updateCaseClause` or the factory supplied by your transformation context instead. */
-export const updateCaseClause = Debug.deprecate(factory.updateCaseClause, factoryDeprecation);
+export const updateCaseClause: typeof factory.updateCaseClause = Debug.deprecate(factory.updateCaseClause, factoryDeprecation);
 
 /** @deprecated Use `factory.createDefaultClause` or the factory supplied by your transformation context instead. */
-export const createDefaultClause = Debug.deprecate(factory.createDefaultClause, factoryDeprecation);
+export const createDefaultClause: typeof factory.createDefaultClause = Debug.deprecate(factory.createDefaultClause, factoryDeprecation);
 
 /** @deprecated Use `factory.updateDefaultClause` or the factory supplied by your transformation context instead. */
-export const updateDefaultClause = Debug.deprecate(factory.updateDefaultClause, factoryDeprecation);
+export const updateDefaultClause: typeof factory.updateDefaultClause = Debug.deprecate(factory.updateDefaultClause, factoryDeprecation);
 
 /** @deprecated Use `factory.createHeritageClause` or the factory supplied by your transformation context instead. */
-export const createHeritageClause = Debug.deprecate(factory.createHeritageClause, factoryDeprecation);
+export const createHeritageClause: typeof factory.createHeritageClause = Debug.deprecate(factory.createHeritageClause, factoryDeprecation);
 
 /** @deprecated Use `factory.updateHeritageClause` or the factory supplied by your transformation context instead. */
-export const updateHeritageClause = Debug.deprecate(factory.updateHeritageClause, factoryDeprecation);
+export const updateHeritageClause: typeof factory.updateHeritageClause = Debug.deprecate(factory.updateHeritageClause, factoryDeprecation);
 
 /** @deprecated Use `factory.createCatchClause` or the factory supplied by your transformation context instead. */
-export const createCatchClause = Debug.deprecate(factory.createCatchClause, factoryDeprecation);
+export const createCatchClause: typeof factory.createCatchClause = Debug.deprecate(factory.createCatchClause, factoryDeprecation);
 
 /** @deprecated Use `factory.updateCatchClause` or the factory supplied by your transformation context instead. */
-export const updateCatchClause = Debug.deprecate(factory.updateCatchClause, factoryDeprecation);
+export const updateCatchClause: typeof factory.updateCatchClause = Debug.deprecate(factory.updateCatchClause, factoryDeprecation);
 
 /** @deprecated Use `factory.createPropertyAssignment` or the factory supplied by your transformation context instead. */
-export const createPropertyAssignment = Debug.deprecate(factory.createPropertyAssignment, factoryDeprecation);
+export const createPropertyAssignment: typeof factory.createPropertyAssignment = Debug.deprecate(factory.createPropertyAssignment, factoryDeprecation);
 
 /** @deprecated Use `factory.updatePropertyAssignment` or the factory supplied by your transformation context instead. */
-export const updatePropertyAssignment = Debug.deprecate(factory.updatePropertyAssignment, factoryDeprecation);
+export const updatePropertyAssignment: typeof factory.updatePropertyAssignment = Debug.deprecate(factory.updatePropertyAssignment, factoryDeprecation);
 
 /** @deprecated Use `factory.createShorthandPropertyAssignment` or the factory supplied by your transformation context instead. */
-export const createShorthandPropertyAssignment = Debug.deprecate(factory.createShorthandPropertyAssignment, factoryDeprecation);
+export const createShorthandPropertyAssignment: typeof factory.createShorthandPropertyAssignment = Debug.deprecate(factory.createShorthandPropertyAssignment, factoryDeprecation);
 
 /** @deprecated Use `factory.updateShorthandPropertyAssignment` or the factory supplied by your transformation context instead. */
-export const updateShorthandPropertyAssignment = Debug.deprecate(factory.updateShorthandPropertyAssignment, factoryDeprecation);
+export const updateShorthandPropertyAssignment: typeof factory.updateShorthandPropertyAssignment = Debug.deprecate(factory.updateShorthandPropertyAssignment, factoryDeprecation);
 
 /** @deprecated Use `factory.createSpreadAssignment` or the factory supplied by your transformation context instead. */
-export const createSpreadAssignment = Debug.deprecate(factory.createSpreadAssignment, factoryDeprecation);
+export const createSpreadAssignment: typeof factory.createSpreadAssignment = Debug.deprecate(factory.createSpreadAssignment, factoryDeprecation);
 
 /** @deprecated Use `factory.updateSpreadAssignment` or the factory supplied by your transformation context instead. */
-export const updateSpreadAssignment = Debug.deprecate(factory.updateSpreadAssignment, factoryDeprecation);
+export const updateSpreadAssignment: typeof factory.updateSpreadAssignment = Debug.deprecate(factory.updateSpreadAssignment, factoryDeprecation);
 
 /** @deprecated Use `factory.createEnumMember` or the factory supplied by your transformation context instead. */
-export const createEnumMember = Debug.deprecate(factory.createEnumMember, factoryDeprecation);
+export const createEnumMember: typeof factory.createEnumMember = Debug.deprecate(factory.createEnumMember, factoryDeprecation);
 
 /** @deprecated Use `factory.updateEnumMember` or the factory supplied by your transformation context instead. */
-export const updateEnumMember = Debug.deprecate(factory.updateEnumMember, factoryDeprecation);
+export const updateEnumMember: typeof factory.updateEnumMember = Debug.deprecate(factory.updateEnumMember, factoryDeprecation);
 
 /** @deprecated Use `factory.updateSourceFile` or the factory supplied by your transformation context instead. */
-export const updateSourceFileNode = Debug.deprecate(factory.updateSourceFile, factoryDeprecation);
+export const updateSourceFileNode: typeof factory.updateSourceFile = Debug.deprecate(factory.updateSourceFile, factoryDeprecation);
 
 /** @deprecated Use `factory.createNotEmittedStatement` or the factory supplied by your transformation context instead. */
-export const createNotEmittedStatement = Debug.deprecate(factory.createNotEmittedStatement, factoryDeprecation);
+export const createNotEmittedStatement: typeof factory.createNotEmittedStatement = Debug.deprecate(factory.createNotEmittedStatement, factoryDeprecation);
 
 /** @deprecated Use `factory.createPartiallyEmittedExpression` or the factory supplied by your transformation context instead. */
-export const createPartiallyEmittedExpression = Debug.deprecate(factory.createPartiallyEmittedExpression, factoryDeprecation);
+export const createPartiallyEmittedExpression: typeof factory.createPartiallyEmittedExpression = Debug.deprecate(factory.createPartiallyEmittedExpression, factoryDeprecation);
 
 /** @deprecated Use `factory.updatePartiallyEmittedExpression` or the factory supplied by your transformation context instead. */
-export const updatePartiallyEmittedExpression = Debug.deprecate(factory.updatePartiallyEmittedExpression, factoryDeprecation);
+export const updatePartiallyEmittedExpression: typeof factory.updatePartiallyEmittedExpression = Debug.deprecate(factory.updatePartiallyEmittedExpression, factoryDeprecation);
 
 /** @deprecated Use `factory.createCommaListExpression` or the factory supplied by your transformation context instead. */
-export const createCommaList = Debug.deprecate(factory.createCommaListExpression, factoryDeprecation);
+export const createCommaList: typeof factory.createCommaListExpression = Debug.deprecate(factory.createCommaListExpression, factoryDeprecation);
 
 /** @deprecated Use `factory.updateCommaListExpression` or the factory supplied by your transformation context instead. */
-export const updateCommaList = Debug.deprecate(factory.updateCommaListExpression, factoryDeprecation);
+export const updateCommaList: typeof factory.updateCommaListExpression = Debug.deprecate(factory.updateCommaListExpression, factoryDeprecation);
 
 /** @deprecated Use `factory.createBundle` or the factory supplied by your transformation context instead. */
-export const createBundle = Debug.deprecate(factory.createBundle, factoryDeprecation);
+export const createBundle: typeof factory.createBundle = Debug.deprecate(factory.createBundle, factoryDeprecation);
 
 /** @deprecated Use `factory.updateBundle` or the factory supplied by your transformation context instead. */
-export const updateBundle = Debug.deprecate(factory.updateBundle, factoryDeprecation);
+export const updateBundle: typeof factory.updateBundle = Debug.deprecate(factory.updateBundle, factoryDeprecation);
 
 /** @deprecated Use `factory.createImmediatelyInvokedFunctionExpression` or the factory supplied by your transformation context instead. */
-export const createImmediatelyInvokedFunctionExpression = Debug.deprecate(factory.createImmediatelyInvokedFunctionExpression, factoryDeprecation);
+export const createImmediatelyInvokedFunctionExpression: typeof factory.createImmediatelyInvokedFunctionExpression = Debug.deprecate(factory.createImmediatelyInvokedFunctionExpression, factoryDeprecation);
 
 /** @deprecated Use `factory.createImmediatelyInvokedArrowFunction` or the factory supplied by your transformation context instead. */
-export const createImmediatelyInvokedArrowFunction = Debug.deprecate(factory.createImmediatelyInvokedArrowFunction, factoryDeprecation);
+export const createImmediatelyInvokedArrowFunction: typeof factory.createImmediatelyInvokedArrowFunction = Debug.deprecate(factory.createImmediatelyInvokedArrowFunction, factoryDeprecation);
 
 /** @deprecated Use `factory.createVoidZero` or the factory supplied by your transformation context instead. */
-export const createVoidZero = Debug.deprecate(factory.createVoidZero, factoryDeprecation);
+export const createVoidZero: typeof factory.createVoidZero = Debug.deprecate(factory.createVoidZero, factoryDeprecation);
 
 /** @deprecated Use `factory.createExportDefault` or the factory supplied by your transformation context instead. */
-export const createExportDefault = Debug.deprecate(factory.createExportDefault, factoryDeprecation);
+export const createExportDefault: typeof factory.createExportDefault = Debug.deprecate(factory.createExportDefault, factoryDeprecation);
 
 /** @deprecated Use `factory.createExternalModuleExport` or the factory supplied by your transformation context instead. */
-export const createExternalModuleExport = Debug.deprecate(factory.createExternalModuleExport, factoryDeprecation);
+export const createExternalModuleExport: typeof factory.createExternalModuleExport = Debug.deprecate(factory.createExternalModuleExport, factoryDeprecation);
 
 /** @deprecated Use `factory.createNamespaceExport` or the factory supplied by your transformation context instead. */
-export const createNamespaceExport = Debug.deprecate(factory.createNamespaceExport, factoryDeprecation);
+export const createNamespaceExport: typeof factory.createNamespaceExport = Debug.deprecate(factory.createNamespaceExport, factoryDeprecation);
 
 /** @deprecated Use `factory.updateNamespaceExport` or the factory supplied by your transformation context instead. */
-export const updateNamespaceExport = Debug.deprecate(factory.updateNamespaceExport, factoryDeprecation);
+export const updateNamespaceExport: typeof factory.updateNamespaceExport = Debug.deprecate(factory.updateNamespaceExport, factoryDeprecation);
 
 /** @deprecated Use `factory.createToken` or the factory supplied by your transformation context instead. */
 export const createToken = Debug.deprecate(function createToken<TKind extends SyntaxKind>(kind: TKind): Token<TKind> {
diff --git a/src/deprecatedCompat/deprecations.ts b/src/deprecatedCompat/deprecations.ts
index d85748d14d..20ac933563 100644
--- a/src/deprecatedCompat/deprecations.ts
+++ b/src/deprecatedCompat/deprecations.ts
@@ -1,4 +1,4 @@
-import { Debug, DeprecationOptions, hasProperty } from "./_namespaces/ts";
+import { Debug, DeprecationOptions, hasProperty, UnionToIntersection } from "./_namespaces/ts";
 
 // The following are deprecations for the public API. Deprecated exports are removed from the compiler itself
 // and compatible implementations are added here, along with an appropriate deprecation warning using
@@ -12,31 +12,58 @@ import { Debug, DeprecationOptions, hasProperty } from "./_namespaces/ts";
 //
 // Once we have determined enough time has passed after a deprecation has been marked as `"warn"` or `"error"`, it will be removed from the public API.
 
-/** Defines a list of overloads by ordinal */
-type OverloadDefinitions = { readonly [P in number]: (...args: any[]) => any; };
-
-/** A function that returns the ordinal of the overload that matches the provided arguments */
-type OverloadBinder<T extends OverloadDefinitions> = (args: OverloadParameters<T>) => OverloadKeys<T> | undefined;
-
-/** Extracts the ordinals from an set of overload definitions. */
-type OverloadKeys<T extends OverloadDefinitions> = Extract<keyof T, number>;
-
-/** Extracts a union of the potential parameter lists for each overload. */
-type OverloadParameters<T extends OverloadDefinitions> = Parameters<{ [P in OverloadKeys<T>]: T[P]; }[OverloadKeys<T>]>;
+/**
+ * Defines a list of overloads by ordinal
+ *
+ * @internal
+ */
+export type OverloadDefinitions = { readonly [P in number]: (...args: any[]) => any; };
+
+/**
+ * A function that returns the ordinal of the overload that matches the provided arguments
+ *
+ * @internal
+ */
+export type OverloadBinder<T extends OverloadDefinitions> = (args: OverloadParameters<T>) => OverloadKeys<T> | undefined;
+
+/**
+ * Extracts the ordinals from an set of overload definitions.
+ *
+ * @internal
+ */
+export type OverloadKeys<T extends OverloadDefinitions> = Extract<keyof T, number>;
+
+/**
+ * Extracts a union of the potential parameter lists for each overload.
+ *
+ * @internal
+ */
+export type OverloadParameters<T extends OverloadDefinitions> = Parameters<{ [P in OverloadKeys<T>]: T[P]; }[OverloadKeys<T>]>;
 
 // NOTE: the following doesn't work in TS 4.4 (the current LKG in main), so we have to use UnionToIntersection for now
-/** Constructs an intersection of each overload in a set of overload definitions. */
 // type OverloadFunction<T extends OverloadDefinitions, R extends ((...args: any[]) => any)[] = [], O = unknown> =
 //     R["length"] extends keyof T ? OverloadFunction<T, [...R, T[R["length"]]], O & T[R["length"]]> :
 //     unknown extends O ? never : O;
-type UnionToIntersection<T> = (T extends any ? (x: T) => any : never) extends (x: infer R) => any ? R : never;
-type OverloadFunction<T extends OverloadDefinitions> = UnionToIntersection<T[keyof T]>;
-
-/** Maps each ordinal in a set of overload definitions to a function that can be used to bind its arguments. */
-type OverloadBinders<T extends OverloadDefinitions> = { [P in OverloadKeys<T>]: (args: OverloadParameters<T>) => boolean | undefined; };
-
-/** Defines deprecations for specific overloads by ordinal. */
-type OverloadDeprecations<T extends OverloadDefinitions> = { [P in OverloadKeys<T>]?: DeprecationOptions; };
+/**
+ * Constructs an intersection of each overload in a set of overload definitions.
+ *
+ * @internal
+ */
+export type OverloadFunction<T extends OverloadDefinitions> = UnionToIntersection<T[keyof T]>;
+
+/**
+ * Maps each ordinal in a set of overload definitions to a function that can be used to bind its arguments.
+ *
+ * @internal
+ */
+export type OverloadBinders<T extends OverloadDefinitions> = { [P in OverloadKeys<T>]: (args: OverloadParameters<T>) => boolean | undefined; };
+
+/**
+ * Defines deprecations for specific overloads by ordinal.
+ *
+ * @internal
+ */
+export type OverloadDeprecations<T extends OverloadDefinitions> = { [P in OverloadKeys<T>]?: DeprecationOptions; };
 
 /** @internal */
 export function createOverload<T extends OverloadDefinitions>(name: string, overloads: T, binder: OverloadBinders<T>, deprecations?: OverloadDeprecations<T>) {
@@ -75,19 +102,23 @@ function createBinder<T extends OverloadDefinitions>(overloads: T, binder: Overl
     };
 }
 
-interface OverloadBuilder {
+/** @internal */
+export interface OverloadBuilder {
     overload<T extends OverloadDefinitions>(overloads: T): BindableOverloadBuilder<T>;
 }
 
-interface BindableOverloadBuilder<T extends OverloadDefinitions> {
+/** @internal */
+export interface BindableOverloadBuilder<T extends OverloadDefinitions> {
     bind(binder: OverloadBinders<T>): BoundOverloadBuilder<T>;
 }
 
-interface FinishableOverloadBuilder<T extends OverloadDefinitions> {
+/** @internal */
+export interface FinishableOverloadBuilder<T extends OverloadDefinitions> {
     finish(): OverloadFunction<T>;
 }
 
-interface BoundOverloadBuilder<T extends OverloadDefinitions> extends FinishableOverloadBuilder<T> {
+/** @internal */
+export interface BoundOverloadBuilder<T extends OverloadDefinitions> extends FinishableOverloadBuilder<T> {
     deprecate(deprecations: OverloadDeprecations<T>): FinishableOverloadBuilder<T>;
 }
 
diff --git a/src/server/editorServices.ts b/src/server/editorServices.ts
index 1ae9921a3c..b3e91f685e 100644
--- a/src/server/editorServices.ts
+++ b/src/server/editorServices.ts
@@ -28,7 +28,7 @@ import {
     parseJsonSourceFileConfigFileContent, parseJsonText, parsePackageName, Path, PerformanceEvent, PluginImport,
     PollingInterval, ProjectPackageJsonInfo, ProjectReference, ReadMapFile, ReadonlyCollection, removeFileExtension,
     removeIgnoredPath, removeMinAndVersionNumbers, ResolvedProjectReference, resolveProjectReferencePath,
-    returnNoopFileWatcher, returnTrue, ScriptKind, Set, SharedExtendedConfigFileWatcher, some, SourceFile, startsWith,
+    returnNoopFileWatcher, returnTrue, ScriptKind, Set, SharedExtendedConfigFileWatcher, some, SourceFile, SourceFileLike, startsWith,
     Ternary, TextChange, toFileNameLowerCase, toPath, tracing, tryAddToSet, tryReadFile, TsConfigSourceFile,
     TypeAcquisition, typeAcquisitionDeclarations, unorderedRemoveItem, updateSharedExtendedConfigFileWatcher,
     updateWatchingWildcardDirectories, UserPreferences, version, WatchDirectoryFlags, WatchFactory, WatchLogLevel,
@@ -397,7 +397,7 @@ function findProjectByName<T extends Project>(projectName: string, projects: T[]
 const noopConfigFileWatcher: FileWatcher = { close: noop };
 
 /** @internal */
-interface ConfigFileExistenceInfo {
+export interface ConfigFileExistenceInfo {
     /**
      * Cached value of existence of config file
      * It is true if there is configured project open for this file.
@@ -2984,7 +2984,7 @@ export class ProjectService {
     }
 
     /** @internal */
-    getSourceFileLike(fileName: string, projectNameOrProject: string | Project, declarationInfo?: ScriptInfo) {
+    getSourceFileLike(fileName: string, projectNameOrProject: string | Project, declarationInfo?: ScriptInfo): SourceFileLike | undefined {
         const project = (projectNameOrProject as Project).projectName ? projectNameOrProject as Project : this.findProject(projectNameOrProject as string);
         if (project) {
             const path = project.toPath(fileName);
diff --git a/src/server/scriptVersionCache.ts b/src/server/scriptVersionCache.ts
index 13a2fbe6a0..fc828b3f8c 100644
--- a/src/server/scriptVersionCache.ts
+++ b/src/server/scriptVersionCache.ts
@@ -6,7 +6,8 @@ import { emptyArray, protocol } from "./_namespaces/ts.server";
 
 const lineCollectionCapacity = 4;
 
-interface LineCollection {
+/** @internal */
+export interface LineCollection {
     charCount(): number;
     lineCount(): number;
     isLeaf(): this is LineLeaf;
@@ -19,7 +20,8 @@ export interface AbsolutePositionAndLineText {
     lineText: string | undefined;
 }
 
-const enum CharRangeSection {
+/** @internal */
+export const enum CharRangeSection {
     PreStart,
     Start,
     Entire,
@@ -28,7 +30,8 @@ const enum CharRangeSection {
     PostEnd
 }
 
-interface LineIndexWalker {
+/** @internal */
+export interface LineIndexWalker {
     goSubtree: boolean;
     done: boolean;
     leaf(relativeStart: number, relativeLength: number, lineCollection: LineLeaf): void;
@@ -568,7 +571,8 @@ export class LineIndex {
     }
 }
 
-class LineNode implements LineCollection {
+/** @internal */
+export class LineNode implements LineCollection {
     totalChars = 0;
     totalLines = 0;
 
@@ -819,7 +823,8 @@ class LineNode implements LineCollection {
     }
 }
 
-class LineLeaf implements LineCollection {
+/** @internal */
+export class LineLeaf implements LineCollection {
     constructor(public text: string) {
     }
 
diff --git a/src/services/codefixes/annotateWithTypeFromJSDoc.ts b/src/services/codefixes/annotateWithTypeFromJSDoc.ts
index 8003b4a713..8220c43714 100644
--- a/src/services/codefixes/annotateWithTypeFromJSDoc.ts
+++ b/src/services/codefixes/annotateWithTypeFromJSDoc.ts
@@ -32,7 +32,8 @@ function getDeclaration(file: SourceFile, pos: number): DeclarationWithType | un
     return tryCast(isParameter(name.parent) ? name.parent.parent : name.parent, parameterShouldGetTypeFromJSDoc);
 }
 
-type DeclarationWithType =
+/** @internal */
+export type DeclarationWithType =
     | FunctionLikeDeclaration
     | VariableDeclaration
     | PropertySignature
diff --git a/src/services/codefixes/generateAccessors.ts b/src/services/codefixes/generateAccessors.ts
index 1ae126ddfa..50366542a9 100644
--- a/src/services/codefixes/generateAccessors.ts
+++ b/src/services/codefixes/generateAccessors.ts
@@ -11,12 +11,19 @@ import {
     SymbolFlags, SyntaxKind, textChanges, TypeChecker, TypeNode,
 } from "../_namespaces/ts";
 
-type AcceptedDeclaration = ParameterPropertyDeclaration | PropertyDeclaration | PropertyAssignment;
-type AcceptedNameType = Identifier | StringLiteral;
-type ContainerDeclaration = ClassLikeDeclaration | ObjectLiteralExpression;
 
-type Info = AccessorInfo | refactor.RefactorErrorInfo;
-interface AccessorInfo {
+/** @internal */
+export type AcceptedDeclaration = ParameterPropertyDeclaration | PropertyDeclaration | PropertyAssignment;
+/** @internal */
+export type AcceptedNameType = Identifier | StringLiteral;
+/** @internal */
+export type ContainerDeclaration = ClassLikeDeclaration | ObjectLiteralExpression;
+
+/** @internal */
+export type AccessorOrRefactorErrorInfo = AccessorInfo | refactor.RefactorErrorInfo;
+
+/** @internal */
+export interface AccessorInfo {
     readonly container: ContainerDeclaration;
     readonly isStatic: boolean;
     readonly isReadonly: boolean;
@@ -117,7 +124,7 @@ function prepareModifierFlagsForField(modifierFlags: ModifierFlags): ModifierFla
 }
 
 /** @internal */
-export function getAccessorConvertiblePropertyAtPosition(file: SourceFile, program: Program, start: number, end: number, considerEmptySpans = true): Info | undefined {
+export function getAccessorConvertiblePropertyAtPosition(file: SourceFile, program: Program, start: number, end: number, considerEmptySpans = true): AccessorOrRefactorErrorInfo | undefined {
     const node = getTokenAtPosition(file, start);
     const cursorRequest = start === end && considerEmptySpans;
     const declaration = findAncestor(node.parent, isAcceptedDeclaration);
diff --git a/src/services/codefixes/helpers.ts b/src/services/codefixes/helpers.ts
index c54f6da012..d523d8567b 100644
--- a/src/services/codefixes/helpers.ts
+++ b/src/services/codefixes/helpers.ts
@@ -8,7 +8,7 @@ import {
     IntersectionType, isArrowFunction, isAutoAccessorPropertyDeclaration, isFunctionDeclaration, isFunctionExpression,
     isGetAccessorDeclaration, isIdentifier, isImportTypeNode, isInJSFile, isLiteralImportTypeNode, isMethodDeclaration,
     isObjectLiteralExpression, isPropertyAccessExpression, isPropertyAssignment, isSetAccessorDeclaration,
-    isStringLiteral, isYieldExpression, LanguageServiceHost, length, map, Map, MethodDeclaration, Modifier,
+    isStringLiteral, isYieldExpression, LanguageServiceHost, length, map, Map, MethodDeclaration, MethodSignature, Modifier,
     ModifierFlags, Node, NodeArray, NodeBuilderFlags, NodeFlags, nullTransformationContext, ObjectFlags,
     ObjectLiteralExpression, ObjectType, ParameterDeclaration, Program, PropertyAssignment, PropertyDeclaration,
     PropertyName, QuotePreference, sameMap, ScriptTarget, Set, SetAccessorDeclaration, setTextRange, Signature,
@@ -57,7 +57,8 @@ export interface TypeConstructionContext {
     host: LanguageServiceHost;
 }
 
-type AddNode = PropertyDeclaration | GetAccessorDeclaration | SetAccessorDeclaration | MethodDeclaration | FunctionExpression | ArrowFunction;
+/** @internal */
+export type AddNode = PropertyDeclaration | GetAccessorDeclaration | SetAccessorDeclaration | MethodDeclaration | FunctionExpression | ArrowFunction;
 
 /** @internal */
 export const enum PreserveOptionalFlags {
@@ -353,7 +354,7 @@ export function createSignatureDeclarationFromCallExpression(
     name: Identifier | string,
     modifierFlags: ModifierFlags,
     contextNode: Node
-) {
+): MethodDeclaration | MethodSignature | FunctionDeclaration {
     const quotePreference = getQuotePreference(context.sourceFile, context.preferences);
     const scriptTarget = getEmitScriptTarget(context.program.getCompilerOptions());
     const tracker = getNoopSymbolTrackerWithResolver(context);
@@ -417,7 +418,8 @@ export function createSignatureDeclarationFromCallExpression(
     }
 }
 
-interface ArgumentTypeParameterAndConstraint {
+/** @internal */
+export interface ArgumentTypeParameterAndConstraint {
     argumentType: Type;
     constraint?: TypeNode;
 }
diff --git a/src/services/completions.ts b/src/services/completions.ts
index 86de7d17e3..f3e4f3f2ec 100644
--- a/src/services/completions.ts
+++ b/src/services/completions.ts
@@ -124,7 +124,8 @@ export enum CompletionSource {
     ObjectLiteralMethodSnippet = "ObjectLiteralMethodSnippet/",
 }
 
-const enum SymbolOriginInfoKind {
+/** @internal */
+export const enum SymbolOriginInfoKind {
     ThisType            = 1 << 0,
     SymbolMember        = 1 << 1,
     Export              = 1 << 2,
@@ -138,7 +139,8 @@ const enum SymbolOriginInfoKind {
     SymbolMemberExport   = SymbolMember | Export,
 }
 
-interface SymbolOriginInfo {
+/** @internal */
+export interface SymbolOriginInfo {
     kind: SymbolOriginInfoKind;
     isDefaultExport?: boolean;
     isFromPackageJson?: boolean;
@@ -210,18 +212,25 @@ function originIsObjectLiteralMethod(origin: SymbolOriginInfo | undefined): orig
     return !!(origin && origin.kind & SymbolOriginInfoKind.ObjectLiteralMethod);
 }
 
-interface UniqueNameSet {
+/** @internal */
+export interface UniqueNameSet {
     add(name: string): void;
     has(name: string): boolean;
 }
 
 /**
  * Map from symbol index in `symbols` -> SymbolOriginInfo.
+ *
+ * @internal
  */
-type SymbolOriginInfoMap = Record<number, SymbolOriginInfo>;
+export type SymbolOriginInfoMap = Record<number, SymbolOriginInfo>;
 
-/** Map from symbol id -> SortText. */
-type SymbolSortTextMap = (SortText | undefined)[];
+/**
+ * Map from symbol id -> SortText.
+ *
+ * @internal
+ */
+export type SymbolSortTextMap = (SortText | undefined)[];
 
 const enum KeywordCompletionFilters {
     None,                           // No keywords
@@ -1881,8 +1890,12 @@ export function getCompletionEntrySymbol(
 }
 
 const enum CompletionDataKind { Data, JsDocTagName, JsDocTag, JsDocParameterName, Keywords }
-/** true: after the `=` sign but no identifier has been typed yet. Else is the Identifier after the initializer. */
-type IsJsxInitializer = boolean | Identifier;
+/**
+ * true: after the `=` sign but no identifier has been typed yet. Else is the Identifier after the initializer.
+ *
+ * @internal
+ */
+export type IsJsxInitializer = boolean | Identifier;
 interface CompletionData {
     readonly kind: CompletionDataKind.Data;
     readonly symbols: readonly Symbol[];
@@ -4319,7 +4332,8 @@ function tryGetObjectLiteralContextualType(node: ObjectLiteralExpression, typeCh
     return undefined;
 }
 
-interface ImportStatementCompletionInfo {
+/** @internal */
+export interface ImportStatementCompletionInfo {
     isKeywordOnlyCompletion: boolean;
     keywordCompletion: TokenSyntaxKind | undefined;
     isNewIdentifierLocation: boolean;
diff --git a/src/services/getEditsForFileRename.ts b/src/services/getEditsForFileRename.ts
index bdd1ac357d..2c2096a860 100644
--- a/src/services/getEditsForFileRename.ts
+++ b/src/services/getEditsForFileRename.ts
@@ -30,8 +30,12 @@ export function getEditsForFileRename(
     });
 }
 
-/** If 'path' refers to an old directory, returns path in the new directory. */
-type PathUpdater = (path: string) => string | undefined;
+/**
+ * If 'path' refers to an old directory, returns path in the new directory.
+ *
+ * @internal
+ */
+export type PathUpdater = (path: string) => string | undefined;
 // exported for tests
 /** @internal */
 export function getPathUpdater(oldFileOrDirPath: string, newFileOrDirPath: string, getCanonicalFileName: GetCanonicalFileName, sourceMapper: SourceMapper | undefined): PathUpdater {
diff --git a/src/services/organizeImports.ts b/src/services/organizeImports.ts
index 8dd382f0e9..d2643e23ea 100644
--- a/src/services/organizeImports.ts
+++ b/src/services/organizeImports.ts
@@ -1,6 +1,7 @@
 import {
     AnyImportOrRequireStatement, arrayIsSorted, binarySearch, compareBooleans, compareStringsCaseInsensitive,
-    compareValues, createScanner, emptyArray, ExportDeclaration, ExportSpecifier, Expression, factory,
+    compareValues, Comparison, createScanner, emptyArray, ExportDeclaration, ExportSpecifier, Expression, factory,
+    FileTextChanges,
     FindAllReferences, flatMap, formatting, getNewLineOrDefaultFromHost, group, Identifier, identity, ImportDeclaration,
     ImportOrExportSpecifier, ImportSpecifier, isAmbientModule, isExportDeclaration, isExternalModuleNameRelative,
     isExternalModuleReference, isImportDeclaration, isNamedExports, isNamedImports, isNamespaceImport, isString,
@@ -24,7 +25,7 @@ export function organizeImports(
     program: Program,
     preferences: UserPreferences,
     skipDestructiveCodeActions?: boolean
-) {
+): FileTextChanges[] {
     const changeTracker = textChanges.ChangeTracker.fromContext({ host, formatContext, preferences });
 
     const coalesceAndOrganizeImports = (importGroup: readonly ImportDeclaration[]) => stableSort(
@@ -468,7 +469,7 @@ function sortSpecifiers<T extends ImportOrExportSpecifier>(specifiers: readonly
 }
 
 /** @internal */
-export function compareImportOrExportSpecifiers<T extends ImportOrExportSpecifier>(s1: T, s2: T) {
+export function compareImportOrExportSpecifiers<T extends ImportOrExportSpecifier>(s1: T, s2: T): Comparison {
     return compareBooleans(s1.isTypeOnly, s2.isTypeOnly)
         || compareIdentifiers(s1.propertyName || s1.name, s2.propertyName || s2.name)
         || compareIdentifiers(s1.name, s2.name);
@@ -525,7 +526,7 @@ export function getImportSpecifierInsertionIndex(sortedImports: SortedReadonlyAr
 }
 
 /** @internal */
-export function compareImportsOrRequireStatements(s1: AnyImportOrRequireStatement, s2: AnyImportOrRequireStatement) {
+export function compareImportsOrRequireStatements(s1: AnyImportOrRequireStatement, s2: AnyImportOrRequireStatement): Comparison {
     return compareModuleSpecifiers(getModuleSpecifierExpression(s1), getModuleSpecifierExpression(s2)) || compareImportKind(s1, s2);
 }
 
diff --git a/src/services/refactors/extractSymbol.ts b/src/services/refactors/extractSymbol.ts
index a49c9f248d..9a702aa1a7 100644
--- a/src/services/refactors/extractSymbol.ts
+++ b/src/services/refactors/extractSymbol.ts
@@ -255,7 +255,8 @@ export namespace Messages {
     export const cannotExtractFunctionsContainingThisToMethod = createMessage("Cannot extract functions containing this to method");
 }
 
-enum RangeFacts {
+/** @internal */
+export enum RangeFacts {
     None = 0,
     HasReturn = 1 << 0,
     IsGenerator = 1 << 1,
@@ -270,8 +271,10 @@ enum RangeFacts {
 
 /**
  * Represents an expression or a list of statements that should be extracted with some extra information
+ *
+ * @internal
  */
-interface TargetRange {
+export interface TargetRange {
     readonly range: Expression | Statement[];
     readonly facts: RangeFacts;
     /**
@@ -287,8 +290,10 @@ interface TargetRange {
 
 /**
  * Result of 'getRangeToExtract' operation: contains either a range or a list of errors
+ *
+ * @internal
  */
-type RangeToExtract = {
+export type RangeToExtract = {
     readonly targetRange?: never;
     readonly errors: readonly Diagnostic[];
 } | {
diff --git a/src/services/sourcemaps.ts b/src/services/sourcemaps.ts
index 73079ef532..8a80b02ffb 100644
--- a/src/services/sourcemaps.ts
+++ b/src/services/sourcemaps.ts
@@ -155,7 +155,7 @@ export function getDocumentPositionMapper(
     host: DocumentPositionMapperHost,
     generatedFileName: string,
     generatedFileLineInfo: LineInfo,
-    readMapFile: ReadMapFile) {
+    readMapFile: ReadMapFile): DocumentPositionMapper | undefined {
     let mapFileName = tryGetSourceMappingURL(generatedFileLineInfo);
     if (mapFileName) {
         const match = base64UrlRegExp.exec(mapFileName);
diff --git a/src/services/symbolDisplay.ts b/src/services/symbolDisplay.ts
index 78d07e625d..ce70ddb0dc 100644
--- a/src/services/symbolDisplay.ts
+++ b/src/services/symbolDisplay.ts
@@ -149,7 +149,8 @@ export function getSymbolModifiers(typeChecker: TypeChecker, symbol: Symbol): st
     return modifiers.size > 0 ? arrayFrom(modifiers.values()).join(",") : ScriptElementKindModifier.none;
 }
 
-interface SymbolDisplayPartsDocumentationAndSymbolKind {
+/** @internal */
+export interface SymbolDisplayPartsDocumentationAndSymbolKind {
     displayParts: SymbolDisplayPart[];
     documentation: SymbolDisplayPart[];
     symbolKind: ScriptElementKind;
diff --git a/src/services/textChanges.ts b/src/services/textChanges.ts
index 2ddc725e83..4673304be2 100644
--- a/src/services/textChanges.ts
+++ b/src/services/textChanges.ts
@@ -1192,7 +1192,8 @@ function assignPositionsToNodeArray(nodes: NodeArray<any>, visitor: Visitor, tes
     return nodeArray;
 }
 
-interface TextChangesWriter extends EmitTextWriter, PrintHandlers {}
+/** @internal */
+export interface TextChangesWriter extends EmitTextWriter, PrintHandlers {}
 
 /** @internal */
 export function createWriter(newLine: string): TextChangesWriter {
diff --git a/src/services/transform.ts b/src/services/transform.ts
index f6fb9314ac..04ad279c73 100644
--- a/src/services/transform.ts
+++ b/src/services/transform.ts
@@ -1,5 +1,6 @@
 import {
     CompilerOptions, concatenate, DiagnosticWithLocation, factory, fixupCompilerOptions, isArray, Node,
+    TransformationResult,
     TransformerFactory, transformNodes,
 } from "./_namespaces/ts";
 
@@ -9,11 +10,11 @@ import {
  * @param transformers An array of `TransformerFactory` callbacks used to process the transformation.
  * @param compilerOptions Optional compiler options.
  */
-export function transform<T extends Node>(source: T | T[], transformers: TransformerFactory<T>[], compilerOptions?: CompilerOptions) {
+export function transform<T extends Node>(source: T | T[], transformers: TransformerFactory<T>[], compilerOptions?: CompilerOptions): TransformationResult<T> {
     const diagnostics: DiagnosticWithLocation[] = [];
     compilerOptions = fixupCompilerOptions(compilerOptions!, diagnostics); // TODO: GH#18217
     const nodes = isArray(source) ? source : [source];
     const result = transformNodes(/*resolver*/ undefined, /*emitHost*/ undefined, factory, compilerOptions, nodes, transformers, /*allowDtsFiles*/ true);
     result.diagnostics = concatenate(result.diagnostics, diagnostics);
     return result;
-}
\ No newline at end of file
+}
diff --git a/src/tsserverlibrary/tsserverlibrary.ts b/src/tsserverlibrary/tsserverlibrary.ts
index bd73794b37..caa2e6b1db 100644
--- a/src/tsserverlibrary/tsserverlibrary.ts
+++ b/src/tsserverlibrary/tsserverlibrary.ts
@@ -1,5 +1 @@
-import * as ts from "./_namespaces/ts";
-
-// TODO(jakebailey): replace const enum with enum in d.ts
-
-export = ts;
+export * from "./_namespaces/ts";
diff --git a/src/typescript/typescript.ts b/src/typescript/typescript.ts
index c9862f6a73..8a5136a1eb 100644
--- a/src/typescript/typescript.ts
+++ b/src/typescript/typescript.ts
@@ -1,8 +1,5 @@
-import * as ts from "./_namespaces/ts";
 import { Debug, LogLevel } from "./_namespaces/ts";
 
-// TODO(jakebailey): replace const enum with enum in d.ts
-
 // enable deprecation logging
 declare const console: any;
 if (typeof console !== "undefined") {
@@ -18,4 +15,4 @@ if (typeof console !== "undefined") {
     };
 }
 
-export = ts;
+export * from "./_namespaces/ts";
diff --git a/tests/baselines/reference/APISample_compile.js b/tests/baselines/reference/APISample_compile.js
index 2f4cb4c89b..3dfec01fc8 100644
--- a/tests/baselines/reference/APISample_compile.js
+++ b/tests/baselines/reference/APISample_compile.js
@@ -76,5 +76,5 @@ function compile(fileNames, options) {
 exports.compile = compile;
 compile(process.argv.slice(2), {
     noEmitOnError: true, noImplicitAny: true,
-    target: 1 /* ts.ScriptTarget.ES5 */, module: ts.ModuleKind.CommonJS
+    target: ts.ScriptTarget.ES5, module: ts.ModuleKind.CommonJS
 });
diff --git a/tests/baselines/reference/APISample_jsdoc.js b/tests/baselines/reference/APISample_jsdoc.js
index a525771c5f..4763a59736 100644
--- a/tests/baselines/reference/APISample_jsdoc.js
+++ b/tests/baselines/reference/APISample_jsdoc.js
@@ -178,10 +178,10 @@ function getAnnotations(node) {
 }
 // these examples are artificial and mostly nonsensical
 function parseSpecificTags(node) {
-    if (node.kind === 166 /* ts.SyntaxKind.Parameter */) {
+    if (node.kind === ts.SyntaxKind.Parameter) {
         return ts.getJSDocParameterTags(node);
     }
-    if (node.kind === 259 /* ts.SyntaxKind.FunctionDeclaration */) {
+    if (node.kind === ts.SyntaxKind.FunctionDeclaration) {
         var func = node;
         if (ts.hasJSDocParameterTags(func)) {
             var flat = [];
@@ -195,11 +195,11 @@ function parseSpecificTags(node) {
     }
 }
 function getReturnTypeFromJSDoc(node) {
-    if (node.kind === 259 /* ts.SyntaxKind.FunctionDeclaration */) {
+    if (node.kind === ts.SyntaxKind.FunctionDeclaration) {
         return ts.getJSDocReturnType(node);
     }
     var type = ts.getJSDocType(node);
-    if (type && type.kind === 181 /* ts.SyntaxKind.FunctionType */) {
+    if (type && type.kind === ts.SyntaxKind.FunctionType) {
         return type.type;
     }
 }
diff --git a/tests/baselines/reference/APISample_linter.js b/tests/baselines/reference/APISample_linter.js
index 69eab7271e..185a346d3a 100644
--- a/tests/baselines/reference/APISample_linter.js
+++ b/tests/baselines/reference/APISample_linter.js
@@ -86,28 +86,28 @@ function delint(sourceFile) {
     delintNode(sourceFile);
     function delintNode(node) {
         switch (node.kind) {
-            case 245 /* ts.SyntaxKind.ForStatement */:
-            case 246 /* ts.SyntaxKind.ForInStatement */:
-            case 244 /* ts.SyntaxKind.WhileStatement */:
-            case 243 /* ts.SyntaxKind.DoStatement */:
-                if (node.statement.kind !== 238 /* ts.SyntaxKind.Block */) {
+            case ts.SyntaxKind.ForStatement:
+            case ts.SyntaxKind.ForInStatement:
+            case ts.SyntaxKind.WhileStatement:
+            case ts.SyntaxKind.DoStatement:
+                if (node.statement.kind !== ts.SyntaxKind.Block) {
                     report(node, "A looping statement's contents should be wrapped in a block body.");
                 }
                 break;
-            case 242 /* ts.SyntaxKind.IfStatement */:
+            case ts.SyntaxKind.IfStatement:
                 var ifStatement = node;
-                if (ifStatement.thenStatement.kind !== 238 /* ts.SyntaxKind.Block */) {
+                if (ifStatement.thenStatement.kind !== ts.SyntaxKind.Block) {
                     report(ifStatement.thenStatement, "An if statement's contents should be wrapped in a block body.");
                 }
                 if (ifStatement.elseStatement &&
-                    ifStatement.elseStatement.kind !== 238 /* ts.SyntaxKind.Block */ &&
-                    ifStatement.elseStatement.kind !== 242 /* ts.SyntaxKind.IfStatement */) {
+                    ifStatement.elseStatement.kind !== ts.SyntaxKind.Block &&
+                    ifStatement.elseStatement.kind !== ts.SyntaxKind.IfStatement) {
                     report(ifStatement.elseStatement, "An else statement's contents should be wrapped in a block body.");
                 }
                 break;
-            case 223 /* ts.SyntaxKind.BinaryExpression */:
+            case ts.SyntaxKind.BinaryExpression:
                 var op = node.operatorToken.kind;
-                if (op === 34 /* ts.SyntaxKind.EqualsEqualsToken */ || op == 35 /* ts.SyntaxKind.ExclamationEqualsToken */) {
+                if (op === ts.SyntaxKind.EqualsEqualsToken || op == ts.SyntaxKind.ExclamationEqualsToken) {
                     report(node, "Use '===' and '!=='.");
                 }
                 break;
@@ -123,7 +123,7 @@ exports.delint = delint;
 var fileNames = process.argv.slice(2);
 fileNames.forEach(function (fileName) {
     // Parse a file
-    var sourceFile = ts.createSourceFile(fileName, readFileSync(fileName).toString(), 2 /* ts.ScriptTarget.ES2015 */, /*setParentNodes */ true);
+    var sourceFile = ts.createSourceFile(fileName, readFileSync(fileName).toString(), ts.ScriptTarget.ES2015, /*setParentNodes */ true);
     // delint it
     delint(sourceFile);
 });
diff --git a/tests/baselines/reference/api/tsserverlibrary.d.ts b/tests/baselines/reference/api/tsserverlibrary.d.ts
index 575116ceed..fb3881b54b 100644
--- a/tests/baselines/reference/api/tsserverlibrary.d.ts
+++ b/tests/baselines/reference/api/tsserverlibrary.d.ts
@@ -14,69 +14,4009 @@ and limitations under the License.
 ***************************************************************************** */
 
 declare namespace ts {
-    const versionMajorMinor = "4.9";
+    export namespace server {
+        export type ActionSet = "action::set";
+        export type ActionInvalidate = "action::invalidate";
+        export type ActionPackageInstalled = "action::packageInstalled";
+        export type EventTypesRegistry = "event::typesRegistry";
+        export type EventBeginInstallTypes = "event::beginInstallTypes";
+        export type EventEndInstallTypes = "event::endInstallTypes";
+        export type EventInitializationFailed = "event::initializationFailed";
+        export interface TypingInstallerResponse {
+            readonly kind: ActionSet | ActionInvalidate | EventTypesRegistry | ActionPackageInstalled | EventBeginInstallTypes | EventEndInstallTypes | EventInitializationFailed;
+        }
+        export interface TypingInstallerRequestWithProjectName {
+            readonly projectName: string;
+        }
+        export interface DiscoverTypings extends TypingInstallerRequestWithProjectName {
+            readonly fileNames: string[];
+            readonly projectRootPath: Path;
+            readonly compilerOptions: CompilerOptions;
+            readonly watchOptions?: WatchOptions;
+            readonly typeAcquisition: TypeAcquisition;
+            readonly unresolvedImports: SortedReadonlyArray<string>;
+            readonly cachePath?: string;
+            readonly kind: "discover";
+        }
+        export interface CloseProject extends TypingInstallerRequestWithProjectName {
+            readonly kind: "closeProject";
+        }
+        export interface TypesRegistryRequest {
+            readonly kind: "typesRegistry";
+        }
+        export interface InstallPackageRequest extends TypingInstallerRequestWithProjectName {
+            readonly kind: "installPackage";
+            readonly fileName: Path;
+            readonly packageName: string;
+            readonly projectRootPath: Path;
+        }
+        export interface PackageInstalledResponse extends ProjectResponse {
+            readonly kind: ActionPackageInstalled;
+            readonly success: boolean;
+            readonly message: string;
+        }
+        export interface InitializationFailedResponse extends TypingInstallerResponse {
+            readonly kind: EventInitializationFailed;
+            readonly message: string;
+            readonly stack?: string;
+        }
+        export interface ProjectResponse extends TypingInstallerResponse {
+            readonly projectName: string;
+        }
+        export interface InvalidateCachedTypings extends ProjectResponse {
+            readonly kind: ActionInvalidate;
+        }
+        export interface InstallTypes extends ProjectResponse {
+            readonly kind: EventBeginInstallTypes | EventEndInstallTypes;
+            readonly eventId: number;
+            readonly typingsInstallerVersion: string;
+            readonly packagesToInstall: readonly string[];
+        }
+        export interface BeginInstallTypes extends InstallTypes {
+            readonly kind: EventBeginInstallTypes;
+        }
+        export interface EndInstallTypes extends InstallTypes {
+            readonly kind: EventEndInstallTypes;
+            readonly installSuccess: boolean;
+        }
+        export interface SetTypings extends ProjectResponse {
+            readonly typeAcquisition: TypeAcquisition;
+            readonly compilerOptions: CompilerOptions;
+            readonly typings: string[];
+            readonly unresolvedImports: SortedReadonlyArray<string>;
+            readonly kind: ActionSet;
+        }
+        export namespace protocol {
+            /**
+             * Declaration module describing the TypeScript Server protocol
+             */
+            export enum CommandTypes {
+                JsxClosingTag = "jsxClosingTag",
+                Brace = "brace",
+                BraceCompletion = "braceCompletion",
+                GetSpanOfEnclosingComment = "getSpanOfEnclosingComment",
+                Change = "change",
+                Close = "close",
+                /** @deprecated Prefer CompletionInfo -- see comment on CompletionsResponse */
+                Completions = "completions",
+                CompletionInfo = "completionInfo",
+                CompletionDetails = "completionEntryDetails",
+                CompileOnSaveAffectedFileList = "compileOnSaveAffectedFileList",
+                CompileOnSaveEmitFile = "compileOnSaveEmitFile",
+                Configure = "configure",
+                Definition = "definition",
+                DefinitionAndBoundSpan = "definitionAndBoundSpan",
+                Implementation = "implementation",
+                Exit = "exit",
+                FileReferences = "fileReferences",
+                Format = "format",
+                Formatonkey = "formatonkey",
+                Geterr = "geterr",
+                GeterrForProject = "geterrForProject",
+                SemanticDiagnosticsSync = "semanticDiagnosticsSync",
+                SyntacticDiagnosticsSync = "syntacticDiagnosticsSync",
+                SuggestionDiagnosticsSync = "suggestionDiagnosticsSync",
+                NavBar = "navbar",
+                Navto = "navto",
+                NavTree = "navtree",
+                NavTreeFull = "navtree-full",
+                /** @deprecated */
+                Occurrences = "occurrences",
+                DocumentHighlights = "documentHighlights",
+                Open = "open",
+                Quickinfo = "quickinfo",
+                References = "references",
+                Reload = "reload",
+                Rename = "rename",
+                Saveto = "saveto",
+                SignatureHelp = "signatureHelp",
+                FindSourceDefinition = "findSourceDefinition",
+                Status = "status",
+                TypeDefinition = "typeDefinition",
+                ProjectInfo = "projectInfo",
+                ReloadProjects = "reloadProjects",
+                Unknown = "unknown",
+                OpenExternalProject = "openExternalProject",
+                OpenExternalProjects = "openExternalProjects",
+                CloseExternalProject = "closeExternalProject",
+                UpdateOpen = "updateOpen",
+                GetOutliningSpans = "getOutliningSpans",
+                TodoComments = "todoComments",
+                Indentation = "indentation",
+                DocCommentTemplate = "docCommentTemplate",
+                CompilerOptionsForInferredProjects = "compilerOptionsForInferredProjects",
+                GetCodeFixes = "getCodeFixes",
+                GetCombinedCodeFix = "getCombinedCodeFix",
+                ApplyCodeActionCommand = "applyCodeActionCommand",
+                GetSupportedCodeFixes = "getSupportedCodeFixes",
+                GetApplicableRefactors = "getApplicableRefactors",
+                GetEditsForRefactor = "getEditsForRefactor",
+                OrganizeImports = "organizeImports",
+                GetEditsForFileRename = "getEditsForFileRename",
+                ConfigurePlugin = "configurePlugin",
+                SelectionRange = "selectionRange",
+                ToggleLineComment = "toggleLineComment",
+                ToggleMultilineComment = "toggleMultilineComment",
+                CommentSelection = "commentSelection",
+                UncommentSelection = "uncommentSelection",
+                PrepareCallHierarchy = "prepareCallHierarchy",
+                ProvideCallHierarchyIncomingCalls = "provideCallHierarchyIncomingCalls",
+                ProvideCallHierarchyOutgoingCalls = "provideCallHierarchyOutgoingCalls",
+                ProvideInlayHints = "provideInlayHints"
+            }
+            /**
+             * A TypeScript Server message
+             */
+            export interface Message {
+                /**
+                 * Sequence number of the message
+                 */
+                seq: number;
+                /**
+                 * One of "request", "response", or "event"
+                 */
+                type: "request" | "response" | "event";
+            }
+            /**
+             * Client-initiated request message
+             */
+            export interface Request extends Message {
+                type: "request";
+                /**
+                 * The command to execute
+                 */
+                command: string;
+                /**
+                 * Object containing arguments for the command
+                 */
+                arguments?: any;
+            }
+            /**
+             * Request to reload the project structure for all the opened files
+             */
+            export interface ReloadProjectsRequest extends Message {
+                command: CommandTypes.ReloadProjects;
+            }
+            /**
+             * Server-initiated event message
+             */
+            export interface Event extends Message {
+                type: "event";
+                /**
+                 * Name of event
+                 */
+                event: string;
+                /**
+                 * Event-specific information
+                 */
+                body?: any;
+            }
+            /**
+             * Response by server to client request message.
+             */
+            export interface Response extends Message {
+                type: "response";
+                /**
+                 * Sequence number of the request message.
+                 */
+                request_seq: number;
+                /**
+                 * Outcome of the request.
+                 */
+                success: boolean;
+                /**
+                 * The command requested.
+                 */
+                command: string;
+                /**
+                 * If success === false, this should always be provided.
+                 * Otherwise, may (or may not) contain a success message.
+                 */
+                message?: string;
+                /**
+                 * Contains message body if success === true.
+                 */
+                body?: any;
+                /**
+                 * Contains extra information that plugin can include to be passed on
+                 */
+                metadata?: unknown;
+                /**
+                 * Exposes information about the performance of this request-response pair.
+                 */
+                performanceData?: PerformanceData;
+            }
+            export interface PerformanceData {
+                /**
+                 * Time spent updating the program graph, in milliseconds.
+                 */
+                updateGraphDurationMs?: number;
+                /**
+                 * The time spent creating or updating the auto-import program, in milliseconds.
+                 */
+                createAutoImportProviderProgramDurationMs?: number;
+            }
+            /**
+             * Arguments for FileRequest messages.
+             */
+            export interface FileRequestArgs {
+                /**
+                 * The file for the request (absolute pathname required).
+                 */
+                file: string;
+                projectFileName?: string;
+            }
+            export interface StatusRequest extends Request {
+                command: CommandTypes.Status;
+            }
+            export interface StatusResponseBody {
+                /**
+                 * The TypeScript version (`ts.version`).
+                 */
+                version: string;
+            }
+            /**
+             * Response to StatusRequest
+             */
+            export interface StatusResponse extends Response {
+                body: StatusResponseBody;
+            }
+            /**
+             * Requests a JS Doc comment template for a given position
+             */
+            export interface DocCommentTemplateRequest extends FileLocationRequest {
+                command: CommandTypes.DocCommentTemplate;
+            }
+            /**
+             * Response to DocCommentTemplateRequest
+             */
+            export interface DocCommandTemplateResponse extends Response {
+                body?: TextInsertion;
+            }
+            /**
+             * A request to get TODO comments from the file
+             */
+            export interface TodoCommentRequest extends FileRequest {
+                command: CommandTypes.TodoComments;
+                arguments: TodoCommentRequestArgs;
+            }
+            /**
+             * Arguments for TodoCommentRequest request.
+             */
+            export interface TodoCommentRequestArgs extends FileRequestArgs {
+                /**
+                 * Array of target TodoCommentDescriptors that describes TODO comments to be found
+                 */
+                descriptors: TodoCommentDescriptor[];
+            }
+            /**
+             * Response for TodoCommentRequest request.
+             */
+            export interface TodoCommentsResponse extends Response {
+                body?: TodoComment[];
+            }
+            /**
+             * A request to determine if the caret is inside a comment.
+             */
+            export interface SpanOfEnclosingCommentRequest extends FileLocationRequest {
+                command: CommandTypes.GetSpanOfEnclosingComment;
+                arguments: SpanOfEnclosingCommentRequestArgs;
+            }
+            export interface SpanOfEnclosingCommentRequestArgs extends FileLocationRequestArgs {
+                /**
+                 * Requires that the enclosing span be a multi-line comment, or else the request returns undefined.
+                 */
+                onlyMultiLine: boolean;
+            }
+            /**
+             * Request to obtain outlining spans in file.
+             */
+            export interface OutliningSpansRequest extends FileRequest {
+                command: CommandTypes.GetOutliningSpans;
+            }
+            export interface OutliningSpan {
+                /** The span of the document to actually collapse. */
+                textSpan: TextSpan;
+                /** The span of the document to display when the user hovers over the collapsed span. */
+                hintSpan: TextSpan;
+                /** The text to display in the editor for the collapsed region. */
+                bannerText: string;
+                /**
+                 * Whether or not this region should be automatically collapsed when
+                 * the 'Collapse to Definitions' command is invoked.
+                 */
+                autoCollapse: boolean;
+                /**
+                 * Classification of the contents of the span
+                 */
+                kind: OutliningSpanKind;
+            }
+            /**
+             * Response to OutliningSpansRequest request.
+             */
+            export interface OutliningSpansResponse extends Response {
+                body?: OutliningSpan[];
+            }
+            /**
+             * A request to get indentation for a location in file
+             */
+            export interface IndentationRequest extends FileLocationRequest {
+                command: CommandTypes.Indentation;
+                arguments: IndentationRequestArgs;
+            }
+            /**
+             * Response for IndentationRequest request.
+             */
+            export interface IndentationResponse extends Response {
+                body?: IndentationResult;
+            }
+            /**
+             * Indentation result representing where indentation should be placed
+             */
+            export interface IndentationResult {
+                /**
+                 * The base position in the document that the indent should be relative to
+                 */
+                position: number;
+                /**
+                 * The number of columns the indent should be at relative to the position's column.
+                 */
+                indentation: number;
+            }
+            /**
+             * Arguments for IndentationRequest request.
+             */
+            export interface IndentationRequestArgs extends FileLocationRequestArgs {
+                /**
+                 * An optional set of settings to be used when computing indentation.
+                 * If argument is omitted - then it will use settings for file that were previously set via 'configure' request or global settings.
+                 */
+                options?: EditorSettings;
+            }
+            /**
+             * Arguments for ProjectInfoRequest request.
+             */
+            export interface ProjectInfoRequestArgs extends FileRequestArgs {
+                /**
+                 * Indicate if the file name list of the project is needed
+                 */
+                needFileNameList: boolean;
+            }
+            /**
+             * A request to get the project information of the current file.
+             */
+            export interface ProjectInfoRequest extends Request {
+                command: CommandTypes.ProjectInfo;
+                arguments: ProjectInfoRequestArgs;
+            }
+            /**
+             * A request to retrieve compiler options diagnostics for a project
+             */
+            export interface CompilerOptionsDiagnosticsRequest extends Request {
+                arguments: CompilerOptionsDiagnosticsRequestArgs;
+            }
+            /**
+             * Arguments for CompilerOptionsDiagnosticsRequest request.
+             */
+            export interface CompilerOptionsDiagnosticsRequestArgs {
+                /**
+                 * Name of the project to retrieve compiler options diagnostics.
+                 */
+                projectFileName: string;
+            }
+            /**
+             * Response message body for "projectInfo" request
+             */
+            export interface ProjectInfo {
+                /**
+                 * For configured project, this is the normalized path of the 'tsconfig.json' file
+                 * For inferred project, this is undefined
+                 */
+                configFileName: string;
+                /**
+                 * The list of normalized file name in the project, including 'lib.d.ts'
+                 */
+                fileNames?: string[];
+                /**
+                 * Indicates if the project has a active language service instance
+                 */
+                languageServiceDisabled?: boolean;
+            }
+            /**
+             * Represents diagnostic info that includes location of diagnostic in two forms
+             * - start position and length of the error span
+             * - startLocation and endLocation - a pair of Location objects that store start/end line and offset of the error span.
+             */
+            export interface DiagnosticWithLinePosition {
+                message: string;
+                start: number;
+                length: number;
+                startLocation: Location;
+                endLocation: Location;
+                category: string;
+                code: number;
+                /** May store more in future. For now, this will simply be `true` to indicate when a diagnostic is an unused-identifier diagnostic. */
+                reportsUnnecessary?: {};
+                reportsDeprecated?: {};
+                relatedInformation?: DiagnosticRelatedInformation[];
+            }
+            /**
+             * Response message for "projectInfo" request
+             */
+            export interface ProjectInfoResponse extends Response {
+                body?: ProjectInfo;
+            }
+            /**
+             * Request whose sole parameter is a file name.
+             */
+            export interface FileRequest extends Request {
+                arguments: FileRequestArgs;
+            }
+            /**
+             * Instances of this interface specify a location in a source file:
+             * (file, line, character offset), where line and character offset are 1-based.
+             */
+            export interface FileLocationRequestArgs extends FileRequestArgs {
+                /**
+                 * The line number for the request (1-based).
+                 */
+                line: number;
+                /**
+                 * The character offset (on the line) for the request (1-based).
+                 */
+                offset: number;
+            }
+            export type FileLocationOrRangeRequestArgs = FileLocationRequestArgs | FileRangeRequestArgs;
+            /**
+             * Request refactorings at a given position or selection area.
+             */
+            export interface GetApplicableRefactorsRequest extends Request {
+                command: CommandTypes.GetApplicableRefactors;
+                arguments: GetApplicableRefactorsRequestArgs;
+            }
+            export type GetApplicableRefactorsRequestArgs = FileLocationOrRangeRequestArgs & {
+                triggerReason?: RefactorTriggerReason;
+                kind?: string;
+            };
+            export type RefactorTriggerReason = "implicit" | "invoked";
+            /**
+             * Response is a list of available refactorings.
+             * Each refactoring exposes one or more "Actions"; a user selects one action to invoke a refactoring
+             */
+            export interface GetApplicableRefactorsResponse extends Response {
+                body?: ApplicableRefactorInfo[];
+            }
+            /**
+             * A set of one or more available refactoring actions, grouped under a parent refactoring.
+             */
+            export interface ApplicableRefactorInfo {
+                /**
+                 * The programmatic name of the refactoring
+                 */
+                name: string;
+                /**
+                 * A description of this refactoring category to show to the user.
+                 * If the refactoring gets inlined (see below), this text will not be visible.
+                 */
+                description: string;
+                /**
+                 * Inlineable refactorings can have their actions hoisted out to the top level
+                 * of a context menu. Non-inlineanable refactorings should always be shown inside
+                 * their parent grouping.
+                 *
+                 * If not specified, this value is assumed to be 'true'
+                 */
+                inlineable?: boolean;
+                actions: RefactorActionInfo[];
+            }
+            /**
+             * Represents a single refactoring action - for example, the "Extract Method..." refactor might
+             * offer several actions, each corresponding to a surround class or closure to extract into.
+             */
+            export interface RefactorActionInfo {
+                /**
+                 * The programmatic name of the refactoring action
+                 */
+                name: string;
+                /**
+                 * A description of this refactoring action to show to the user.
+                 * If the parent refactoring is inlined away, this will be the only text shown,
+                 * so this description should make sense by itself if the parent is inlineable=true
+                 */
+                description: string;
+                /**
+                 * A message to show to the user if the refactoring cannot be applied in
+                 * the current context.
+                 */
+                notApplicableReason?: string;
+                /**
+                 * The hierarchical dotted name of the refactor action.
+                 */
+                kind?: string;
+            }
+            export interface GetEditsForRefactorRequest extends Request {
+                command: CommandTypes.GetEditsForRefactor;
+                arguments: GetEditsForRefactorRequestArgs;
+            }
+            /**
+             * Request the edits that a particular refactoring action produces.
+             * Callers must specify the name of the refactor and the name of the action.
+             */
+            export type GetEditsForRefactorRequestArgs = FileLocationOrRangeRequestArgs & {
+                refactor: string;
+                action: string;
+            };
+            export interface GetEditsForRefactorResponse extends Response {
+                body?: RefactorEditInfo;
+            }
+            export interface RefactorEditInfo {
+                edits: FileCodeEdits[];
+                /**
+                 * An optional location where the editor should start a rename operation once
+                 * the refactoring edits have been applied
+                 */
+                renameLocation?: Location;
+                renameFilename?: string;
+            }
+            /**
+             * Organize imports by:
+             *   1) Removing unused imports
+             *   2) Coalescing imports from the same module
+             *   3) Sorting imports
+             */
+            export interface OrganizeImportsRequest extends Request {
+                command: CommandTypes.OrganizeImports;
+                arguments: OrganizeImportsRequestArgs;
+            }
+            export type OrganizeImportsScope = GetCombinedCodeFixScope;
+            export interface OrganizeImportsRequestArgs {
+                scope: OrganizeImportsScope;
+                skipDestructiveCodeActions?: boolean;
+            }
+            export interface OrganizeImportsResponse extends Response {
+                body: readonly FileCodeEdits[];
+            }
+            export interface GetEditsForFileRenameRequest extends Request {
+                command: CommandTypes.GetEditsForFileRename;
+                arguments: GetEditsForFileRenameRequestArgs;
+            }
+            /** Note: Paths may also be directories. */
+            export interface GetEditsForFileRenameRequestArgs {
+                readonly oldFilePath: string;
+                readonly newFilePath: string;
+            }
+            export interface GetEditsForFileRenameResponse extends Response {
+                body: readonly FileCodeEdits[];
+            }
+            /**
+             * Request for the available codefixes at a specific position.
+             */
+            export interface CodeFixRequest extends Request {
+                command: CommandTypes.GetCodeFixes;
+                arguments: CodeFixRequestArgs;
+            }
+            export interface GetCombinedCodeFixRequest extends Request {
+                command: CommandTypes.GetCombinedCodeFix;
+                arguments: GetCombinedCodeFixRequestArgs;
+            }
+            export interface GetCombinedCodeFixResponse extends Response {
+                body: CombinedCodeActions;
+            }
+            export interface ApplyCodeActionCommandRequest extends Request {
+                command: CommandTypes.ApplyCodeActionCommand;
+                arguments: ApplyCodeActionCommandRequestArgs;
+            }
+            export interface ApplyCodeActionCommandResponse extends Response {
+            }
+            export interface FileRangeRequestArgs extends FileRequestArgs {
+                /**
+                 * The line number for the request (1-based).
+                 */
+                startLine: number;
+                /**
+                 * The character offset (on the line) for the request (1-based).
+                 */
+                startOffset: number;
+                /**
+                 * The line number for the request (1-based).
+                 */
+                endLine: number;
+                /**
+                 * The character offset (on the line) for the request (1-based).
+                 */
+                endOffset: number;
+            }
+            /**
+             * Instances of this interface specify errorcodes on a specific location in a sourcefile.
+             */
+            export interface CodeFixRequestArgs extends FileRangeRequestArgs {
+                /**
+                 * Errorcodes we want to get the fixes for.
+                 */
+                errorCodes: readonly number[];
+            }
+            export interface GetCombinedCodeFixRequestArgs {
+                scope: GetCombinedCodeFixScope;
+                fixId: {};
+            }
+            export interface GetCombinedCodeFixScope {
+                type: "file";
+                args: FileRequestArgs;
+            }
+            export interface ApplyCodeActionCommandRequestArgs {
+                /** May also be an array of commands. */
+                command: {};
+            }
+            /**
+             * Response for GetCodeFixes request.
+             */
+            export interface GetCodeFixesResponse extends Response {
+                body?: CodeAction[];
+            }
+            /**
+             * A request whose arguments specify a file location (file, line, col).
+             */
+            export interface FileLocationRequest extends FileRequest {
+                arguments: FileLocationRequestArgs;
+            }
+            /**
+             * A request to get codes of supported code fixes.
+             */
+            export interface GetSupportedCodeFixesRequest extends Request {
+                command: CommandTypes.GetSupportedCodeFixes;
+            }
+            /**
+             * A response for GetSupportedCodeFixesRequest request.
+             */
+            export interface GetSupportedCodeFixesResponse extends Response {
+                /**
+                 * List of error codes supported by the server.
+                 */
+                body?: string[];
+            }
+            /**
+             * A request to get encoded semantic classifications for a span in the file
+             */
+            export interface EncodedSemanticClassificationsRequest extends FileRequest {
+                arguments: EncodedSemanticClassificationsRequestArgs;
+            }
+            /**
+             * Arguments for EncodedSemanticClassificationsRequest request.
+             */
+            export interface EncodedSemanticClassificationsRequestArgs extends FileRequestArgs {
+                /**
+                 * Start position of the span.
+                 */
+                start: number;
+                /**
+                 * Length of the span.
+                 */
+                length: number;
+                /**
+                 * Optional parameter for the semantic highlighting response, if absent it
+                 * defaults to "original".
+                 */
+                format?: "original" | "2020";
+            }
+            /** The response for a EncodedSemanticClassificationsRequest */
+            export interface EncodedSemanticClassificationsResponse extends Response {
+                body?: EncodedSemanticClassificationsResponseBody;
+            }
+            /**
+             * Implementation response message. Gives series of text spans depending on the format ar.
+             */
+            export interface EncodedSemanticClassificationsResponseBody {
+                endOfLineState: EndOfLineState;
+                spans: number[];
+            }
+            /**
+             * Arguments in document highlight request; include: filesToSearch, file,
+             * line, offset.
+             */
+            export interface DocumentHighlightsRequestArgs extends FileLocationRequestArgs {
+                /**
+                 * List of files to search for document highlights.
+                 */
+                filesToSearch: string[];
+            }
+            /**
+             * Go to definition request; value of command field is
+             * "definition". Return response giving the file locations that
+             * define the symbol found in file at location line, col.
+             */
+            export interface DefinitionRequest extends FileLocationRequest {
+                command: CommandTypes.Definition;
+            }
+            export interface DefinitionAndBoundSpanRequest extends FileLocationRequest {
+                readonly command: CommandTypes.DefinitionAndBoundSpan;
+            }
+            export interface FindSourceDefinitionRequest extends FileLocationRequest {
+                readonly command: CommandTypes.FindSourceDefinition;
+            }
+            export interface DefinitionAndBoundSpanResponse extends Response {
+                readonly body: DefinitionInfoAndBoundSpan;
+            }
+            /**
+             * Go to type request; value of command field is
+             * "typeDefinition". Return response giving the file locations that
+             * define the type for the symbol found in file at location line, col.
+             */
+            export interface TypeDefinitionRequest extends FileLocationRequest {
+                command: CommandTypes.TypeDefinition;
+            }
+            /**
+             * Go to implementation request; value of command field is
+             * "implementation". Return response giving the file locations that
+             * implement the symbol found in file at location line, col.
+             */
+            export interface ImplementationRequest extends FileLocationRequest {
+                command: CommandTypes.Implementation;
+            }
+            /**
+             * Location in source code expressed as (one-based) line and (one-based) column offset.
+             */
+            export interface Location {
+                line: number;
+                offset: number;
+            }
+            /**
+             * Object found in response messages defining a span of text in source code.
+             */
+            export interface TextSpan {
+                /**
+                 * First character of the definition.
+                 */
+                start: Location;
+                /**
+                 * One character past last character of the definition.
+                 */
+                end: Location;
+            }
+            /**
+             * Object found in response messages defining a span of text in a specific source file.
+             */
+            export interface FileSpan extends TextSpan {
+                /**
+                 * File containing text span.
+                 */
+                file: string;
+            }
+            export interface JSDocTagInfo {
+                /** Name of the JSDoc tag */
+                name: string;
+                /**
+                 * Comment text after the JSDoc tag -- the text after the tag name until the next tag or end of comment
+                 * Display parts when UserPreferences.displayPartsForJSDoc is true, flattened to string otherwise.
+                 */
+                text?: string | SymbolDisplayPart[];
+            }
+            export interface TextSpanWithContext extends TextSpan {
+                contextStart?: Location;
+                contextEnd?: Location;
+            }
+            export interface FileSpanWithContext extends FileSpan, TextSpanWithContext {
+            }
+            export interface DefinitionInfo extends FileSpanWithContext {
+                /**
+                 * When true, the file may or may not exist.
+                 */
+                unverified?: boolean;
+            }
+            export interface DefinitionInfoAndBoundSpan {
+                definitions: readonly DefinitionInfo[];
+                textSpan: TextSpan;
+            }
+            /**
+             * Definition response message.  Gives text range for definition.
+             */
+            export interface DefinitionResponse extends Response {
+                body?: DefinitionInfo[];
+            }
+            export interface DefinitionInfoAndBoundSpanResponse extends Response {
+                body?: DefinitionInfoAndBoundSpan;
+            }
+            /** @deprecated Use `DefinitionInfoAndBoundSpanResponse` instead. */
+            export type DefinitionInfoAndBoundSpanReponse = DefinitionInfoAndBoundSpanResponse;
+            /**
+             * Definition response message.  Gives text range for definition.
+             */
+            export interface TypeDefinitionResponse extends Response {
+                body?: FileSpanWithContext[];
+            }
+            /**
+             * Implementation response message.  Gives text range for implementations.
+             */
+            export interface ImplementationResponse extends Response {
+                body?: FileSpanWithContext[];
+            }
+            /**
+             * Request to get brace completion for a location in the file.
+             */
+            export interface BraceCompletionRequest extends FileLocationRequest {
+                command: CommandTypes.BraceCompletion;
+                arguments: BraceCompletionRequestArgs;
+            }
+            /**
+             * Argument for BraceCompletionRequest request.
+             */
+            export interface BraceCompletionRequestArgs extends FileLocationRequestArgs {
+                /**
+                 * Kind of opening brace
+                 */
+                openingBrace: string;
+            }
+            export interface JsxClosingTagRequest extends FileLocationRequest {
+                readonly command: CommandTypes.JsxClosingTag;
+                readonly arguments: JsxClosingTagRequestArgs;
+            }
+            export interface JsxClosingTagRequestArgs extends FileLocationRequestArgs {
+            }
+            export interface JsxClosingTagResponse extends Response {
+                readonly body: TextInsertion;
+            }
+            /**
+             * @deprecated
+             * Get occurrences request; value of command field is
+             * "occurrences". Return response giving spans that are relevant
+             * in the file at a given line and column.
+             */
+            export interface OccurrencesRequest extends FileLocationRequest {
+                command: CommandTypes.Occurrences;
+            }
+            /** @deprecated */
+            export interface OccurrencesResponseItem extends FileSpanWithContext {
+                /**
+                 * True if the occurrence is a write location, false otherwise.
+                 */
+                isWriteAccess: boolean;
+                /**
+                 * True if the occurrence is in a string, undefined otherwise;
+                 */
+                isInString?: true;
+            }
+            /** @deprecated */
+            export interface OccurrencesResponse extends Response {
+                body?: OccurrencesResponseItem[];
+            }
+            /**
+             * Get document highlights request; value of command field is
+             * "documentHighlights". Return response giving spans that are relevant
+             * in the file at a given line and column.
+             */
+            export interface DocumentHighlightsRequest extends FileLocationRequest {
+                command: CommandTypes.DocumentHighlights;
+                arguments: DocumentHighlightsRequestArgs;
+            }
+            /**
+             * Span augmented with extra information that denotes the kind of the highlighting to be used for span.
+             */
+            export interface HighlightSpan extends TextSpanWithContext {
+                kind: HighlightSpanKind;
+            }
+            /**
+             * Represents a set of highligh spans for a give name
+             */
+            export interface DocumentHighlightsItem {
+                /**
+                 * File containing highlight spans.
+                 */
+                file: string;
+                /**
+                 * Spans to highlight in file.
+                 */
+                highlightSpans: HighlightSpan[];
+            }
+            /**
+             * Response for a DocumentHighlightsRequest request.
+             */
+            export interface DocumentHighlightsResponse extends Response {
+                body?: DocumentHighlightsItem[];
+            }
+            /**
+             * Find references request; value of command field is
+             * "references". Return response giving the file locations that
+             * reference the symbol found in file at location line, col.
+             */
+            export interface ReferencesRequest extends FileLocationRequest {
+                command: CommandTypes.References;
+            }
+            export interface ReferencesResponseItem extends FileSpanWithContext {
+                /** Text of line containing the reference.  Including this
+                 *  with the response avoids latency of editor loading files
+                 * to show text of reference line (the server already has
+                 * loaded the referencing files).
+                 */
+                lineText: string;
+                /**
+                 * True if reference is a write location, false otherwise.
+                 */
+                isWriteAccess: boolean;
+                /**
+                 * Present only if the search was triggered from a declaration.
+                 * True indicates that the references refers to the same symbol
+                 * (i.e. has the same meaning) as the declaration that began the
+                 * search.
+                 */
+                isDefinition?: boolean;
+            }
+            /**
+             * The body of a "references" response message.
+             */
+            export interface ReferencesResponseBody {
+                /**
+                 * The file locations referencing the symbol.
+                 */
+                refs: readonly ReferencesResponseItem[];
+                /**
+                 * The name of the symbol.
+                 */
+                symbolName: string;
+                /**
+                 * The start character offset of the symbol (on the line provided by the references request).
+                 */
+                symbolStartOffset: number;
+                /**
+                 * The full display name of the symbol.
+                 */
+                symbolDisplayString: string;
+            }
+            /**
+             * Response to "references" request.
+             */
+            export interface ReferencesResponse extends Response {
+                body?: ReferencesResponseBody;
+            }
+            export interface FileReferencesRequest extends FileRequest {
+                command: CommandTypes.FileReferences;
+            }
+            export interface FileReferencesResponseBody {
+                /**
+                 * The file locations referencing the symbol.
+                 */
+                refs: readonly ReferencesResponseItem[];
+                /**
+                 * The name of the symbol.
+                 */
+                symbolName: string;
+            }
+            export interface FileReferencesResponse extends Response {
+                body?: FileReferencesResponseBody;
+            }
+            /**
+             * Argument for RenameRequest request.
+             */
+            export interface RenameRequestArgs extends FileLocationRequestArgs {
+                /**
+                 * Should text at specified location be found/changed in comments?
+                 */
+                findInComments?: boolean;
+                /**
+                 * Should text at specified location be found/changed in strings?
+                 */
+                findInStrings?: boolean;
+            }
+            /**
+             * Rename request; value of command field is "rename". Return
+             * response giving the file locations that reference the symbol
+             * found in file at location line, col. Also return full display
+             * name of the symbol so that client can print it unambiguously.
+             */
+            export interface RenameRequest extends FileLocationRequest {
+                command: CommandTypes.Rename;
+                arguments: RenameRequestArgs;
+            }
+            /**
+             * Information about the item to be renamed.
+             */
+            export type RenameInfo = RenameInfoSuccess | RenameInfoFailure;
+            export interface RenameInfoSuccess {
+                /**
+                 * True if item can be renamed.
+                 */
+                canRename: true;
+                /**
+                 * File or directory to rename.
+                 * If set, `getEditsForFileRename` should be called instead of `findRenameLocations`.
+                 */
+                fileToRename?: string;
+                /**
+                 * Display name of the item to be renamed.
+                 */
+                displayName: string;
+                /**
+                 * Full display name of item to be renamed.
+                 */
+                fullDisplayName: string;
+                /**
+                 * The items's kind (such as 'className' or 'parameterName' or plain 'text').
+                 */
+                kind: ScriptElementKind;
+                /**
+                 * Optional modifiers for the kind (such as 'public').
+                 */
+                kindModifiers: string;
+                /** Span of text to rename. */
+                triggerSpan: TextSpan;
+            }
+            export interface RenameInfoFailure {
+                canRename: false;
+                /**
+                 * Error message if item can not be renamed.
+                 */
+                localizedErrorMessage: string;
+            }
+            /**
+             *  A group of text spans, all in 'file'.
+             */
+            export interface SpanGroup {
+                /** The file to which the spans apply */
+                file: string;
+                /** The text spans in this group */
+                locs: RenameTextSpan[];
+            }
+            export interface RenameTextSpan extends TextSpanWithContext {
+                readonly prefixText?: string;
+                readonly suffixText?: string;
+            }
+            export interface RenameResponseBody {
+                /**
+                 * Information about the item to be renamed.
+                 */
+                info: RenameInfo;
+                /**
+                 * An array of span groups (one per file) that refer to the item to be renamed.
+                 */
+                locs: readonly SpanGroup[];
+            }
+            /**
+             * Rename response message.
+             */
+            export interface RenameResponse extends Response {
+                body?: RenameResponseBody;
+            }
+            /**
+             * Represents a file in external project.
+             * External project is project whose set of files, compilation options and open\close state
+             * is maintained by the client (i.e. if all this data come from .csproj file in Visual Studio).
+             * External project will exist even if all files in it are closed and should be closed explicitly.
+             * If external project includes one or more tsconfig.json/jsconfig.json files then tsserver will
+             * create configured project for every config file but will maintain a link that these projects were created
+             * as a result of opening external project so they should be removed once external project is closed.
+             */
+            export interface ExternalFile {
+                /**
+                 * Name of file file
+                 */
+                fileName: string;
+                /**
+                 * Script kind of the file
+                 */
+                scriptKind?: ScriptKindName | ScriptKind;
+                /**
+                 * Whether file has mixed content (i.e. .cshtml file that combines html markup with C#/JavaScript)
+                 */
+                hasMixedContent?: boolean;
+                /**
+                 * Content of the file
+                 */
+                content?: string;
+            }
+            /**
+             * Represent an external project
+             */
+            export interface ExternalProject {
+                /**
+                 * Project name
+                 */
+                projectFileName: string;
+                /**
+                 * List of root files in project
+                 */
+                rootFiles: ExternalFile[];
+                /**
+                 * Compiler options for the project
+                 */
+                options: ExternalProjectCompilerOptions;
+                /**
+                 * @deprecated typingOptions. Use typeAcquisition instead
+                 */
+                typingOptions?: TypeAcquisition;
+                /**
+                 * Explicitly specified type acquisition for the project
+                 */
+                typeAcquisition?: TypeAcquisition;
+            }
+            export interface CompileOnSaveMixin {
+                /**
+                 * If compile on save is enabled for the project
+                 */
+                compileOnSave?: boolean;
+            }
+            /**
+             * For external projects, some of the project settings are sent together with
+             * compiler settings.
+             */
+            export type ExternalProjectCompilerOptions = CompilerOptions & CompileOnSaveMixin & WatchOptions;
+            export interface FileWithProjectReferenceRedirectInfo {
+                /**
+                 * Name of file
+                 */
+                fileName: string;
+                /**
+                 * True if the file is primarily included in a referenced project
+                 */
+                isSourceOfProjectReferenceRedirect: boolean;
+            }
+            /**
+             * Represents a set of changes that happen in project
+             */
+            export interface ProjectChanges {
+                /**
+                 * List of added files
+                 */
+                added: string[] | FileWithProjectReferenceRedirectInfo[];
+                /**
+                 * List of removed files
+                 */
+                removed: string[] | FileWithProjectReferenceRedirectInfo[];
+                /**
+                 * List of updated files
+                 */
+                updated: string[] | FileWithProjectReferenceRedirectInfo[];
+                /**
+                 * List of files that have had their project reference redirect status updated
+                 * Only provided when the synchronizeProjectList request has includeProjectReferenceRedirectInfo set to true
+                 */
+                updatedRedirects?: FileWithProjectReferenceRedirectInfo[];
+            }
+            /**
+             * Information found in a configure request.
+             */
+            export interface ConfigureRequestArguments {
+                /**
+                 * Information about the host, for example 'Emacs 24.4' or
+                 * 'Sublime Text version 3075'
+                 */
+                hostInfo?: string;
+                /**
+                 * If present, tab settings apply only to this file.
+                 */
+                file?: string;
+                /**
+                 * The format options to use during formatting and other code editing features.
+                 */
+                formatOptions?: FormatCodeSettings;
+                preferences?: UserPreferences;
+                /**
+                 * The host's additional supported .js file extensions
+                 */
+                extraFileExtensions?: FileExtensionInfo[];
+                watchOptions?: WatchOptions;
+            }
+            export enum WatchFileKind {
+                FixedPollingInterval = "FixedPollingInterval",
+                PriorityPollingInterval = "PriorityPollingInterval",
+                DynamicPriorityPolling = "DynamicPriorityPolling",
+                FixedChunkSizePolling = "FixedChunkSizePolling",
+                UseFsEvents = "UseFsEvents",
+                UseFsEventsOnParentDirectory = "UseFsEventsOnParentDirectory"
+            }
+            export enum WatchDirectoryKind {
+                UseFsEvents = "UseFsEvents",
+                FixedPollingInterval = "FixedPollingInterval",
+                DynamicPriorityPolling = "DynamicPriorityPolling",
+                FixedChunkSizePolling = "FixedChunkSizePolling"
+            }
+            export enum PollingWatchKind {
+                FixedInterval = "FixedInterval",
+                PriorityInterval = "PriorityInterval",
+                DynamicPriority = "DynamicPriority",
+                FixedChunkSize = "FixedChunkSize"
+            }
+            export interface WatchOptions {
+                watchFile?: WatchFileKind | ts.WatchFileKind;
+                watchDirectory?: WatchDirectoryKind | ts.WatchDirectoryKind;
+                fallbackPolling?: PollingWatchKind | ts.PollingWatchKind;
+                synchronousWatchDirectory?: boolean;
+                excludeDirectories?: string[];
+                excludeFiles?: string[];
+                [option: string]: CompilerOptionsValue | undefined;
+            }
+            /**
+             *  Configure request; value of command field is "configure".  Specifies
+             *  host information, such as host type, tab size, and indent size.
+             */
+            export interface ConfigureRequest extends Request {
+                command: CommandTypes.Configure;
+                arguments: ConfigureRequestArguments;
+            }
+            /**
+             * Response to "configure" request.  This is just an acknowledgement, so
+             * no body field is required.
+             */
+            export interface ConfigureResponse extends Response {
+            }
+            export interface ConfigurePluginRequestArguments {
+                pluginName: string;
+                configuration: any;
+            }
+            export interface ConfigurePluginRequest extends Request {
+                command: CommandTypes.ConfigurePlugin;
+                arguments: ConfigurePluginRequestArguments;
+            }
+            export interface ConfigurePluginResponse extends Response {
+            }
+            export interface SelectionRangeRequest extends FileRequest {
+                command: CommandTypes.SelectionRange;
+                arguments: SelectionRangeRequestArgs;
+            }
+            export interface SelectionRangeRequestArgs extends FileRequestArgs {
+                locations: Location[];
+            }
+            export interface SelectionRangeResponse extends Response {
+                body?: SelectionRange[];
+            }
+            export interface SelectionRange {
+                textSpan: TextSpan;
+                parent?: SelectionRange;
+            }
+            export interface ToggleLineCommentRequest extends FileRequest {
+                command: CommandTypes.ToggleLineComment;
+                arguments: FileRangeRequestArgs;
+            }
+            export interface ToggleMultilineCommentRequest extends FileRequest {
+                command: CommandTypes.ToggleMultilineComment;
+                arguments: FileRangeRequestArgs;
+            }
+            export interface CommentSelectionRequest extends FileRequest {
+                command: CommandTypes.CommentSelection;
+                arguments: FileRangeRequestArgs;
+            }
+            export interface UncommentSelectionRequest extends FileRequest {
+                command: CommandTypes.UncommentSelection;
+                arguments: FileRangeRequestArgs;
+            }
+            /**
+             *  Information found in an "open" request.
+             */
+            export interface OpenRequestArgs extends FileRequestArgs {
+                /**
+                 * Used when a version of the file content is known to be more up to date than the one on disk.
+                 * Then the known content will be used upon opening instead of the disk copy
+                 */
+                fileContent?: string;
+                /**
+                 * Used to specify the script kind of the file explicitly. It could be one of the following:
+                 *      "TS", "JS", "TSX", "JSX"
+                 */
+                scriptKindName?: ScriptKindName;
+                /**
+                 * Used to limit the searching for project config file. If given the searching will stop at this
+                 * root path; otherwise it will go all the way up to the dist root path.
+                 */
+                projectRootPath?: string;
+            }
+            export type ScriptKindName = "TS" | "JS" | "TSX" | "JSX";
+            /**
+             * Open request; value of command field is "open". Notify the
+             * server that the client has file open.  The server will not
+             * monitor the filesystem for changes in this file and will assume
+             * that the client is updating the server (using the change and/or
+             * reload messages) when the file changes. Server does not currently
+             * send a response to an open request.
+             */
+            export interface OpenRequest extends Request {
+                command: CommandTypes.Open;
+                arguments: OpenRequestArgs;
+            }
+            /**
+             * Request to open or update external project
+             */
+            export interface OpenExternalProjectRequest extends Request {
+                command: CommandTypes.OpenExternalProject;
+                arguments: OpenExternalProjectArgs;
+            }
+            /**
+             * Arguments to OpenExternalProjectRequest request
+             */
+            export type OpenExternalProjectArgs = ExternalProject;
+            /**
+             * Request to open multiple external projects
+             */
+            export interface OpenExternalProjectsRequest extends Request {
+                command: CommandTypes.OpenExternalProjects;
+                arguments: OpenExternalProjectsArgs;
+            }
+            /**
+             * Arguments to OpenExternalProjectsRequest
+             */
+            export interface OpenExternalProjectsArgs {
+                /**
+                 * List of external projects to open or update
+                 */
+                projects: ExternalProject[];
+            }
+            /**
+             * Response to OpenExternalProjectRequest request. This is just an acknowledgement, so
+             * no body field is required.
+             */
+            export interface OpenExternalProjectResponse extends Response {
+            }
+            /**
+             * Response to OpenExternalProjectsRequest request. This is just an acknowledgement, so
+             * no body field is required.
+             */
+            export interface OpenExternalProjectsResponse extends Response {
+            }
+            /**
+             * Request to close external project.
+             */
+            export interface CloseExternalProjectRequest extends Request {
+                command: CommandTypes.CloseExternalProject;
+                arguments: CloseExternalProjectRequestArgs;
+            }
+            /**
+             * Arguments to CloseExternalProjectRequest request
+             */
+            export interface CloseExternalProjectRequestArgs {
+                /**
+                 * Name of the project to close
+                 */
+                projectFileName: string;
+            }
+            /**
+             * Response to CloseExternalProjectRequest request. This is just an acknowledgement, so
+             * no body field is required.
+             */
+            export interface CloseExternalProjectResponse extends Response {
+            }
+            /**
+             * Request to synchronize list of open files with the client
+             */
+            export interface UpdateOpenRequest extends Request {
+                command: CommandTypes.UpdateOpen;
+                arguments: UpdateOpenRequestArgs;
+            }
+            /**
+             * Arguments to UpdateOpenRequest
+             */
+            export interface UpdateOpenRequestArgs {
+                /**
+                 * List of newly open files
+                 */
+                openFiles?: OpenRequestArgs[];
+                /**
+                 * List of open files files that were changes
+                 */
+                changedFiles?: FileCodeEdits[];
+                /**
+                 * List of files that were closed
+                 */
+                closedFiles?: string[];
+            }
+            /**
+             * External projects have a typeAcquisition option so they need to be added separately to compiler options for inferred projects.
+             */
+            export type InferredProjectCompilerOptions = ExternalProjectCompilerOptions & TypeAcquisition;
+            /**
+             * Request to set compiler options for inferred projects.
+             * External projects are opened / closed explicitly.
+             * Configured projects are opened when user opens loose file that has 'tsconfig.json' or 'jsconfig.json' anywhere in one of containing folders.
+             * This configuration file will be used to obtain a list of files and configuration settings for the project.
+             * Inferred projects are created when user opens a loose file that is not the part of external project
+             * or configured project and will contain only open file and transitive closure of referenced files if 'useOneInferredProject' is false,
+             * or all open loose files and its transitive closure of referenced files if 'useOneInferredProject' is true.
+             */
+            export interface SetCompilerOptionsForInferredProjectsRequest extends Request {
+                command: CommandTypes.CompilerOptionsForInferredProjects;
+                arguments: SetCompilerOptionsForInferredProjectsArgs;
+            }
+            /**
+             * Argument for SetCompilerOptionsForInferredProjectsRequest request.
+             */
+            export interface SetCompilerOptionsForInferredProjectsArgs {
+                /**
+                 * Compiler options to be used with inferred projects.
+                 */
+                options: InferredProjectCompilerOptions;
+                /**
+                 * Specifies the project root path used to scope compiler options.
+                 * It is an error to provide this property if the server has not been started with
+                 * `useInferredProjectPerProjectRoot` enabled.
+                 */
+                projectRootPath?: string;
+            }
+            /**
+             * Response to SetCompilerOptionsForInferredProjectsResponse request. This is just an acknowledgement, so
+             * no body field is required.
+             */
+            export interface SetCompilerOptionsForInferredProjectsResponse extends Response {
+            }
+            /**
+             *  Exit request; value of command field is "exit".  Ask the server process
+             *  to exit.
+             */
+            export interface ExitRequest extends Request {
+                command: CommandTypes.Exit;
+            }
+            /**
+             * Close request; value of command field is "close". Notify the
+             * server that the client has closed a previously open file.  If
+             * file is still referenced by open files, the server will resume
+             * monitoring the filesystem for changes to file.  Server does not
+             * currently send a response to a close request.
+             */
+            export interface CloseRequest extends FileRequest {
+                command: CommandTypes.Close;
+            }
+            /**
+             * Request to obtain the list of files that should be regenerated if target file is recompiled.
+             * NOTE: this us query-only operation and does not generate any output on disk.
+             */
+            export interface CompileOnSaveAffectedFileListRequest extends FileRequest {
+                command: CommandTypes.CompileOnSaveAffectedFileList;
+            }
+            /**
+             * Contains a list of files that should be regenerated in a project
+             */
+            export interface CompileOnSaveAffectedFileListSingleProject {
+                /**
+                 * Project name
+                 */
+                projectFileName: string;
+                /**
+                 * List of files names that should be recompiled
+                 */
+                fileNames: string[];
+                /**
+                 * true if project uses outFile or out compiler option
+                 */
+                projectUsesOutFile: boolean;
+            }
+            /**
+             * Response for CompileOnSaveAffectedFileListRequest request;
+             */
+            export interface CompileOnSaveAffectedFileListResponse extends Response {
+                body: CompileOnSaveAffectedFileListSingleProject[];
+            }
+            /**
+             * Request to recompile the file. All generated outputs (.js, .d.ts or .js.map files) is written on disk.
+             */
+            export interface CompileOnSaveEmitFileRequest extends FileRequest {
+                command: CommandTypes.CompileOnSaveEmitFile;
+                arguments: CompileOnSaveEmitFileRequestArgs;
+            }
+            /**
+             * Arguments for CompileOnSaveEmitFileRequest
+             */
+            export interface CompileOnSaveEmitFileRequestArgs extends FileRequestArgs {
+                /**
+                 * if true - then file should be recompiled even if it does not have any changes.
+                 */
+                forced?: boolean;
+                includeLinePosition?: boolean;
+                /** if true - return response as object with emitSkipped and diagnostics */
+                richResponse?: boolean;
+            }
+            export interface CompileOnSaveEmitFileResponse extends Response {
+                body: boolean | EmitResult;
+            }
+            export interface EmitResult {
+                emitSkipped: boolean;
+                diagnostics: Diagnostic[] | DiagnosticWithLinePosition[];
+            }
+            /**
+             * Quickinfo request; value of command field is
+             * "quickinfo". Return response giving a quick type and
+             * documentation string for the symbol found in file at location
+             * line, col.
+             */
+            export interface QuickInfoRequest extends FileLocationRequest {
+                command: CommandTypes.Quickinfo;
+                arguments: FileLocationRequestArgs;
+            }
+            /**
+             * Body of QuickInfoResponse.
+             */
+            export interface QuickInfoResponseBody {
+                /**
+                 * The symbol's kind (such as 'className' or 'parameterName' or plain 'text').
+                 */
+                kind: ScriptElementKind;
+                /**
+                 * Optional modifiers for the kind (such as 'public').
+                 */
+                kindModifiers: string;
+                /**
+                 * Starting file location of symbol.
+                 */
+                start: Location;
+                /**
+                 * One past last character of symbol.
+                 */
+                end: Location;
+                /**
+                 * Type and kind of symbol.
+                 */
+                displayString: string;
+                /**
+                 * Documentation associated with symbol.
+                 * Display parts when UserPreferences.displayPartsForJSDoc is true, flattened to string otherwise.
+                 */
+                documentation: string | SymbolDisplayPart[];
+                /**
+                 * JSDoc tags associated with symbol.
+                 */
+                tags: JSDocTagInfo[];
+            }
+            /**
+             * Quickinfo response message.
+             */
+            export interface QuickInfoResponse extends Response {
+                body?: QuickInfoResponseBody;
+            }
+            /**
+             * Arguments for format messages.
+             */
+            export interface FormatRequestArgs extends FileLocationRequestArgs {
+                /**
+                 * Last line of range for which to format text in file.
+                 */
+                endLine: number;
+                /**
+                 * Character offset on last line of range for which to format text in file.
+                 */
+                endOffset: number;
+                /**
+                 * Format options to be used.
+                 */
+                options?: FormatCodeSettings;
+            }
+            /**
+             * Format request; value of command field is "format".  Return
+             * response giving zero or more edit instructions.  The edit
+             * instructions will be sorted in file order.  Applying the edit
+             * instructions in reverse to file will result in correctly
+             * reformatted text.
+             */
+            export interface FormatRequest extends FileLocationRequest {
+                command: CommandTypes.Format;
+                arguments: FormatRequestArgs;
+            }
+            /**
+             * Object found in response messages defining an editing
+             * instruction for a span of text in source code.  The effect of
+             * this instruction is to replace the text starting at start and
+             * ending one character before end with newText. For an insertion,
+             * the text span is empty.  For a deletion, newText is empty.
+             */
+            export interface CodeEdit {
+                /**
+                 * First character of the text span to edit.
+                 */
+                start: Location;
+                /**
+                 * One character past last character of the text span to edit.
+                 */
+                end: Location;
+                /**
+                 * Replace the span defined above with this string (may be
+                 * the empty string).
+                 */
+                newText: string;
+            }
+            export interface FileCodeEdits {
+                fileName: string;
+                textChanges: CodeEdit[];
+            }
+            export interface CodeFixResponse extends Response {
+                /** The code actions that are available */
+                body?: CodeFixAction[];
+            }
+            export interface CodeAction {
+                /** Description of the code action to display in the UI of the editor */
+                description: string;
+                /** Text changes to apply to each file as part of the code action */
+                changes: FileCodeEdits[];
+                /** A command is an opaque object that should be passed to `ApplyCodeActionCommandRequestArgs` without modification.  */
+                commands?: {}[];
+            }
+            export interface CombinedCodeActions {
+                changes: readonly FileCodeEdits[];
+                commands?: readonly {}[];
+            }
+            export interface CodeFixAction extends CodeAction {
+                /** Short name to identify the fix, for use by telemetry. */
+                fixName: string;
+                /**
+                 * If present, one may call 'getCombinedCodeFix' with this fixId.
+                 * This may be omitted to indicate that the code fix can't be applied in a group.
+                 */
+                fixId?: {};
+                /** Should be present if and only if 'fixId' is. */
+                fixAllDescription?: string;
+            }
+            /**
+             * Format and format on key response message.
+             */
+            export interface FormatResponse extends Response {
+                body?: CodeEdit[];
+            }
+            /**
+             * Arguments for format on key messages.
+             */
+            export interface FormatOnKeyRequestArgs extends FileLocationRequestArgs {
+                /**
+                 * Key pressed (';', '\n', or '}').
+                 */
+                key: string;
+                options?: FormatCodeSettings;
+            }
+            /**
+             * Format on key request; value of command field is
+             * "formatonkey". Given file location and key typed (as string),
+             * return response giving zero or more edit instructions.  The
+             * edit instructions will be sorted in file order.  Applying the
+             * edit instructions in reverse to file will result in correctly
+             * reformatted text.
+             */
+            export interface FormatOnKeyRequest extends FileLocationRequest {
+                command: CommandTypes.Formatonkey;
+                arguments: FormatOnKeyRequestArgs;
+            }
+            export type CompletionsTriggerCharacter = "." | '"' | "'" | "`" | "/" | "@" | "<" | "#" | " ";
+            export enum CompletionTriggerKind {
+                /** Completion was triggered by typing an identifier, manual invocation (e.g Ctrl+Space) or via API. */
+                Invoked = 1,
+                /** Completion was triggered by a trigger character. */
+                TriggerCharacter = 2,
+                /** Completion was re-triggered as the current completion list is incomplete. */
+                TriggerForIncompleteCompletions = 3
+            }
+            /**
+             * Arguments for completions messages.
+             */
+            export interface CompletionsRequestArgs extends FileLocationRequestArgs {
+                /**
+                 * Optional prefix to apply to possible completions.
+                 */
+                prefix?: string;
+                /**
+                 * Character that was responsible for triggering completion.
+                 * Should be `undefined` if a user manually requested completion.
+                 */
+                triggerCharacter?: CompletionsTriggerCharacter;
+                triggerKind?: CompletionTriggerKind;
+                /**
+                 * @deprecated Use UserPreferences.includeCompletionsForModuleExports
+                 */
+                includeExternalModuleExports?: boolean;
+                /**
+                 * @deprecated Use UserPreferences.includeCompletionsWithInsertText
+                 */
+                includeInsertTextCompletions?: boolean;
+            }
+            /**
+             * Completions request; value of command field is "completions".
+             * Given a file location (file, line, col) and a prefix (which may
+             * be the empty string), return the possible completions that
+             * begin with prefix.
+             */
+            export interface CompletionsRequest extends FileLocationRequest {
+                command: CommandTypes.Completions | CommandTypes.CompletionInfo;
+                arguments: CompletionsRequestArgs;
+            }
+            /**
+             * Arguments for completion details request.
+             */
+            export interface CompletionDetailsRequestArgs extends FileLocationRequestArgs {
+                /**
+                 * Names of one or more entries for which to obtain details.
+                 */
+                entryNames: (string | CompletionEntryIdentifier)[];
+            }
+            export interface CompletionEntryIdentifier {
+                name: string;
+                source?: string;
+                data?: unknown;
+            }
+            /**
+             * Completion entry details request; value of command field is
+             * "completionEntryDetails".  Given a file location (file, line,
+             * col) and an array of completion entry names return more
+             * detailed information for each completion entry.
+             */
+            export interface CompletionDetailsRequest extends FileLocationRequest {
+                command: CommandTypes.CompletionDetails;
+                arguments: CompletionDetailsRequestArgs;
+            }
+            /**
+             * Part of a symbol description.
+             */
+            export interface SymbolDisplayPart {
+                /**
+                 * Text of an item describing the symbol.
+                 */
+                text: string;
+                /**
+                 * The symbol's kind (such as 'className' or 'parameterName' or plain 'text').
+                 */
+                kind: string;
+            }
+            /** A part of a symbol description that links from a jsdoc @link tag to a declaration */
+            export interface JSDocLinkDisplayPart extends SymbolDisplayPart {
+                /** The location of the declaration that the @link tag links to. */
+                target: FileSpan;
+            }
+            /**
+             * An item found in a completion response.
+             */
+            export interface CompletionEntry {
+                /**
+                 * The symbol's name.
+                 */
+                name: string;
+                /**
+                 * The symbol's kind (such as 'className' or 'parameterName').
+                 */
+                kind: ScriptElementKind;
+                /**
+                 * Optional modifiers for the kind (such as 'public').
+                 */
+                kindModifiers?: string;
+                /**
+                 * A string that is used for comparing completion items so that they can be ordered.  This
+                 * is often the same as the name but may be different in certain circumstances.
+                 */
+                sortText: string;
+                /**
+                 * Text to insert instead of `name`.
+                 * This is used to support bracketed completions; If `name` might be "a-b" but `insertText` would be `["a-b"]`,
+                 * coupled with `replacementSpan` to replace a dotted access with a bracket access.
+                 */
+                insertText?: string;
+                /**
+                 * `insertText` should be interpreted as a snippet if true.
+                 */
+                isSnippet?: true;
+                /**
+                 * An optional span that indicates the text to be replaced by this completion item.
+                 * If present, this span should be used instead of the default one.
+                 * It will be set if the required span differs from the one generated by the default replacement behavior.
+                 */
+                replacementSpan?: TextSpan;
+                /**
+                 * Indicates whether commiting this completion entry will require additional code actions to be
+                 * made to avoid errors. The CompletionEntryDetails will have these actions.
+                 */
+                hasAction?: true;
+                /**
+                 * Identifier (not necessarily human-readable) identifying where this completion came from.
+                 */
+                source?: string;
+                /**
+                 * Human-readable description of the `source`.
+                 */
+                sourceDisplay?: SymbolDisplayPart[];
+                /**
+                 * Additional details for the label.
+                 */
+                labelDetails?: CompletionEntryLabelDetails;
+                /**
+                 * If true, this completion should be highlighted as recommended. There will only be one of these.
+                 * This will be set when we know the user should write an expression with a certain type and that type is an enum or constructable class.
+                 * Then either that enum/class or a namespace containing it will be the recommended symbol.
+                 */
+                isRecommended?: true;
+                /**
+                 * If true, this completion was generated from traversing the name table of an unchecked JS file,
+                 * and therefore may not be accurate.
+                 */
+                isFromUncheckedFile?: true;
+                /**
+                 * If true, this completion was for an auto-import of a module not yet in the program, but listed
+                 * in the project package.json. Used for telemetry reporting.
+                 */
+                isPackageJsonImport?: true;
+                /**
+                 * If true, this completion was an auto-import-style completion of an import statement (i.e., the
+                 * module specifier was inserted along with the imported identifier). Used for telemetry reporting.
+                 */
+                isImportStatementCompletion?: true;
+                /**
+                 * A property to be sent back to TS Server in the CompletionDetailsRequest, along with `name`,
+                 * that allows TS Server to look up the symbol represented by the completion item, disambiguating
+                 * items with the same name.
+                 */
+                data?: unknown;
+            }
+            export interface CompletionEntryLabelDetails {
+                /**
+                 * An optional string which is rendered less prominently directly after
+                 * {@link CompletionEntry.name name}, without any spacing. Should be
+                 * used for function signatures or type annotations.
+                 */
+                detail?: string;
+                /**
+                 * An optional string which is rendered less prominently after
+                 * {@link CompletionEntryLabelDetails.detail}. Should be used for fully qualified
+                 * names or file path.
+                 */
+                description?: string;
+            }
+            /**
+             * Additional completion entry details, available on demand
+             */
+            export interface CompletionEntryDetails {
+                /**
+                 * The symbol's name.
+                 */
+                name: string;
+                /**
+                 * The symbol's kind (such as 'className' or 'parameterName').
+                 */
+                kind: ScriptElementKind;
+                /**
+                 * Optional modifiers for the kind (such as 'public').
+                 */
+                kindModifiers: string;
+                /**
+                 * Display parts of the symbol (similar to quick info).
+                 */
+                displayParts: SymbolDisplayPart[];
+                /**
+                 * Documentation strings for the symbol.
+                 */
+                documentation?: SymbolDisplayPart[];
+                /**
+                 * JSDoc tags for the symbol.
+                 */
+                tags?: JSDocTagInfo[];
+                /**
+                 * The associated code actions for this entry
+                 */
+                codeActions?: CodeAction[];
+                /**
+                 * @deprecated Use `sourceDisplay` instead.
+                 */
+                source?: SymbolDisplayPart[];
+                /**
+                 * Human-readable description of the `source` from the CompletionEntry.
+                 */
+                sourceDisplay?: SymbolDisplayPart[];
+            }
+            /** @deprecated Prefer CompletionInfoResponse, which supports several top-level fields in addition to the array of entries. */
+            export interface CompletionsResponse extends Response {
+                body?: CompletionEntry[];
+            }
+            export interface CompletionInfoResponse extends Response {
+                body?: CompletionInfo;
+            }
+            export interface CompletionInfo {
+                readonly flags?: number;
+                readonly isGlobalCompletion: boolean;
+                readonly isMemberCompletion: boolean;
+                readonly isNewIdentifierLocation: boolean;
+                /**
+                 * In the absence of `CompletionEntry["replacementSpan"]`, the editor may choose whether to use
+                 * this span or its default one. If `CompletionEntry["replacementSpan"]` is defined, that span
+                 * must be used to commit that completion entry.
+                 */
+                readonly optionalReplacementSpan?: TextSpan;
+                readonly isIncomplete?: boolean;
+                readonly entries: readonly CompletionEntry[];
+            }
+            export interface CompletionDetailsResponse extends Response {
+                body?: CompletionEntryDetails[];
+            }
+            /**
+             * Signature help information for a single parameter
+             */
+            export interface SignatureHelpParameter {
+                /**
+                 * The parameter's name
+                 */
+                name: string;
+                /**
+                 * Documentation of the parameter.
+                 */
+                documentation: SymbolDisplayPart[];
+                /**
+                 * Display parts of the parameter.
+                 */
+                displayParts: SymbolDisplayPart[];
+                /**
+                 * Whether the parameter is optional or not.
+                 */
+                isOptional: boolean;
+            }
+            /**
+             * Represents a single signature to show in signature help.
+             */
+            export interface SignatureHelpItem {
+                /**
+                 * Whether the signature accepts a variable number of arguments.
+                 */
+                isVariadic: boolean;
+                /**
+                 * The prefix display parts.
+                 */
+                prefixDisplayParts: SymbolDisplayPart[];
+                /**
+                 * The suffix display parts.
+                 */
+                suffixDisplayParts: SymbolDisplayPart[];
+                /**
+                 * The separator display parts.
+                 */
+                separatorDisplayParts: SymbolDisplayPart[];
+                /**
+                 * The signature helps items for the parameters.
+                 */
+                parameters: SignatureHelpParameter[];
+                /**
+                 * The signature's documentation
+                 */
+                documentation: SymbolDisplayPart[];
+                /**
+                 * The signature's JSDoc tags
+                 */
+                tags: JSDocTagInfo[];
+            }
+            /**
+             * Signature help items found in the response of a signature help request.
+             */
+            export interface SignatureHelpItems {
+                /**
+                 * The signature help items.
+                 */
+                items: SignatureHelpItem[];
+                /**
+                 * The span for which signature help should appear on a signature
+                 */
+                applicableSpan: TextSpan;
+                /**
+                 * The item selected in the set of available help items.
+                 */
+                selectedItemIndex: number;
+                /**
+                 * The argument selected in the set of parameters.
+                 */
+                argumentIndex: number;
+                /**
+                 * The argument count
+                 */
+                argumentCount: number;
+            }
+            export type SignatureHelpTriggerCharacter = "," | "(" | "<";
+            export type SignatureHelpRetriggerCharacter = SignatureHelpTriggerCharacter | ")";
+            /**
+             * Arguments of a signature help request.
+             */
+            export interface SignatureHelpRequestArgs extends FileLocationRequestArgs {
+                /**
+                 * Reason why signature help was invoked.
+                 * See each individual possible
+                 */
+                triggerReason?: SignatureHelpTriggerReason;
+            }
+            export type SignatureHelpTriggerReason = SignatureHelpInvokedReason | SignatureHelpCharacterTypedReason | SignatureHelpRetriggeredReason;
+            /**
+             * Signals that the user manually requested signature help.
+             * The language service will unconditionally attempt to provide a result.
+             */
+            export interface SignatureHelpInvokedReason {
+                kind: "invoked";
+                triggerCharacter?: undefined;
+            }
+            /**
+             * Signals that the signature help request came from a user typing a character.
+             * Depending on the character and the syntactic context, the request may or may not be served a result.
+             */
+            export interface SignatureHelpCharacterTypedReason {
+                kind: "characterTyped";
+                /**
+                 * Character that was responsible for triggering signature help.
+                 */
+                triggerCharacter: SignatureHelpTriggerCharacter;
+            }
+            /**
+             * Signals that this signature help request came from typing a character or moving the cursor.
+             * This should only occur if a signature help session was already active and the editor needs to see if it should adjust.
+             * The language service will unconditionally attempt to provide a result.
+             * `triggerCharacter` can be `undefined` for a retrigger caused by a cursor move.
+             */
+            export interface SignatureHelpRetriggeredReason {
+                kind: "retrigger";
+                /**
+                 * Character that was responsible for triggering signature help.
+                 */
+                triggerCharacter?: SignatureHelpRetriggerCharacter;
+            }
+            /**
+             * Signature help request; value of command field is "signatureHelp".
+             * Given a file location (file, line, col), return the signature
+             * help.
+             */
+            export interface SignatureHelpRequest extends FileLocationRequest {
+                command: CommandTypes.SignatureHelp;
+                arguments: SignatureHelpRequestArgs;
+            }
+            /**
+             * Response object for a SignatureHelpRequest.
+             */
+            export interface SignatureHelpResponse extends Response {
+                body?: SignatureHelpItems;
+            }
+            export type InlayHintKind = "Type" | "Parameter" | "Enum";
+            export interface InlayHintsRequestArgs extends FileRequestArgs {
+                /**
+                 * Start position of the span.
+                 */
+                start: number;
+                /**
+                 * Length of the span.
+                 */
+                length: number;
+            }
+            export interface InlayHintsRequest extends Request {
+                command: CommandTypes.ProvideInlayHints;
+                arguments: InlayHintsRequestArgs;
+            }
+            export interface InlayHintItem {
+                text: string;
+                position: Location;
+                kind: InlayHintKind;
+                whitespaceBefore?: boolean;
+                whitespaceAfter?: boolean;
+            }
+            export interface InlayHintsResponse extends Response {
+                body?: InlayHintItem[];
+            }
+            /**
+             * Synchronous request for semantic diagnostics of one file.
+             */
+            export interface SemanticDiagnosticsSyncRequest extends FileRequest {
+                command: CommandTypes.SemanticDiagnosticsSync;
+                arguments: SemanticDiagnosticsSyncRequestArgs;
+            }
+            export interface SemanticDiagnosticsSyncRequestArgs extends FileRequestArgs {
+                includeLinePosition?: boolean;
+            }
+            /**
+             * Response object for synchronous sematic diagnostics request.
+             */
+            export interface SemanticDiagnosticsSyncResponse extends Response {
+                body?: Diagnostic[] | DiagnosticWithLinePosition[];
+            }
+            export interface SuggestionDiagnosticsSyncRequest extends FileRequest {
+                command: CommandTypes.SuggestionDiagnosticsSync;
+                arguments: SuggestionDiagnosticsSyncRequestArgs;
+            }
+            export type SuggestionDiagnosticsSyncRequestArgs = SemanticDiagnosticsSyncRequestArgs;
+            export type SuggestionDiagnosticsSyncResponse = SemanticDiagnosticsSyncResponse;
+            /**
+             * Synchronous request for syntactic diagnostics of one file.
+             */
+            export interface SyntacticDiagnosticsSyncRequest extends FileRequest {
+                command: CommandTypes.SyntacticDiagnosticsSync;
+                arguments: SyntacticDiagnosticsSyncRequestArgs;
+            }
+            export interface SyntacticDiagnosticsSyncRequestArgs extends FileRequestArgs {
+                includeLinePosition?: boolean;
+            }
+            /**
+             * Response object for synchronous syntactic diagnostics request.
+             */
+            export interface SyntacticDiagnosticsSyncResponse extends Response {
+                body?: Diagnostic[] | DiagnosticWithLinePosition[];
+            }
+            /**
+             * Arguments for GeterrForProject request.
+             */
+            export interface GeterrForProjectRequestArgs {
+                /**
+                 * the file requesting project error list
+                 */
+                file: string;
+                /**
+                 * Delay in milliseconds to wait before starting to compute
+                 * errors for the files in the file list
+                 */
+                delay: number;
+            }
+            /**
+             * GeterrForProjectRequest request; value of command field is
+             * "geterrForProject". It works similarly with 'Geterr', only
+             * it request for every file in this project.
+             */
+            export interface GeterrForProjectRequest extends Request {
+                command: CommandTypes.GeterrForProject;
+                arguments: GeterrForProjectRequestArgs;
+            }
+            /**
+             * Arguments for geterr messages.
+             */
+            export interface GeterrRequestArgs {
+                /**
+                 * List of file names for which to compute compiler errors.
+                 * The files will be checked in list order.
+                 */
+                files: string[];
+                /**
+                 * Delay in milliseconds to wait before starting to compute
+                 * errors for the files in the file list
+                 */
+                delay: number;
+            }
+            /**
+             * Geterr request; value of command field is "geterr". Wait for
+             * delay milliseconds and then, if during the wait no change or
+             * reload messages have arrived for the first file in the files
+             * list, get the syntactic errors for the file, field requests,
+             * and then get the semantic errors for the file.  Repeat with a
+             * smaller delay for each subsequent file on the files list.  Best
+             * practice for an editor is to send a file list containing each
+             * file that is currently visible, in most-recently-used order.
+             */
+            export interface GeterrRequest extends Request {
+                command: CommandTypes.Geterr;
+                arguments: GeterrRequestArgs;
+            }
+            export type RequestCompletedEventName = "requestCompleted";
+            /**
+             * Event that is sent when server have finished processing request with specified id.
+             */
+            export interface RequestCompletedEvent extends Event {
+                event: RequestCompletedEventName;
+                body: RequestCompletedEventBody;
+            }
+            export interface RequestCompletedEventBody {
+                request_seq: number;
+            }
+            /**
+             * Item of diagnostic information found in a DiagnosticEvent message.
+             */
+            export interface Diagnostic {
+                /**
+                 * Starting file location at which text applies.
+                 */
+                start: Location;
+                /**
+                 * The last file location at which the text applies.
+                 */
+                end: Location;
+                /**
+                 * Text of diagnostic message.
+                 */
+                text: string;
+                /**
+                 * The category of the diagnostic message, e.g. "error", "warning", or "suggestion".
+                 */
+                category: string;
+                reportsUnnecessary?: {};
+                reportsDeprecated?: {};
+                /**
+                 * Any related spans the diagnostic may have, such as other locations relevant to an error, such as declarartion sites
+                 */
+                relatedInformation?: DiagnosticRelatedInformation[];
+                /**
+                 * The error code of the diagnostic message.
+                 */
+                code?: number;
+                /**
+                 * The name of the plugin reporting the message.
+                 */
+                source?: string;
+            }
+            export interface DiagnosticWithFileName extends Diagnostic {
+                /**
+                 * Name of the file the diagnostic is in
+                 */
+                fileName: string;
+            }
+            /**
+             * Represents additional spans returned with a diagnostic which are relevant to it
+             */
+            export interface DiagnosticRelatedInformation {
+                /**
+                 * The category of the related information message, e.g. "error", "warning", or "suggestion".
+                 */
+                category: string;
+                /**
+                 * The code used ot identify the related information
+                 */
+                code: number;
+                /**
+                 * Text of related or additional information.
+                 */
+                message: string;
+                /**
+                 * Associated location
+                 */
+                span?: FileSpan;
+            }
+            export interface DiagnosticEventBody {
+                /**
+                 * The file for which diagnostic information is reported.
+                 */
+                file: string;
+                /**
+                 * An array of diagnostic information items.
+                 */
+                diagnostics: Diagnostic[];
+            }
+            export type DiagnosticEventKind = "semanticDiag" | "syntaxDiag" | "suggestionDiag";
+            /**
+             * Event message for DiagnosticEventKind event types.
+             * These events provide syntactic and semantic errors for a file.
+             */
+            export interface DiagnosticEvent extends Event {
+                body?: DiagnosticEventBody;
+                event: DiagnosticEventKind;
+            }
+            export interface ConfigFileDiagnosticEventBody {
+                /**
+                 * The file which trigged the searching and error-checking of the config file
+                 */
+                triggerFile: string;
+                /**
+                 * The name of the found config file.
+                 */
+                configFile: string;
+                /**
+                 * An arry of diagnostic information items for the found config file.
+                 */
+                diagnostics: DiagnosticWithFileName[];
+            }
+            /**
+             * Event message for "configFileDiag" event type.
+             * This event provides errors for a found config file.
+             */
+            export interface ConfigFileDiagnosticEvent extends Event {
+                body?: ConfigFileDiagnosticEventBody;
+                event: "configFileDiag";
+            }
+            export type ProjectLanguageServiceStateEventName = "projectLanguageServiceState";
+            export interface ProjectLanguageServiceStateEvent extends Event {
+                event: ProjectLanguageServiceStateEventName;
+                body?: ProjectLanguageServiceStateEventBody;
+            }
+            export interface ProjectLanguageServiceStateEventBody {
+                /**
+                 * Project name that has changes in the state of language service.
+                 * For configured projects this will be the config file path.
+                 * For external projects this will be the name of the projects specified when project was open.
+                 * For inferred projects this event is not raised.
+                 */
+                projectName: string;
+                /**
+                 * True if language service state switched from disabled to enabled
+                 * and false otherwise.
+                 */
+                languageServiceEnabled: boolean;
+            }
+            export type ProjectsUpdatedInBackgroundEventName = "projectsUpdatedInBackground";
+            export interface ProjectsUpdatedInBackgroundEvent extends Event {
+                event: ProjectsUpdatedInBackgroundEventName;
+                body: ProjectsUpdatedInBackgroundEventBody;
+            }
+            export interface ProjectsUpdatedInBackgroundEventBody {
+                /**
+                 * Current set of open files
+                 */
+                openFiles: string[];
+            }
+            export type ProjectLoadingStartEventName = "projectLoadingStart";
+            export interface ProjectLoadingStartEvent extends Event {
+                event: ProjectLoadingStartEventName;
+                body: ProjectLoadingStartEventBody;
+            }
+            export interface ProjectLoadingStartEventBody {
+                /** name of the project */
+                projectName: string;
+                /** reason for loading */
+                reason: string;
+            }
+            export type ProjectLoadingFinishEventName = "projectLoadingFinish";
+            export interface ProjectLoadingFinishEvent extends Event {
+                event: ProjectLoadingFinishEventName;
+                body: ProjectLoadingFinishEventBody;
+            }
+            export interface ProjectLoadingFinishEventBody {
+                /** name of the project */
+                projectName: string;
+            }
+            export type SurveyReadyEventName = "surveyReady";
+            export interface SurveyReadyEvent extends Event {
+                event: SurveyReadyEventName;
+                body: SurveyReadyEventBody;
+            }
+            export interface SurveyReadyEventBody {
+                /** Name of the survey. This is an internal machine- and programmer-friendly name */
+                surveyId: string;
+            }
+            export type LargeFileReferencedEventName = "largeFileReferenced";
+            export interface LargeFileReferencedEvent extends Event {
+                event: LargeFileReferencedEventName;
+                body: LargeFileReferencedEventBody;
+            }
+            export interface LargeFileReferencedEventBody {
+                /**
+                 * name of the large file being loaded
+                 */
+                file: string;
+                /**
+                 * size of the file
+                 */
+                fileSize: number;
+                /**
+                 * max file size allowed on the server
+                 */
+                maxFileSize: number;
+            }
+            /**
+             * Arguments for reload request.
+             */
+            export interface ReloadRequestArgs extends FileRequestArgs {
+                /**
+                 * Name of temporary file from which to reload file
+                 * contents. May be same as file.
+                 */
+                tmpfile: string;
+            }
+            /**
+             * Reload request message; value of command field is "reload".
+             * Reload contents of file with name given by the 'file' argument
+             * from temporary file with name given by the 'tmpfile' argument.
+             * The two names can be identical.
+             */
+            export interface ReloadRequest extends FileRequest {
+                command: CommandTypes.Reload;
+                arguments: ReloadRequestArgs;
+            }
+            /**
+             * Response to "reload" request. This is just an acknowledgement, so
+             * no body field is required.
+             */
+            export interface ReloadResponse extends Response {
+            }
+            /**
+             * Arguments for saveto request.
+             */
+            export interface SavetoRequestArgs extends FileRequestArgs {
+                /**
+                 * Name of temporary file into which to save server's view of
+                 * file contents.
+                 */
+                tmpfile: string;
+            }
+            /**
+             * Saveto request message; value of command field is "saveto".
+             * For debugging purposes, save to a temporaryfile (named by
+             * argument 'tmpfile') the contents of file named by argument
+             * 'file'.  The server does not currently send a response to a
+             * "saveto" request.
+             */
+            export interface SavetoRequest extends FileRequest {
+                command: CommandTypes.Saveto;
+                arguments: SavetoRequestArgs;
+            }
+            /**
+             * Arguments for navto request message.
+             */
+            export interface NavtoRequestArgs {
+                /**
+                 * Search term to navigate to from current location; term can
+                 * be '.*' or an identifier prefix.
+                 */
+                searchValue: string;
+                /**
+                 *  Optional limit on the number of items to return.
+                 */
+                maxResultCount?: number;
+                /**
+                 * The file for the request (absolute pathname required).
+                 */
+                file?: string;
+                /**
+                 * Optional flag to indicate we want results for just the current file
+                 * or the entire project.
+                 */
+                currentFileOnly?: boolean;
+                projectFileName?: string;
+            }
+            /**
+             * Navto request message; value of command field is "navto".
+             * Return list of objects giving file locations and symbols that
+             * match the search term given in argument 'searchTerm'.  The
+             * context for the search is given by the named file.
+             */
+            export interface NavtoRequest extends Request {
+                command: CommandTypes.Navto;
+                arguments: NavtoRequestArgs;
+            }
+            /**
+             * An item found in a navto response.
+             */
+            export interface NavtoItem extends FileSpan {
+                /**
+                 * The symbol's name.
+                 */
+                name: string;
+                /**
+                 * The symbol's kind (such as 'className' or 'parameterName').
+                 */
+                kind: ScriptElementKind;
+                /**
+                 * exact, substring, or prefix.
+                 */
+                matchKind: string;
+                /**
+                 * If this was a case sensitive or insensitive match.
+                 */
+                isCaseSensitive: boolean;
+                /**
+                 * Optional modifiers for the kind (such as 'public').
+                 */
+                kindModifiers?: string;
+                /**
+                 * Name of symbol's container symbol (if any); for example,
+                 * the class name if symbol is a class member.
+                 */
+                containerName?: string;
+                /**
+                 * Kind of symbol's container symbol (if any).
+                 */
+                containerKind?: ScriptElementKind;
+            }
+            /**
+             * Navto response message. Body is an array of navto items.  Each
+             * item gives a symbol that matched the search term.
+             */
+            export interface NavtoResponse extends Response {
+                body?: NavtoItem[];
+            }
+            /**
+             * Arguments for change request message.
+             */
+            export interface ChangeRequestArgs extends FormatRequestArgs {
+                /**
+                 * Optional string to insert at location (file, line, offset).
+                 */
+                insertString?: string;
+            }
+            /**
+             * Change request message; value of command field is "change".
+             * Update the server's view of the file named by argument 'file'.
+             * Server does not currently send a response to a change request.
+             */
+            export interface ChangeRequest extends FileLocationRequest {
+                command: CommandTypes.Change;
+                arguments: ChangeRequestArgs;
+            }
+            /**
+             * Response to "brace" request.
+             */
+            export interface BraceResponse extends Response {
+                body?: TextSpan[];
+            }
+            /**
+             * Brace matching request; value of command field is "brace".
+             * Return response giving the file locations of matching braces
+             * found in file at location line, offset.
+             */
+            export interface BraceRequest extends FileLocationRequest {
+                command: CommandTypes.Brace;
+            }
+            /**
+             * NavBar items request; value of command field is "navbar".
+             * Return response giving the list of navigation bar entries
+             * extracted from the requested file.
+             */
+            export interface NavBarRequest extends FileRequest {
+                command: CommandTypes.NavBar;
+            }
+            /**
+             * NavTree request; value of command field is "navtree".
+             * Return response giving the navigation tree of the requested file.
+             */
+            export interface NavTreeRequest extends FileRequest {
+                command: CommandTypes.NavTree;
+            }
+            export interface NavigationBarItem {
+                /**
+                 * The item's display text.
+                 */
+                text: string;
+                /**
+                 * The symbol's kind (such as 'className' or 'parameterName').
+                 */
+                kind: ScriptElementKind;
+                /**
+                 * Optional modifiers for the kind (such as 'public').
+                 */
+                kindModifiers?: string;
+                /**
+                 * The definition locations of the item.
+                 */
+                spans: TextSpan[];
+                /**
+                 * Optional children.
+                 */
+                childItems?: NavigationBarItem[];
+                /**
+                 * Number of levels deep this item should appear.
+                 */
+                indent: number;
+            }
+            /** protocol.NavigationTree is identical to ts.NavigationTree, except using protocol.TextSpan instead of ts.TextSpan */
+            export interface NavigationTree {
+                text: string;
+                kind: ScriptElementKind;
+                kindModifiers: string;
+                spans: TextSpan[];
+                nameSpan: TextSpan | undefined;
+                childItems?: NavigationTree[];
+            }
+            export type TelemetryEventName = "telemetry";
+            export interface TelemetryEvent extends Event {
+                event: TelemetryEventName;
+                body: TelemetryEventBody;
+            }
+            export interface TelemetryEventBody {
+                telemetryEventName: string;
+                payload: any;
+            }
+            export type TypesInstallerInitializationFailedEventName = "typesInstallerInitializationFailed";
+            export interface TypesInstallerInitializationFailedEvent extends Event {
+                event: TypesInstallerInitializationFailedEventName;
+                body: TypesInstallerInitializationFailedEventBody;
+            }
+            export interface TypesInstallerInitializationFailedEventBody {
+                message: string;
+            }
+            export type TypingsInstalledTelemetryEventName = "typingsInstalled";
+            export interface TypingsInstalledTelemetryEventBody extends TelemetryEventBody {
+                telemetryEventName: TypingsInstalledTelemetryEventName;
+                payload: TypingsInstalledTelemetryEventPayload;
+            }
+            export interface TypingsInstalledTelemetryEventPayload {
+                /**
+                 * Comma separated list of installed typing packages
+                 */
+                installedPackages: string;
+                /**
+                 * true if install request succeeded, otherwise - false
+                 */
+                installSuccess: boolean;
+                /**
+                 * version of typings installer
+                 */
+                typingsInstallerVersion: string;
+            }
+            export type BeginInstallTypesEventName = "beginInstallTypes";
+            export type EndInstallTypesEventName = "endInstallTypes";
+            export interface BeginInstallTypesEvent extends Event {
+                event: BeginInstallTypesEventName;
+                body: BeginInstallTypesEventBody;
+            }
+            export interface EndInstallTypesEvent extends Event {
+                event: EndInstallTypesEventName;
+                body: EndInstallTypesEventBody;
+            }
+            export interface InstallTypesEventBody {
+                /**
+                 * correlation id to match begin and end events
+                 */
+                eventId: number;
+                /**
+                 * list of packages to install
+                 */
+                packages: readonly string[];
+            }
+            export interface BeginInstallTypesEventBody extends InstallTypesEventBody {
+            }
+            export interface EndInstallTypesEventBody extends InstallTypesEventBody {
+                /**
+                 * true if installation succeeded, otherwise false
+                 */
+                success: boolean;
+            }
+            export interface NavBarResponse extends Response {
+                body?: NavigationBarItem[];
+            }
+            export interface NavTreeResponse extends Response {
+                body?: NavigationTree;
+            }
+            export interface CallHierarchyItem {
+                name: string;
+                kind: ScriptElementKind;
+                kindModifiers?: string;
+                file: string;
+                span: TextSpan;
+                selectionSpan: TextSpan;
+                containerName?: string;
+            }
+            export interface CallHierarchyIncomingCall {
+                from: CallHierarchyItem;
+                fromSpans: TextSpan[];
+            }
+            export interface CallHierarchyOutgoingCall {
+                to: CallHierarchyItem;
+                fromSpans: TextSpan[];
+            }
+            export interface PrepareCallHierarchyRequest extends FileLocationRequest {
+                command: CommandTypes.PrepareCallHierarchy;
+            }
+            export interface PrepareCallHierarchyResponse extends Response {
+                readonly body: CallHierarchyItem | CallHierarchyItem[];
+            }
+            export interface ProvideCallHierarchyIncomingCallsRequest extends FileLocationRequest {
+                command: CommandTypes.ProvideCallHierarchyIncomingCalls;
+            }
+            export interface ProvideCallHierarchyIncomingCallsResponse extends Response {
+                readonly body: CallHierarchyIncomingCall[];
+            }
+            export interface ProvideCallHierarchyOutgoingCallsRequest extends FileLocationRequest {
+                command: CommandTypes.ProvideCallHierarchyOutgoingCalls;
+            }
+            export interface ProvideCallHierarchyOutgoingCallsResponse extends Response {
+                readonly body: CallHierarchyOutgoingCall[];
+            }
+            export enum IndentStyle {
+                None = "None",
+                Block = "Block",
+                Smart = "Smart"
+            }
+            export enum SemicolonPreference {
+                Ignore = "ignore",
+                Insert = "insert",
+                Remove = "remove"
+            }
+            export interface EditorSettings {
+                baseIndentSize?: number;
+                indentSize?: number;
+                tabSize?: number;
+                newLineCharacter?: string;
+                convertTabsToSpaces?: boolean;
+                indentStyle?: IndentStyle | ts.IndentStyle;
+                trimTrailingWhitespace?: boolean;
+            }
+            export interface FormatCodeSettings extends EditorSettings {
+                insertSpaceAfterCommaDelimiter?: boolean;
+                insertSpaceAfterSemicolonInForStatements?: boolean;
+                insertSpaceBeforeAndAfterBinaryOperators?: boolean;
+                insertSpaceAfterConstructor?: boolean;
+                insertSpaceAfterKeywordsInControlFlowStatements?: boolean;
+                insertSpaceAfterFunctionKeywordForAnonymousFunctions?: boolean;
+                insertSpaceAfterOpeningAndBeforeClosingEmptyBraces?: boolean;
+                insertSpaceAfterOpeningAndBeforeClosingNonemptyParenthesis?: boolean;
+                insertSpaceAfterOpeningAndBeforeClosingNonemptyBrackets?: boolean;
+                insertSpaceAfterOpeningAndBeforeClosingNonemptyBraces?: boolean;
+                insertSpaceAfterOpeningAndBeforeClosingTemplateStringBraces?: boolean;
+                insertSpaceAfterOpeningAndBeforeClosingJsxExpressionBraces?: boolean;
+                insertSpaceAfterTypeAssertion?: boolean;
+                insertSpaceBeforeFunctionParenthesis?: boolean;
+                placeOpenBraceOnNewLineForFunctions?: boolean;
+                placeOpenBraceOnNewLineForControlBlocks?: boolean;
+                insertSpaceBeforeTypeAnnotation?: boolean;
+                semicolons?: SemicolonPreference;
+            }
+            export interface UserPreferences {
+                readonly disableSuggestions?: boolean;
+                readonly quotePreference?: "auto" | "double" | "single";
+                /**
+                 * If enabled, TypeScript will search through all external modules' exports and add them to the completions list.
+                 * This affects lone identifier completions but not completions on the right hand side of `obj.`.
+                 */
+                readonly includeCompletionsForModuleExports?: boolean;
+                /**
+                 * Enables auto-import-style completions on partially-typed import statements. E.g., allows
+                 * `import write|` to be completed to `import { writeFile } from "fs"`.
+                 */
+                readonly includeCompletionsForImportStatements?: boolean;
+                /**
+                 * Allows completions to be formatted with snippet text, indicated by `CompletionItem["isSnippet"]`.
+                 */
+                readonly includeCompletionsWithSnippetText?: boolean;
+                /**
+                 * If enabled, the completion list will include completions with invalid identifier names.
+                 * For those entries, The `insertText` and `replacementSpan` properties will be set to change from `.x` property access to `["x"]`.
+                 */
+                readonly includeCompletionsWithInsertText?: boolean;
+                /**
+                 * Unless this option is `false`, or `includeCompletionsWithInsertText` is not enabled,
+                 * member completion lists triggered with `.` will include entries on potentially-null and potentially-undefined
+                 * values, with insertion text to replace preceding `.` tokens with `?.`.
+                 */
+                readonly includeAutomaticOptionalChainCompletions?: boolean;
+                /**
+                 * If enabled, completions for class members (e.g. methods and properties) will include
+                 * a whole declaration for the member.
+                 * E.g., `class A { f| }` could be completed to `class A { foo(): number {} }`, instead of
+                 * `class A { foo }`.
+                 */
+                readonly includeCompletionsWithClassMemberSnippets?: boolean;
+                /**
+                 * If enabled, object literal methods will have a method declaration completion entry in addition
+                 * to the regular completion entry containing just the method name.
+                 * E.g., `const objectLiteral: T = { f| }` could be completed to `const objectLiteral: T = { foo(): void {} }`,
+                 * in addition to `const objectLiteral: T = { foo }`.
+                 */
+                readonly includeCompletionsWithObjectLiteralMethodSnippets?: boolean;
+                /**
+                 * Indicates whether {@link CompletionEntry.labelDetails completion entry label details} are supported.
+                 * If not, contents of `labelDetails` may be included in the {@link CompletionEntry.name} property.
+                 */
+                readonly useLabelDetailsInCompletionEntries?: boolean;
+                readonly allowIncompleteCompletions?: boolean;
+                readonly importModuleSpecifierPreference?: "shortest" | "project-relative" | "relative" | "non-relative";
+                /** Determines whether we import `foo/index.ts` as "foo", "foo/index", or "foo/index.js" */
+                readonly importModuleSpecifierEnding?: "auto" | "minimal" | "index" | "js";
+                readonly allowTextChangesInNewFiles?: boolean;
+                readonly lazyConfiguredProjectsFromExternalProject?: boolean;
+                readonly providePrefixAndSuffixTextForRename?: boolean;
+                readonly provideRefactorNotApplicableReason?: boolean;
+                readonly allowRenameOfImportPath?: boolean;
+                readonly includePackageJsonAutoImports?: "auto" | "on" | "off";
+                readonly jsxAttributeCompletionStyle?: "auto" | "braces" | "none";
+                readonly displayPartsForJSDoc?: boolean;
+                readonly generateReturnInDocTemplate?: boolean;
+                readonly includeInlayParameterNameHints?: "none" | "literals" | "all";
+                readonly includeInlayParameterNameHintsWhenArgumentMatchesName?: boolean;
+                readonly includeInlayFunctionParameterTypeHints?: boolean;
+                readonly includeInlayVariableTypeHints?: boolean;
+                readonly includeInlayVariableTypeHintsWhenTypeMatchesName?: boolean;
+                readonly includeInlayPropertyDeclarationTypeHints?: boolean;
+                readonly includeInlayFunctionLikeReturnTypeHints?: boolean;
+                readonly includeInlayEnumMemberValueHints?: boolean;
+                readonly autoImportFileExcludePatterns?: string[];
+            }
+            export interface CompilerOptions {
+                allowJs?: boolean;
+                allowSyntheticDefaultImports?: boolean;
+                allowUnreachableCode?: boolean;
+                allowUnusedLabels?: boolean;
+                alwaysStrict?: boolean;
+                baseUrl?: string;
+                charset?: string;
+                checkJs?: boolean;
+                declaration?: boolean;
+                declarationDir?: string;
+                disableSizeLimit?: boolean;
+                downlevelIteration?: boolean;
+                emitBOM?: boolean;
+                emitDecoratorMetadata?: boolean;
+                experimentalDecorators?: boolean;
+                forceConsistentCasingInFileNames?: boolean;
+                importHelpers?: boolean;
+                inlineSourceMap?: boolean;
+                inlineSources?: boolean;
+                isolatedModules?: boolean;
+                jsx?: JsxEmit | ts.JsxEmit;
+                lib?: string[];
+                locale?: string;
+                mapRoot?: string;
+                maxNodeModuleJsDepth?: number;
+                module?: ModuleKind | ts.ModuleKind;
+                moduleResolution?: ModuleResolutionKind | ts.ModuleResolutionKind;
+                newLine?: NewLineKind | ts.NewLineKind;
+                noEmit?: boolean;
+                noEmitHelpers?: boolean;
+                noEmitOnError?: boolean;
+                noErrorTruncation?: boolean;
+                noFallthroughCasesInSwitch?: boolean;
+                noImplicitAny?: boolean;
+                noImplicitReturns?: boolean;
+                noImplicitThis?: boolean;
+                noUnusedLocals?: boolean;
+                noUnusedParameters?: boolean;
+                noImplicitUseStrict?: boolean;
+                noLib?: boolean;
+                noResolve?: boolean;
+                out?: string;
+                outDir?: string;
+                outFile?: string;
+                paths?: MapLike<string[]>;
+                plugins?: PluginImport[];
+                preserveConstEnums?: boolean;
+                preserveSymlinks?: boolean;
+                project?: string;
+                reactNamespace?: string;
+                removeComments?: boolean;
+                references?: ProjectReference[];
+                rootDir?: string;
+                rootDirs?: string[];
+                skipLibCheck?: boolean;
+                skipDefaultLibCheck?: boolean;
+                sourceMap?: boolean;
+                sourceRoot?: string;
+                strict?: boolean;
+                strictNullChecks?: boolean;
+                suppressExcessPropertyErrors?: boolean;
+                suppressImplicitAnyIndexErrors?: boolean;
+                useDefineForClassFields?: boolean;
+                target?: ScriptTarget | ts.ScriptTarget;
+                traceResolution?: boolean;
+                resolveJsonModule?: boolean;
+                types?: string[];
+                /** Paths used to used to compute primary types search locations */
+                typeRoots?: string[];
+                [option: string]: CompilerOptionsValue | undefined;
+            }
+            export enum JsxEmit {
+                None = "None",
+                Preserve = "Preserve",
+                ReactNative = "ReactNative",
+                React = "React"
+            }
+            export enum ModuleKind {
+                None = "None",
+                CommonJS = "CommonJS",
+                AMD = "AMD",
+                UMD = "UMD",
+                System = "System",
+                ES6 = "ES6",
+                ES2015 = "ES2015",
+                ESNext = "ESNext"
+            }
+            export enum ModuleResolutionKind {
+                Classic = "Classic",
+                Node = "Node"
+            }
+            export enum NewLineKind {
+                Crlf = "Crlf",
+                Lf = "Lf"
+            }
+            export enum ScriptTarget {
+                ES3 = "ES3",
+                ES5 = "ES5",
+                ES6 = "ES6",
+                ES2015 = "ES2015",
+                ES2016 = "ES2016",
+                ES2017 = "ES2017",
+                ES2018 = "ES2018",
+                ES2019 = "ES2019",
+                ES2020 = "ES2020",
+                ES2021 = "ES2021",
+                ES2022 = "ES2022",
+                ESNext = "ESNext"
+            }
+            export enum ClassificationType {
+                comment = 1,
+                identifier = 2,
+                keyword = 3,
+                numericLiteral = 4,
+                operator = 5,
+                stringLiteral = 6,
+                regularExpressionLiteral = 7,
+                whiteSpace = 8,
+                text = 9,
+                punctuation = 10,
+                className = 11,
+                enumName = 12,
+                interfaceName = 13,
+                moduleName = 14,
+                typeParameterName = 15,
+                typeAliasName = 16,
+                parameterName = 17,
+                docCommentTagName = 18,
+                jsxOpenTagName = 19,
+                jsxCloseTagName = 20,
+                jsxSelfClosingTagName = 21,
+                jsxAttribute = 22,
+                jsxText = 23,
+                jsxAttributeStringLiteralValue = 24,
+                bigintLiteral = 25
+            }
+        }
+        export interface CompressedData {
+            length: number;
+            compressionKind: string;
+            data: any;
+        }
+        export type ModuleImportResult = {
+            module: {};
+            error: undefined;
+        } | {
+            module: undefined;
+            error: {
+                stack?: string;
+                message?: string;
+            };
+        };
+        /** @deprecated Use {@link ModuleImportResult} instead. */
+        export type RequireResult = ModuleImportResult;
+        export interface ServerHost extends System {
+            watchFile(path: string, callback: FileWatcherCallback, pollingInterval?: number, options?: WatchOptions): FileWatcher;
+            watchDirectory(path: string, callback: DirectoryWatcherCallback, recursive?: boolean, options?: WatchOptions): FileWatcher;
+            setTimeout(callback: (...args: any[]) => void, ms: number, ...args: any[]): any;
+            clearTimeout(timeoutId: any): void;
+            setImmediate(callback: (...args: any[]) => void, ...args: any[]): any;
+            clearImmediate(timeoutId: any): void;
+            gc?(): void;
+            trace?(s: string): void;
+            require?(initialPath: string, moduleName: string): ModuleImportResult;
+        }
+        export function createInstallTypingsRequest(project: Project, typeAcquisition: TypeAcquisition, unresolvedImports: SortedReadonlyArray<string>, cachePath?: string): DiscoverTypings;
+        export function toNormalizedPath(fileName: string): NormalizedPath;
+        export function normalizedPathToPath(normalizedPath: NormalizedPath, currentDirectory: string, getCanonicalFileName: (f: string) => string): Path;
+        export function asNormalizedPath(fileName: string): NormalizedPath;
+        export function createNormalizedPathMap<T>(): NormalizedPathMap<T>;
+        export function isInferredProjectName(name: string): boolean;
+        export function makeInferredProjectName(counter: number): string;
+        export function createSortedArray<T>(): SortedArray<T>;
+        export enum LogLevel {
+            terse = 0,
+            normal = 1,
+            requestTime = 2,
+            verbose = 3
+        }
+        export const emptyArray: SortedReadonlyArray<never>;
+        export interface Logger {
+            close(): void;
+            hasLevel(level: LogLevel): boolean;
+            loggingEnabled(): boolean;
+            perftrc(s: string): void;
+            info(s: string): void;
+            startGroup(): void;
+            endGroup(): void;
+            msg(s: string, type?: Msg): void;
+            getLogFileName(): string | undefined;
+        }
+        export enum Msg {
+            Err = "Err",
+            Info = "Info",
+            Perf = "Perf"
+        }
+        export namespace Msg {
+            /** @deprecated Only here for backwards-compatibility. Prefer just `Msg`. */
+            type Types = Msg;
+        }
+        export namespace Errors {
+            function ThrowNoProject(): never;
+            function ThrowProjectLanguageServiceDisabled(): never;
+            function ThrowProjectDoesNotContainDocument(fileName: string, project: Project): never;
+        }
+        export type NormalizedPath = string & {
+            __normalizedPathTag: any;
+        };
+        export interface NormalizedPathMap<T> {
+            get(path: NormalizedPath): T | undefined;
+            set(path: NormalizedPath, value: T): void;
+            contains(path: NormalizedPath): boolean;
+            remove(path: NormalizedPath): void;
+        }
+        export function isDynamicFileName(fileName: NormalizedPath): boolean;
+        export interface ScriptInfoVersion {
+            svc: number;
+            text: number;
+        }
+        export class ScriptInfo {
+            private readonly host;
+            readonly fileName: NormalizedPath;
+            readonly scriptKind: ScriptKind;
+            readonly hasMixedContent: boolean;
+            readonly path: Path;
+            /**
+             * All projects that include this file
+             */
+            readonly containingProjects: Project[];
+            private formatSettings;
+            private preferences;
+            private textStorage;
+            constructor(host: ServerHost, fileName: NormalizedPath, scriptKind: ScriptKind, hasMixedContent: boolean, path: Path, initialVersion?: ScriptInfoVersion);
+            isScriptOpen(): boolean;
+            open(newText: string): void;
+            close(fileExists?: boolean): void;
+            getSnapshot(): IScriptSnapshot;
+            private ensureRealPath;
+            getFormatCodeSettings(): FormatCodeSettings | undefined;
+            getPreferences(): protocol.UserPreferences | undefined;
+            attachToProject(project: Project): boolean;
+            isAttached(project: Project): boolean;
+            detachFromProject(project: Project): void;
+            detachAllProjects(): void;
+            getDefaultProject(): Project;
+            registerFileUpdate(): void;
+            setOptions(formatSettings: FormatCodeSettings, preferences: protocol.UserPreferences | undefined): void;
+            getLatestVersion(): string;
+            saveTo(fileName: string): void;
+            reloadFromFile(tempFileName?: NormalizedPath): boolean;
+            editContent(start: number, end: number, newText: string): void;
+            markContainingProjectsAsDirty(): void;
+            isOrphan(): boolean;
+            /**
+             *  @param line 1 based index
+             */
+            lineToTextSpan(line: number): TextSpan;
+            /**
+             * @param line 1 based index
+             * @param offset 1 based index
+             */
+            lineOffsetToPosition(line: number, offset: number): number;
+            positionToLineOffset(position: number): protocol.Location;
+            isJavaScript(): boolean;
+        }
+        export interface InstallPackageOptionsWithProject extends InstallPackageOptions {
+            projectName: string;
+            projectRootPath: Path;
+        }
+        export interface ITypingsInstaller {
+            isKnownTypesPackageName(name: string): boolean;
+            installPackage(options: InstallPackageOptionsWithProject): Promise<ApplyCodeActionCommandResult>;
+            enqueueInstallTypingsRequest(p: Project, typeAcquisition: TypeAcquisition, unresolvedImports: SortedReadonlyArray<string> | undefined): void;
+            attach(projectService: ProjectService): void;
+            onProjectClosed(p: Project): void;
+            readonly globalTypingsCacheLocation: string | undefined;
+        }
+        export const nullTypingsInstaller: ITypingsInstaller;
+        export function allRootFilesAreJsOrDts(project: Project): boolean;
+        export function allFilesAreJsOrDts(project: Project): boolean;
+        export enum ProjectKind {
+            Inferred = 0,
+            Configured = 1,
+            External = 2,
+            AutoImportProvider = 3,
+            Auxiliary = 4
+        }
+        export interface PluginCreateInfo {
+            project: Project;
+            languageService: LanguageService;
+            languageServiceHost: LanguageServiceHost;
+            serverHost: ServerHost;
+            session?: Session<unknown>;
+            config: any;
+        }
+        export interface PluginModule {
+            create(createInfo: PluginCreateInfo): LanguageService;
+            getExternalFiles?(proj: Project): string[];
+            onConfigurationChanged?(config: any): void;
+        }
+        export interface PluginModuleWithName {
+            name: string;
+            module: PluginModule;
+        }
+        export type PluginModuleFactory = (mod: {
+            typescript: typeof ts;
+        }) => PluginModule;
+        export abstract class Project implements LanguageServiceHost, ModuleResolutionHost {
+            readonly projectKind: ProjectKind;
+            readonly projectService: ProjectService;
+            private documentRegistry;
+            private compilerOptions;
+            compileOnSaveEnabled: boolean;
+            protected watchOptions: WatchOptions | undefined;
+            private rootFiles;
+            private rootFilesMap;
+            private program;
+            private externalFiles;
+            private missingFilesMap;
+            private generatedFilesMap;
+            private plugins;
+            protected languageService: LanguageService;
+            languageServiceEnabled: boolean;
+            readonly trace?: (s: string) => void;
+            readonly realpath?: (path: string) => string;
+            private builderState;
+            /**
+             * Set of files names that were updated since the last call to getChangesSinceVersion.
+             */
+            private updatedFileNames;
+            /**
+             * Set of files that was returned from the last call to getChangesSinceVersion.
+             */
+            private lastReportedFileNames;
+            /**
+             * Last version that was reported.
+             */
+            private lastReportedVersion;
+            /**
+             * Current project's program version. (incremented everytime new program is created that is not complete reuse from the old one)
+             * This property is changed in 'updateGraph' based on the set of files in program
+             */
+            private projectProgramVersion;
+            /**
+             * Current version of the project state. It is changed when:
+             * - new root file was added/removed
+             * - edit happen in some file that is currently included in the project.
+             * This property is different from projectStructureVersion since in most cases edits don't affect set of files in the project
+             */
+            private projectStateVersion;
+            protected projectErrors: Diagnostic[] | undefined;
+            protected isInitialLoadPending: () => boolean;
+            private readonly cancellationToken;
+            isNonTsProject(): boolean;
+            isJsOnlyProject(): boolean;
+            static resolveModule(moduleName: string, initialDir: string, host: ServerHost, log: (message: string) => void, logErrors?: (message: string) => void): {} | undefined;
+            isKnownTypesPackageName(name: string): boolean;
+            installPackage(options: InstallPackageOptions): Promise<ApplyCodeActionCommandResult>;
+            private get typingsCache();
+            getCompilationSettings(): ts.CompilerOptions;
+            getCompilerOptions(): ts.CompilerOptions;
+            getNewLine(): string;
+            getProjectVersion(): string;
+            getProjectReferences(): readonly ProjectReference[] | undefined;
+            getScriptFileNames(): string[];
+            private getOrCreateScriptInfoAndAttachToProject;
+            getScriptKind(fileName: string): ts.ScriptKind;
+            getScriptVersion(filename: string): string;
+            getScriptSnapshot(filename: string): IScriptSnapshot | undefined;
+            getCancellationToken(): HostCancellationToken;
+            getCurrentDirectory(): string;
+            getDefaultLibFileName(): string;
+            useCaseSensitiveFileNames(): boolean;
+            readDirectory(path: string, extensions?: readonly string[], exclude?: readonly string[], include?: readonly string[], depth?: number): string[];
+            readFile(fileName: string): string | undefined;
+            writeFile(fileName: string, content: string): void;
+            fileExists(file: string): boolean;
+            resolveModuleNames(moduleNames: string[], containingFile: string, reusedNames?: string[], redirectedReference?: ResolvedProjectReference, _options?: CompilerOptions, containingSourceFile?: SourceFile): (ResolvedModuleFull | undefined)[];
+            getModuleResolutionCache(): ModuleResolutionCache | undefined;
+            getResolvedModuleWithFailedLookupLocationsFromCache(moduleName: string, containingFile: string, resolutionMode?: ModuleKind.CommonJS | ModuleKind.ESNext): ResolvedModuleWithFailedLookupLocations | undefined;
+            resolveTypeReferenceDirectives(typeDirectiveNames: string[] | FileReference[], containingFile: string, redirectedReference?: ResolvedProjectReference, _options?: CompilerOptions, containingFileMode?: SourceFile["impliedNodeFormat"] | undefined): (ResolvedTypeReferenceDirective | undefined)[];
+            directoryExists(path: string): boolean;
+            getDirectories(path: string): string[];
+            log(s: string): void;
+            error(s: string): void;
+            private setInternalCompilerOptionsForEmittingJsFiles;
+            /**
+             * Get the errors that dont have any file name associated
+             */
+            getGlobalProjectErrors(): readonly Diagnostic[];
+            /**
+             * Get all the project errors
+             */
+            getAllProjectErrors(): readonly Diagnostic[];
+            setProjectErrors(projectErrors: Diagnostic[] | undefined): void;
+            getLanguageService(ensureSynchronized?: boolean): LanguageService;
+            getCompileOnSaveAffectedFileList(scriptInfo: ScriptInfo): string[];
+            /**
+             * Returns true if emit was conducted
+             */
+            emitFile(scriptInfo: ScriptInfo, writeFile: (path: string, data: string, writeByteOrderMark?: boolean) => void): EmitResult;
+            enableLanguageService(): void;
+            disableLanguageService(lastFileExceededProgramSize?: string): void;
+            getProjectName(): string;
+            protected removeLocalTypingsFromTypeAcquisition(newTypeAcquisition: TypeAcquisition): TypeAcquisition;
+            getExternalFiles(): SortedReadonlyArray<string>;
+            getSourceFile(path: Path): ts.SourceFile | undefined;
+            close(): void;
+            private detachScriptInfoIfNotRoot;
+            isClosed(): boolean;
+            hasRoots(): boolean;
+            getRootFiles(): ts.server.NormalizedPath[];
+            getRootScriptInfos(): ts.server.ScriptInfo[];
+            getScriptInfos(): ScriptInfo[];
+            getExcludedFiles(): readonly NormalizedPath[];
+            getFileNames(excludeFilesFromExternalLibraries?: boolean, excludeConfigFiles?: boolean): ts.server.NormalizedPath[];
+            hasConfigFile(configFilePath: NormalizedPath): boolean;
+            containsScriptInfo(info: ScriptInfo): boolean;
+            containsFile(filename: NormalizedPath, requireOpen?: boolean): boolean;
+            isRoot(info: ScriptInfo): boolean;
+            addRoot(info: ScriptInfo, fileName?: NormalizedPath): void;
+            addMissingFileRoot(fileName: NormalizedPath): void;
+            removeFile(info: ScriptInfo, fileExists: boolean, detachFromProject: boolean): void;
+            registerFileUpdate(fileName: string): void;
+            markAsDirty(): void;
+            /**
+             * Updates set of files that contribute to this project
+             * @returns: true if set of files in the project stays the same and false - otherwise.
+             */
+            updateGraph(): boolean;
+            protected removeExistingTypings(include: string[]): string[];
+            private updateGraphWorker;
+            private detachScriptInfoFromProject;
+            private addMissingFileWatcher;
+            private isWatchedMissingFile;
+            private createGeneratedFileWatcher;
+            private isValidGeneratedFileWatcher;
+            private clearGeneratedFileWatch;
+            getScriptInfoForNormalizedPath(fileName: NormalizedPath): ScriptInfo | undefined;
+            getScriptInfo(uncheckedFileName: string): ts.server.ScriptInfo | undefined;
+            filesToString(writeProjectFileNames: boolean): string;
+            setCompilerOptions(compilerOptions: CompilerOptions): void;
+            setTypeAcquisition(newTypeAcquisition: TypeAcquisition | undefined): void;
+            getTypeAcquisition(): ts.TypeAcquisition;
+            protected removeRoot(info: ScriptInfo): void;
+            protected enableGlobalPlugins(options: CompilerOptions, pluginConfigOverrides: Map<any> | undefined): void;
+            protected enablePlugin(pluginConfigEntry: PluginImport, searchPaths: string[], pluginConfigOverrides: Map<any> | undefined): void;
+            private enableProxy;
+            /** Starts a new check for diagnostics. Call this if some file has updated that would cause diagnostics to be changed. */
+            refreshDiagnostics(): void;
+        }
+        /**
+         * If a file is opened and no tsconfig (or jsconfig) is found,
+         * the file and its imports/references are put into an InferredProject.
+         */
+        export class InferredProject extends Project {
+            private _isJsInferredProject;
+            toggleJsInferredProject(isJsInferredProject: boolean): void;
+            setCompilerOptions(options?: CompilerOptions): void;
+            /** this is canonical project root path */
+            readonly projectRootPath: string | undefined;
+            addRoot(info: ScriptInfo): void;
+            removeRoot(info: ScriptInfo): void;
+            isProjectWithSingleRoot(): boolean;
+            close(): void;
+            getTypeAcquisition(): TypeAcquisition;
+        }
+        export class AutoImportProviderProject extends Project {
+            private hostProject;
+            private rootFileNames;
+            isOrphan(): boolean;
+            updateGraph(): boolean;
+            hasRoots(): boolean;
+            markAsDirty(): void;
+            getScriptFileNames(): string[];
+            getLanguageService(): never;
+            getModuleResolutionHostForAutoImportProvider(): never;
+            getProjectReferences(): readonly ts.ProjectReference[] | undefined;
+            getTypeAcquisition(): TypeAcquisition;
+        }
+        /**
+         * If a file is opened, the server will look for a tsconfig (or jsconfig)
+         * and if successful create a ConfiguredProject for it.
+         * Otherwise it will create an InferredProject.
+         */
+        export class ConfiguredProject extends Project {
+            readonly canonicalConfigFilePath: NormalizedPath;
+            /** Ref count to the project when opened from external project */
+            private externalProjectRefCount;
+            private projectReferences;
+            /**
+             * If the project has reload from disk pending, it reloads (and then updates graph as part of that) instead of just updating the graph
+             * @returns: true if set of files in the project stays the same and false - otherwise.
+             */
+            updateGraph(): boolean;
+            getConfigFilePath(): ts.server.NormalizedPath;
+            getProjectReferences(): readonly ProjectReference[] | undefined;
+            updateReferences(refs: readonly ProjectReference[] | undefined): void;
+            /**
+             * Get the errors that dont have any file name associated
+             */
+            getGlobalProjectErrors(): readonly Diagnostic[];
+            /**
+             * Get all the project errors
+             */
+            getAllProjectErrors(): readonly Diagnostic[];
+            setProjectErrors(projectErrors: Diagnostic[]): void;
+            close(): void;
+            getEffectiveTypeRoots(): string[];
+        }
+        /**
+         * Project whose configuration is handled externally, such as in a '.csproj'.
+         * These are created only if a host explicitly calls `openExternalProject`.
+         */
+        export class ExternalProject extends Project {
+            externalProjectName: string;
+            compileOnSaveEnabled: boolean;
+            excludedFiles: readonly NormalizedPath[];
+            updateGraph(): boolean;
+            getExcludedFiles(): readonly ts.server.NormalizedPath[];
+        }
+        export function convertFormatOptions(protocolOptions: protocol.FormatCodeSettings): FormatCodeSettings;
+        export function convertCompilerOptions(protocolOptions: protocol.ExternalProjectCompilerOptions): CompilerOptions & protocol.CompileOnSaveMixin;
+        export function convertWatchOptions(protocolOptions: protocol.ExternalProjectCompilerOptions, currentDirectory?: string): WatchOptionsAndErrors | undefined;
+        export function convertTypeAcquisition(protocolOptions: protocol.InferredProjectCompilerOptions): TypeAcquisition | undefined;
+        export function tryConvertScriptKindName(scriptKindName: protocol.ScriptKindName | ScriptKind): ScriptKind;
+        export function convertScriptKindName(scriptKindName: protocol.ScriptKindName): ScriptKind.Unknown | ScriptKind.JS | ScriptKind.JSX | ScriptKind.TS | ScriptKind.TSX;
+        export const maxProgramSizeForNonTsFiles: number;
+        export const ProjectsUpdatedInBackgroundEvent = "projectsUpdatedInBackground";
+        export interface ProjectsUpdatedInBackgroundEvent {
+            eventName: typeof ProjectsUpdatedInBackgroundEvent;
+            data: {
+                openFiles: string[];
+            };
+        }
+        export const ProjectLoadingStartEvent = "projectLoadingStart";
+        export interface ProjectLoadingStartEvent {
+            eventName: typeof ProjectLoadingStartEvent;
+            data: {
+                project: Project;
+                reason: string;
+            };
+        }
+        export const ProjectLoadingFinishEvent = "projectLoadingFinish";
+        export interface ProjectLoadingFinishEvent {
+            eventName: typeof ProjectLoadingFinishEvent;
+            data: {
+                project: Project;
+            };
+        }
+        export const LargeFileReferencedEvent = "largeFileReferenced";
+        export interface LargeFileReferencedEvent {
+            eventName: typeof LargeFileReferencedEvent;
+            data: {
+                file: string;
+                fileSize: number;
+                maxFileSize: number;
+            };
+        }
+        export const ConfigFileDiagEvent = "configFileDiag";
+        export interface ConfigFileDiagEvent {
+            eventName: typeof ConfigFileDiagEvent;
+            data: {
+                triggerFile: string;
+                configFileName: string;
+                diagnostics: readonly Diagnostic[];
+            };
+        }
+        export const ProjectLanguageServiceStateEvent = "projectLanguageServiceState";
+        export interface ProjectLanguageServiceStateEvent {
+            eventName: typeof ProjectLanguageServiceStateEvent;
+            data: {
+                project: Project;
+                languageServiceEnabled: boolean;
+            };
+        }
+        export const ProjectInfoTelemetryEvent = "projectInfo";
+        /** This will be converted to the payload of a protocol.TelemetryEvent in session.defaultEventHandler. */
+        export interface ProjectInfoTelemetryEvent {
+            readonly eventName: typeof ProjectInfoTelemetryEvent;
+            readonly data: ProjectInfoTelemetryEventData;
+        }
+        export const OpenFileInfoTelemetryEvent = "openFileInfo";
+        /**
+         * Info that we may send about a file that was just opened.
+         * Info about a file will only be sent once per session, even if the file changes in ways that might affect the info.
+         * Currently this is only sent for '.js' files.
+         */
+        export interface OpenFileInfoTelemetryEvent {
+            readonly eventName: typeof OpenFileInfoTelemetryEvent;
+            readonly data: OpenFileInfoTelemetryEventData;
+        }
+        export interface ProjectInfoTelemetryEventData {
+            /** Cryptographically secure hash of project file location. */
+            readonly projectId: string;
+            /** Count of file extensions seen in the project. */
+            readonly fileStats: FileStats;
+            /**
+             * Any compiler options that might contain paths will be taken out.
+             * Enum compiler options will be converted to strings.
+             */
+            readonly compilerOptions: CompilerOptions;
+            readonly extends: boolean | undefined;
+            readonly files: boolean | undefined;
+            readonly include: boolean | undefined;
+            readonly exclude: boolean | undefined;
+            readonly compileOnSave: boolean;
+            readonly typeAcquisition: ProjectInfoTypeAcquisitionData;
+            readonly configFileName: "tsconfig.json" | "jsconfig.json" | "other";
+            readonly projectType: "external" | "configured";
+            readonly languageServiceEnabled: boolean;
+            /** TypeScript version used by the server. */
+            readonly version: string;
+        }
+        export interface OpenFileInfoTelemetryEventData {
+            readonly info: OpenFileInfo;
+        }
+        export interface ProjectInfoTypeAcquisitionData {
+            readonly enable: boolean | undefined;
+            readonly include: boolean;
+            readonly exclude: boolean;
+        }
+        export interface FileStats {
+            readonly js: number;
+            readonly jsSize?: number;
+            readonly jsx: number;
+            readonly jsxSize?: number;
+            readonly ts: number;
+            readonly tsSize?: number;
+            readonly tsx: number;
+            readonly tsxSize?: number;
+            readonly dts: number;
+            readonly dtsSize?: number;
+            readonly deferred: number;
+            readonly deferredSize?: number;
+        }
+        export interface OpenFileInfo {
+            readonly checkJs: boolean;
+        }
+        export type ProjectServiceEvent = LargeFileReferencedEvent | ProjectsUpdatedInBackgroundEvent | ProjectLoadingStartEvent | ProjectLoadingFinishEvent | ConfigFileDiagEvent | ProjectLanguageServiceStateEvent | ProjectInfoTelemetryEvent | OpenFileInfoTelemetryEvent;
+        export type ProjectServiceEventHandler = (event: ProjectServiceEvent) => void;
+        export interface SafeList {
+            [name: string]: {
+                match: RegExp;
+                exclude?: (string | number)[][];
+                types?: string[];
+            };
+        }
+        export interface TypesMapFile {
+            typesMap: SafeList;
+            simpleMap: {
+                [libName: string]: string;
+            };
+        }
+        export interface HostConfiguration {
+            formatCodeOptions: FormatCodeSettings;
+            preferences: protocol.UserPreferences;
+            hostInfo: string;
+            extraFileExtensions?: FileExtensionInfo[];
+            watchOptions?: WatchOptions;
+        }
+        export interface OpenConfiguredProjectResult {
+            configFileName?: NormalizedPath;
+            configFileErrors?: readonly Diagnostic[];
+        }
+        export interface ProjectServiceOptions {
+            host: ServerHost;
+            logger: Logger;
+            cancellationToken: HostCancellationToken;
+            useSingleInferredProject: boolean;
+            useInferredProjectPerProjectRoot: boolean;
+            typingsInstaller: ITypingsInstaller;
+            eventHandler?: ProjectServiceEventHandler;
+            suppressDiagnosticEvents?: boolean;
+            throttleWaitMilliseconds?: number;
+            globalPlugins?: readonly string[];
+            pluginProbeLocations?: readonly string[];
+            allowLocalPluginLoads?: boolean;
+            typesMapLocation?: string;
+            /** @deprecated use serverMode instead */
+            syntaxOnly?: boolean;
+            serverMode?: LanguageServiceMode;
+            session: Session<unknown> | undefined;
+        }
+        export interface WatchOptionsAndErrors {
+            watchOptions: WatchOptions;
+            errors: Diagnostic[] | undefined;
+        }
+        export class ProjectService {
+            private readonly nodeModulesWatchers;
+            /**
+             * Contains all the deleted script info's version information so that
+             * it does not reset when creating script info again
+             * (and could have potentially collided with version where contents mismatch)
+             */
+            private readonly filenameToScriptInfoVersion;
+            private readonly allJsFilesForOpenFileTelemetry;
+            /**
+             * maps external project file name to list of config files that were the part of this project
+             */
+            private readonly externalProjectToConfiguredProjectMap;
+            /**
+             * external projects (configuration and list of root files is not controlled by tsserver)
+             */
+            readonly externalProjects: ExternalProject[];
+            /**
+             * projects built from openFileRoots
+             */
+            readonly inferredProjects: InferredProject[];
+            /**
+             * projects specified by a tsconfig.json file
+             */
+            readonly configuredProjects: Map<ConfiguredProject>;
+            /**
+             * Open files: with value being project root path, and key being Path of the file that is open
+             */
+            readonly openFiles: Map<NormalizedPath | undefined>;
+            /**
+             * Map of open files that are opened without complete path but have projectRoot as current directory
+             */
+            private readonly openFilesWithNonRootedDiskPath;
+            private compilerOptionsForInferredProjects;
+            private compilerOptionsForInferredProjectsPerProjectRoot;
+            private watchOptionsForInferredProjects;
+            private watchOptionsForInferredProjectsPerProjectRoot;
+            private typeAcquisitionForInferredProjects;
+            private typeAcquisitionForInferredProjectsPerProjectRoot;
+            /**
+             * Project size for configured or external projects
+             */
+            private readonly projectToSizeMap;
+            private readonly hostConfiguration;
+            private safelist;
+            private readonly legacySafelist;
+            private pendingProjectUpdates;
+            readonly currentDirectory: NormalizedPath;
+            readonly toCanonicalFileName: (f: string) => string;
+            readonly host: ServerHost;
+            readonly logger: Logger;
+            readonly cancellationToken: HostCancellationToken;
+            readonly useSingleInferredProject: boolean;
+            readonly useInferredProjectPerProjectRoot: boolean;
+            readonly typingsInstaller: ITypingsInstaller;
+            private readonly globalCacheLocationDirectoryPath;
+            readonly throttleWaitMilliseconds?: number;
+            private readonly eventHandler?;
+            private readonly suppressDiagnosticEvents?;
+            readonly globalPlugins: readonly string[];
+            readonly pluginProbeLocations: readonly string[];
+            readonly allowLocalPluginLoads: boolean;
+            private currentPluginConfigOverrides;
+            readonly typesMapLocation: string | undefined;
+            /** @deprecated use serverMode instead */
+            readonly syntaxOnly: boolean;
+            readonly serverMode: LanguageServiceMode;
+            /** Tracks projects that we have already sent telemetry for. */
+            private readonly seenProjects;
+            private performanceEventHandler?;
+            private pendingPluginEnablements?;
+            private currentPluginEnablementPromise?;
+            constructor(opts: ProjectServiceOptions);
+            toPath(fileName: string): Path;
+            private loadTypesMap;
+            updateTypingsForProject(response: SetTypings | InvalidateCachedTypings | PackageInstalledResponse): void;
+            private delayUpdateProjectGraph;
+            private delayUpdateProjectGraphs;
+            setCompilerOptionsForInferredProjects(projectCompilerOptions: protocol.InferredProjectCompilerOptions, projectRootPath?: string): void;
+            findProject(projectName: string): Project | undefined;
+            getDefaultProjectForFile(fileName: NormalizedPath, ensureProject: boolean): Project | undefined;
+            private doEnsureDefaultProjectForFile;
+            getScriptInfoEnsuringProjectsUptoDate(uncheckedFileName: string): ScriptInfo | undefined;
+            /**
+             * Ensures the project structures are upto date
+             * This means,
+             * - we go through all the projects and update them if they are dirty
+             * - if updates reflect some change in structure or there was pending request to ensure projects for open files
+             *   ensure that each open script info has project
+             */
+            private ensureProjectStructuresUptoDate;
+            getFormatCodeOptions(file: NormalizedPath): FormatCodeSettings;
+            getPreferences(file: NormalizedPath): protocol.UserPreferences;
+            getHostFormatCodeOptions(): FormatCodeSettings;
+            getHostPreferences(): protocol.UserPreferences;
+            private onSourceFileChanged;
+            private handleSourceMapProjects;
+            private delayUpdateSourceInfoProjects;
+            private delayUpdateProjectsOfScriptInfoPath;
+            private handleDeletedFile;
+            private removeProject;
+            private assignOrphanScriptInfosToInferredProject;
+            /**
+             * Remove this file from the set of open, non-configured files.
+             * @param info The file that has been closed or newly configured
+             */
+            private closeOpenFile;
+            private deleteScriptInfo;
+            private configFileExists;
+            /**
+             * Returns true if the configFileExistenceInfo is needed/impacted by open files that are root of inferred project
+             */
+            private configFileExistenceImpactsRootOfInferredProject;
+            /**
+             * This is called on file close, so that we stop watching the config file for this script info
+             */
+            private stopWatchingConfigFilesForClosedScriptInfo;
+            /**
+             * This function tries to search for a tsconfig.json for the given file.
+             * This is different from the method the compiler uses because
+             * the compiler can assume it will always start searching in the
+             * current directory (the directory in which tsc was invoked).
+             * The server must start searching from the directory containing
+             * the newly opened file.
+             */
+            private forEachConfigFileLocation;
+            /**
+             * This function tries to search for a tsconfig.json for the given file.
+             * This is different from the method the compiler uses because
+             * the compiler can assume it will always start searching in the
+             * current directory (the directory in which tsc was invoked).
+             * The server must start searching from the directory containing
+             * the newly opened file.
+             * If script info is passed in, it is asserted to be open script info
+             * otherwise just file name
+             */
+            private getConfigFileNameForFile;
+            private printProjects;
+            private getConfiguredProjectByCanonicalConfigFilePath;
+            private findExternalProjectByProjectName;
+            /** Get a filename if the language service exceeds the maximum allowed program size; otherwise returns undefined. */
+            private getFilenameForExceededTotalSizeLimitForNonTsFiles;
+            private createExternalProject;
+            private addFilesToNonInferredProject;
+            private updateNonInferredProjectFiles;
+            private updateRootAndOptionsOfNonInferredProject;
+            private sendConfigFileDiagEvent;
+            private getOrCreateInferredProjectForProjectRootPathIfEnabled;
+            private getOrCreateSingleInferredProjectIfEnabled;
+            private getOrCreateSingleInferredWithoutProjectRoot;
+            private createInferredProject;
+            getScriptInfo(uncheckedFileName: string): ScriptInfo | undefined;
+            private watchClosedScriptInfo;
+            private createNodeModulesWatcher;
+            private watchClosedScriptInfoInNodeModules;
+            private getModifiedTime;
+            private refreshScriptInfo;
+            private refreshScriptInfosInDirectory;
+            private stopWatchingScriptInfo;
+            private getOrCreateScriptInfoNotOpenedByClientForNormalizedPath;
+            private getOrCreateScriptInfoOpenedByClientForNormalizedPath;
+            getOrCreateScriptInfoForNormalizedPath(fileName: NormalizedPath, openedByClient: boolean, fileContent?: string, scriptKind?: ScriptKind, hasMixedContent?: boolean, hostToQueryFileExistsOn?: {
+                fileExists(path: string): boolean;
+            }): ScriptInfo | undefined;
+            private getOrCreateScriptInfoWorker;
+            /**
+             * This gets the script info for the normalized path. If the path is not rooted disk path then the open script info with project root context is preferred
+             */
+            getScriptInfoForNormalizedPath(fileName: NormalizedPath): ScriptInfo | undefined;
+            getScriptInfoForPath(fileName: Path): ScriptInfo | undefined;
+            private addSourceInfoToSourceMap;
+            private addMissingSourceMapFile;
+            setHostConfiguration(args: protocol.ConfigureRequestArguments): void;
+            closeLog(): void;
+            /**
+             * This function rebuilds the project for every file opened by the client
+             * This does not reload contents of open files from disk. But we could do that if needed
+             */
+            reloadProjects(): void;
+            /**
+             * This function goes through all the openFiles and tries to file the config file for them.
+             * If the config file is found and it refers to existing project, it reloads it either immediately
+             * or schedules it for reload depending on delayReload option
+             * If there is no existing project it just opens the configured project for the config file
+             * reloadForInfo provides a way to filter out files to reload configured project for
+             */
+            private reloadConfiguredProjectForFiles;
+            /**
+             * Remove the root of inferred project if script info is part of another project
+             */
+            private removeRootOfInferredProjectIfNowPartOfOtherProject;
+            /**
+             * This function is to update the project structure for every inferred project.
+             * It is called on the premise that all the configured projects are
+             * up to date.
+             * This will go through open files and assign them to inferred project if open file is not part of any other project
+             * After that all the inferred project graphs are updated
+             */
+            private ensureProjectForOpenFiles;
+            /**
+             * Open file whose contents is managed by the client
+             * @param filename is absolute pathname
+             * @param fileContent is a known version of the file content that is more up to date than the one on disk
+             */
+            openClientFile(fileName: string, fileContent?: string, scriptKind?: ScriptKind, projectRootPath?: string): OpenConfiguredProjectResult;
+            private findExternalProjectContainingOpenScriptInfo;
+            private getOrCreateOpenScriptInfo;
+            private assignProjectToOpenedScriptInfo;
+            private createAncestorProjects;
+            private ensureProjectChildren;
+            private cleanupAfterOpeningFile;
+            openClientFileWithNormalizedPath(fileName: NormalizedPath, fileContent?: string, scriptKind?: ScriptKind, hasMixedContent?: boolean, projectRootPath?: NormalizedPath): OpenConfiguredProjectResult;
+            private removeOrphanConfiguredProjects;
+            private removeOrphanScriptInfos;
+            private telemetryOnOpenFile;
+            /**
+             * Close file whose contents is managed by the client
+             * @param filename is absolute pathname
+             */
+            closeClientFile(uncheckedFileName: string): void;
+            private collectChanges;
+            private closeConfiguredProjectReferencedFromExternalProject;
+            closeExternalProject(uncheckedFileName: string): void;
+            openExternalProjects(projects: protocol.ExternalProject[]): void;
+            /** Makes a filename safe to insert in a RegExp */
+            private static readonly filenameEscapeRegexp;
+            private static escapeFilenameForRegex;
+            resetSafeList(): void;
+            applySafeList(proj: protocol.ExternalProject): NormalizedPath[];
+            openExternalProject(proj: protocol.ExternalProject): void;
+            hasDeferredExtension(): boolean;
+            private enableRequestedPluginsAsync;
+            private enableRequestedPluginsWorker;
+            private enableRequestedPluginsForProjectAsync;
+            configurePlugin(args: protocol.ConfigurePluginRequestArguments): void;
+        }
+        export function formatMessage<T extends protocol.Message>(msg: T, logger: Logger, byteLength: (s: string, encoding: string) => number, newLine: string): string;
+        export interface ServerCancellationToken extends HostCancellationToken {
+            setRequest(requestId: number): void;
+            resetRequest(requestId: number): void;
+        }
+        export const nullCancellationToken: ServerCancellationToken;
+        export interface PendingErrorCheck {
+            fileName: NormalizedPath;
+            project: Project;
+        }
+        export type CommandNames = protocol.CommandTypes;
+        export const CommandNames: any;
+        export type Event = <T extends object>(body: T, eventName: string) => void;
+        export interface EventSender {
+            event: Event;
+        }
+        export interface SessionOptions {
+            host: ServerHost;
+            cancellationToken: ServerCancellationToken;
+            useSingleInferredProject: boolean;
+            useInferredProjectPerProjectRoot: boolean;
+            typingsInstaller: ITypingsInstaller;
+            byteLength: (buf: string, encoding?: string) => number;
+            hrtime: (start?: number[]) => number[];
+            logger: Logger;
+            /**
+             * If falsy, all events are suppressed.
+             */
+            canUseEvents: boolean;
+            eventHandler?: ProjectServiceEventHandler;
+            /** Has no effect if eventHandler is also specified. */
+            suppressDiagnosticEvents?: boolean;
+            /** @deprecated use serverMode instead */
+            syntaxOnly?: boolean;
+            serverMode?: LanguageServiceMode;
+            throttleWaitMilliseconds?: number;
+            noGetErrOnBackgroundUpdate?: boolean;
+            globalPlugins?: readonly string[];
+            pluginProbeLocations?: readonly string[];
+            allowLocalPluginLoads?: boolean;
+            typesMapLocation?: string;
+        }
+        export class Session<TMessage = string> implements EventSender {
+            private readonly gcTimer;
+            protected projectService: ProjectService;
+            private changeSeq;
+            private performanceData;
+            private currentRequestId;
+            private errorCheck;
+            protected host: ServerHost;
+            private readonly cancellationToken;
+            protected readonly typingsInstaller: ITypingsInstaller;
+            protected byteLength: (buf: string, encoding?: string) => number;
+            private hrtime;
+            protected logger: Logger;
+            protected canUseEvents: boolean;
+            private suppressDiagnosticEvents?;
+            private eventHandler;
+            private readonly noGetErrOnBackgroundUpdate?;
+            constructor(opts: SessionOptions);
+            private sendRequestCompletedEvent;
+            private addPerformanceData;
+            private performanceEventHandler;
+            private defaultEventHandler;
+            private projectsUpdatedInBackgroundEvent;
+            logError(err: Error, cmd: string): void;
+            private logErrorWorker;
+            send(msg: protocol.Message): void;
+            protected writeMessage(msg: protocol.Message): void;
+            event<T extends object>(body: T, eventName: string): void;
+            /** @deprecated */
+            output(info: any, cmdName: string, reqSeq?: number, errorMsg?: string): void;
+            private doOutput;
+            private semanticCheck;
+            private syntacticCheck;
+            private suggestionCheck;
+            private sendDiagnosticsEvent;
+            /** It is the caller's responsibility to verify that `!this.suppressDiagnosticEvents`. */
+            private updateErrorCheck;
+            private cleanProjects;
+            private cleanup;
+            private getEncodedSyntacticClassifications;
+            private getEncodedSemanticClassifications;
+            private getProject;
+            private getConfigFileAndProject;
+            private getConfigFileDiagnostics;
+            private convertToDiagnosticsWithLinePositionFromDiagnosticFile;
+            private getCompilerOptionsDiagnostics;
+            private convertToDiagnosticsWithLinePosition;
+            private getDiagnosticsWorker;
+            private getDefinition;
+            private mapDefinitionInfoLocations;
+            private getDefinitionAndBoundSpan;
+            private findSourceDefinition;
+            private getEmitOutput;
+            private mapJSDocTagInfo;
+            private mapDisplayParts;
+            private mapSignatureHelpItems;
+            private mapDefinitionInfo;
+            private static mapToOriginalLocation;
+            private toFileSpan;
+            private toFileSpanWithContext;
+            private getTypeDefinition;
+            private mapImplementationLocations;
+            private getImplementation;
+            private getOccurrences;
+            private getSyntacticDiagnosticsSync;
+            private getSemanticDiagnosticsSync;
+            private getSuggestionDiagnosticsSync;
+            private getJsxClosingTag;
+            private getDocumentHighlights;
+            private provideInlayHints;
+            private setCompilerOptionsForInferredProjects;
+            private getProjectInfo;
+            private getProjectInfoWorker;
+            private getRenameInfo;
+            private getProjects;
+            private getDefaultProject;
+            private getRenameLocations;
+            private mapRenameInfo;
+            private toSpanGroups;
+            private getReferences;
+            private getFileReferences;
+            /**
+             * @param fileName is the name of the file to be opened
+             * @param fileContent is a version of the file content that is known to be more up to date than the one on disk
+             */
+            private openClientFile;
+            private getPosition;
+            private getPositionInFile;
+            private getFileAndProject;
+            private getFileAndLanguageServiceForSyntacticOperation;
+            private getFileAndProjectWorker;
+            private getOutliningSpans;
+            private getTodoComments;
+            private getDocCommentTemplate;
+            private getSpanOfEnclosingComment;
+            private getIndentation;
+            private getBreakpointStatement;
+            private getNameOrDottedNameSpan;
+            private isValidBraceCompletion;
+            private getQuickInfoWorker;
+            private getFormattingEditsForRange;
+            private getFormattingEditsForRangeFull;
+            private getFormattingEditsForDocumentFull;
+            private getFormattingEditsAfterKeystrokeFull;
+            private getFormattingEditsAfterKeystroke;
+            private getCompletions;
+            private getCompletionEntryDetails;
+            private getCompileOnSaveAffectedFileList;
+            private emitFile;
+            private getSignatureHelpItems;
+            private toPendingErrorCheck;
+            private getDiagnostics;
+            private change;
+            private reload;
+            private saveToTmp;
+            private closeClientFile;
+            private mapLocationNavigationBarItems;
+            private getNavigationBarItems;
+            private toLocationNavigationTree;
+            private getNavigationTree;
+            private getNavigateToItems;
+            private getFullNavigateToItems;
+            private getSupportedCodeFixes;
+            private isLocation;
+            private extractPositionOrRange;
+            private getRange;
+            private getApplicableRefactors;
+            private getEditsForRefactor;
+            private organizeImports;
+            private getEditsForFileRename;
+            private getCodeFixes;
+            private getCombinedCodeFix;
+            private applyCodeActionCommand;
+            private getStartAndEndPosition;
+            private mapCodeAction;
+            private mapCodeFixAction;
+            private mapTextChangesToCodeEdits;
+            private mapTextChangeToCodeEdit;
+            private convertTextChangeToCodeEdit;
+            private getBraceMatching;
+            private getDiagnosticsForProject;
+            private configurePlugin;
+            private getSmartSelectionRange;
+            private toggleLineComment;
+            private toggleMultilineComment;
+            private commentSelection;
+            private uncommentSelection;
+            private mapSelectionRange;
+            private getScriptInfoFromProjectService;
+            private toProtocolCallHierarchyItem;
+            private toProtocolCallHierarchyIncomingCall;
+            private toProtocolCallHierarchyOutgoingCall;
+            private prepareCallHierarchy;
+            private provideCallHierarchyIncomingCalls;
+            private provideCallHierarchyOutgoingCalls;
+            getCanonicalFileName(fileName: string): string;
+            exit(): void;
+            private notRequired;
+            private requiredResponse;
+            private handlers;
+            addProtocolHandler(command: string, handler: (request: protocol.Request) => HandlerResponse): void;
+            private setCurrentRequest;
+            private resetCurrentRequest;
+            executeWithRequestId<T>(requestId: number, f: () => T): T;
+            executeCommand(request: protocol.Request): HandlerResponse;
+            onMessage(message: TMessage): void;
+            protected parseMessage(message: TMessage): protocol.Request;
+            protected toStringMessage(message: TMessage): string;
+            private getFormatOptions;
+            private getPreferences;
+            private getHostFormatOptions;
+            private getHostPreferences;
+        }
+        export interface HandlerResponse {
+            response?: {};
+            responseRequired?: boolean;
+        }
+    }
+    export const versionMajorMinor = "4.9";
     /** The version of the TypeScript compiler release */
-    const version: string;
+    export const version: string;
     /**
      * Type of objects whose values are all of the same type.
      * The `in` and `for-in` operators can *not* be safely used,
      * since `Object.prototype` may be modified by outside code.
      */
-    interface MapLike<T> {
+    export interface MapLike<T> {
         [index: string]: T;
     }
-    interface SortedReadonlyArray<T> extends ReadonlyArray<T> {
+    export interface SortedReadonlyArray<T> extends ReadonlyArray<T> {
         " __sortedArrayBrand": any;
     }
-    interface SortedArray<T> extends Array<T> {
+    export interface SortedArray<T> extends Array<T> {
         " __sortedArrayBrand": any;
     }
     /** Common read methods for ES6 Map/Set. */
-    interface ReadonlyCollection<K> {
+    export interface ReadonlyCollection<K> {
         readonly size: number;
         has(key: K): boolean;
         keys(): Iterator<K>;
     }
     /** Common write methods for ES6 Map/Set. */
-    interface Collection<K> extends ReadonlyCollection<K> {
+    export interface Collection<K> extends ReadonlyCollection<K> {
         delete(key: K): boolean;
         clear(): void;
     }
     /** ES6 Map interface, only read methods included. */
-    interface ReadonlyESMap<K, V> extends ReadonlyCollection<K> {
+    export interface ReadonlyESMap<K, V> extends ReadonlyCollection<K> {
         get(key: K): V | undefined;
         values(): Iterator<V>;
-        entries(): Iterator<[K, V]>;
+        entries(): Iterator<[
+            K,
+            V
+        ]>;
         forEach(action: (value: V, key: K) => void): void;
     }
     /**
      * ES6 Map interface, only read methods included.
      */
+    export interface ReadonlyMap<T> extends ReadonlyESMap<string, T> {
+    }
+    /**
+     * @deprecated Use `ts.ReadonlyESMap<K, V>` instead.
+     */
     interface ReadonlyMap<T> extends ReadonlyESMap<string, T> {
     }
     /** ES6 Map interface. */
-    interface ESMap<K, V> extends ReadonlyESMap<K, V>, Collection<K> {
+    export interface ESMap<K, V> extends ReadonlyESMap<K, V>, Collection<K> {
         set(key: K, value: V): this;
     }
     /**
      * ES6 Map interface.
      */
+    export interface Map<T> extends ESMap<string, T> {
+    }
+    /**
+     * @deprecated Use `ts.ESMap<K, V>` instead.
+     */
     interface Map<T> extends ESMap<string, T> {
     }
     /** ES6 Set interface, only read methods included. */
-    interface ReadonlySet<T> extends ReadonlyCollection<T> {
+    export interface ReadonlySet<T> extends ReadonlyCollection<T> {
         has(value: T): boolean;
         values(): Iterator<T>;
-        entries(): Iterator<[T, T]>;
+        entries(): Iterator<[
+            T,
+            T
+        ]>;
         forEach(action: (value: T, key: T) => void): void;
     }
     /** ES6 Set interface. */
-    interface Set<T> extends ReadonlySet<T>, Collection<T> {
+    export interface Set<T> extends ReadonlySet<T>, Collection<T> {
         add(value: T): this;
         delete(value: T): boolean;
     }
     /** ES6 Iterator type. */
-    interface Iterator<T> {
+    export interface Iterator<T> {
         next(): {
             value: T;
             done?: false;
@@ -86,11 +4026,9 @@ declare namespace ts {
         };
     }
     /** Array that is only intended to be pushed to, never read. */
-    interface Push<T> {
+    export interface Push<T> {
         push(...values: T[]): void;
     }
-}
-declare namespace ts {
     export type Path = string & {
         __pathBrand: any;
     };
@@ -496,7 +4434,7 @@ declare namespace ts {
         FirstJSDocNode = 312,
         LastJSDocNode = 350,
         FirstJSDocTagNode = 330,
-        LastJSDocTagNode = 350,
+        LastJSDocTagNode = 350
     }
     export type TriviaSyntaxKind = SyntaxKind.SingleLineCommentTrivia | SyntaxKind.MultiLineCommentTrivia | SyntaxKind.NewLineTrivia | SyntaxKind.WhitespaceTrivia | SyntaxKind.ShebangTrivia | SyntaxKind.ConflictMarkerTrivia;
     export type LiteralSyntaxKind = SyntaxKind.NumericLiteral | SyntaxKind.BigIntLiteral | SyntaxKind.StringLiteral | SyntaxKind.JsxText | SyntaxKind.JsxTextAllWhiteSpaces | SyntaxKind.RegularExpressionLiteral | SyntaxKind.NoSubstitutionTemplateLiteral;
@@ -537,7 +4475,7 @@ declare namespace ts {
         ReachabilityCheckFlags = 768,
         ReachabilityAndEmitFlags = 2816,
         ContextFlags = 50720768,
-        TypeExcludesFlags = 40960,
+        TypeExcludesFlags = 40960
     }
     export enum ModifierFlags {
         None = 0,
@@ -581,6 +4519,47 @@ declare namespace ts {
         readonly flags: NodeFlags;
         readonly parent: Node;
     }
+    interface Node {
+        getSourceFile(): SourceFile;
+        getChildCount(sourceFile?: SourceFile): number;
+        getChildAt(index: number, sourceFile?: SourceFile): Node;
+        getChildren(sourceFile?: SourceFile): Node[];
+        getStart(sourceFile?: SourceFile, includeJsDocComment?: boolean): number;
+        getFullStart(): number;
+        getEnd(): number;
+        getWidth(sourceFile?: SourceFileLike): number;
+        getFullWidth(): number;
+        getLeadingTriviaWidth(sourceFile?: SourceFile): number;
+        getFullText(sourceFile?: SourceFile): string;
+        getText(sourceFile?: SourceFile): string;
+        getFirstToken(sourceFile?: SourceFile): Node | undefined;
+        getLastToken(sourceFile?: SourceFile): Node | undefined;
+        forEachChild<T>(cbNode: (node: Node) => T | undefined, cbNodeArray?: (nodes: NodeArray<Node>) => T | undefined): T | undefined;
+    }
+    interface Node {
+        /**
+         * @deprecated `decorators` has been removed from `Node` and merged with `modifiers` on the `Node` subtypes that support them.
+         * Use `ts.canHaveDecorators()` to test whether a `Node` can have decorators.
+         * Use `ts.getDecorators()` to get the decorators of a `Node`.
+         *
+         * For example:
+         * ```ts
+         * const decorators = ts.canHaveDecorators(node) ? ts.getDecorators(node) : undefined;
+         * ```
+         */
+        readonly decorators?: undefined;
+        /**
+         * @deprecated `modifiers` has been removed from `Node` and moved to the `Node` subtypes that support them.
+         * Use `ts.canHaveModifiers()` to test whether a `Node` can have modifiers.
+         * Use `ts.getModifiers()` to get the modifiers of a `Node`.
+         *
+         * For example:
+         * ```ts
+         * const modifiers = ts.canHaveModifiers(node) ? ts.getModifiers(node) : undefined;
+         * ```
+         */
+        readonly modifiers?: NodeArray<ModifierLike> | undefined;
+    }
     export interface JSDocContainer {
     }
     export type HasJSDoc = ParameterDeclaration | CallSignatureDeclaration | ClassStaticBlockDeclaration | ConstructSignatureDeclaration | MethodSignature | PropertySignature | ArrowFunction | ParenthesizedExpression | SpreadAssignment | ShorthandPropertyAssignment | PropertyAssignment | FunctionExpression | EmptyStatement | DebuggerStatement | Block | VariableStatement | ExpressionStatement | IfStatement | DoStatement | WhileStatement | ForStatement | ForInStatement | ForOfStatement | BreakStatement | ContinueStatement | ReturnStatement | WithStatement | SwitchStatement | LabeledStatement | ThrowStatement | TryStatement | FunctionDeclaration | ConstructorDeclaration | MethodDeclaration | VariableDeclaration | PropertyDeclaration | AccessorDeclaration | ClassLikeDeclaration | InterfaceDeclaration | TypeAliasDeclaration | EnumMember | EnumDeclaration | ModuleDeclaration | ImportEqualsDeclaration | ImportDeclaration | NamespaceExportDeclaration | ExportAssignment | IndexSignatureDeclaration | FunctionTypeNode | ConstructorTypeNode | JSDocFunctionType | ExportDeclaration | NamedTupleMember | ExportSpecifier | CaseClause | EndOfFileToken;
@@ -661,6 +4640,9 @@ declare namespace ts {
         readonly originalKeywordKind?: SyntaxKind;
         isInJSDocNamespace?: boolean;
     }
+    interface Identifier {
+        readonly text: string;
+    }
     export interface TransientIdentifier extends Identifier {
         resolvedSymbol: Symbol;
     }
@@ -691,6 +4673,9 @@ declare namespace ts {
         readonly kind: SyntaxKind.PrivateIdentifier;
         readonly escapedText: __String;
     }
+    interface PrivateIdentifier {
+        readonly text: string;
+    }
     export interface Decorator extends Node {
         readonly kind: SyntaxKind.Decorator;
         readonly parent: NamedDeclaration;
@@ -759,6 +4744,10 @@ declare namespace ts {
         readonly questionToken?: QuestionToken;
         readonly type?: TypeNode;
     }
+    interface PropertySignature {
+        /** @deprecated A property signature cannot have an initializer */
+        readonly initializer?: Expression | undefined;
+    }
     export interface PropertyDeclaration extends ClassElement, JSDocContainer {
         readonly kind: SyntaxKind.PropertyDeclaration;
         readonly parent: ClassLikeDeclaration;
@@ -784,6 +4773,12 @@ declare namespace ts {
         readonly name: PropertyName;
         readonly initializer: Expression;
     }
+    interface PropertyAssignment {
+        /** @deprecated A property assignment cannot have a question token */
+        readonly questionToken?: QuestionToken | undefined;
+        /** @deprecated A property assignment cannot have an exclamation token */
+        readonly exclamationToken?: ExclamationToken | undefined;
+    }
     export interface ShorthandPropertyAssignment extends ObjectLiteralElement, JSDocContainer {
         readonly kind: SyntaxKind.ShorthandPropertyAssignment;
         readonly parent: ObjectLiteralExpression;
@@ -791,6 +4786,14 @@ declare namespace ts {
         readonly equalsToken?: EqualsToken;
         readonly objectAssignmentInitializer?: Expression;
     }
+    interface ShorthandPropertyAssignment {
+        /** @deprecated A shorthand property assignment cannot have modifiers */
+        readonly modifiers?: NodeArray<Modifier> | undefined;
+        /** @deprecated A shorthand property assignment cannot have a question token */
+        readonly questionToken?: QuestionToken | undefined;
+        /** @deprecated A shorthand property assignment cannot have an exclamation token */
+        readonly exclamationToken?: ExclamationToken | undefined;
+    }
     export interface SpreadAssignment extends ObjectLiteralElement, JSDocContainer {
         readonly kind: SyntaxKind.SpreadAssignment;
         readonly parent: ObjectLiteralExpression;
@@ -916,6 +4919,10 @@ declare namespace ts {
     export interface FunctionTypeNode extends FunctionOrConstructorTypeNodeBase {
         readonly kind: SyntaxKind.FunctionType;
     }
+    interface FunctionTypeNode {
+        /** @deprecated A function type cannot have modifiers */
+        readonly modifiers?: NodeArray<Modifier> | undefined;
+    }
     export interface ConstructorTypeNode extends FunctionOrConstructorTypeNodeBase {
         readonly kind: SyntaxKind.ConstructorType;
         readonly modifiers?: NodeArray<Modifier>;
@@ -1209,7 +5216,7 @@ declare namespace ts {
         Octal = 32,
         HexSpecifier = 64,
         BinarySpecifier = 128,
-        OctalSpecifier = 256,
+        OctalSpecifier = 256
     }
     export interface NumericLiteral extends LiteralExpression, Declaration {
         readonly kind: SyntaxKind.NumericLiteral;
@@ -2076,6 +6083,9 @@ declare namespace ts {
     export interface SourceFileLike {
         readonly text: string;
     }
+    interface SourceFileLike {
+        getLineAndCharacterOfPosition(pos: number): LineAndCharacter;
+    }
     export interface SourceFile extends Declaration {
         readonly kind: SyntaxKind.SourceFile;
         readonly statements: NodeArray<Statement>;
@@ -2118,6 +6128,13 @@ declare namespace ts {
          */
         impliedNodeFormat?: ModuleKind.ESNext | ModuleKind.CommonJS;
     }
+    interface SourceFile {
+        getLineAndCharacterOfPosition(pos: number): LineAndCharacter;
+        getLineEndOfPosition(pos: number): number;
+        getLineStarts(): readonly number[];
+        getPositionOfLineAndCharacter(line: number, character: number): number;
+        update(newText: string, textChangeRange: TextChangeRange): SourceFile;
+    }
     export interface Bundle extends Node {
         readonly kind: SyntaxKind.Bundle;
         readonly prepends: readonly (InputFiles | UnparsedSource)[];
@@ -2487,7 +6504,7 @@ declare namespace ts {
         WriteTypeParametersOrArguments = 1,
         UseOnlyExternalAliasing = 2,
         AllowAnyNodeKind = 4,
-        UseAliasDefinedOutsideCurrentScope = 8,
+        UseAliasDefinedOutsideCurrentScope = 8
     }
     export enum TypePredicateKind {
         This = 0,
@@ -2584,7 +6601,7 @@ declare namespace ts {
         ExportHasLocal = 944,
         BlockScoped = 418,
         PropertyOrAccessor = 98308,
-        ClassMember = 106500,
+        ClassMember = 106500
     }
     export interface Symbol {
         flags: SymbolFlags;
@@ -2595,6 +6612,15 @@ declare namespace ts {
         exports?: SymbolTable;
         globalExports?: SymbolTable;
     }
+    interface Symbol {
+        readonly name: string;
+        getFlags(): SymbolFlags;
+        getEscapedName(): __String;
+        getName(): string;
+        getDeclarations(): Declaration[] | undefined;
+        getDocumentationComment(typeChecker: TypeChecker | undefined): SymbolDisplayPart[];
+        getJsDocTags(checker?: TypeChecker): JSDocTagInfo[];
+    }
     export enum InternalSymbolName {
         Call = "__call",
         Constructor = "__constructor",
@@ -2683,7 +6709,7 @@ declare namespace ts {
         InstantiablePrimitive = 406847488,
         Instantiable = 465829888,
         StructuredOrInstantiable = 469499904,
-        Narrowable = 536624127,
+        Narrowable = 536624127
     }
     export type DestructuringPattern = BindingPattern | ObjectLiteralExpression | ArrayLiteralExpression;
     export interface Type {
@@ -2693,6 +6719,31 @@ declare namespace ts {
         aliasSymbol?: Symbol;
         aliasTypeArguments?: readonly Type[];
     }
+    interface Type {
+        getFlags(): TypeFlags;
+        getSymbol(): Symbol | undefined;
+        getProperties(): Symbol[];
+        getProperty(propertyName: string): Symbol | undefined;
+        getApparentProperties(): Symbol[];
+        getCallSignatures(): readonly Signature[];
+        getConstructSignatures(): readonly Signature[];
+        getStringIndexType(): Type | undefined;
+        getNumberIndexType(): Type | undefined;
+        getBaseTypes(): BaseType[] | undefined;
+        getNonNullableType(): Type;
+        getConstraint(): Type | undefined;
+        getDefault(): Type | undefined;
+        isUnion(): this is UnionType;
+        isIntersection(): this is IntersectionType;
+        isUnionOrIntersection(): this is UnionOrIntersectionType;
+        isLiteral(): this is LiteralType;
+        isStringLiteral(): this is StringLiteralType;
+        isNumberLiteral(): this is NumberLiteralType;
+        isTypeParameter(): this is TypeParameter;
+        isClassOrInterface(): this is InterfaceType;
+        isClass(): this is InterfaceType;
+        isIndexType(): this is IndexType;
+    }
     export interface LiteralType extends Type {
         value: string | number | PseudoBigInt;
         freshType: LiteralType;
@@ -2732,7 +6783,7 @@ declare namespace ts {
         ClassOrInterface = 3,
         ContainsSpread = 2097152,
         ObjectRestType = 4194304,
-        InstantiationExpressionType = 8388608,
+        InstantiationExpressionType = 8388608
     }
     export interface ObjectType extends Type {
         objectFlags: ObjectFlags;
@@ -2765,6 +6816,9 @@ declare namespace ts {
         target: GenericType;
         node?: TypeReferenceNode | ArrayTypeNode | TupleTypeNode;
     }
+    interface TypeReference {
+        typeArguments?: readonly Type[];
+    }
     export interface DeferredTypeReference extends TypeReference {
     }
     export interface GenericType extends InterfaceType, TypeReference {
@@ -2858,6 +6912,15 @@ declare namespace ts {
         typeParameters?: readonly TypeParameter[];
         parameters: readonly Symbol[];
     }
+    interface Signature {
+        getDeclaration(): SignatureDeclaration;
+        getTypeParameters(): TypeParameter[] | undefined;
+        getParameters(): Symbol[];
+        getTypeParameterAtPosition(pos: number): Type;
+        getReturnType(): Type;
+        getDocumentationComment(typeChecker: TypeChecker | undefined): SymbolDisplayPart[];
+        getJsDocTags(): JSDocTagInfo[];
+    }
     export enum IndexKind {
         String = 0,
         Number = 1
@@ -3333,6 +7396,9 @@ declare namespace ts {
         text: string;
         skipTrivia?: (pos: number) => number;
     }
+    interface SourceMapSource {
+        getLineAndCharacterOfPosition(pos: number): LineAndCharacter;
+    }
     export enum EmitFlags {
         None = 0,
         SingleLine = 1,
@@ -3362,7 +7428,7 @@ declare namespace ts {
         NoHoisting = 2097152,
         HasEndOfDeclarationMarker = 4194304,
         Iterator = 8388608,
-        NoAsciiEscaping = 16777216,
+        NoAsciiEscaping = 16777216
     }
     export interface EmitHelperBase {
         readonly name: string;
@@ -3864,90 +7930,263 @@ declare namespace ts {
         createExternalModuleExport(exportName: Identifier): ExportDeclaration;
         restoreOuterExpressions(outerExpression: Expression | undefined, innerExpression: Expression, kinds?: OuterExpressionKinds): Expression;
     }
-    export interface CoreTransformationContext {
-        readonly factory: NodeFactory;
-        /** Gets the compiler options supplied to the transformer. */
-        getCompilerOptions(): CompilerOptions;
-        /** Starts a new lexical environment. */
-        startLexicalEnvironment(): void;
-        /** Suspends the current lexical environment, usually after visiting a parameter list. */
-        suspendLexicalEnvironment(): void;
-        /** Resumes a suspended lexical environment, usually before visiting a function body. */
-        resumeLexicalEnvironment(): void;
-        /** Ends a lexical environment, returning any declarations. */
-        endLexicalEnvironment(): Statement[] | undefined;
-        /** Hoists a function declaration to the containing scope. */
-        hoistFunctionDeclaration(node: FunctionDeclaration): void;
-        /** Hoists a variable declaration to the containing scope. */
-        hoistVariableDeclaration(node: Identifier): void;
+    interface NodeFactory {
+        /** @deprecated Use the overload that accepts 'modifiers' */
+        createConstructorTypeNode(typeParameters: readonly TypeParameterDeclaration[] | undefined, parameters: readonly ParameterDeclaration[], type: TypeNode): ConstructorTypeNode;
+        /** @deprecated Use the overload that accepts 'modifiers' */
+        updateConstructorTypeNode(node: ConstructorTypeNode, typeParameters: NodeArray<TypeParameterDeclaration> | undefined, parameters: NodeArray<ParameterDeclaration>, type: TypeNode): ConstructorTypeNode;
     }
-    export interface TransformationContext extends CoreTransformationContext {
-        /** Records a request for a non-scoped emit helper in the current context. */
-        requestEmitHelper(helper: EmitHelper): void;
-        /** Gets and resets the requested non-scoped emit helpers. */
-        readEmitHelpers(): EmitHelper[] | undefined;
-        /** Enables expression substitutions in the pretty printer for the provided SyntaxKind. */
-        enableSubstitution(kind: SyntaxKind): void;
-        /** Determines whether expression substitutions are enabled for the provided node. */
-        isSubstitutionEnabled(node: Node): boolean;
+    interface NodeFactory {
+        createImportTypeNode(argument: TypeNode, assertions?: ImportTypeAssertionContainer, qualifier?: EntityName, typeArguments?: readonly TypeNode[], isTypeOf?: boolean): ImportTypeNode;
+        /** @deprecated Use the overload that accepts 'assertions' */
+        createImportTypeNode(argument: TypeNode, qualifier?: EntityName, typeArguments?: readonly TypeNode[], isTypeOf?: boolean): ImportTypeNode;
+        /** @deprecated Use the overload that accepts 'assertions' */
+        updateImportTypeNode(node: ImportTypeNode, argument: TypeNode, qualifier: EntityName | undefined, typeArguments: readonly TypeNode[] | undefined, isTypeOf?: boolean): ImportTypeNode;
+    }
+    interface NodeFactory {
+        /** @deprecated Use the overload that accepts 'modifiers' */
+        createTypeParameterDeclaration(name: string | Identifier, constraint?: TypeNode, defaultType?: TypeNode): TypeParameterDeclaration;
+        /** @deprecated Use the overload that accepts 'modifiers' */
+        updateTypeParameterDeclaration(node: TypeParameterDeclaration, name: Identifier, constraint: TypeNode | undefined, defaultType: TypeNode | undefined): TypeParameterDeclaration;
+    }
+    interface NodeFactory {
         /**
-         * Hook used by transformers to substitute expressions just before they
-         * are emitted by the pretty printer.
-         *
-         * NOTE: Transformation hooks should only be modified during `Transformer` initialization,
-         * before returning the `NodeTransformer` callback.
+         * @deprecated Decorators have been combined with modifiers. Callers should use an overload that does not accept a `decorators` parameter.
          */
-        onSubstituteNode: (hint: EmitHint, node: Node) => Node;
+        createParameterDeclaration(decorators: readonly Decorator[] | undefined, modifiers: readonly Modifier[] | undefined, dotDotDotToken: DotDotDotToken | undefined, name: string | BindingName, questionToken?: QuestionToken, type?: TypeNode, initializer?: Expression): ParameterDeclaration;
         /**
-         * Enables before/after emit notifications in the pretty printer for the provided
-         * SyntaxKind.
+         * @deprecated Decorators have been combined with modifiers. Callers should use an overload that does not accept a `decorators` parameter.
          */
-        enableEmitNotification(kind: SyntaxKind): void;
+        updateParameterDeclaration(node: ParameterDeclaration, decorators: readonly Decorator[] | undefined, modifiers: readonly Modifier[] | undefined, dotDotDotToken: DotDotDotToken | undefined, name: string | BindingName, questionToken: QuestionToken | undefined, type: TypeNode | undefined, initializer: Expression | undefined): ParameterDeclaration;
         /**
-         * Determines whether before/after emit notifications should be raised in the pretty
-         * printer when it emits a node.
+         * @deprecated Decorators have been combined with modifiers. Callers should use an overload that does not accept a `decorators` parameter.
          */
-        isEmitNotificationEnabled(node: Node): boolean;
+        createPropertyDeclaration(decorators: readonly Decorator[] | undefined, modifiers: readonly Modifier[] | undefined, name: string | PropertyName, questionOrExclamationToken: QuestionToken | ExclamationToken | undefined, type: TypeNode | undefined, initializer: Expression | undefined): PropertyDeclaration;
         /**
-         * Hook used to allow transformers to capture state before or after
-         * the printer emits a node.
-         *
-         * NOTE: Transformation hooks should only be modified during `Transformer` initialization,
-         * before returning the `NodeTransformer` callback.
+         * @deprecated Decorators have been combined with modifiers. Callers should use an overload that does not accept a `decorators` parameter.
          */
-        onEmitNode: (hint: EmitHint, node: Node, emitCallback: (hint: EmitHint, node: Node) => void) => void;
-    }
-    export interface TransformationResult<T extends Node> {
-        /** Gets the transformed source files. */
-        transformed: T[];
-        /** Gets diagnostics for the transformation. */
-        diagnostics?: DiagnosticWithLocation[];
+        updatePropertyDeclaration(node: PropertyDeclaration, decorators: readonly Decorator[] | undefined, modifiers: readonly Modifier[] | undefined, name: string | PropertyName, questionOrExclamationToken: QuestionToken | ExclamationToken | undefined, type: TypeNode | undefined, initializer: Expression | undefined): PropertyDeclaration;
         /**
-         * Gets a substitute for a node, if one is available; otherwise, returns the original node.
-         *
-         * @param hint A hint as to the intended usage of the node.
-         * @param node The node to substitute.
+         * @deprecated Decorators have been combined with modifiers. Callers should use an overload that does not accept a `decorators` parameter.
          */
-        substituteNode(hint: EmitHint, node: Node): Node;
+        createMethodDeclaration(decorators: readonly Decorator[] | undefined, modifiers: readonly Modifier[] | undefined, asteriskToken: AsteriskToken | undefined, name: string | PropertyName, questionToken: QuestionToken | undefined, typeParameters: readonly TypeParameterDeclaration[] | undefined, parameters: readonly ParameterDeclaration[], type: TypeNode | undefined, body: Block | undefined): MethodDeclaration;
         /**
-         * Emits a node with possible notification.
-         *
-         * @param hint A hint as to the intended usage of the node.
-         * @param node The node to emit.
-         * @param emitCallback A callback used to emit the node.
+         * @deprecated Decorators have been combined with modifiers. Callers should use an overload that does not accept a `decorators` parameter.
          */
-        emitNodeWithNotification(hint: EmitHint, node: Node, emitCallback: (hint: EmitHint, node: Node) => void): void;
+        updateMethodDeclaration(node: MethodDeclaration, decorators: readonly Decorator[] | undefined, modifiers: readonly Modifier[] | undefined, asteriskToken: AsteriskToken | undefined, name: PropertyName, questionToken: QuestionToken | undefined, typeParameters: readonly TypeParameterDeclaration[] | undefined, parameters: readonly ParameterDeclaration[], type: TypeNode | undefined, body: Block | undefined): MethodDeclaration;
         /**
-         * Indicates if a given node needs an emit notification
-         *
-         * @param node The node to emit.
+         * @deprecated This node does not support Decorators. Callers should use an overload that does not accept a `decorators` parameter.
          */
-        isEmitNotificationEnabled?(node: Node): boolean;
+        createConstructorDeclaration(decorators: readonly Decorator[] | undefined, modifiers: readonly Modifier[] | undefined, parameters: readonly ParameterDeclaration[], body: Block | undefined): ConstructorDeclaration;
         /**
-         * Clean up EmitNode entries on any parse-tree nodes.
+         * @deprecated This node does not support Decorators. Callers should use an overload that does not accept a `decorators` parameter.
          */
-        dispose(): void;
-    }
+        updateConstructorDeclaration(node: ConstructorDeclaration, decorators: readonly Decorator[] | undefined, modifiers: readonly Modifier[] | undefined, parameters: readonly ParameterDeclaration[], body: Block | undefined): ConstructorDeclaration;
+        /**
+         * @deprecated Decorators have been combined with modifiers. Callers should use an overload that does not accept a `decorators` parameter.
+         */
+        createGetAccessorDeclaration(decorators: readonly Decorator[] | undefined, modifiers: readonly Modifier[] | undefined, name: string | PropertyName, parameters: readonly ParameterDeclaration[], type: TypeNode | undefined, body: Block | undefined): GetAccessorDeclaration;
+        /**
+         * @deprecated Decorators have been combined with modifiers. Callers should use an overload that does not accept a `decorators` parameter.
+         */
+        updateGetAccessorDeclaration(node: GetAccessorDeclaration, decorators: readonly Decorator[] | undefined, modifiers: readonly Modifier[] | undefined, name: PropertyName, parameters: readonly ParameterDeclaration[], type: TypeNode | undefined, body: Block | undefined): GetAccessorDeclaration;
+        /**
+         * @deprecated Decorators have been combined with modifiers. Callers should use an overload that does not accept a `decorators` parameter.
+         */
+        createSetAccessorDeclaration(decorators: readonly Decorator[] | undefined, modifiers: readonly Modifier[] | undefined, name: string | PropertyName, parameters: readonly ParameterDeclaration[], body: Block | undefined): SetAccessorDeclaration;
+        /**
+         * @deprecated Decorators have been combined with modifiers. Callers should use an overload that does not accept a `decorators` parameter.
+         */
+        updateSetAccessorDeclaration(node: SetAccessorDeclaration, decorators: readonly Decorator[] | undefined, modifiers: readonly Modifier[] | undefined, name: PropertyName, parameters: readonly ParameterDeclaration[], body: Block | undefined): SetAccessorDeclaration;
+        /**
+         * @deprecated Decorators are no longer supported for this function. Callers should use an overload that does not accept a `decorators` parameter.
+         */
+        createIndexSignature(decorators: readonly Decorator[] | undefined, modifiers: readonly Modifier[] | undefined, parameters: readonly ParameterDeclaration[], type: TypeNode): IndexSignatureDeclaration;
+        /**
+         * @deprecated Decorators and modifiers are no longer supported for this function. Callers should use an overload that does not accept the `decorators` and `modifiers` parameters.
+         */
+        updateIndexSignature(node: IndexSignatureDeclaration, decorators: readonly Decorator[] | undefined, modifiers: readonly Modifier[] | undefined, parameters: readonly ParameterDeclaration[], type: TypeNode): IndexSignatureDeclaration;
+        /**
+         * @deprecated Decorators and modifiers are no longer supported for this function. Callers should use an overload that does not accept the `decorators` and `modifiers` parameters.
+         */
+        createClassStaticBlockDeclaration(decorators: readonly Decorator[] | undefined, modifiers: readonly Modifier[] | undefined, body: Block): ClassStaticBlockDeclaration;
+        /**
+         * @deprecated Decorators are no longer supported for this function. Callers should use an overload that does not accept a `decorators` parameter.
+         */
+        updateClassStaticBlockDeclaration(node: ClassStaticBlockDeclaration, decorators: readonly Decorator[] | undefined, modifiers: readonly Modifier[] | undefined, body: Block): ClassStaticBlockDeclaration;
+        /**
+         * @deprecated Decorators have been combined with modifiers. Callers should use an overload that does not accept a `decorators` parameter.
+         */
+        createClassExpression(decorators: readonly Decorator[] | undefined, modifiers: readonly Modifier[] | undefined, name: string | Identifier | undefined, typeParameters: readonly TypeParameterDeclaration[] | undefined, heritageClauses: readonly HeritageClause[] | undefined, members: readonly ClassElement[]): ClassExpression;
+        /**
+         * @deprecated Decorators have been combined with modifiers. Callers should use an overload that does not accept a `decorators` parameter.
+         */
+        updateClassExpression(node: ClassExpression, decorators: readonly Decorator[] | undefined, modifiers: readonly Modifier[] | undefined, name: Identifier | undefined, typeParameters: readonly TypeParameterDeclaration[] | undefined, heritageClauses: readonly HeritageClause[] | undefined, members: readonly ClassElement[]): ClassExpression;
+        /**
+         * @deprecated Decorators are no longer supported for this function. Callers should use an overload that does not accept a `decorators` parameter.
+         */
+        createFunctionDeclaration(decorators: readonly Decorator[] | undefined, modifiers: readonly Modifier[] | undefined, asteriskToken: AsteriskToken | undefined, name: string | Identifier | undefined, typeParameters: readonly TypeParameterDeclaration[] | undefined, parameters: readonly ParameterDeclaration[], type: TypeNode | undefined, body: Block | undefined): FunctionDeclaration;
+        /**
+         * @deprecated Decorators are no longer supported for this function. Callers should use an overload that does not accept a `decorators` parameter.
+         */
+        updateFunctionDeclaration(node: FunctionDeclaration, decorators: readonly Decorator[] | undefined, modifiers: readonly Modifier[] | undefined, asteriskToken: AsteriskToken | undefined, name: Identifier | undefined, typeParameters: readonly TypeParameterDeclaration[] | undefined, parameters: readonly ParameterDeclaration[], type: TypeNode | undefined, body: Block | undefined): FunctionDeclaration;
+        /**
+         * @deprecated Decorators have been combined with modifiers. Callers should use an overload that does not accept a `decorators` parameter.
+         */
+        createClassDeclaration(decorators: readonly Decorator[] | undefined, modifiers: readonly Modifier[] | undefined, name: string | Identifier | undefined, typeParameters: readonly TypeParameterDeclaration[] | undefined, heritageClauses: readonly HeritageClause[] | undefined, members: readonly ClassElement[]): ClassDeclaration;
+        /**
+         * @deprecated Decorators have been combined with modifiers. Callers should use an overload that does not accept a `decorators` parameter.
+         */
+        updateClassDeclaration(node: ClassDeclaration, decorators: readonly Decorator[] | undefined, modifiers: readonly Modifier[] | undefined, name: Identifier | undefined, typeParameters: readonly TypeParameterDeclaration[] | undefined, heritageClauses: readonly HeritageClause[] | undefined, members: readonly ClassElement[]): ClassDeclaration;
+        /**
+         * @deprecated Decorators are no longer supported for this function. Callers should use an overload that does not accept a `decorators` parameter.
+         */
+        createInterfaceDeclaration(decorators: readonly Decorator[] | undefined, modifiers: readonly Modifier[] | undefined, name: string | Identifier, typeParameters: readonly TypeParameterDeclaration[] | undefined, heritageClauses: readonly HeritageClause[] | undefined, members: readonly TypeElement[]): InterfaceDeclaration;
+        /**
+         * @deprecated Decorators are no longer supported for this function. Callers should use an overload that does not accept a `decorators` parameter.
+         */
+        updateInterfaceDeclaration(node: InterfaceDeclaration, decorators: readonly Decorator[] | undefined, modifiers: readonly Modifier[] | undefined, name: Identifier, typeParameters: readonly TypeParameterDeclaration[] | undefined, heritageClauses: readonly HeritageClause[] | undefined, members: readonly TypeElement[]): InterfaceDeclaration;
+        /**
+         * @deprecated Decorators are no longer supported for this function. Callers should use an overload that does not accept a `decorators` parameter.
+         */
+        createTypeAliasDeclaration(decorators: readonly Decorator[] | undefined, modifiers: readonly Modifier[] | undefined, name: string | Identifier, typeParameters: readonly TypeParameterDeclaration[] | undefined, type: TypeNode): TypeAliasDeclaration;
+        /**
+         * @deprecated Decorators are no longer supported for this function. Callers should use an overload that does not accept a `decorators` parameter.
+         */
+        updateTypeAliasDeclaration(node: TypeAliasDeclaration, decorators: readonly Decorator[] | undefined, modifiers: readonly Modifier[] | undefined, name: Identifier, typeParameters: readonly TypeParameterDeclaration[] | undefined, type: TypeNode): TypeAliasDeclaration;
+        /**
+         * @deprecated Decorators are no longer supported for this function. Callers should use an overload that does not accept a `decorators` parameter.
+         */
+        createEnumDeclaration(decorators: readonly Decorator[] | undefined, modifiers: readonly Modifier[] | undefined, name: string | Identifier, members: readonly EnumMember[]): EnumDeclaration;
+        /**
+         * @deprecated Decorators are no longer supported for this function. Callers should use an overload that does not accept a `decorators` parameter.
+         */
+        updateEnumDeclaration(node: EnumDeclaration, decorators: readonly Decorator[] | undefined, modifiers: readonly Modifier[] | undefined, name: Identifier, members: readonly EnumMember[]): EnumDeclaration;
+        /**
+         * @deprecated Decorators are no longer supported for this function. Callers should use an overload that does not accept a `decorators` parameter.
+         */
+        createModuleDeclaration(decorators: readonly Decorator[] | undefined, modifiers: readonly Modifier[] | undefined, name: ModuleName, body: ModuleBody | undefined, flags?: NodeFlags): ModuleDeclaration;
+        /**
+         * @deprecated Decorators are no longer supported for this function. Callers should use an overload that does not accept a `decorators` parameter.
+         */
+        updateModuleDeclaration(node: ModuleDeclaration, decorators: readonly Decorator[] | undefined, modifiers: readonly Modifier[] | undefined, name: ModuleName, body: ModuleBody | undefined): ModuleDeclaration;
+        /**
+         * @deprecated Decorators are no longer supported for this function. Callers should use an overload that does not accept a `decorators` parameter.
+         */
+        createImportEqualsDeclaration(decorators: readonly Decorator[] | undefined, modifiers: readonly Modifier[] | undefined, isTypeOnly: boolean, name: string | Identifier, moduleReference: ModuleReference): ImportEqualsDeclaration;
+        /**
+         * @deprecated Decorators are no longer supported for this function. Callers should use an overload that does not accept a `decorators` parameter.
+         */
+        updateImportEqualsDeclaration(node: ImportEqualsDeclaration, decorators: readonly Decorator[] | undefined, modifiers: readonly Modifier[] | undefined, isTypeOnly: boolean, name: Identifier, moduleReference: ModuleReference): ImportEqualsDeclaration;
+        /**
+         * @deprecated Decorators are no longer supported for this function. Callers should use an overload that does not accept a `decorators` parameter.
+         */
+        createImportDeclaration(decorators: readonly Decorator[] | undefined, modifiers: readonly Modifier[] | undefined, importClause: ImportClause | undefined, moduleSpecifier: Expression, assertClause?: AssertClause): ImportDeclaration;
+        /**
+         * @deprecated Decorators are no longer supported for this function. Callers should use an overload that does not accept a `decorators` parameter.
+         */
+        updateImportDeclaration(node: ImportDeclaration, decorators: readonly Decorator[] | undefined, modifiers: readonly Modifier[] | undefined, importClause: ImportClause | undefined, moduleSpecifier: Expression, assertClause: AssertClause | undefined): ImportDeclaration;
+        /**
+         * @deprecated Decorators are no longer supported for this function. Callers should use an overload that does not accept a `decorators` parameter.
+         */
+        createExportAssignment(decorators: readonly Decorator[] | undefined, modifiers: readonly Modifier[] | undefined, isExportEquals: boolean | undefined, expression: Expression): ExportAssignment;
+        /**
+         * @deprecated Decorators are no longer supported for this function. Callers should use an overload that does not accept a `decorators` parameter.
+         */
+        updateExportAssignment(node: ExportAssignment, decorators: readonly Decorator[] | undefined, modifiers: readonly Modifier[] | undefined, expression: Expression): ExportAssignment;
+        /**
+         * @deprecated Decorators are no longer supported for this function. Callers should use an overload that does not accept a `decorators` parameter.
+         */
+        createExportDeclaration(decorators: readonly Decorator[] | undefined, modifiers: readonly Modifier[] | undefined, isTypeOnly: boolean, exportClause: NamedExportBindings | undefined, moduleSpecifier?: Expression, assertClause?: AssertClause): ExportDeclaration;
+        /**
+         * @deprecated Decorators are no longer supported for this function. Callers should use an overload that does not accept a `decorators` parameter.
+         */
+        updateExportDeclaration(node: ExportDeclaration, decorators: readonly Decorator[] | undefined, modifiers: readonly Modifier[] | undefined, isTypeOnly: boolean, exportClause: NamedExportBindings | undefined, moduleSpecifier: Expression | undefined, assertClause: AssertClause | undefined): ExportDeclaration;
+    }
+    export interface CoreTransformationContext {
+        readonly factory: NodeFactory;
+        /** Gets the compiler options supplied to the transformer. */
+        getCompilerOptions(): CompilerOptions;
+        /** Starts a new lexical environment. */
+        startLexicalEnvironment(): void;
+        /** Suspends the current lexical environment, usually after visiting a parameter list. */
+        suspendLexicalEnvironment(): void;
+        /** Resumes a suspended lexical environment, usually before visiting a function body. */
+        resumeLexicalEnvironment(): void;
+        /** Ends a lexical environment, returning any declarations. */
+        endLexicalEnvironment(): Statement[] | undefined;
+        /** Hoists a function declaration to the containing scope. */
+        hoistFunctionDeclaration(node: FunctionDeclaration): void;
+        /** Hoists a variable declaration to the containing scope. */
+        hoistVariableDeclaration(node: Identifier): void;
+    }
+    export interface TransformationContext extends CoreTransformationContext {
+        /** Records a request for a non-scoped emit helper in the current context. */
+        requestEmitHelper(helper: EmitHelper): void;
+        /** Gets and resets the requested non-scoped emit helpers. */
+        readEmitHelpers(): EmitHelper[] | undefined;
+        /** Enables expression substitutions in the pretty printer for the provided SyntaxKind. */
+        enableSubstitution(kind: SyntaxKind): void;
+        /** Determines whether expression substitutions are enabled for the provided node. */
+        isSubstitutionEnabled(node: Node): boolean;
+        /**
+         * Hook used by transformers to substitute expressions just before they
+         * are emitted by the pretty printer.
+         *
+         * NOTE: Transformation hooks should only be modified during `Transformer` initialization,
+         * before returning the `NodeTransformer` callback.
+         */
+        onSubstituteNode: (hint: EmitHint, node: Node) => Node;
+        /**
+         * Enables before/after emit notifications in the pretty printer for the provided
+         * SyntaxKind.
+         */
+        enableEmitNotification(kind: SyntaxKind): void;
+        /**
+         * Determines whether before/after emit notifications should be raised in the pretty
+         * printer when it emits a node.
+         */
+        isEmitNotificationEnabled(node: Node): boolean;
+        /**
+         * Hook used to allow transformers to capture state before or after
+         * the printer emits a node.
+         *
+         * NOTE: Transformation hooks should only be modified during `Transformer` initialization,
+         * before returning the `NodeTransformer` callback.
+         */
+        onEmitNode: (hint: EmitHint, node: Node, emitCallback: (hint: EmitHint, node: Node) => void) => void;
+    }
+    export interface TransformationResult<T extends Node> {
+        /** Gets the transformed source files. */
+        transformed: T[];
+        /** Gets diagnostics for the transformation. */
+        diagnostics?: DiagnosticWithLocation[];
+        /**
+         * Gets a substitute for a node, if one is available; otherwise, returns the original node.
+         *
+         * @param hint A hint as to the intended usage of the node.
+         * @param node The node to substitute.
+         */
+        substituteNode(hint: EmitHint, node: Node): Node;
+        /**
+         * Emits a node with possible notification.
+         *
+         * @param hint A hint as to the intended usage of the node.
+         * @param node The node to emit.
+         * @param emitCallback A callback used to emit the node.
+         */
+        emitNodeWithNotification(hint: EmitHint, node: Node, emitCallback: (hint: EmitHint, node: Node) => void): void;
+        /**
+         * Indicates if a given node needs an emit notification
+         *
+         * @param node The node to emit.
+         */
+        isEmitNotificationEnabled?(node: Node): boolean;
+        /**
+         * Clean up EmitNode entries on any parse-tree nodes.
+         */
+        dispose(): void;
+    }
     /**
      * A function that is used to initialize and return a `Transformer` callback, which in turn
      * will be used to transform one or more nodes.
@@ -4174,11 +8413,7 @@ declare namespace ts {
         negative: boolean;
         base10Value: string;
     }
-    export {};
-}
-declare function setTimeout(handler: (...args: any[]) => void, timeout: number): any;
-declare function clearTimeout(handle: any): void;
-declare namespace ts {
+    export function getNodeMajorVersion(): number | undefined;
     export enum FileWatcherEventKind {
         Created = 0,
         Changed = 1,
@@ -4231,13 +8466,30 @@ declare namespace ts {
     export interface FileWatcher {
         close(): void;
     }
-    export function getNodeMajorVersion(): number | undefined;
     export let sys: System;
-    export {};
-}
-declare namespace ts {
-    type ErrorCallback = (message: DiagnosticMessage, length: number) => void;
-    interface Scanner {
+    export function tokenToString(t: SyntaxKind): string | undefined;
+    export function getPositionOfLineAndCharacter(sourceFile: SourceFileLike, line: number, character: number): number;
+    export function getLineAndCharacterOfPosition(sourceFile: SourceFileLike, position: number): LineAndCharacter;
+    export function isWhiteSpaceLike(ch: number): boolean;
+    /** Does not include line breaks. For that, see isWhiteSpaceLike. */
+    export function isWhiteSpaceSingleLine(ch: number): boolean;
+    export function isLineBreak(ch: number): boolean;
+    export function couldStartTrivia(text: string, pos: number): boolean;
+    export function forEachLeadingCommentRange<U>(text: string, pos: number, cb: (pos: number, end: number, kind: CommentKind, hasTrailingNewLine: boolean) => U): U | undefined;
+    export function forEachLeadingCommentRange<T, U>(text: string, pos: number, cb: (pos: number, end: number, kind: CommentKind, hasTrailingNewLine: boolean, state: T) => U, state: T): U | undefined;
+    export function forEachTrailingCommentRange<U>(text: string, pos: number, cb: (pos: number, end: number, kind: CommentKind, hasTrailingNewLine: boolean) => U): U | undefined;
+    export function forEachTrailingCommentRange<T, U>(text: string, pos: number, cb: (pos: number, end: number, kind: CommentKind, hasTrailingNewLine: boolean, state: T) => U, state: T): U | undefined;
+    export function reduceEachLeadingCommentRange<T, U>(text: string, pos: number, cb: (pos: number, end: number, kind: CommentKind, hasTrailingNewLine: boolean, state: T, memo: U) => U, state: T, initial: U): U | undefined;
+    export function reduceEachTrailingCommentRange<T, U>(text: string, pos: number, cb: (pos: number, end: number, kind: CommentKind, hasTrailingNewLine: boolean, state: T, memo: U) => U, state: T, initial: U): U | undefined;
+    export function getLeadingCommentRanges(text: string, pos: number): CommentRange[] | undefined;
+    export function getTrailingCommentRanges(text: string, pos: number): CommentRange[] | undefined;
+    /** Optionally, get the shebang */
+    export function getShebang(text: string): string | undefined;
+    export function isIdentifierStart(ch: number, languageVersion: ScriptTarget | undefined): boolean;
+    export function isIdentifierPart(ch: number, languageVersion: ScriptTarget | undefined, identifierVariant?: LanguageVariant): boolean;
+    export function createScanner(languageVersion: ScriptTarget, skipTrivia: boolean, languageVariant?: LanguageVariant, textInitial?: string, onError?: ErrorCallback, start?: number, length?: number): Scanner;
+    export type ErrorCallback = (message: DiagnosticMessage, length: number) => void;
+    export interface Scanner {
         getStartPos(): number;
         getToken(): SyntaxKind;
         getTextPos(): number;
@@ -4276,49 +8528,25 @@ declare namespace ts {
         scanRange<T>(start: number, length: number, callback: () => T): T;
         tryScan<T>(callback: () => T): T;
     }
-    function tokenToString(t: SyntaxKind): string | undefined;
-    function getPositionOfLineAndCharacter(sourceFile: SourceFileLike, line: number, character: number): number;
-    function getLineAndCharacterOfPosition(sourceFile: SourceFileLike, position: number): LineAndCharacter;
-    function isWhiteSpaceLike(ch: number): boolean;
-    /** Does not include line breaks. For that, see isWhiteSpaceLike. */
-    function isWhiteSpaceSingleLine(ch: number): boolean;
-    function isLineBreak(ch: number): boolean;
-    function couldStartTrivia(text: string, pos: number): boolean;
-    function forEachLeadingCommentRange<U>(text: string, pos: number, cb: (pos: number, end: number, kind: CommentKind, hasTrailingNewLine: boolean) => U): U | undefined;
-    function forEachLeadingCommentRange<T, U>(text: string, pos: number, cb: (pos: number, end: number, kind: CommentKind, hasTrailingNewLine: boolean, state: T) => U, state: T): U | undefined;
-    function forEachTrailingCommentRange<U>(text: string, pos: number, cb: (pos: number, end: number, kind: CommentKind, hasTrailingNewLine: boolean) => U): U | undefined;
-    function forEachTrailingCommentRange<T, U>(text: string, pos: number, cb: (pos: number, end: number, kind: CommentKind, hasTrailingNewLine: boolean, state: T) => U, state: T): U | undefined;
-    function reduceEachLeadingCommentRange<T, U>(text: string, pos: number, cb: (pos: number, end: number, kind: CommentKind, hasTrailingNewLine: boolean, state: T, memo: U) => U, state: T, initial: U): U | undefined;
-    function reduceEachTrailingCommentRange<T, U>(text: string, pos: number, cb: (pos: number, end: number, kind: CommentKind, hasTrailingNewLine: boolean, state: T, memo: U) => U, state: T, initial: U): U | undefined;
-    function getLeadingCommentRanges(text: string, pos: number): CommentRange[] | undefined;
-    function getTrailingCommentRanges(text: string, pos: number): CommentRange[] | undefined;
-    /** Optionally, get the shebang */
-    function getShebang(text: string): string | undefined;
-    function isIdentifierStart(ch: number, languageVersion: ScriptTarget | undefined): boolean;
-    function isIdentifierPart(ch: number, languageVersion: ScriptTarget | undefined, identifierVariant?: LanguageVariant): boolean;
-    function createScanner(languageVersion: ScriptTarget, skipTrivia: boolean, languageVariant?: LanguageVariant, textInitial?: string, onError?: ErrorCallback, start?: number, length?: number): Scanner;
-}
-declare namespace ts {
-    function isExternalModuleNameRelative(moduleName: string): boolean;
-    function sortAndDeduplicateDiagnostics<T extends Diagnostic>(diagnostics: readonly T[]): SortedReadonlyArray<T>;
-    function getDefaultLibFileName(options: CompilerOptions): string;
-    function textSpanEnd(span: TextSpan): number;
-    function textSpanIsEmpty(span: TextSpan): boolean;
-    function textSpanContainsPosition(span: TextSpan, position: number): boolean;
-    function textSpanContainsTextSpan(span: TextSpan, other: TextSpan): boolean;
-    function textSpanOverlapsWith(span: TextSpan, other: TextSpan): boolean;
-    function textSpanOverlap(span1: TextSpan, span2: TextSpan): TextSpan | undefined;
-    function textSpanIntersectsWithTextSpan(span: TextSpan, other: TextSpan): boolean;
-    function textSpanIntersectsWith(span: TextSpan, start: number, length: number): boolean;
-    function decodedTextSpanIntersectsWith(start1: number, length1: number, start2: number, length2: number): boolean;
-    function textSpanIntersectsWithPosition(span: TextSpan, position: number): boolean;
-    function textSpanIntersection(span1: TextSpan, span2: TextSpan): TextSpan | undefined;
-    function createTextSpan(start: number, length: number): TextSpan;
-    function createTextSpanFromBounds(start: number, end: number): TextSpan;
-    function textChangeRangeNewSpan(range: TextChangeRange): TextSpan;
-    function textChangeRangeIsUnchanged(range: TextChangeRange): boolean;
-    function createTextChangeRange(span: TextSpan, newLength: number): TextChangeRange;
-    let unchangedTextChangeRange: TextChangeRange;
+    export function isExternalModuleNameRelative(moduleName: string): boolean;
+    export function sortAndDeduplicateDiagnostics<T extends Diagnostic>(diagnostics: readonly T[]): SortedReadonlyArray<T>;
+    export function getDefaultLibFileName(options: CompilerOptions): string;
+    export function textSpanEnd(span: TextSpan): number;
+    export function textSpanIsEmpty(span: TextSpan): boolean;
+    export function textSpanContainsPosition(span: TextSpan, position: number): boolean;
+    export function textSpanContainsTextSpan(span: TextSpan, other: TextSpan): boolean;
+    export function textSpanOverlapsWith(span: TextSpan, other: TextSpan): boolean;
+    export function textSpanOverlap(span1: TextSpan, span2: TextSpan): TextSpan | undefined;
+    export function textSpanIntersectsWithTextSpan(span: TextSpan, other: TextSpan): boolean;
+    export function textSpanIntersectsWith(span: TextSpan, start: number, length: number): boolean;
+    export function decodedTextSpanIntersectsWith(start1: number, length1: number, start2: number, length2: number): boolean;
+    export function textSpanIntersectsWithPosition(span: TextSpan, position: number): boolean;
+    export function textSpanIntersection(span1: TextSpan, span2: TextSpan): TextSpan | undefined;
+    export function createTextSpan(start: number, length: number): TextSpan;
+    export function createTextSpanFromBounds(start: number, end: number): TextSpan;
+    export function textChangeRangeNewSpan(range: TextChangeRange): TextSpan;
+    export function textChangeRangeIsUnchanged(range: TextChangeRange): boolean;
+    export function createTextChangeRange(span: TextSpan, newLength: number): TextChangeRange;
     /**
      * Called to merge all the changes that occurred across several versions of a script snapshot
      * into a single change.  i.e. if a user keeps making successive edits to a script we will
@@ -4327,53 +8555,49 @@ declare namespace ts {
      * This function will then merge those changes into a single change range valid between V1 and
      * Vn.
      */
-    function collapseTextChangeRangesAcrossMultipleVersions(changes: readonly TextChangeRange[]): TextChangeRange;
-    function getTypeParameterOwner(d: Declaration): Declaration | undefined;
-    type ParameterPropertyDeclaration = ParameterDeclaration & {
-        parent: ConstructorDeclaration;
-        name: Identifier;
-    };
-    function isParameterPropertyDeclaration(node: Node, parent: Node): node is ParameterPropertyDeclaration;
-    function isEmptyBindingPattern(node: BindingName): node is BindingPattern;
-    function isEmptyBindingElement(node: BindingElement): boolean;
-    function walkUpBindingElementsAndPatterns(binding: BindingElement): VariableDeclaration | ParameterDeclaration;
-    function getCombinedModifierFlags(node: Declaration): ModifierFlags;
-    function getCombinedNodeFlags(node: Node): NodeFlags;
+    export function collapseTextChangeRangesAcrossMultipleVersions(changes: readonly TextChangeRange[]): TextChangeRange;
+    export function getTypeParameterOwner(d: Declaration): Declaration | undefined;
+    export function isParameterPropertyDeclaration(node: Node, parent: Node): node is ParameterPropertyDeclaration;
+    export function isEmptyBindingPattern(node: BindingName): node is BindingPattern;
+    export function isEmptyBindingElement(node: BindingElement): boolean;
+    export function walkUpBindingElementsAndPatterns(binding: BindingElement): VariableDeclaration | ParameterDeclaration;
+    export function getCombinedModifierFlags(node: Declaration): ModifierFlags;
+    export function getCombinedNodeFlags(node: Node): NodeFlags;
     /**
      * Checks to see if the locale is in the appropriate format,
      * and if it is, attempts to set the appropriate language.
      */
-    function validateLocaleAndSetLanguage(locale: string, sys: {
+    export function validateLocaleAndSetLanguage(locale: string, sys: {
         getExecutingFilePath(): string;
         resolvePath(path: string): string;
         fileExists(fileName: string): boolean;
         readFile(fileName: string): string | undefined;
     }, errors?: Push<Diagnostic>): void;
-    function getOriginalNode(node: Node): Node;
-    function getOriginalNode<T extends Node>(node: Node, nodeTest: (node: Node) => node is T): T;
-    function getOriginalNode(node: Node | undefined): Node | undefined;
-    function getOriginalNode<T extends Node>(node: Node | undefined, nodeTest: (node: Node | undefined) => node is T): T | undefined;
+    export function getOriginalNode(node: Node): Node;
+    export function getOriginalNode<T extends Node>(node: Node, nodeTest: (node: Node) => node is T): T;
+    export function getOriginalNode(node: Node | undefined): Node | undefined;
+    export function getOriginalNode<T extends Node>(node: Node | undefined, nodeTest: (node: Node | undefined) => node is T): T | undefined;
     /**
      * Iterates through the parent chain of a node and performs the callback on each parent until the callback
      * returns a truthy value, then returns that value.
      * If no such value is found, it applies the callback until the parent pointer is undefined or the callback returns "quit"
      * At that point findAncestor returns undefined.
      */
-    function findAncestor<T extends Node>(node: Node | undefined, callback: (element: Node) => element is T): T | undefined;
-    function findAncestor(node: Node | undefined, callback: (element: Node) => boolean | "quit"): Node | undefined;
+    export function findAncestor<T extends Node>(node: Node | undefined, callback: (element: Node) => element is T): T | undefined;
+    export function findAncestor(node: Node | undefined, callback: (element: Node) => boolean | "quit"): Node | undefined;
     /**
      * Gets a value indicating whether a node originated in the parse tree.
      *
      * @param node The node to test.
      */
-    function isParseTreeNode(node: Node): boolean;
+    export function isParseTreeNode(node: Node): boolean;
     /**
      * Gets the original parse tree node for a node.
      *
      * @param node The original node.
      * @returns The original parse tree node if found; otherwise, undefined.
      */
-    function getParseTreeNode(node: Node | undefined): Node | undefined;
+    export function getParseTreeNode(node: Node | undefined): Node | undefined;
     /**
      * Gets the original parse tree node for a node.
      *
@@ -4381,22 +8605,22 @@ declare namespace ts {
      * @param nodeTest A callback used to ensure the correct type of parse tree node is returned.
      * @returns The original parse tree node if found; otherwise, undefined.
      */
-    function getParseTreeNode<T extends Node>(node: T | undefined, nodeTest?: (node: Node) => node is T): T | undefined;
+    export function getParseTreeNode<T extends Node>(node: T | undefined, nodeTest?: (node: Node) => node is T): T | undefined;
     /** Add an extra underscore to identifiers that start with two underscores to avoid issues with magic names like '__proto__' */
-    function escapeLeadingUnderscores(identifier: string): __String;
+    export function escapeLeadingUnderscores(identifier: string): __String;
     /**
      * Remove extra underscore from escaped identifier text content.
      *
      * @param identifier The escaped identifier text.
      * @returns The unescaped identifier text.
      */
-    function unescapeLeadingUnderscores(identifier: __String): string;
-    function idText(identifierOrPrivateName: Identifier | PrivateIdentifier): string;
-    function symbolName(symbol: Symbol): string;
-    function getNameOfJSDocTypedef(declaration: JSDocTypedefTag): Identifier | PrivateIdentifier | undefined;
-    function getNameOfDeclaration(declaration: Declaration | Expression | undefined): DeclarationName | undefined;
-    function getDecorators(node: HasDecorators): readonly Decorator[] | undefined;
-    function getModifiers(node: HasModifiers): readonly Modifier[] | undefined;
+    export function unescapeLeadingUnderscores(identifier: __String): string;
+    export function idText(identifierOrPrivateName: Identifier | PrivateIdentifier): string;
+    export function symbolName(symbol: Symbol): string;
+    export function getNameOfJSDocTypedef(declaration: JSDocTypedefTag): Identifier | PrivateIdentifier | undefined;
+    export function getNameOfDeclaration(declaration: Declaration | Expression | undefined): DeclarationName | undefined;
+    export function getDecorators(node: HasDecorators): readonly Decorator[] | undefined;
+    export function getModifiers(node: HasModifiers): readonly Modifier[] | undefined;
     /**
      * Gets the JSDoc parameter tags for the node if present.
      *
@@ -4409,7 +8633,7 @@ declare namespace ts {
      *
      * For binding patterns, parameter tags are matched by position.
      */
-    function getJSDocParameterTags(param: ParameterDeclaration): readonly JSDocParameterTag[];
+    export function getJSDocParameterTags(param: ParameterDeclaration): readonly JSDocParameterTag[];
     /**
      * Gets the JSDoc type parameter tags for the node if present.
      *
@@ -4420,41 +8644,41 @@ declare namespace ts {
      * node are returned first, so in the previous example, the template
      * tag on the containing function expression would be first.
      */
-    function getJSDocTypeParameterTags(param: TypeParameterDeclaration): readonly JSDocTemplateTag[];
+    export function getJSDocTypeParameterTags(param: TypeParameterDeclaration): readonly JSDocTemplateTag[];
     /**
      * Return true if the node has JSDoc parameter tags.
      *
      * @remarks Includes parameter tags that are not directly on the node,
      * for example on a variable declaration whose initializer is a function expression.
      */
-    function hasJSDocParameterTags(node: FunctionLikeDeclaration | SignatureDeclaration): boolean;
+    export function hasJSDocParameterTags(node: FunctionLikeDeclaration | SignatureDeclaration): boolean;
     /** Gets the JSDoc augments tag for the node if present */
-    function getJSDocAugmentsTag(node: Node): JSDocAugmentsTag | undefined;
+    export function getJSDocAugmentsTag(node: Node): JSDocAugmentsTag | undefined;
     /** Gets the JSDoc implements tags for the node if present */
-    function getJSDocImplementsTags(node: Node): readonly JSDocImplementsTag[];
+    export function getJSDocImplementsTags(node: Node): readonly JSDocImplementsTag[];
     /** Gets the JSDoc class tag for the node if present */
-    function getJSDocClassTag(node: Node): JSDocClassTag | undefined;
+    export function getJSDocClassTag(node: Node): JSDocClassTag | undefined;
     /** Gets the JSDoc public tag for the node if present */
-    function getJSDocPublicTag(node: Node): JSDocPublicTag | undefined;
+    export function getJSDocPublicTag(node: Node): JSDocPublicTag | undefined;
     /** Gets the JSDoc private tag for the node if present */
-    function getJSDocPrivateTag(node: Node): JSDocPrivateTag | undefined;
+    export function getJSDocPrivateTag(node: Node): JSDocPrivateTag | undefined;
     /** Gets the JSDoc protected tag for the node if present */
-    function getJSDocProtectedTag(node: Node): JSDocProtectedTag | undefined;
+    export function getJSDocProtectedTag(node: Node): JSDocProtectedTag | undefined;
     /** Gets the JSDoc protected tag for the node if present */
-    function getJSDocReadonlyTag(node: Node): JSDocReadonlyTag | undefined;
-    function getJSDocOverrideTagNoCache(node: Node): JSDocOverrideTag | undefined;
+    export function getJSDocReadonlyTag(node: Node): JSDocReadonlyTag | undefined;
+    export function getJSDocOverrideTagNoCache(node: Node): JSDocOverrideTag | undefined;
     /** Gets the JSDoc deprecated tag for the node if present */
-    function getJSDocDeprecatedTag(node: Node): JSDocDeprecatedTag | undefined;
+    export function getJSDocDeprecatedTag(node: Node): JSDocDeprecatedTag | undefined;
     /** Gets the JSDoc enum tag for the node if present */
-    function getJSDocEnumTag(node: Node): JSDocEnumTag | undefined;
+    export function getJSDocEnumTag(node: Node): JSDocEnumTag | undefined;
     /** Gets the JSDoc this tag for the node if present */
-    function getJSDocThisTag(node: Node): JSDocThisTag | undefined;
+    export function getJSDocThisTag(node: Node): JSDocThisTag | undefined;
     /** Gets the JSDoc return tag for the node if present */
-    function getJSDocReturnTag(node: Node): JSDocReturnTag | undefined;
+    export function getJSDocReturnTag(node: Node): JSDocReturnTag | undefined;
     /** Gets the JSDoc template tag for the node if present */
-    function getJSDocTemplateTag(node: Node): JSDocTemplateTag | undefined;
+    export function getJSDocTemplateTag(node: Node): JSDocTemplateTag | undefined;
     /** Gets the JSDoc type tag for the node if present and valid */
-    function getJSDocTypeTag(node: Node): JSDocTypeTag | undefined;
+    export function getJSDocTypeTag(node: Node): JSDocTypeTag | undefined;
     /**
      * Gets the type node for the node if provided via JSDoc.
      *
@@ -4466,22 +8690,22 @@ declare namespace ts {
      * node are examined first, so in the previous example, the type
      * tag directly on the node would be returned.
      */
-    function getJSDocType(node: Node): TypeNode | undefined;
+    export function getJSDocType(node: Node): TypeNode | undefined;
     /**
      * Gets the return type node for the node if provided via JSDoc return tag or type tag.
      *
      * @remarks `getJSDocReturnTag` just gets the whole JSDoc tag. This function
      * gets the type from inside the braces, after the fat arrow, etc.
      */
-    function getJSDocReturnType(node: Node): TypeNode | undefined;
+    export function getJSDocReturnType(node: Node): TypeNode | undefined;
     /** Get all JSDoc tags related to a node, including those on parent nodes. */
-    function getJSDocTags(node: Node): readonly JSDocTag[];
+    export function getJSDocTags(node: Node): readonly JSDocTag[];
     /** Gets all JSDoc tags that match a specified predicate */
-    function getAllJSDocTags<T extends JSDocTag>(node: Node, predicate: (tag: JSDocTag) => tag is T): readonly T[];
+    export function getAllJSDocTags<T extends JSDocTag>(node: Node, predicate: (tag: JSDocTag) => tag is T): readonly T[];
     /** Gets all JSDoc tags of a specified kind */
-    function getAllJSDocTagsOfKind(node: Node, kind: SyntaxKind): readonly JSDocTag[];
+    export function getAllJSDocTagsOfKind(node: Node, kind: SyntaxKind): readonly JSDocTag[];
     /** Gets the text of a jsdoc comment, flattening links to their text. */
-    function getTextOfJSDocComment(comment?: string | NodeArray<JSDocComment>): string | undefined;
+    export function getTextOfJSDocComment(comment?: string | NodeArray<JSDocComment>): string | undefined;
     /**
      * Gets the effective type parameters. If the node was parsed in a
      * JavaScript file, gets the type parameters from the `@template` tag from JSDoc.
@@ -4492,375 +8716,370 @@ declare namespace ts {
      * /** @type {Id} /
      * function id(x) { return x }
      */
-    function getEffectiveTypeParameterDeclarations(node: DeclarationWithTypeParameters): readonly TypeParameterDeclaration[];
-    function getEffectiveConstraintOfTypeParameter(node: TypeParameterDeclaration): TypeNode | undefined;
-    function isMemberName(node: Node): node is MemberName;
-    function isPropertyAccessChain(node: Node): node is PropertyAccessChain;
-    function isElementAccessChain(node: Node): node is ElementAccessChain;
-    function isCallChain(node: Node): node is CallChain;
-    function isOptionalChain(node: Node): node is PropertyAccessChain | ElementAccessChain | CallChain | NonNullChain;
-    function isNullishCoalesce(node: Node): boolean;
-    function isConstTypeReference(node: Node): boolean;
-    function skipPartiallyEmittedExpressions(node: Expression): Expression;
-    function skipPartiallyEmittedExpressions(node: Node): Node;
-    function isNonNullChain(node: Node): node is NonNullChain;
-    function isBreakOrContinueStatement(node: Node): node is BreakOrContinueStatement;
-    function isNamedExportBindings(node: Node): node is NamedExportBindings;
-    function isUnparsedTextLike(node: Node): node is UnparsedTextLike;
-    function isUnparsedNode(node: Node): node is UnparsedNode;
-    function isJSDocPropertyLikeTag(node: Node): node is JSDocPropertyLikeTag;
+    export function getEffectiveTypeParameterDeclarations(node: DeclarationWithTypeParameters): readonly TypeParameterDeclaration[];
+    export function getEffectiveConstraintOfTypeParameter(node: TypeParameterDeclaration): TypeNode | undefined;
+    export function isMemberName(node: Node): node is MemberName;
+    export function isPropertyAccessChain(node: Node): node is PropertyAccessChain;
+    export function isElementAccessChain(node: Node): node is ElementAccessChain;
+    export function isCallChain(node: Node): node is CallChain;
+    export function isOptionalChain(node: Node): node is PropertyAccessChain | ElementAccessChain | CallChain | NonNullChain;
+    export function isNullishCoalesce(node: Node): boolean;
+    export function isConstTypeReference(node: Node): boolean;
+    export function skipPartiallyEmittedExpressions(node: Expression): Expression;
+    export function skipPartiallyEmittedExpressions(node: Node): Node;
+    export function isNonNullChain(node: Node): node is NonNullChain;
+    export function isBreakOrContinueStatement(node: Node): node is BreakOrContinueStatement;
+    export function isNamedExportBindings(node: Node): node is NamedExportBindings;
+    export function isUnparsedTextLike(node: Node): node is UnparsedTextLike;
+    export function isUnparsedNode(node: Node): node is UnparsedNode;
+    export function isJSDocPropertyLikeTag(node: Node): node is JSDocPropertyLikeTag;
     /**
      * True if kind is of some token syntax kind.
      * For example, this is true for an IfKeyword but not for an IfStatement.
      * Literals are considered tokens, except TemplateLiteral, but does include TemplateHead/Middle/Tail.
      */
-    function isTokenKind(kind: SyntaxKind): boolean;
+    export function isTokenKind(kind: SyntaxKind): boolean;
     /**
      * True if node is of some token syntax kind.
      * For example, this is true for an IfKeyword but not for an IfStatement.
      * Literals are considered tokens, except TemplateLiteral, but does include TemplateHead/Middle/Tail.
      */
-    function isToken(n: Node): boolean;
-    function isLiteralExpression(node: Node): node is LiteralExpression;
-    function isTemplateLiteralToken(node: Node): node is TemplateLiteralToken;
-    function isTemplateMiddleOrTemplateTail(node: Node): node is TemplateMiddle | TemplateTail;
-    function isImportOrExportSpecifier(node: Node): node is ImportSpecifier | ExportSpecifier;
-    function isTypeOnlyImportOrExportDeclaration(node: Node): node is TypeOnlyAliasDeclaration;
-    function isAssertionKey(node: Node): node is AssertionKey;
-    function isStringTextContainingNode(node: Node): node is StringLiteral | TemplateLiteralToken;
-    function isModifier(node: Node): node is Modifier;
-    function isEntityName(node: Node): node is EntityName;
-    function isPropertyName(node: Node): node is PropertyName;
-    function isBindingName(node: Node): node is BindingName;
-    function isFunctionLike(node: Node | undefined): node is SignatureDeclaration;
-    function isClassElement(node: Node): node is ClassElement;
-    function isClassLike(node: Node): node is ClassLikeDeclaration;
-    function isAccessor(node: Node): node is AccessorDeclaration;
-    function isAutoAccessorPropertyDeclaration(node: Node): node is AutoAccessorPropertyDeclaration;
-    function isModifierLike(node: Node): node is ModifierLike;
-    function isTypeElement(node: Node): node is TypeElement;
-    function isClassOrTypeElement(node: Node): node is ClassElement | TypeElement;
-    function isObjectLiteralElementLike(node: Node): node is ObjectLiteralElementLike;
+    export function isToken(n: Node): boolean;
+    export function isLiteralExpression(node: Node): node is LiteralExpression;
+    export function isTemplateLiteralToken(node: Node): node is TemplateLiteralToken;
+    export function isTemplateMiddleOrTemplateTail(node: Node): node is TemplateMiddle | TemplateTail;
+    export function isImportOrExportSpecifier(node: Node): node is ImportSpecifier | ExportSpecifier;
+    export function isTypeOnlyImportOrExportDeclaration(node: Node): node is TypeOnlyAliasDeclaration;
+    export function isAssertionKey(node: Node): node is AssertionKey;
+    export function isStringTextContainingNode(node: Node): node is StringLiteral | TemplateLiteralToken;
+    export function isModifier(node: Node): node is Modifier;
+    export function isEntityName(node: Node): node is EntityName;
+    export function isPropertyName(node: Node): node is PropertyName;
+    export function isBindingName(node: Node): node is BindingName;
+    export function isFunctionLike(node: Node | undefined): node is SignatureDeclaration;
+    export function isClassElement(node: Node): node is ClassElement;
+    export function isClassLike(node: Node): node is ClassLikeDeclaration;
+    export function isAccessor(node: Node): node is AccessorDeclaration;
+    export function isAutoAccessorPropertyDeclaration(node: Node): node is AutoAccessorPropertyDeclaration;
+    export function isModifierLike(node: Node): node is ModifierLike;
+    export function isTypeElement(node: Node): node is TypeElement;
+    export function isClassOrTypeElement(node: Node): node is ClassElement | TypeElement;
+    export function isObjectLiteralElementLike(node: Node): node is ObjectLiteralElementLike;
     /**
      * Node test that determines whether a node is a valid type node.
      * This differs from the `isPartOfTypeNode` function which determines whether a node is *part*
      * of a TypeNode.
      */
-    function isTypeNode(node: Node): node is TypeNode;
-    function isFunctionOrConstructorTypeNode(node: Node): node is FunctionTypeNode | ConstructorTypeNode;
-    function isPropertyAccessOrQualifiedName(node: Node): node is PropertyAccessExpression | QualifiedName;
-    function isCallLikeExpression(node: Node): node is CallLikeExpression;
-    function isCallOrNewExpression(node: Node): node is CallExpression | NewExpression;
-    function isTemplateLiteral(node: Node): node is TemplateLiteral;
-    function isAssertionExpression(node: Node): node is AssertionExpression;
-    function isIterationStatement(node: Node, lookInLabeledStatements: false): node is IterationStatement;
-    function isIterationStatement(node: Node, lookInLabeledStatements: boolean): node is IterationStatement | LabeledStatement;
-    function isJsxOpeningLikeElement(node: Node): node is JsxOpeningLikeElement;
-    function isCaseOrDefaultClause(node: Node): node is CaseOrDefaultClause;
+    export function isTypeNode(node: Node): node is TypeNode;
+    export function isFunctionOrConstructorTypeNode(node: Node): node is FunctionTypeNode | ConstructorTypeNode;
+    export function isPropertyAccessOrQualifiedName(node: Node): node is PropertyAccessExpression | QualifiedName;
+    export function isCallLikeExpression(node: Node): node is CallLikeExpression;
+    export function isCallOrNewExpression(node: Node): node is CallExpression | NewExpression;
+    export function isTemplateLiteral(node: Node): node is TemplateLiteral;
+    export function isAssertionExpression(node: Node): node is AssertionExpression;
+    export function isIterationStatement(node: Node, lookInLabeledStatements: false): node is IterationStatement;
+    export function isIterationStatement(node: Node, lookInLabeledStatements: boolean): node is IterationStatement | LabeledStatement;
+    export function isJsxOpeningLikeElement(node: Node): node is JsxOpeningLikeElement;
+    export function isCaseOrDefaultClause(node: Node): node is CaseOrDefaultClause;
     /** True if node is of a kind that may contain comment text. */
-    function isJSDocCommentContainingNode(node: Node): boolean;
-    function isSetAccessor(node: Node): node is SetAccessorDeclaration;
-    function isGetAccessor(node: Node): node is GetAccessorDeclaration;
+    export function isJSDocCommentContainingNode(node: Node): boolean;
+    export function isSetAccessor(node: Node): node is SetAccessorDeclaration;
+    export function isGetAccessor(node: Node): node is GetAccessorDeclaration;
     /** True if has initializer node attached to it. */
-    function hasOnlyExpressionInitializer(node: Node): node is HasExpressionInitializer;
-    function isObjectLiteralElement(node: Node): node is ObjectLiteralElement;
-    function isStringLiteralLike(node: Node): node is StringLiteralLike;
-    function isJSDocLinkLike(node: Node): node is JSDocLink | JSDocLinkCode | JSDocLinkPlain;
-    function hasRestParameter(s: SignatureDeclaration | JSDocSignature): boolean;
-    function isRestParameter(node: ParameterDeclaration | JSDocParameterTag): boolean;
-}
-declare namespace ts {
-    const factory: NodeFactory;
-    function createUnparsedSourceFile(text: string): UnparsedSource;
-    function createUnparsedSourceFile(inputFile: InputFiles, type: "js" | "dts", stripInternal?: boolean): UnparsedSource;
-    function createUnparsedSourceFile(text: string, mapPath: string | undefined, map: string | undefined): UnparsedSource;
-    function createInputFiles(javascriptText: string, declarationText: string): InputFiles;
-    function createInputFiles(readFileText: (path: string) => string | undefined, javascriptPath: string, javascriptMapPath: string | undefined, declarationPath: string, declarationMapPath: string | undefined, buildInfoPath: string | undefined): InputFiles;
-    function createInputFiles(javascriptText: string, declarationText: string, javascriptMapPath: string | undefined, javascriptMapText: string | undefined, declarationMapPath: string | undefined, declarationMapText: string | undefined): InputFiles;
+    export function hasOnlyExpressionInitializer(node: Node): node is HasExpressionInitializer;
+    export function isObjectLiteralElement(node: Node): node is ObjectLiteralElement;
+    export function isStringLiteralLike(node: Node): node is StringLiteralLike;
+    export function isJSDocLinkLike(node: Node): node is JSDocLink | JSDocLinkCode | JSDocLinkPlain;
+    export function hasRestParameter(s: SignatureDeclaration | JSDocSignature): boolean;
+    export function isRestParameter(node: ParameterDeclaration | JSDocParameterTag): boolean;
+    export let unchangedTextChangeRange: TextChangeRange;
+    export type ParameterPropertyDeclaration = ParameterDeclaration & {
+        parent: ConstructorDeclaration;
+        name: Identifier;
+    };
+    export function createUnparsedSourceFile(text: string): UnparsedSource;
+    export function createUnparsedSourceFile(inputFile: InputFiles, type: "js" | "dts", stripInternal?: boolean): UnparsedSource;
+    export function createUnparsedSourceFile(text: string, mapPath: string | undefined, map: string | undefined): UnparsedSource;
+    export function createInputFiles(javascriptText: string, declarationText: string): InputFiles;
+    export function createInputFiles(readFileText: (path: string) => string | undefined, javascriptPath: string, javascriptMapPath: string | undefined, declarationPath: string, declarationMapPath: string | undefined, buildInfoPath: string | undefined): InputFiles;
+    export function createInputFiles(javascriptText: string, declarationText: string, javascriptMapPath: string | undefined, javascriptMapText: string | undefined, declarationMapPath: string | undefined, declarationMapText: string | undefined): InputFiles;
     /**
      * Create an external source map source file reference
      */
-    function createSourceMapSource(fileName: string, text: string, skipTrivia?: (pos: number) => number): SourceMapSource;
-    function setOriginalNode<T extends Node>(node: T, original: Node | undefined): T;
-}
-declare namespace ts {
+    export function createSourceMapSource(fileName: string, text: string, skipTrivia?: (pos: number) => number): SourceMapSource;
+    export function setOriginalNode<T extends Node>(node: T, original: Node | undefined): T;
+    export const factory: NodeFactory;
     /**
      * Clears any `EmitNode` entries from parse-tree nodes.
      * @param sourceFile A source file.
      */
-    function disposeEmitNodes(sourceFile: SourceFile | undefined): void;
+    export function disposeEmitNodes(sourceFile: SourceFile | undefined): void;
     /**
      * Sets flags that control emit behavior of a node.
      */
-    function setEmitFlags<T extends Node>(node: T, emitFlags: EmitFlags): T;
+    export function setEmitFlags<T extends Node>(node: T, emitFlags: EmitFlags): T;
     /**
      * Gets a custom text range to use when emitting source maps.
      */
-    function getSourceMapRange(node: Node): SourceMapRange;
+    export function getSourceMapRange(node: Node): SourceMapRange;
     /**
      * Sets a custom text range to use when emitting source maps.
      */
-    function setSourceMapRange<T extends Node>(node: T, range: SourceMapRange | undefined): T;
+    export function setSourceMapRange<T extends Node>(node: T, range: SourceMapRange | undefined): T;
     /**
      * Gets the TextRange to use for source maps for a token of a node.
      */
-    function getTokenSourceMapRange(node: Node, token: SyntaxKind): SourceMapRange | undefined;
+    export function getTokenSourceMapRange(node: Node, token: SyntaxKind): SourceMapRange | undefined;
     /**
      * Sets the TextRange to use for source maps for a token of a node.
      */
-    function setTokenSourceMapRange<T extends Node>(node: T, token: SyntaxKind, range: SourceMapRange | undefined): T;
+    export function setTokenSourceMapRange<T extends Node>(node: T, token: SyntaxKind, range: SourceMapRange | undefined): T;
     /**
      * Gets a custom text range to use when emitting comments.
      */
-    function getCommentRange(node: Node): TextRange;
+    export function getCommentRange(node: Node): TextRange;
     /**
      * Sets a custom text range to use when emitting comments.
      */
-    function setCommentRange<T extends Node>(node: T, range: TextRange): T;
-    function getSyntheticLeadingComments(node: Node): SynthesizedComment[] | undefined;
-    function setSyntheticLeadingComments<T extends Node>(node: T, comments: SynthesizedComment[] | undefined): T;
-    function addSyntheticLeadingComment<T extends Node>(node: T, kind: SyntaxKind.SingleLineCommentTrivia | SyntaxKind.MultiLineCommentTrivia, text: string, hasTrailingNewLine?: boolean): T;
-    function getSyntheticTrailingComments(node: Node): SynthesizedComment[] | undefined;
-    function setSyntheticTrailingComments<T extends Node>(node: T, comments: SynthesizedComment[] | undefined): T;
-    function addSyntheticTrailingComment<T extends Node>(node: T, kind: SyntaxKind.SingleLineCommentTrivia | SyntaxKind.MultiLineCommentTrivia, text: string, hasTrailingNewLine?: boolean): T;
-    function moveSyntheticComments<T extends Node>(node: T, original: Node): T;
+    export function setCommentRange<T extends Node>(node: T, range: TextRange): T;
+    export function getSyntheticLeadingComments(node: Node): SynthesizedComment[] | undefined;
+    export function setSyntheticLeadingComments<T extends Node>(node: T, comments: SynthesizedComment[] | undefined): T;
+    export function addSyntheticLeadingComment<T extends Node>(node: T, kind: SyntaxKind.SingleLineCommentTrivia | SyntaxKind.MultiLineCommentTrivia, text: string, hasTrailingNewLine?: boolean): T;
+    export function getSyntheticTrailingComments(node: Node): SynthesizedComment[] | undefined;
+    export function setSyntheticTrailingComments<T extends Node>(node: T, comments: SynthesizedComment[] | undefined): T;
+    export function addSyntheticTrailingComment<T extends Node>(node: T, kind: SyntaxKind.SingleLineCommentTrivia | SyntaxKind.MultiLineCommentTrivia, text: string, hasTrailingNewLine?: boolean): T;
+    export function moveSyntheticComments<T extends Node>(node: T, original: Node): T;
     /**
      * Gets the constant value to emit for an expression representing an enum.
      */
-    function getConstantValue(node: AccessExpression): string | number | undefined;
+    export function getConstantValue(node: AccessExpression): string | number | undefined;
     /**
      * Sets the constant value to emit for an expression.
      */
-    function setConstantValue(node: AccessExpression, value: string | number): AccessExpression;
+    export function setConstantValue(node: AccessExpression, value: string | number): AccessExpression;
     /**
      * Adds an EmitHelper to a node.
      */
-    function addEmitHelper<T extends Node>(node: T, helper: EmitHelper): T;
+    export function addEmitHelper<T extends Node>(node: T, helper: EmitHelper): T;
     /**
      * Add EmitHelpers to a node.
      */
-    function addEmitHelpers<T extends Node>(node: T, helpers: EmitHelper[] | undefined): T;
+    export function addEmitHelpers<T extends Node>(node: T, helpers: EmitHelper[] | undefined): T;
     /**
      * Removes an EmitHelper from a node.
      */
-    function removeEmitHelper(node: Node, helper: EmitHelper): boolean;
+    export function removeEmitHelper(node: Node, helper: EmitHelper): boolean;
     /**
      * Gets the EmitHelpers of a node.
      */
-    function getEmitHelpers(node: Node): EmitHelper[] | undefined;
+    export function getEmitHelpers(node: Node): EmitHelper[] | undefined;
     /**
      * Moves matching emit helpers from a source node to a target node.
      */
-    function moveEmitHelpers(source: Node, target: Node, predicate: (helper: EmitHelper) => boolean): void;
-}
-declare namespace ts {
-    function isNumericLiteral(node: Node): node is NumericLiteral;
-    function isBigIntLiteral(node: Node): node is BigIntLiteral;
-    function isStringLiteral(node: Node): node is StringLiteral;
-    function isJsxText(node: Node): node is JsxText;
-    function isRegularExpressionLiteral(node: Node): node is RegularExpressionLiteral;
-    function isNoSubstitutionTemplateLiteral(node: Node): node is NoSubstitutionTemplateLiteral;
-    function isTemplateHead(node: Node): node is TemplateHead;
-    function isTemplateMiddle(node: Node): node is TemplateMiddle;
-    function isTemplateTail(node: Node): node is TemplateTail;
-    function isDotDotDotToken(node: Node): node is DotDotDotToken;
-    function isPlusToken(node: Node): node is PlusToken;
-    function isMinusToken(node: Node): node is MinusToken;
-    function isAsteriskToken(node: Node): node is AsteriskToken;
-    function isIdentifier(node: Node): node is Identifier;
-    function isPrivateIdentifier(node: Node): node is PrivateIdentifier;
-    function isQualifiedName(node: Node): node is QualifiedName;
-    function isComputedPropertyName(node: Node): node is ComputedPropertyName;
-    function isTypeParameterDeclaration(node: Node): node is TypeParameterDeclaration;
-    function isParameter(node: Node): node is ParameterDeclaration;
-    function isDecorator(node: Node): node is Decorator;
-    function isPropertySignature(node: Node): node is PropertySignature;
-    function isPropertyDeclaration(node: Node): node is PropertyDeclaration;
-    function isMethodSignature(node: Node): node is MethodSignature;
-    function isMethodDeclaration(node: Node): node is MethodDeclaration;
-    function isClassStaticBlockDeclaration(node: Node): node is ClassStaticBlockDeclaration;
-    function isConstructorDeclaration(node: Node): node is ConstructorDeclaration;
-    function isGetAccessorDeclaration(node: Node): node is GetAccessorDeclaration;
-    function isSetAccessorDeclaration(node: Node): node is SetAccessorDeclaration;
-    function isCallSignatureDeclaration(node: Node): node is CallSignatureDeclaration;
-    function isConstructSignatureDeclaration(node: Node): node is ConstructSignatureDeclaration;
-    function isIndexSignatureDeclaration(node: Node): node is IndexSignatureDeclaration;
-    function isTypePredicateNode(node: Node): node is TypePredicateNode;
-    function isTypeReferenceNode(node: Node): node is TypeReferenceNode;
-    function isFunctionTypeNode(node: Node): node is FunctionTypeNode;
-    function isConstructorTypeNode(node: Node): node is ConstructorTypeNode;
-    function isTypeQueryNode(node: Node): node is TypeQueryNode;
-    function isTypeLiteralNode(node: Node): node is TypeLiteralNode;
-    function isArrayTypeNode(node: Node): node is ArrayTypeNode;
-    function isTupleTypeNode(node: Node): node is TupleTypeNode;
-    function isNamedTupleMember(node: Node): node is NamedTupleMember;
-    function isOptionalTypeNode(node: Node): node is OptionalTypeNode;
-    function isRestTypeNode(node: Node): node is RestTypeNode;
-    function isUnionTypeNode(node: Node): node is UnionTypeNode;
-    function isIntersectionTypeNode(node: Node): node is IntersectionTypeNode;
-    function isConditionalTypeNode(node: Node): node is ConditionalTypeNode;
-    function isInferTypeNode(node: Node): node is InferTypeNode;
-    function isParenthesizedTypeNode(node: Node): node is ParenthesizedTypeNode;
-    function isThisTypeNode(node: Node): node is ThisTypeNode;
-    function isTypeOperatorNode(node: Node): node is TypeOperatorNode;
-    function isIndexedAccessTypeNode(node: Node): node is IndexedAccessTypeNode;
-    function isMappedTypeNode(node: Node): node is MappedTypeNode;
-    function isLiteralTypeNode(node: Node): node is LiteralTypeNode;
-    function isImportTypeNode(node: Node): node is ImportTypeNode;
-    function isTemplateLiteralTypeSpan(node: Node): node is TemplateLiteralTypeSpan;
-    function isTemplateLiteralTypeNode(node: Node): node is TemplateLiteralTypeNode;
-    function isObjectBindingPattern(node: Node): node is ObjectBindingPattern;
-    function isArrayBindingPattern(node: Node): node is ArrayBindingPattern;
-    function isBindingElement(node: Node): node is BindingElement;
-    function isArrayLiteralExpression(node: Node): node is ArrayLiteralExpression;
-    function isObjectLiteralExpression(node: Node): node is ObjectLiteralExpression;
-    function isPropertyAccessExpression(node: Node): node is PropertyAccessExpression;
-    function isElementAccessExpression(node: Node): node is ElementAccessExpression;
-    function isCallExpression(node: Node): node is CallExpression;
-    function isNewExpression(node: Node): node is NewExpression;
-    function isTaggedTemplateExpression(node: Node): node is TaggedTemplateExpression;
-    function isTypeAssertionExpression(node: Node): node is TypeAssertion;
-    function isParenthesizedExpression(node: Node): node is ParenthesizedExpression;
-    function isFunctionExpression(node: Node): node is FunctionExpression;
-    function isArrowFunction(node: Node): node is ArrowFunction;
-    function isDeleteExpression(node: Node): node is DeleteExpression;
-    function isTypeOfExpression(node: Node): node is TypeOfExpression;
-    function isVoidExpression(node: Node): node is VoidExpression;
-    function isAwaitExpression(node: Node): node is AwaitExpression;
-    function isPrefixUnaryExpression(node: Node): node is PrefixUnaryExpression;
-    function isPostfixUnaryExpression(node: Node): node is PostfixUnaryExpression;
-    function isBinaryExpression(node: Node): node is BinaryExpression;
-    function isConditionalExpression(node: Node): node is ConditionalExpression;
-    function isTemplateExpression(node: Node): node is TemplateExpression;
-    function isYieldExpression(node: Node): node is YieldExpression;
-    function isSpreadElement(node: Node): node is SpreadElement;
-    function isClassExpression(node: Node): node is ClassExpression;
-    function isOmittedExpression(node: Node): node is OmittedExpression;
-    function isExpressionWithTypeArguments(node: Node): node is ExpressionWithTypeArguments;
-    function isAsExpression(node: Node): node is AsExpression;
-    function isSatisfiesExpression(node: Node): node is SatisfiesExpression;
-    function isNonNullExpression(node: Node): node is NonNullExpression;
-    function isMetaProperty(node: Node): node is MetaProperty;
-    function isSyntheticExpression(node: Node): node is SyntheticExpression;
-    function isPartiallyEmittedExpression(node: Node): node is PartiallyEmittedExpression;
-    function isCommaListExpression(node: Node): node is CommaListExpression;
-    function isTemplateSpan(node: Node): node is TemplateSpan;
-    function isSemicolonClassElement(node: Node): node is SemicolonClassElement;
-    function isBlock(node: Node): node is Block;
-    function isVariableStatement(node: Node): node is VariableStatement;
-    function isEmptyStatement(node: Node): node is EmptyStatement;
-    function isExpressionStatement(node: Node): node is ExpressionStatement;
-    function isIfStatement(node: Node): node is IfStatement;
-    function isDoStatement(node: Node): node is DoStatement;
-    function isWhileStatement(node: Node): node is WhileStatement;
-    function isForStatement(node: Node): node is ForStatement;
-    function isForInStatement(node: Node): node is ForInStatement;
-    function isForOfStatement(node: Node): node is ForOfStatement;
-    function isContinueStatement(node: Node): node is ContinueStatement;
-    function isBreakStatement(node: Node): node is BreakStatement;
-    function isReturnStatement(node: Node): node is ReturnStatement;
-    function isWithStatement(node: Node): node is WithStatement;
-    function isSwitchStatement(node: Node): node is SwitchStatement;
-    function isLabeledStatement(node: Node): node is LabeledStatement;
-    function isThrowStatement(node: Node): node is ThrowStatement;
-    function isTryStatement(node: Node): node is TryStatement;
-    function isDebuggerStatement(node: Node): node is DebuggerStatement;
-    function isVariableDeclaration(node: Node): node is VariableDeclaration;
-    function isVariableDeclarationList(node: Node): node is VariableDeclarationList;
-    function isFunctionDeclaration(node: Node): node is FunctionDeclaration;
-    function isClassDeclaration(node: Node): node is ClassDeclaration;
-    function isInterfaceDeclaration(node: Node): node is InterfaceDeclaration;
-    function isTypeAliasDeclaration(node: Node): node is TypeAliasDeclaration;
-    function isEnumDeclaration(node: Node): node is EnumDeclaration;
-    function isModuleDeclaration(node: Node): node is ModuleDeclaration;
-    function isModuleBlock(node: Node): node is ModuleBlock;
-    function isCaseBlock(node: Node): node is CaseBlock;
-    function isNamespaceExportDeclaration(node: Node): node is NamespaceExportDeclaration;
-    function isImportEqualsDeclaration(node: Node): node is ImportEqualsDeclaration;
-    function isImportDeclaration(node: Node): node is ImportDeclaration;
-    function isImportClause(node: Node): node is ImportClause;
-    function isImportTypeAssertionContainer(node: Node): node is ImportTypeAssertionContainer;
-    function isAssertClause(node: Node): node is AssertClause;
-    function isAssertEntry(node: Node): node is AssertEntry;
-    function isNamespaceImport(node: Node): node is NamespaceImport;
-    function isNamespaceExport(node: Node): node is NamespaceExport;
-    function isNamedImports(node: Node): node is NamedImports;
-    function isImportSpecifier(node: Node): node is ImportSpecifier;
-    function isExportAssignment(node: Node): node is ExportAssignment;
-    function isExportDeclaration(node: Node): node is ExportDeclaration;
-    function isNamedExports(node: Node): node is NamedExports;
-    function isExportSpecifier(node: Node): node is ExportSpecifier;
-    function isMissingDeclaration(node: Node): node is MissingDeclaration;
-    function isNotEmittedStatement(node: Node): node is NotEmittedStatement;
-    function isExternalModuleReference(node: Node): node is ExternalModuleReference;
-    function isJsxElement(node: Node): node is JsxElement;
-    function isJsxSelfClosingElement(node: Node): node is JsxSelfClosingElement;
-    function isJsxOpeningElement(node: Node): node is JsxOpeningElement;
-    function isJsxClosingElement(node: Node): node is JsxClosingElement;
-    function isJsxFragment(node: Node): node is JsxFragment;
-    function isJsxOpeningFragment(node: Node): node is JsxOpeningFragment;
-    function isJsxClosingFragment(node: Node): node is JsxClosingFragment;
-    function isJsxAttribute(node: Node): node is JsxAttribute;
-    function isJsxAttributes(node: Node): node is JsxAttributes;
-    function isJsxSpreadAttribute(node: Node): node is JsxSpreadAttribute;
-    function isJsxExpression(node: Node): node is JsxExpression;
-    function isCaseClause(node: Node): node is CaseClause;
-    function isDefaultClause(node: Node): node is DefaultClause;
-    function isHeritageClause(node: Node): node is HeritageClause;
-    function isCatchClause(node: Node): node is CatchClause;
-    function isPropertyAssignment(node: Node): node is PropertyAssignment;
-    function isShorthandPropertyAssignment(node: Node): node is ShorthandPropertyAssignment;
-    function isSpreadAssignment(node: Node): node is SpreadAssignment;
-    function isEnumMember(node: Node): node is EnumMember;
-    function isUnparsedPrepend(node: Node): node is UnparsedPrepend;
-    function isSourceFile(node: Node): node is SourceFile;
-    function isBundle(node: Node): node is Bundle;
-    function isUnparsedSource(node: Node): node is UnparsedSource;
-    function isJSDocTypeExpression(node: Node): node is JSDocTypeExpression;
-    function isJSDocNameReference(node: Node): node is JSDocNameReference;
-    function isJSDocMemberName(node: Node): node is JSDocMemberName;
-    function isJSDocLink(node: Node): node is JSDocLink;
-    function isJSDocLinkCode(node: Node): node is JSDocLinkCode;
-    function isJSDocLinkPlain(node: Node): node is JSDocLinkPlain;
-    function isJSDocAllType(node: Node): node is JSDocAllType;
-    function isJSDocUnknownType(node: Node): node is JSDocUnknownType;
-    function isJSDocNullableType(node: Node): node is JSDocNullableType;
-    function isJSDocNonNullableType(node: Node): node is JSDocNonNullableType;
-    function isJSDocOptionalType(node: Node): node is JSDocOptionalType;
-    function isJSDocFunctionType(node: Node): node is JSDocFunctionType;
-    function isJSDocVariadicType(node: Node): node is JSDocVariadicType;
-    function isJSDocNamepathType(node: Node): node is JSDocNamepathType;
-    function isJSDoc(node: Node): node is JSDoc;
-    function isJSDocTypeLiteral(node: Node): node is JSDocTypeLiteral;
-    function isJSDocSignature(node: Node): node is JSDocSignature;
-    function isJSDocAugmentsTag(node: Node): node is JSDocAugmentsTag;
-    function isJSDocAuthorTag(node: Node): node is JSDocAuthorTag;
-    function isJSDocClassTag(node: Node): node is JSDocClassTag;
-    function isJSDocCallbackTag(node: Node): node is JSDocCallbackTag;
-    function isJSDocPublicTag(node: Node): node is JSDocPublicTag;
-    function isJSDocPrivateTag(node: Node): node is JSDocPrivateTag;
-    function isJSDocProtectedTag(node: Node): node is JSDocProtectedTag;
-    function isJSDocReadonlyTag(node: Node): node is JSDocReadonlyTag;
-    function isJSDocOverrideTag(node: Node): node is JSDocOverrideTag;
-    function isJSDocDeprecatedTag(node: Node): node is JSDocDeprecatedTag;
-    function isJSDocSeeTag(node: Node): node is JSDocSeeTag;
-    function isJSDocEnumTag(node: Node): node is JSDocEnumTag;
-    function isJSDocParameterTag(node: Node): node is JSDocParameterTag;
-    function isJSDocReturnTag(node: Node): node is JSDocReturnTag;
-    function isJSDocThisTag(node: Node): node is JSDocThisTag;
-    function isJSDocTypeTag(node: Node): node is JSDocTypeTag;
-    function isJSDocTemplateTag(node: Node): node is JSDocTemplateTag;
-    function isJSDocTypedefTag(node: Node): node is JSDocTypedefTag;
-    function isJSDocUnknownTag(node: Node): node is JSDocUnknownTag;
-    function isJSDocPropertyTag(node: Node): node is JSDocPropertyTag;
-    function isJSDocImplementsTag(node: Node): node is JSDocImplementsTag;
-}
-declare namespace ts {
-    function setTextRange<T extends TextRange>(range: T, location: TextRange | undefined): T;
-    function canHaveModifiers(node: Node): node is HasModifiers;
-    function canHaveDecorators(node: Node): node is HasDecorators;
-}
-declare namespace ts {
+    export function moveEmitHelpers(source: Node, target: Node, predicate: (helper: EmitHelper) => boolean): void;
+    export function isNumericLiteral(node: Node): node is NumericLiteral;
+    export function isBigIntLiteral(node: Node): node is BigIntLiteral;
+    export function isStringLiteral(node: Node): node is StringLiteral;
+    export function isJsxText(node: Node): node is JsxText;
+    export function isRegularExpressionLiteral(node: Node): node is RegularExpressionLiteral;
+    export function isNoSubstitutionTemplateLiteral(node: Node): node is NoSubstitutionTemplateLiteral;
+    export function isTemplateHead(node: Node): node is TemplateHead;
+    export function isTemplateMiddle(node: Node): node is TemplateMiddle;
+    export function isTemplateTail(node: Node): node is TemplateTail;
+    export function isDotDotDotToken(node: Node): node is DotDotDotToken;
+    export function isPlusToken(node: Node): node is PlusToken;
+    export function isMinusToken(node: Node): node is MinusToken;
+    export function isAsteriskToken(node: Node): node is AsteriskToken;
+    export function isIdentifier(node: Node): node is Identifier;
+    export function isPrivateIdentifier(node: Node): node is PrivateIdentifier;
+    export function isQualifiedName(node: Node): node is QualifiedName;
+    export function isComputedPropertyName(node: Node): node is ComputedPropertyName;
+    export function isTypeParameterDeclaration(node: Node): node is TypeParameterDeclaration;
+    export function isParameter(node: Node): node is ParameterDeclaration;
+    export function isDecorator(node: Node): node is Decorator;
+    export function isPropertySignature(node: Node): node is PropertySignature;
+    export function isPropertyDeclaration(node: Node): node is PropertyDeclaration;
+    export function isMethodSignature(node: Node): node is MethodSignature;
+    export function isMethodDeclaration(node: Node): node is MethodDeclaration;
+    export function isClassStaticBlockDeclaration(node: Node): node is ClassStaticBlockDeclaration;
+    export function isConstructorDeclaration(node: Node): node is ConstructorDeclaration;
+    export function isGetAccessorDeclaration(node: Node): node is GetAccessorDeclaration;
+    export function isSetAccessorDeclaration(node: Node): node is SetAccessorDeclaration;
+    export function isCallSignatureDeclaration(node: Node): node is CallSignatureDeclaration;
+    export function isConstructSignatureDeclaration(node: Node): node is ConstructSignatureDeclaration;
+    export function isIndexSignatureDeclaration(node: Node): node is IndexSignatureDeclaration;
+    export function isTypePredicateNode(node: Node): node is TypePredicateNode;
+    export function isTypeReferenceNode(node: Node): node is TypeReferenceNode;
+    export function isFunctionTypeNode(node: Node): node is FunctionTypeNode;
+    export function isConstructorTypeNode(node: Node): node is ConstructorTypeNode;
+    export function isTypeQueryNode(node: Node): node is TypeQueryNode;
+    export function isTypeLiteralNode(node: Node): node is TypeLiteralNode;
+    export function isArrayTypeNode(node: Node): node is ArrayTypeNode;
+    export function isTupleTypeNode(node: Node): node is TupleTypeNode;
+    export function isNamedTupleMember(node: Node): node is NamedTupleMember;
+    export function isOptionalTypeNode(node: Node): node is OptionalTypeNode;
+    export function isRestTypeNode(node: Node): node is RestTypeNode;
+    export function isUnionTypeNode(node: Node): node is UnionTypeNode;
+    export function isIntersectionTypeNode(node: Node): node is IntersectionTypeNode;
+    export function isConditionalTypeNode(node: Node): node is ConditionalTypeNode;
+    export function isInferTypeNode(node: Node): node is InferTypeNode;
+    export function isParenthesizedTypeNode(node: Node): node is ParenthesizedTypeNode;
+    export function isThisTypeNode(node: Node): node is ThisTypeNode;
+    export function isTypeOperatorNode(node: Node): node is TypeOperatorNode;
+    export function isIndexedAccessTypeNode(node: Node): node is IndexedAccessTypeNode;
+    export function isMappedTypeNode(node: Node): node is MappedTypeNode;
+    export function isLiteralTypeNode(node: Node): node is LiteralTypeNode;
+    export function isImportTypeNode(node: Node): node is ImportTypeNode;
+    export function isTemplateLiteralTypeSpan(node: Node): node is TemplateLiteralTypeSpan;
+    export function isTemplateLiteralTypeNode(node: Node): node is TemplateLiteralTypeNode;
+    export function isObjectBindingPattern(node: Node): node is ObjectBindingPattern;
+    export function isArrayBindingPattern(node: Node): node is ArrayBindingPattern;
+    export function isBindingElement(node: Node): node is BindingElement;
+    export function isArrayLiteralExpression(node: Node): node is ArrayLiteralExpression;
+    export function isObjectLiteralExpression(node: Node): node is ObjectLiteralExpression;
+    export function isPropertyAccessExpression(node: Node): node is PropertyAccessExpression;
+    export function isElementAccessExpression(node: Node): node is ElementAccessExpression;
+    export function isCallExpression(node: Node): node is CallExpression;
+    export function isNewExpression(node: Node): node is NewExpression;
+    export function isTaggedTemplateExpression(node: Node): node is TaggedTemplateExpression;
+    export function isTypeAssertionExpression(node: Node): node is TypeAssertion;
+    export function isParenthesizedExpression(node: Node): node is ParenthesizedExpression;
+    export function isFunctionExpression(node: Node): node is FunctionExpression;
+    export function isArrowFunction(node: Node): node is ArrowFunction;
+    export function isDeleteExpression(node: Node): node is DeleteExpression;
+    export function isTypeOfExpression(node: Node): node is TypeOfExpression;
+    export function isVoidExpression(node: Node): node is VoidExpression;
+    export function isAwaitExpression(node: Node): node is AwaitExpression;
+    export function isPrefixUnaryExpression(node: Node): node is PrefixUnaryExpression;
+    export function isPostfixUnaryExpression(node: Node): node is PostfixUnaryExpression;
+    export function isBinaryExpression(node: Node): node is BinaryExpression;
+    export function isConditionalExpression(node: Node): node is ConditionalExpression;
+    export function isTemplateExpression(node: Node): node is TemplateExpression;
+    export function isYieldExpression(node: Node): node is YieldExpression;
+    export function isSpreadElement(node: Node): node is SpreadElement;
+    export function isClassExpression(node: Node): node is ClassExpression;
+    export function isOmittedExpression(node: Node): node is OmittedExpression;
+    export function isExpressionWithTypeArguments(node: Node): node is ExpressionWithTypeArguments;
+    export function isAsExpression(node: Node): node is AsExpression;
+    export function isSatisfiesExpression(node: Node): node is SatisfiesExpression;
+    export function isNonNullExpression(node: Node): node is NonNullExpression;
+    export function isMetaProperty(node: Node): node is MetaProperty;
+    export function isSyntheticExpression(node: Node): node is SyntheticExpression;
+    export function isPartiallyEmittedExpression(node: Node): node is PartiallyEmittedExpression;
+    export function isCommaListExpression(node: Node): node is CommaListExpression;
+    export function isTemplateSpan(node: Node): node is TemplateSpan;
+    export function isSemicolonClassElement(node: Node): node is SemicolonClassElement;
+    export function isBlock(node: Node): node is Block;
+    export function isVariableStatement(node: Node): node is VariableStatement;
+    export function isEmptyStatement(node: Node): node is EmptyStatement;
+    export function isExpressionStatement(node: Node): node is ExpressionStatement;
+    export function isIfStatement(node: Node): node is IfStatement;
+    export function isDoStatement(node: Node): node is DoStatement;
+    export function isWhileStatement(node: Node): node is WhileStatement;
+    export function isForStatement(node: Node): node is ForStatement;
+    export function isForInStatement(node: Node): node is ForInStatement;
+    export function isForOfStatement(node: Node): node is ForOfStatement;
+    export function isContinueStatement(node: Node): node is ContinueStatement;
+    export function isBreakStatement(node: Node): node is BreakStatement;
+    export function isReturnStatement(node: Node): node is ReturnStatement;
+    export function isWithStatement(node: Node): node is WithStatement;
+    export function isSwitchStatement(node: Node): node is SwitchStatement;
+    export function isLabeledStatement(node: Node): node is LabeledStatement;
+    export function isThrowStatement(node: Node): node is ThrowStatement;
+    export function isTryStatement(node: Node): node is TryStatement;
+    export function isDebuggerStatement(node: Node): node is DebuggerStatement;
+    export function isVariableDeclaration(node: Node): node is VariableDeclaration;
+    export function isVariableDeclarationList(node: Node): node is VariableDeclarationList;
+    export function isFunctionDeclaration(node: Node): node is FunctionDeclaration;
+    export function isClassDeclaration(node: Node): node is ClassDeclaration;
+    export function isInterfaceDeclaration(node: Node): node is InterfaceDeclaration;
+    export function isTypeAliasDeclaration(node: Node): node is TypeAliasDeclaration;
+    export function isEnumDeclaration(node: Node): node is EnumDeclaration;
+    export function isModuleDeclaration(node: Node): node is ModuleDeclaration;
+    export function isModuleBlock(node: Node): node is ModuleBlock;
+    export function isCaseBlock(node: Node): node is CaseBlock;
+    export function isNamespaceExportDeclaration(node: Node): node is NamespaceExportDeclaration;
+    export function isImportEqualsDeclaration(node: Node): node is ImportEqualsDeclaration;
+    export function isImportDeclaration(node: Node): node is ImportDeclaration;
+    export function isImportClause(node: Node): node is ImportClause;
+    export function isImportTypeAssertionContainer(node: Node): node is ImportTypeAssertionContainer;
+    export function isAssertClause(node: Node): node is AssertClause;
+    export function isAssertEntry(node: Node): node is AssertEntry;
+    export function isNamespaceImport(node: Node): node is NamespaceImport;
+    export function isNamespaceExport(node: Node): node is NamespaceExport;
+    export function isNamedImports(node: Node): node is NamedImports;
+    export function isImportSpecifier(node: Node): node is ImportSpecifier;
+    export function isExportAssignment(node: Node): node is ExportAssignment;
+    export function isExportDeclaration(node: Node): node is ExportDeclaration;
+    export function isNamedExports(node: Node): node is NamedExports;
+    export function isExportSpecifier(node: Node): node is ExportSpecifier;
+    export function isMissingDeclaration(node: Node): node is MissingDeclaration;
+    export function isNotEmittedStatement(node: Node): node is NotEmittedStatement;
+    export function isExternalModuleReference(node: Node): node is ExternalModuleReference;
+    export function isJsxElement(node: Node): node is JsxElement;
+    export function isJsxSelfClosingElement(node: Node): node is JsxSelfClosingElement;
+    export function isJsxOpeningElement(node: Node): node is JsxOpeningElement;
+    export function isJsxClosingElement(node: Node): node is JsxClosingElement;
+    export function isJsxFragment(node: Node): node is JsxFragment;
+    export function isJsxOpeningFragment(node: Node): node is JsxOpeningFragment;
+    export function isJsxClosingFragment(node: Node): node is JsxClosingFragment;
+    export function isJsxAttribute(node: Node): node is JsxAttribute;
+    export function isJsxAttributes(node: Node): node is JsxAttributes;
+    export function isJsxSpreadAttribute(node: Node): node is JsxSpreadAttribute;
+    export function isJsxExpression(node: Node): node is JsxExpression;
+    export function isCaseClause(node: Node): node is CaseClause;
+    export function isDefaultClause(node: Node): node is DefaultClause;
+    export function isHeritageClause(node: Node): node is HeritageClause;
+    export function isCatchClause(node: Node): node is CatchClause;
+    export function isPropertyAssignment(node: Node): node is PropertyAssignment;
+    export function isShorthandPropertyAssignment(node: Node): node is ShorthandPropertyAssignment;
+    export function isSpreadAssignment(node: Node): node is SpreadAssignment;
+    export function isEnumMember(node: Node): node is EnumMember;
+    export function isUnparsedPrepend(node: Node): node is UnparsedPrepend;
+    export function isSourceFile(node: Node): node is SourceFile;
+    export function isBundle(node: Node): node is Bundle;
+    export function isUnparsedSource(node: Node): node is UnparsedSource;
+    export function isJSDocTypeExpression(node: Node): node is JSDocTypeExpression;
+    export function isJSDocNameReference(node: Node): node is JSDocNameReference;
+    export function isJSDocMemberName(node: Node): node is JSDocMemberName;
+    export function isJSDocLink(node: Node): node is JSDocLink;
+    export function isJSDocLinkCode(node: Node): node is JSDocLinkCode;
+    export function isJSDocLinkPlain(node: Node): node is JSDocLinkPlain;
+    export function isJSDocAllType(node: Node): node is JSDocAllType;
+    export function isJSDocUnknownType(node: Node): node is JSDocUnknownType;
+    export function isJSDocNullableType(node: Node): node is JSDocNullableType;
+    export function isJSDocNonNullableType(node: Node): node is JSDocNonNullableType;
+    export function isJSDocOptionalType(node: Node): node is JSDocOptionalType;
+    export function isJSDocFunctionType(node: Node): node is JSDocFunctionType;
+    export function isJSDocVariadicType(node: Node): node is JSDocVariadicType;
+    export function isJSDocNamepathType(node: Node): node is JSDocNamepathType;
+    export function isJSDoc(node: Node): node is JSDoc;
+    export function isJSDocTypeLiteral(node: Node): node is JSDocTypeLiteral;
+    export function isJSDocSignature(node: Node): node is JSDocSignature;
+    export function isJSDocAugmentsTag(node: Node): node is JSDocAugmentsTag;
+    export function isJSDocAuthorTag(node: Node): node is JSDocAuthorTag;
+    export function isJSDocClassTag(node: Node): node is JSDocClassTag;
+    export function isJSDocCallbackTag(node: Node): node is JSDocCallbackTag;
+    export function isJSDocPublicTag(node: Node): node is JSDocPublicTag;
+    export function isJSDocPrivateTag(node: Node): node is JSDocPrivateTag;
+    export function isJSDocProtectedTag(node: Node): node is JSDocProtectedTag;
+    export function isJSDocReadonlyTag(node: Node): node is JSDocReadonlyTag;
+    export function isJSDocOverrideTag(node: Node): node is JSDocOverrideTag;
+    export function isJSDocDeprecatedTag(node: Node): node is JSDocDeprecatedTag;
+    export function isJSDocSeeTag(node: Node): node is JSDocSeeTag;
+    export function isJSDocEnumTag(node: Node): node is JSDocEnumTag;
+    export function isJSDocParameterTag(node: Node): node is JSDocParameterTag;
+    export function isJSDocReturnTag(node: Node): node is JSDocReturnTag;
+    export function isJSDocThisTag(node: Node): node is JSDocThisTag;
+    export function isJSDocTypeTag(node: Node): node is JSDocTypeTag;
+    export function isJSDocTemplateTag(node: Node): node is JSDocTemplateTag;
+    export function isJSDocTypedefTag(node: Node): node is JSDocTypedefTag;
+    export function isJSDocUnknownTag(node: Node): node is JSDocUnknownTag;
+    export function isJSDocPropertyTag(node: Node): node is JSDocPropertyTag;
+    export function isJSDocImplementsTag(node: Node): node is JSDocImplementsTag;
+    export function setTextRange<T extends TextRange>(range: T, location: TextRange | undefined): T;
+    export function canHaveModifiers(node: Node): node is HasModifiers;
+    export function canHaveDecorators(node: Node): node is HasDecorators;
     /**
      * Invokes a callback for each child of the given node. The 'cbNode' callback is invoked for all child nodes
      * stored in properties. If a 'cbNodes' callback is specified, it is invoked for embedded arrays; otherwise,
@@ -4875,6 +9094,16 @@ declare namespace ts {
      * that they appear in the source code. The language service depends on this property to locate nodes by position.
      */
     export function forEachChild<T>(node: Node, cbNode: (node: Node) => T | undefined, cbNodes?: (nodes: NodeArray<Node>) => T | undefined): T | undefined;
+    export function createSourceFile(fileName: string, sourceText: string, languageVersionOrOptions: ScriptTarget | CreateSourceFileOptions, setParentNodes?: boolean, scriptKind?: ScriptKind): SourceFile;
+    export function parseIsolatedEntityName(text: string, languageVersion: ScriptTarget): EntityName | undefined;
+    /**
+     * Parse json text into SyntaxTree and return node and parse errors if any
+     * @param fileName
+     * @param sourceText
+     */
+    export function parseJsonText(fileName: string, sourceText: string): JsonSourceFile;
+    export function isExternalModule(file: SourceFile): boolean;
+    export function updateSourceFile(sourceFile: SourceFile, newText: string, textChangeRange: TextChangeRange, aggressiveChecks?: boolean): SourceFile;
     export interface CreateSourceFileOptions {
         languageVersion: ScriptTarget;
         /**
@@ -4890,38 +9119,9 @@ declare namespace ts {
          */
         setExternalModuleIndicator?: (file: SourceFile) => void;
     }
-    export function createSourceFile(fileName: string, sourceText: string, languageVersionOrOptions: ScriptTarget | CreateSourceFileOptions, setParentNodes?: boolean, scriptKind?: ScriptKind): SourceFile;
-    export function parseIsolatedEntityName(text: string, languageVersion: ScriptTarget): EntityName | undefined;
+    export function parseCommandLine(commandLine: readonly string[], readFile?: (path: string) => string | undefined): ParsedCommandLine;
     /**
-     * Parse json text into SyntaxTree and return node and parse errors if any
-     * @param fileName
-     * @param sourceText
-     */
-    export function parseJsonText(fileName: string, sourceText: string): JsonSourceFile;
-    export function isExternalModule(file: SourceFile): boolean;
-    export function updateSourceFile(sourceFile: SourceFile, newText: string, textChangeRange: TextChangeRange, aggressiveChecks?: boolean): SourceFile;
-    export {};
-}
-declare namespace ts {
-    export function parseCommandLine(commandLine: readonly string[], readFile?: (path: string) => string | undefined): ParsedCommandLine;
-    export type DiagnosticReporter = (diagnostic: Diagnostic) => void;
-    /**
-     * Reports config file diagnostics
-     */
-    export interface ConfigFileDiagnosticsReporter {
-        /**
-         * Reports unrecoverable error when parsing config file
-         */
-        onUnRecoverableConfigFileDiagnostic: DiagnosticReporter;
-    }
-    /**
-     * Interface extending ParseConfigHost to support ParseConfigFile that reads config file and reports errors
-     */
-    export interface ParseConfigFileHost extends ParseConfigHost, ConfigFileDiagnosticsReporter {
-        getCurrentDirectory(): string;
-    }
-    /**
-     * Reads the config file, reports errors if any and exits if the config file cannot be found
+     * Reads the config file, reports errors if any and exits if the config file cannot be found
      */
     export function getParsedCommandLineOfConfigFile(configFileName: string, optionsToExtend: CompilerOptions | undefined, host: ParseConfigFileHost, extendedConfigCache?: Map<ExtendedConfigCacheEntry>, watchOptionsToExtend?: WatchOptions, extraFileExtensions?: readonly FileExtensionInfo[]): ParsedCommandLine | undefined;
     /**
@@ -4966,6 +9166,30 @@ declare namespace ts {
      *    file to. e.g. outDir
      */
     export function parseJsonSourceFileConfigFileContent(sourceFile: TsConfigSourceFile, host: ParseConfigHost, basePath: string, existingOptions?: CompilerOptions, configFileName?: string, resolutionStack?: Path[], extraFileExtensions?: readonly FileExtensionInfo[], extendedConfigCache?: Map<ExtendedConfigCacheEntry>, existingWatchOptions?: WatchOptions): ParsedCommandLine;
+    export function convertCompilerOptionsFromJson(jsonOptions: any, basePath: string, configFileName?: string): {
+        options: CompilerOptions;
+        errors: Diagnostic[];
+    };
+    export function convertTypeAcquisitionFromJson(jsonOptions: any, basePath: string, configFileName?: string): {
+        options: TypeAcquisition;
+        errors: Diagnostic[];
+    };
+    export type DiagnosticReporter = (diagnostic: Diagnostic) => void;
+    /**
+     * Reports config file diagnostics
+     */
+    export interface ConfigFileDiagnosticsReporter {
+        /**
+         * Reports unrecoverable error when parsing config file
+         */
+        onUnRecoverableConfigFileDiagnostic: DiagnosticReporter;
+    }
+    /**
+     * Interface extending ParseConfigHost to support ParseConfigFile that reads config file and reports errors
+     */
+    export interface ParseConfigFileHost extends ParseConfigHost, ConfigFileDiagnosticsReporter {
+        getCurrentDirectory(): string;
+    }
     export interface ParsedTsconfig {
         raw: any;
         options?: CompilerOptions;
@@ -4980,17 +9204,6 @@ declare namespace ts {
         extendedResult: TsConfigSourceFile;
         extendedConfig: ParsedTsconfig | undefined;
     }
-    export function convertCompilerOptionsFromJson(jsonOptions: any, basePath: string, configFileName?: string): {
-        options: CompilerOptions;
-        errors: Diagnostic[];
-    };
-    export function convertTypeAcquisitionFromJson(jsonOptions: any, basePath: string, configFileName?: string): {
-        options: TypeAcquisition;
-        errors: Diagnostic[];
-    };
-    export {};
-}
-declare namespace ts {
     export function getEffectiveTypeRoots(options: CompilerOptions, host: GetEffectiveTypeRootsHost): string[] | undefined;
     /**
      * @param {string | undefined} containingFile - file that contains type reference directive, can be undefined if containing file is unknown.
@@ -5007,6 +9220,12 @@ declare namespace ts {
      *   this list is only the set of defaults that are implicitly included.
      */
     export function getAutomaticTypeDirectiveNames(options: CompilerOptions, host: ModuleResolutionHost): string[];
+    export function createModuleResolutionCache(currentDirectory: string, getCanonicalFileName: (s: string) => string, options?: CompilerOptions): ModuleResolutionCache;
+    export function createTypeReferenceDirectiveResolutionCache(currentDirectory: string, getCanonicalFileName: (s: string) => string, options?: CompilerOptions, packageJsonInfoCache?: PackageJsonInfoCache): TypeReferenceDirectiveResolutionCache;
+    export function resolveModuleNameFromCache(moduleName: string, containingFile: string, cache: ModuleResolutionCache, mode?: ModuleKind.CommonJS | ModuleKind.ESNext): ResolvedModuleWithFailedLookupLocations | undefined;
+    export function resolveModuleName(moduleName: string, containingFile: string, compilerOptions: CompilerOptions, host: ModuleResolutionHost, cache?: ModuleResolutionCache, redirectedReference?: ResolvedProjectReference, resolutionMode?: ModuleKind.CommonJS | ModuleKind.ESNext): ResolvedModuleWithFailedLookupLocations;
+    export function nodeModuleNameResolver(moduleName: string, containingFile: string, compilerOptions: CompilerOptions, host: ModuleResolutionHost, cache?: ModuleResolutionCache, redirectedReference?: ResolvedProjectReference): ResolvedModuleWithFailedLookupLocations;
+    export function classicNameResolver(moduleName: string, containingFile: string, compilerOptions: CompilerOptions, host: ModuleResolutionHost, cache?: NonRelativeModuleNameResolutionCache, redirectedReference?: ResolvedProjectReference): ResolvedModuleWithFailedLookupLocations;
     export interface TypeReferenceDirectiveResolutionCache extends PerDirectoryResolutionCache<ResolvedTypeReferenceDirectiveWithFailedLookupLocations>, PackageJsonInfoCache {
     }
     export interface ModeAwareCache<T> {
@@ -5047,15 +9266,6 @@ declare namespace ts {
         get(directory: string): ResolvedModuleWithFailedLookupLocations | undefined;
         set(directory: string, result: ResolvedModuleWithFailedLookupLocations): void;
     }
-    export function createModuleResolutionCache(currentDirectory: string, getCanonicalFileName: (s: string) => string, options?: CompilerOptions): ModuleResolutionCache;
-    export function createTypeReferenceDirectiveResolutionCache(currentDirectory: string, getCanonicalFileName: (s: string) => string, options?: CompilerOptions, packageJsonInfoCache?: PackageJsonInfoCache): TypeReferenceDirectiveResolutionCache;
-    export function resolveModuleNameFromCache(moduleName: string, containingFile: string, cache: ModuleResolutionCache, mode?: ModuleKind.CommonJS | ModuleKind.ESNext): ResolvedModuleWithFailedLookupLocations | undefined;
-    export function resolveModuleName(moduleName: string, containingFile: string, compilerOptions: CompilerOptions, host: ModuleResolutionHost, cache?: ModuleResolutionCache, redirectedReference?: ResolvedProjectReference, resolutionMode?: ModuleKind.CommonJS | ModuleKind.ESNext): ResolvedModuleWithFailedLookupLocations;
-    export function nodeModuleNameResolver(moduleName: string, containingFile: string, compilerOptions: CompilerOptions, host: ModuleResolutionHost, cache?: ModuleResolutionCache, redirectedReference?: ResolvedProjectReference): ResolvedModuleWithFailedLookupLocations;
-    export function classicNameResolver(moduleName: string, containingFile: string, compilerOptions: CompilerOptions, host: ModuleResolutionHost, cache?: NonRelativeModuleNameResolutionCache, redirectedReference?: ResolvedProjectReference): ResolvedModuleWithFailedLookupLocations;
-    export {};
-}
-declare namespace ts {
     /**
      * Visits a Node using the supplied visitor, possibly returning a new Node in its place.
      *
@@ -5064,7 +9274,7 @@ declare namespace ts {
      * @param test A callback to execute to verify the Node is valid.
      * @param lift An optional callback to execute to lift a NodeArray into a valid Node.
      */
-    function visitNode<T extends Node>(node: T, visitor: Visitor | undefined, test?: (node: Node) => boolean, lift?: (node: readonly Node[]) => T): T;
+    export function visitNode<T extends Node>(node: T, visitor: Visitor | undefined, test?: (node: Node) => boolean, lift?: (node: readonly Node[]) => T): T;
     /**
      * Visits a Node using the supplied visitor, possibly returning a new Node in its place.
      *
@@ -5073,7 +9283,7 @@ declare namespace ts {
      * @param test A callback to execute to verify the Node is valid.
      * @param lift An optional callback to execute to lift a NodeArray into a valid Node.
      */
-    function visitNode<T extends Node>(node: T | undefined, visitor: Visitor | undefined, test?: (node: Node) => boolean, lift?: (node: readonly Node[]) => T): T | undefined;
+    export function visitNode<T extends Node>(node: T | undefined, visitor: Visitor | undefined, test?: (node: Node) => boolean, lift?: (node: readonly Node[]) => T): T | undefined;
     /**
      * Visits a NodeArray using the supplied visitor, possibly returning a new NodeArray in its place.
      *
@@ -5083,7 +9293,7 @@ declare namespace ts {
      * @param start An optional value indicating the starting offset at which to start visiting.
      * @param count An optional value indicating the maximum number of nodes to visit.
      */
-    function visitNodes<T extends Node>(nodes: NodeArray<T>, visitor: Visitor | undefined, test?: (node: Node) => boolean, start?: number, count?: number): NodeArray<T>;
+    export function visitNodes<T extends Node>(nodes: NodeArray<T>, visitor: Visitor | undefined, test?: (node: Node) => boolean, start?: number, count?: number): NodeArray<T>;
     /**
      * Visits a NodeArray using the supplied visitor, possibly returning a new NodeArray in its place.
      *
@@ -5093,37 +9303,37 @@ declare namespace ts {
      * @param start An optional value indicating the starting offset at which to start visiting.
      * @param count An optional value indicating the maximum number of nodes to visit.
      */
-    function visitNodes<T extends Node>(nodes: NodeArray<T> | undefined, visitor: Visitor | undefined, test?: (node: Node) => boolean, start?: number, count?: number): NodeArray<T> | undefined;
+    export function visitNodes<T extends Node>(nodes: NodeArray<T> | undefined, visitor: Visitor | undefined, test?: (node: Node) => boolean, start?: number, count?: number): NodeArray<T> | undefined;
     /**
      * Starts a new lexical environment and visits a statement list, ending the lexical environment
      * and merging hoisted declarations upon completion.
      */
-    function visitLexicalEnvironment(statements: NodeArray<Statement>, visitor: Visitor, context: TransformationContext, start?: number, ensureUseStrict?: boolean, nodesVisitor?: NodesVisitor): NodeArray<Statement>;
+    export function visitLexicalEnvironment(statements: NodeArray<Statement>, visitor: Visitor, context: TransformationContext, start?: number, ensureUseStrict?: boolean, nodesVisitor?: NodesVisitor): NodeArray<Statement>;
     /**
      * Starts a new lexical environment and visits a parameter list, suspending the lexical
      * environment upon completion.
      */
-    function visitParameterList(nodes: NodeArray<ParameterDeclaration>, visitor: Visitor, context: TransformationContext, nodesVisitor?: NodesVisitor): NodeArray<ParameterDeclaration>;
-    function visitParameterList(nodes: NodeArray<ParameterDeclaration> | undefined, visitor: Visitor, context: TransformationContext, nodesVisitor?: NodesVisitor): NodeArray<ParameterDeclaration> | undefined;
+    export function visitParameterList(nodes: NodeArray<ParameterDeclaration>, visitor: Visitor, context: TransformationContext, nodesVisitor?: NodesVisitor): NodeArray<ParameterDeclaration>;
+    export function visitParameterList(nodes: NodeArray<ParameterDeclaration> | undefined, visitor: Visitor, context: TransformationContext, nodesVisitor?: NodesVisitor): NodeArray<ParameterDeclaration> | undefined;
     /**
      * Resumes a suspended lexical environment and visits a function body, ending the lexical
      * environment and merging hoisted declarations upon completion.
      */
-    function visitFunctionBody(node: FunctionBody, visitor: Visitor, context: TransformationContext): FunctionBody;
+    export function visitFunctionBody(node: FunctionBody, visitor: Visitor, context: TransformationContext): FunctionBody;
     /**
      * Resumes a suspended lexical environment and visits a function body, ending the lexical
      * environment and merging hoisted declarations upon completion.
      */
-    function visitFunctionBody(node: FunctionBody | undefined, visitor: Visitor, context: TransformationContext): FunctionBody | undefined;
+    export function visitFunctionBody(node: FunctionBody | undefined, visitor: Visitor, context: TransformationContext): FunctionBody | undefined;
     /**
      * Resumes a suspended lexical environment and visits a concise body, ending the lexical
      * environment and merging hoisted declarations upon completion.
      */
-    function visitFunctionBody(node: ConciseBody, visitor: Visitor, context: TransformationContext): ConciseBody;
+    export function visitFunctionBody(node: ConciseBody, visitor: Visitor, context: TransformationContext): ConciseBody;
     /**
      * Visits an iteration body, adding any block-scoped variables required by the transformation.
      */
-    function visitIterationBody(body: Statement, visitor: Visitor, context: TransformationContext): Statement;
+    export function visitIterationBody(body: Statement, visitor: Visitor, context: TransformationContext): Statement;
     /**
      * Visits each child of a Node using the supplied visitor, possibly returning a new Node of the same kind in its place.
      *
@@ -5131,7 +9341,7 @@ declare namespace ts {
      * @param visitor The callback used to visit each child.
      * @param context A lexical environment context for the visitor.
      */
-    function visitEachChild<T extends Node>(node: T, visitor: Visitor, context: TransformationContext): T;
+    export function visitEachChild<T extends Node>(node: T, visitor: Visitor, context: TransformationContext): T;
     /**
      * Visits each child of a Node using the supplied visitor, possibly returning a new Node of the same kind in its place.
      *
@@ -5139,23 +9349,14 @@ declare namespace ts {
      * @param visitor The callback used to visit each child.
      * @param context A lexical environment context for the visitor.
      */
-    function visitEachChild<T extends Node>(node: T | undefined, visitor: Visitor, context: TransformationContext, nodesVisitor?: typeof visitNodes, tokenVisitor?: Visitor): T | undefined;
-}
-declare namespace ts {
-    function getTsBuildInfoEmitOutputFilePath(options: CompilerOptions): string | undefined;
-    function getOutputFileNames(commandLine: ParsedCommandLine, inputFileName: string, ignoreCase: boolean): readonly string[];
-    function createPrinter(printerOptions?: PrinterOptions, handlers?: PrintHandlers): Printer;
-}
-declare namespace ts {
+    export function visitEachChild<T extends Node>(node: T | undefined, visitor: Visitor, context: TransformationContext, nodesVisitor?: typeof visitNodes, tokenVisitor?: Visitor): T | undefined;
+    export function getTsBuildInfoEmitOutputFilePath(options: CompilerOptions): string | undefined;
+    export function getOutputFileNames(commandLine: ParsedCommandLine, inputFileName: string, ignoreCase: boolean): readonly string[];
+    export function createPrinter(printerOptions?: PrinterOptions, handlers?: PrintHandlers): Printer;
     export function findConfigFile(searchPath: string, fileExists: (fileName: string) => boolean, configName?: string): string | undefined;
     export function resolveTripleslashReference(moduleName: string, containingFile: string): string;
     export function createCompilerHost(options: CompilerOptions, setParentNodes?: boolean): CompilerHost;
     export function getPreEmitDiagnostics(program: Program, sourceFile?: SourceFile, cancellationToken?: CancellationToken): readonly Diagnostic[];
-    export interface FormatDiagnosticsHost {
-        getCurrentDirectory(): string;
-        getCanonicalFileName(fileName: string): string;
-        getNewLine(): string;
-    }
     export function formatDiagnostics(diagnostics: readonly Diagnostic[], host: FormatDiagnosticsHost): string;
     export function formatDiagnostic(diagnostic: Diagnostic, host: FormatDiagnosticsHost): string;
     export function formatDiagnosticsWithColorAndContext(diagnostics: readonly Diagnostic[], host: FormatDiagnosticsHost): string;
@@ -5223,34 +9424,50 @@ declare namespace ts {
      * @returns A 'Program' object.
      */
     export function createProgram(rootNames: readonly string[], options: CompilerOptions, host?: CompilerHost, oldProgram?: Program, configFileParsingDiagnostics?: readonly Diagnostic[]): Program;
-    /** @deprecated */ export interface ResolveProjectReferencePathHost {
-        fileExists(fileName: string): boolean;
-    }
     /**
      * Returns the target config filename of a project reference.
      * Note: The file might not exist.
      */
     export function resolveProjectReferencePath(ref: ProjectReference): ResolvedConfigFileName;
     /** @deprecated */ export function resolveProjectReferencePath(host: ResolveProjectReferencePathHost, ref: ProjectReference): ResolvedConfigFileName;
-    export {};
-}
-declare namespace ts {
-    interface EmitOutput {
+    export interface FormatDiagnosticsHost {
+        getCurrentDirectory(): string;
+        getCanonicalFileName(fileName: string): string;
+        getNewLine(): string;
+    }
+    /** @deprecated */ export interface ResolveProjectReferencePathHost {
+        fileExists(fileName: string): boolean;
+    }
+    export interface EmitOutput {
         outputFiles: OutputFile[];
         emitSkipped: boolean;
     }
-    interface OutputFile {
+    export interface OutputFile {
         name: string;
         writeByteOrderMark: boolean;
         text: string;
     }
-}
-declare namespace ts {
-    type AffectedFileResult<T> = {
+    /**
+     * Create the builder to manage semantic diagnostics and cache them
+     */
+    export function createSemanticDiagnosticsBuilderProgram(newProgram: Program, host: BuilderProgramHost, oldProgram?: SemanticDiagnosticsBuilderProgram, configFileParsingDiagnostics?: readonly Diagnostic[]): SemanticDiagnosticsBuilderProgram;
+    export function createSemanticDiagnosticsBuilderProgram(rootNames: readonly string[] | undefined, options: CompilerOptions | undefined, host?: CompilerHost, oldProgram?: SemanticDiagnosticsBuilderProgram, configFileParsingDiagnostics?: readonly Diagnostic[], projectReferences?: readonly ProjectReference[]): SemanticDiagnosticsBuilderProgram;
+    /**
+     * Create the builder that can handle the changes in program and iterate through changed files
+     * to emit the those files and manage semantic diagnostics cache as well
+     */
+    export function createEmitAndSemanticDiagnosticsBuilderProgram(newProgram: Program, host: BuilderProgramHost, oldProgram?: EmitAndSemanticDiagnosticsBuilderProgram, configFileParsingDiagnostics?: readonly Diagnostic[]): EmitAndSemanticDiagnosticsBuilderProgram;
+    export function createEmitAndSemanticDiagnosticsBuilderProgram(rootNames: readonly string[] | undefined, options: CompilerOptions | undefined, host?: CompilerHost, oldProgram?: EmitAndSemanticDiagnosticsBuilderProgram, configFileParsingDiagnostics?: readonly Diagnostic[], projectReferences?: readonly ProjectReference[]): EmitAndSemanticDiagnosticsBuilderProgram;
+    /**
+     * Creates a builder thats just abstraction over program and can be used with watch
+     */
+    export function createAbstractBuilder(newProgram: Program, host: BuilderProgramHost, oldProgram?: BuilderProgram, configFileParsingDiagnostics?: readonly Diagnostic[]): BuilderProgram;
+    export function createAbstractBuilder(rootNames: readonly string[] | undefined, options: CompilerOptions | undefined, host?: CompilerHost, oldProgram?: BuilderProgram, configFileParsingDiagnostics?: readonly Diagnostic[], projectReferences?: readonly ProjectReference[]): BuilderProgram;
+    export type AffectedFileResult<T> = {
         result: T;
         affected: SourceFile | Program;
     } | undefined;
-    interface BuilderProgramHost {
+    export interface BuilderProgramHost {
         /**
          * return true if file names are treated with case sensitivity
          */
@@ -5268,7 +9485,7 @@ declare namespace ts {
     /**
      * Builder to manage the program state changes
      */
-    interface BuilderProgram {
+    export interface BuilderProgram {
         /**
          * Returns current program
          */
@@ -5338,7 +9555,7 @@ declare namespace ts {
     /**
      * The builder that caches the semantic diagnostics for the program and handles the changed files and affected files
      */
-    interface SemanticDiagnosticsBuilderProgram extends BuilderProgram {
+    export interface SemanticDiagnosticsBuilderProgram extends BuilderProgram {
         /**
          * Gets the semantic diagnostics from the program for the next affected file and caches it
          * Returns undefined if the iteration is complete
@@ -5349,7 +9566,7 @@ declare namespace ts {
      * The builder that can handle the changes in program and iterate through changed file to emit the files
      * The semantic diagnostics are cached per file and managed by clearing for the changed/affected files
      */
-    interface EmitAndSemanticDiagnosticsBuilderProgram extends SemanticDiagnosticsBuilderProgram {
+    export interface EmitAndSemanticDiagnosticsBuilderProgram extends SemanticDiagnosticsBuilderProgram {
         /**
          * Emits the next affected file's emit result (EmitResult and sourceFiles emitted) or returns undefined if iteration is complete
          * The first of writeFile if provided, writeFile of BuilderProgramHost if provided, writeFile of compiler host
@@ -5357,32 +9574,28 @@ declare namespace ts {
          */
         emitNextAffectedFile(writeFile?: WriteFileCallback, cancellationToken?: CancellationToken, emitOnlyDtsFiles?: boolean, customTransformers?: CustomTransformers): AffectedFileResult<EmitResult>;
     }
+    export function readBuilderProgram(compilerOptions: CompilerOptions, host: ReadBuildProgramHost): EmitAndSemanticDiagnosticsBuilderProgram | undefined;
+    export function createIncrementalCompilerHost(options: CompilerOptions, system?: System): CompilerHost;
+    export function createIncrementalProgram<T extends BuilderProgram = EmitAndSemanticDiagnosticsBuilderProgram>({ rootNames, options, configFileParsingDiagnostics, projectReferences, host, createProgram }: IncrementalProgramOptions<T>): T;
     /**
-     * Create the builder to manage semantic diagnostics and cache them
+     * Create the watch compiler host for either configFile or fileNames and its options
      */
-    function createSemanticDiagnosticsBuilderProgram(newProgram: Program, host: BuilderProgramHost, oldProgram?: SemanticDiagnosticsBuilderProgram, configFileParsingDiagnostics?: readonly Diagnostic[]): SemanticDiagnosticsBuilderProgram;
-    function createSemanticDiagnosticsBuilderProgram(rootNames: readonly string[] | undefined, options: CompilerOptions | undefined, host?: CompilerHost, oldProgram?: SemanticDiagnosticsBuilderProgram, configFileParsingDiagnostics?: readonly Diagnostic[], projectReferences?: readonly ProjectReference[]): SemanticDiagnosticsBuilderProgram;
+    export function createWatchCompilerHost<T extends BuilderProgram>(configFileName: string, optionsToExtend: CompilerOptions | undefined, system: System, createProgram?: CreateProgram<T>, reportDiagnostic?: DiagnosticReporter, reportWatchStatus?: WatchStatusReporter, watchOptionsToExtend?: WatchOptions, extraFileExtensions?: readonly FileExtensionInfo[]): WatchCompilerHostOfConfigFile<T>;
+    export function createWatchCompilerHost<T extends BuilderProgram>(rootFiles: string[], options: CompilerOptions, system: System, createProgram?: CreateProgram<T>, reportDiagnostic?: DiagnosticReporter, reportWatchStatus?: WatchStatusReporter, projectReferences?: readonly ProjectReference[], watchOptions?: WatchOptions): WatchCompilerHostOfFilesAndCompilerOptions<T>;
     /**
-     * Create the builder that can handle the changes in program and iterate through changed files
-     * to emit the those files and manage semantic diagnostics cache as well
+     * Creates the watch from the host for root files and compiler options
      */
-    function createEmitAndSemanticDiagnosticsBuilderProgram(newProgram: Program, host: BuilderProgramHost, oldProgram?: EmitAndSemanticDiagnosticsBuilderProgram, configFileParsingDiagnostics?: readonly Diagnostic[]): EmitAndSemanticDiagnosticsBuilderProgram;
-    function createEmitAndSemanticDiagnosticsBuilderProgram(rootNames: readonly string[] | undefined, options: CompilerOptions | undefined, host?: CompilerHost, oldProgram?: EmitAndSemanticDiagnosticsBuilderProgram, configFileParsingDiagnostics?: readonly Diagnostic[], projectReferences?: readonly ProjectReference[]): EmitAndSemanticDiagnosticsBuilderProgram;
+    export function createWatchProgram<T extends BuilderProgram>(host: WatchCompilerHostOfFilesAndCompilerOptions<T>): WatchOfFilesAndCompilerOptions<T>;
     /**
-     * Creates a builder thats just abstraction over program and can be used with watch
+     * Creates the watch from the host for config file
      */
-    function createAbstractBuilder(newProgram: Program, host: BuilderProgramHost, oldProgram?: BuilderProgram, configFileParsingDiagnostics?: readonly Diagnostic[]): BuilderProgram;
-    function createAbstractBuilder(rootNames: readonly string[] | undefined, options: CompilerOptions | undefined, host?: CompilerHost, oldProgram?: BuilderProgram, configFileParsingDiagnostics?: readonly Diagnostic[], projectReferences?: readonly ProjectReference[]): BuilderProgram;
-}
-declare namespace ts {
-    interface ReadBuildProgramHost {
+    export function createWatchProgram<T extends BuilderProgram>(host: WatchCompilerHostOfConfigFile<T>): WatchOfConfigFile<T>;
+    export interface ReadBuildProgramHost {
         useCaseSensitiveFileNames(): boolean;
         getCurrentDirectory(): string;
         readFile(fileName: string): string | undefined;
     }
-    function readBuilderProgram(compilerOptions: CompilerOptions, host: ReadBuildProgramHost): EmitAndSemanticDiagnosticsBuilderProgram | undefined;
-    function createIncrementalCompilerHost(options: CompilerOptions, system?: System): CompilerHost;
-    interface IncrementalProgramOptions<T extends BuilderProgram> {
+    export interface IncrementalProgramOptions<T extends BuilderProgram> {
         rootNames: readonly string[];
         options: CompilerOptions;
         configFileParsingDiagnostics?: readonly Diagnostic[];
@@ -5390,12 +9603,11 @@ declare namespace ts {
         host?: CompilerHost;
         createProgram?: CreateProgram<T>;
     }
-    function createIncrementalProgram<T extends BuilderProgram = EmitAndSemanticDiagnosticsBuilderProgram>({ rootNames, options, configFileParsingDiagnostics, projectReferences, host, createProgram }: IncrementalProgramOptions<T>): T;
-    type WatchStatusReporter = (diagnostic: Diagnostic, newLine: string, options: CompilerOptions, errorCount?: number) => void;
+    export type WatchStatusReporter = (diagnostic: Diagnostic, newLine: string, options: CompilerOptions, errorCount?: number) => void;
     /** Create the program with rootNames and options, if they are undefined, oldProgram and new configFile diagnostics create new program */
-    type CreateProgram<T extends BuilderProgram> = (rootNames: readonly string[] | undefined, options: CompilerOptions | undefined, host?: CompilerHost, oldProgram?: T, configFileParsingDiagnostics?: readonly Diagnostic[], projectReferences?: readonly ProjectReference[] | undefined) => T;
+    export type CreateProgram<T extends BuilderProgram> = (rootNames: readonly string[] | undefined, options: CompilerOptions | undefined, host?: CompilerHost, oldProgram?: T, configFileParsingDiagnostics?: readonly Diagnostic[], projectReferences?: readonly ProjectReference[] | undefined) => T;
     /** Host that has watch functionality used in --watch mode */
-    interface WatchHost {
+    export interface WatchHost {
         /** If provided, called with Diagnostic message that informs about change in watch status */
         onWatchStatusChange?(diagnostic: Diagnostic, newLine: string, options: CompilerOptions, errorCount?: number): void;
         /** Used to watch changes in source files, missing files needed to update the program or config file */
@@ -5407,7 +9619,7 @@ declare namespace ts {
         /** If provided, will be used to reset existing delayed compilation */
         clearTimeout?(timeoutId: any): void;
     }
-    interface ProgramHost<T extends BuilderProgram> {
+    export interface ProgramHost<T extends BuilderProgram> {
         /**
          * Used to create the program when need for program creation or recreation detected
          */
@@ -5451,7 +9663,7 @@ declare namespace ts {
          */
         getModuleResolutionCache?(): ModuleResolutionCache | undefined;
     }
-    interface WatchCompilerHost<T extends BuilderProgram> extends ProgramHost<T>, WatchHost {
+    export interface WatchCompilerHost<T extends BuilderProgram> extends ProgramHost<T>, WatchHost {
         /** Instead of using output d.ts file from project reference, use its source file */
         useSourceOfProjectReferenceRedirect?(): boolean;
         /** If provided, use this method to get parsed command lines for referenced projects */
@@ -5462,7 +9674,7 @@ declare namespace ts {
     /**
      * Host to create watch with root files and options
      */
-    interface WatchCompilerHostOfFilesAndCompilerOptions<T extends BuilderProgram> extends WatchCompilerHost<T> {
+    export interface WatchCompilerHostOfFilesAndCompilerOptions<T extends BuilderProgram> extends WatchCompilerHost<T> {
         /** root files to use to generate program */
         rootFiles: string[];
         /** Compiler options */
@@ -5474,7 +9686,7 @@ declare namespace ts {
     /**
      * Host to create watch with config file
      */
-    interface WatchCompilerHostOfConfigFile<T extends BuilderProgram> extends WatchCompilerHost<T>, ConfigFileDiagnosticsReporter {
+    export interface WatchCompilerHostOfConfigFile<T extends BuilderProgram> extends WatchCompilerHost<T>, ConfigFileDiagnosticsReporter {
         /** Name of the config file to compile */
         configFileName: string;
         /** Options to extend */
@@ -5487,7 +9699,7 @@ declare namespace ts {
          */
         readDirectory(path: string, extensions?: readonly string[], exclude?: readonly string[], include?: readonly string[], depth?: number): string[];
     }
-    interface Watch<T> {
+    export interface Watch<T> {
         /** Synchronize with host and get updated program */
         getProgram(): T;
         /** Closes the watch */
@@ -5496,31 +9708,24 @@ declare namespace ts {
     /**
      * Creates the watch what generates program using the config file
      */
-    interface WatchOfConfigFile<T> extends Watch<T> {
+    export interface WatchOfConfigFile<T> extends Watch<T> {
     }
     /**
      * Creates the watch that generates program using the root files and compiler options
      */
-    interface WatchOfFilesAndCompilerOptions<T> extends Watch<T> {
+    export interface WatchOfFilesAndCompilerOptions<T> extends Watch<T> {
         /** Updates the root files in the program, only if this is not config file compilation */
         updateRootFileNames(fileNames: string[]): void;
     }
     /**
-     * Create the watch compiler host for either configFile or fileNames and its options
-     */
-    function createWatchCompilerHost<T extends BuilderProgram>(configFileName: string, optionsToExtend: CompilerOptions | undefined, system: System, createProgram?: CreateProgram<T>, reportDiagnostic?: DiagnosticReporter, reportWatchStatus?: WatchStatusReporter, watchOptionsToExtend?: WatchOptions, extraFileExtensions?: readonly FileExtensionInfo[]): WatchCompilerHostOfConfigFile<T>;
-    function createWatchCompilerHost<T extends BuilderProgram>(rootFiles: string[], options: CompilerOptions, system: System, createProgram?: CreateProgram<T>, reportDiagnostic?: DiagnosticReporter, reportWatchStatus?: WatchStatusReporter, projectReferences?: readonly ProjectReference[], watchOptions?: WatchOptions): WatchCompilerHostOfFilesAndCompilerOptions<T>;
-    /**
-     * Creates the watch from the host for root files and compiler options
-     */
-    function createWatchProgram<T extends BuilderProgram>(host: WatchCompilerHostOfFilesAndCompilerOptions<T>): WatchOfFilesAndCompilerOptions<T>;
-    /**
-     * Creates the watch from the host for config file
+     * Create a function that reports watch status by writing to the system and handles the formating of the diagnostic
      */
-    function createWatchProgram<T extends BuilderProgram>(host: WatchCompilerHostOfConfigFile<T>): WatchOfConfigFile<T>;
-}
-declare namespace ts {
-    interface BuildOptions {
+    export function createBuilderStatusReporter(system: System, pretty?: boolean): DiagnosticReporter;
+    export function createSolutionBuilderHost<T extends BuilderProgram = EmitAndSemanticDiagnosticsBuilderProgram>(system?: System, createProgram?: CreateProgram<T>, reportDiagnostic?: DiagnosticReporter, reportSolutionBuilderStatus?: DiagnosticReporter, reportErrorSummary?: ReportEmitErrorSummary): SolutionBuilderHost<T>;
+    export function createSolutionBuilderWithWatchHost<T extends BuilderProgram = EmitAndSemanticDiagnosticsBuilderProgram>(system?: System, createProgram?: CreateProgram<T>, reportDiagnostic?: DiagnosticReporter, reportSolutionBuilderStatus?: DiagnosticReporter, reportWatchStatus?: WatchStatusReporter): SolutionBuilderWithWatchHost<T>;
+    export function createSolutionBuilder<T extends BuilderProgram>(host: SolutionBuilderHost<T>, rootNames: readonly string[], defaultOptions: BuildOptions): SolutionBuilder<T>;
+    export function createSolutionBuilderWithWatch<T extends BuilderProgram>(host: SolutionBuilderWithWatchHost<T>, rootNames: readonly string[], defaultOptions: BuildOptions, baseWatchOptions?: WatchOptions): SolutionBuilder<T>;
+    export interface BuildOptions {
         dry?: boolean;
         force?: boolean;
         verbose?: boolean;
@@ -5529,12 +9734,12 @@ declare namespace ts {
         traceResolution?: boolean;
         [option: string]: CompilerOptionsValue | undefined;
     }
-    type ReportEmitErrorSummary = (errorCount: number, filesInError: (ReportFileInError | undefined)[]) => void;
-    interface ReportFileInError {
+    export type ReportEmitErrorSummary = (errorCount: number, filesInError: (ReportFileInError | undefined)[]) => void;
+    export interface ReportFileInError {
         fileName: string;
         line: number;
     }
-    interface SolutionBuilderHostBase<T extends BuilderProgram> extends ProgramHost<T> {
+    export interface SolutionBuilderHostBase<T extends BuilderProgram> extends ProgramHost<T> {
         createDirectory?(path: string): void;
         /**
          * Should provide create directory and writeFile if done of invalidatedProjects is not invoked with
@@ -5550,32 +9755,24 @@ declare namespace ts {
         reportSolutionBuilderStatus: DiagnosticReporter;
         afterProgramEmitAndDiagnostics?(program: T): void;
     }
-    interface SolutionBuilderHost<T extends BuilderProgram> extends SolutionBuilderHostBase<T> {
+    export interface SolutionBuilderHost<T extends BuilderProgram> extends SolutionBuilderHostBase<T> {
         reportErrorSummary?: ReportEmitErrorSummary;
     }
-    interface SolutionBuilderWithWatchHost<T extends BuilderProgram> extends SolutionBuilderHostBase<T>, WatchHost {
+    export interface SolutionBuilderWithWatchHost<T extends BuilderProgram> extends SolutionBuilderHostBase<T>, WatchHost {
     }
-    interface SolutionBuilder<T extends BuilderProgram> {
+    export interface SolutionBuilder<T extends BuilderProgram> {
         build(project?: string, cancellationToken?: CancellationToken, writeFile?: WriteFileCallback, getCustomTransformers?: (project: string) => CustomTransformers): ExitStatus;
         clean(project?: string): ExitStatus;
         buildReferences(project: string, cancellationToken?: CancellationToken, writeFile?: WriteFileCallback, getCustomTransformers?: (project: string) => CustomTransformers): ExitStatus;
         cleanReferences(project?: string): ExitStatus;
         getNextInvalidatedProject(cancellationToken?: CancellationToken): InvalidatedProject<T> | undefined;
     }
-    /**
-     * Create a function that reports watch status by writing to the system and handles the formating of the diagnostic
-     */
-    function createBuilderStatusReporter(system: System, pretty?: boolean): DiagnosticReporter;
-    function createSolutionBuilderHost<T extends BuilderProgram = EmitAndSemanticDiagnosticsBuilderProgram>(system?: System, createProgram?: CreateProgram<T>, reportDiagnostic?: DiagnosticReporter, reportSolutionBuilderStatus?: DiagnosticReporter, reportErrorSummary?: ReportEmitErrorSummary): SolutionBuilderHost<T>;
-    function createSolutionBuilderWithWatchHost<T extends BuilderProgram = EmitAndSemanticDiagnosticsBuilderProgram>(system?: System, createProgram?: CreateProgram<T>, reportDiagnostic?: DiagnosticReporter, reportSolutionBuilderStatus?: DiagnosticReporter, reportWatchStatus?: WatchStatusReporter): SolutionBuilderWithWatchHost<T>;
-    function createSolutionBuilder<T extends BuilderProgram>(host: SolutionBuilderHost<T>, rootNames: readonly string[], defaultOptions: BuildOptions): SolutionBuilder<T>;
-    function createSolutionBuilderWithWatch<T extends BuilderProgram>(host: SolutionBuilderWithWatchHost<T>, rootNames: readonly string[], defaultOptions: BuildOptions, baseWatchOptions?: WatchOptions): SolutionBuilder<T>;
-    enum InvalidatedProjectKind {
+    export enum InvalidatedProjectKind {
         Build = 0,
         UpdateBundle = 1,
         UpdateOutputFileStamps = 2
     }
-    interface InvalidatedProjectBase {
+    export interface InvalidatedProjectBase {
         readonly kind: InvalidatedProjectKind;
         readonly project: ResolvedConfigFileName;
         /**
@@ -5585,11 +9782,11 @@ declare namespace ts {
         getCompilerOptions(): CompilerOptions;
         getCurrentDirectory(): string;
     }
-    interface UpdateOutputFileStampsProject extends InvalidatedProjectBase {
+    export interface UpdateOutputFileStampsProject extends InvalidatedProjectBase {
         readonly kind: InvalidatedProjectKind.UpdateOutputFileStamps;
         updateOutputFileStatmps(): void;
     }
-    interface BuildInvalidedProject<T extends BuilderProgram> extends InvalidatedProjectBase {
+    export interface BuildInvalidedProject<T extends BuilderProgram> extends InvalidatedProjectBase {
         readonly kind: InvalidatedProjectKind.Build;
         getBuilderProgram(): T | undefined;
         getProgram(): Program | undefined;
@@ -5604,176 +9801,26 @@ declare namespace ts {
         getSemanticDiagnosticsOfNextAffectedFile(cancellationToken?: CancellationToken, ignoreSourceFile?: (sourceFile: SourceFile) => boolean): AffectedFileResult<readonly Diagnostic[]>;
         emit(targetSourceFile?: SourceFile, writeFile?: WriteFileCallback, cancellationToken?: CancellationToken, emitOnlyDtsFiles?: boolean, customTransformers?: CustomTransformers): EmitResult | undefined;
     }
-    interface UpdateBundleProject<T extends BuilderProgram> extends InvalidatedProjectBase {
+    export interface UpdateBundleProject<T extends BuilderProgram> extends InvalidatedProjectBase {
         readonly kind: InvalidatedProjectKind.UpdateBundle;
         emit(writeFile?: WriteFileCallback, customTransformers?: CustomTransformers): EmitResult | BuildInvalidedProject<T> | undefined;
     }
-    type InvalidatedProject<T extends BuilderProgram> = UpdateOutputFileStampsProject | BuildInvalidedProject<T> | UpdateBundleProject<T>;
-}
-declare namespace ts.server {
-    type ActionSet = "action::set";
-    type ActionInvalidate = "action::invalidate";
-    type ActionPackageInstalled = "action::packageInstalled";
-    type EventTypesRegistry = "event::typesRegistry";
-    type EventBeginInstallTypes = "event::beginInstallTypes";
-    type EventEndInstallTypes = "event::endInstallTypes";
-    type EventInitializationFailed = "event::initializationFailed";
-}
-declare namespace ts.server {
-    interface TypingInstallerResponse {
-        readonly kind: ActionSet | ActionInvalidate | EventTypesRegistry | ActionPackageInstalled | EventBeginInstallTypes | EventEndInstallTypes | EventInitializationFailed;
-    }
-    interface TypingInstallerRequestWithProjectName {
-        readonly projectName: string;
-    }
-    interface DiscoverTypings extends TypingInstallerRequestWithProjectName {
-        readonly fileNames: string[];
-        readonly projectRootPath: Path;
-        readonly compilerOptions: CompilerOptions;
-        readonly watchOptions?: WatchOptions;
-        readonly typeAcquisition: TypeAcquisition;
-        readonly unresolvedImports: SortedReadonlyArray<string>;
-        readonly cachePath?: string;
-        readonly kind: "discover";
-    }
-    interface CloseProject extends TypingInstallerRequestWithProjectName {
-        readonly kind: "closeProject";
-    }
-    interface TypesRegistryRequest {
-        readonly kind: "typesRegistry";
-    }
-    interface InstallPackageRequest extends TypingInstallerRequestWithProjectName {
-        readonly kind: "installPackage";
-        readonly fileName: Path;
-        readonly packageName: string;
-        readonly projectRootPath: Path;
-    }
-    interface PackageInstalledResponse extends ProjectResponse {
-        readonly kind: ActionPackageInstalled;
-        readonly success: boolean;
-        readonly message: string;
-    }
-    interface InitializationFailedResponse extends TypingInstallerResponse {
-        readonly kind: EventInitializationFailed;
-        readonly message: string;
-        readonly stack?: string;
-    }
-    interface ProjectResponse extends TypingInstallerResponse {
-        readonly projectName: string;
-    }
-    interface InvalidateCachedTypings extends ProjectResponse {
-        readonly kind: ActionInvalidate;
-    }
-    interface InstallTypes extends ProjectResponse {
-        readonly kind: EventBeginInstallTypes | EventEndInstallTypes;
-        readonly eventId: number;
-        readonly typingsInstallerVersion: string;
-        readonly packagesToInstall: readonly string[];
-    }
-    interface BeginInstallTypes extends InstallTypes {
-        readonly kind: EventBeginInstallTypes;
-    }
-    interface EndInstallTypes extends InstallTypes {
-        readonly kind: EventEndInstallTypes;
-        readonly installSuccess: boolean;
-    }
-    interface SetTypings extends ProjectResponse {
-        readonly typeAcquisition: TypeAcquisition;
-        readonly compilerOptions: CompilerOptions;
-        readonly typings: string[];
-        readonly unresolvedImports: SortedReadonlyArray<string>;
-        readonly kind: ActionSet;
-    }
-}
-declare namespace ts {
-    interface Node {
-        getSourceFile(): SourceFile;
-        getChildCount(sourceFile?: SourceFile): number;
-        getChildAt(index: number, sourceFile?: SourceFile): Node;
-        getChildren(sourceFile?: SourceFile): Node[];
-        getStart(sourceFile?: SourceFile, includeJsDocComment?: boolean): number;
-        getFullStart(): number;
-        getEnd(): number;
-        getWidth(sourceFile?: SourceFileLike): number;
-        getFullWidth(): number;
-        getLeadingTriviaWidth(sourceFile?: SourceFile): number;
-        getFullText(sourceFile?: SourceFile): string;
-        getText(sourceFile?: SourceFile): string;
-        getFirstToken(sourceFile?: SourceFile): Node | undefined;
-        getLastToken(sourceFile?: SourceFile): Node | undefined;
-        forEachChild<T>(cbNode: (node: Node) => T | undefined, cbNodeArray?: (nodes: NodeArray<Node>) => T | undefined): T | undefined;
-    }
-    interface Identifier {
-        readonly text: string;
-    }
-    interface PrivateIdentifier {
-        readonly text: string;
-    }
-    interface Symbol {
-        readonly name: string;
-        getFlags(): SymbolFlags;
-        getEscapedName(): __String;
-        getName(): string;
-        getDeclarations(): Declaration[] | undefined;
-        getDocumentationComment(typeChecker: TypeChecker | undefined): SymbolDisplayPart[];
-        getJsDocTags(checker?: TypeChecker): JSDocTagInfo[];
-    }
-    interface Type {
-        getFlags(): TypeFlags;
-        getSymbol(): Symbol | undefined;
-        getProperties(): Symbol[];
-        getProperty(propertyName: string): Symbol | undefined;
-        getApparentProperties(): Symbol[];
-        getCallSignatures(): readonly Signature[];
-        getConstructSignatures(): readonly Signature[];
-        getStringIndexType(): Type | undefined;
-        getNumberIndexType(): Type | undefined;
-        getBaseTypes(): BaseType[] | undefined;
-        getNonNullableType(): Type;
-        getConstraint(): Type | undefined;
-        getDefault(): Type | undefined;
-        isUnion(): this is UnionType;
-        isIntersection(): this is IntersectionType;
-        isUnionOrIntersection(): this is UnionOrIntersectionType;
-        isLiteral(): this is LiteralType;
-        isStringLiteral(): this is StringLiteralType;
-        isNumberLiteral(): this is NumberLiteralType;
-        isTypeParameter(): this is TypeParameter;
-        isClassOrInterface(): this is InterfaceType;
-        isClass(): this is InterfaceType;
-        isIndexType(): this is IndexType;
-    }
-    interface TypeReference {
-        typeArguments?: readonly Type[];
-    }
-    interface Signature {
-        getDeclaration(): SignatureDeclaration;
-        getTypeParameters(): TypeParameter[] | undefined;
-        getParameters(): Symbol[];
-        getTypeParameterAtPosition(pos: number): Type;
-        getReturnType(): Type;
-        getDocumentationComment(typeChecker: TypeChecker | undefined): SymbolDisplayPart[];
-        getJsDocTags(): JSDocTagInfo[];
-    }
-    interface SourceFile {
-        getLineAndCharacterOfPosition(pos: number): LineAndCharacter;
-        getLineEndOfPosition(pos: number): number;
-        getLineStarts(): readonly number[];
-        getPositionOfLineAndCharacter(line: number, character: number): number;
-        update(newText: string, textChangeRange: TextChangeRange): SourceFile;
+    export type InvalidatedProject<T extends BuilderProgram> = UpdateOutputFileStampsProject | BuildInvalidedProject<T> | UpdateBundleProject<T>;
+    export namespace FindAllReferences {
     }
-    interface SourceFileLike {
-        getLineAndCharacterOfPosition(pos: number): LineAndCharacter;
+    export namespace refactor {
+        export namespace extractSymbol {
+        }
     }
-    interface SourceMapSource {
-        getLineAndCharacterOfPosition(pos: number): LineAndCharacter;
+    export namespace formatting {
     }
+    export function getDefaultFormatCodeSettings(newLineCharacter?: string): FormatCodeSettings;
     /**
      * Represents an immutable snapshot of a script at a specified time.Once acquired, the
      * snapshot is observably immutable. i.e. the same calls with the same parameters will return
      * the same values.
      */
-    interface IScriptSnapshot {
+    export interface IScriptSnapshot {
         /** Gets a portion of the script snapshot specified by [start, end). */
         getText(start: number, end: number): string;
         /** Gets the length of this script snapshot. */
@@ -5789,10 +9836,10 @@ declare namespace ts {
         /** Releases all resources held by this script snapshot */
         dispose?(): void;
     }
-    namespace ScriptSnapshot {
+    export namespace ScriptSnapshot {
         function fromString(text: string): IScriptSnapshot;
     }
-    interface PreProcessedFileInfo {
+    export interface PreProcessedFileInfo {
         referencedFiles: FileReference[];
         typeReferenceDirectives: FileReference[];
         libReferenceDirectives: FileReference[];
@@ -5800,28 +9847,28 @@ declare namespace ts {
         ambientExternalModules?: string[];
         isLibFile: boolean;
     }
-    interface HostCancellationToken {
+    export interface HostCancellationToken {
         isCancellationRequested(): boolean;
     }
-    interface InstallPackageOptions {
+    export interface InstallPackageOptions {
         fileName: Path;
         packageName: string;
     }
-    interface PerformanceEvent {
+    export interface PerformanceEvent {
         kind: "UpdateGraph" | "CreatePackageJsonAutoImportProvider";
         durationMs: number;
     }
-    enum LanguageServiceMode {
+    export enum LanguageServiceMode {
         Semantic = 0,
         PartialSemantic = 1,
         Syntactic = 2
     }
-    interface IncompleteCompletionsCache {
+    export interface IncompleteCompletionsCache {
         get(): CompletionInfo | undefined;
         set(response: CompletionInfo): void;
         clear(): void;
     }
-    interface LanguageServiceHost extends GetEffectiveTypeRootsHost, MinimalResolutionCacheHost {
+    export interface LanguageServiceHost extends GetEffectiveTypeRootsHost, MinimalResolutionCacheHost {
         getCompilationSettings(): CompilerOptions;
         getNewLine?(): string;
         getProjectVersion?(): string;
@@ -5856,14 +9903,14 @@ declare namespace ts {
         writeFile?(fileName: string, content: string): void;
         getParsedCommandLine?(fileName: string): ParsedCommandLine | undefined;
     }
-    type WithMetadata<T> = T & {
+    export type WithMetadata<T> = T & {
         metadata?: unknown;
     };
-    enum SemanticClassificationFormat {
+    export enum SemanticClassificationFormat {
         Original = "original",
         TwentyTwenty = "2020"
     }
-    interface LanguageService {
+    export interface LanguageService {
         /** This is used as a part of restarting the language service. */
         cleanupSemanticCache(): void;
         /**
@@ -6025,18 +10072,18 @@ declare namespace ts {
         uncommentSelection(fileName: string, textRange: TextRange): TextChange[];
         dispose(): void;
     }
-    interface JsxClosingTagInfo {
+    export interface JsxClosingTagInfo {
         readonly newText: string;
     }
-    interface CombinedCodeFixScope {
+    export interface CombinedCodeFixScope {
         type: "file";
         fileName: string;
     }
-    interface OrganizeImportsArgs extends CombinedCodeFixScope {
+    export interface OrganizeImportsArgs extends CombinedCodeFixScope {
         skipDestructiveCodeActions?: boolean;
     }
-    type CompletionsTriggerCharacter = "." | '"' | "'" | "`" | "/" | "@" | "<" | "#" | " ";
-    enum CompletionTriggerKind {
+    export type CompletionsTriggerCharacter = "." | '"' | "'" | "`" | "/" | "@" | "<" | "#" | " ";
+    export enum CompletionTriggerKind {
         /** Completion was triggered by typing an identifier, manual invocation (e.g Ctrl+Space) or via API. */
         Invoked = 1,
         /** Completion was triggered by a trigger character. */
@@ -6044,7 +10091,7 @@ declare namespace ts {
         /** Completion was re-triggered as the current completion list is incomplete. */
         TriggerForIncompleteCompletions = 3
     }
-    interface GetCompletionsAtPositionOptions extends UserPreferences {
+    export interface GetCompletionsAtPositionOptions extends UserPreferences {
         /**
          * If the editor is asking for completions because a certain character was typed
          * (as opposed to when the user explicitly requested them) this should be set.
@@ -6056,17 +10103,17 @@ declare namespace ts {
         /** @deprecated Use includeCompletionsWithInsertText */
         includeInsertTextCompletions?: boolean;
     }
-    type SignatureHelpTriggerCharacter = "," | "(" | "<";
-    type SignatureHelpRetriggerCharacter = SignatureHelpTriggerCharacter | ")";
-    interface SignatureHelpItemsOptions {
+    export type SignatureHelpTriggerCharacter = "," | "(" | "<";
+    export type SignatureHelpRetriggerCharacter = SignatureHelpTriggerCharacter | ")";
+    export interface SignatureHelpItemsOptions {
         triggerReason?: SignatureHelpTriggerReason;
     }
-    type SignatureHelpTriggerReason = SignatureHelpInvokedReason | SignatureHelpCharacterTypedReason | SignatureHelpRetriggeredReason;
+    export type SignatureHelpTriggerReason = SignatureHelpInvokedReason | SignatureHelpCharacterTypedReason | SignatureHelpRetriggeredReason;
     /**
      * Signals that the user manually requested signature help.
      * The language service will unconditionally attempt to provide a result.
      */
-    interface SignatureHelpInvokedReason {
+    export interface SignatureHelpInvokedReason {
         kind: "invoked";
         triggerCharacter?: undefined;
     }
@@ -6074,7 +10121,7 @@ declare namespace ts {
      * Signals that the signature help request came from a user typing a character.
      * Depending on the character and the syntactic context, the request may or may not be served a result.
      */
-    interface SignatureHelpCharacterTypedReason {
+    export interface SignatureHelpCharacterTypedReason {
         kind: "characterTyped";
         /**
          * Character that was responsible for triggering signature help.
@@ -6087,25 +10134,25 @@ declare namespace ts {
      * The language service will unconditionally attempt to provide a result.
      * `triggerCharacter` can be `undefined` for a retrigger caused by a cursor move.
      */
-    interface SignatureHelpRetriggeredReason {
+    export interface SignatureHelpRetriggeredReason {
         kind: "retrigger";
         /**
          * Character that was responsible for triggering signature help.
          */
         triggerCharacter?: SignatureHelpRetriggerCharacter;
     }
-    interface ApplyCodeActionCommandResult {
+    export interface ApplyCodeActionCommandResult {
         successMessage: string;
     }
-    interface Classifications {
+    export interface Classifications {
         spans: number[];
         endOfLineState: EndOfLineState;
     }
-    interface ClassifiedSpan {
+    export interface ClassifiedSpan {
         textSpan: TextSpan;
         classificationType: ClassificationTypeNames;
     }
-    interface ClassifiedSpan2020 {
+    export interface ClassifiedSpan2020 {
         textSpan: TextSpan;
         classificationType: number;
     }
@@ -6115,7 +10162,7 @@ declare namespace ts {
      * The navbar is returned as a list of top-level items, each of which has a list of child items.
      * Child items always have an empty array for their `childItems`.
      */
-    interface NavigationBarItem {
+    export interface NavigationBarItem {
         text: string;
         kind: ScriptElementKind;
         kindModifiers: string;
@@ -6129,7 +10176,7 @@ declare namespace ts {
      * Node in a tree of nested declarations in a file.
      * The top node is always a script or module node.
      */
-    interface NavigationTree {
+    export interface NavigationTree {
         /** Name of the declaration, or a short description, e.g. "<class>". */
         text: string;
         kind: ScriptElementKind;
@@ -6144,7 +10191,7 @@ declare namespace ts {
         /** Present if non-empty */
         childItems?: NavigationTree[];
     }
-    interface CallHierarchyItem {
+    export interface CallHierarchyItem {
         name: string;
         kind: ScriptElementKind;
         kindModifiers?: string;
@@ -6153,45 +10200,45 @@ declare namespace ts {
         selectionSpan: TextSpan;
         containerName?: string;
     }
-    interface CallHierarchyIncomingCall {
+    export interface CallHierarchyIncomingCall {
         from: CallHierarchyItem;
         fromSpans: TextSpan[];
     }
-    interface CallHierarchyOutgoingCall {
+    export interface CallHierarchyOutgoingCall {
         to: CallHierarchyItem;
         fromSpans: TextSpan[];
     }
-    enum InlayHintKind {
+    export enum InlayHintKind {
         Type = "Type",
         Parameter = "Parameter",
         Enum = "Enum"
     }
-    interface InlayHint {
+    export interface InlayHint {
         text: string;
         position: number;
         kind: InlayHintKind;
         whitespaceBefore?: boolean;
         whitespaceAfter?: boolean;
     }
-    interface TodoCommentDescriptor {
+    export interface TodoCommentDescriptor {
         text: string;
         priority: number;
     }
-    interface TodoComment {
+    export interface TodoComment {
         descriptor: TodoCommentDescriptor;
         message: string;
         position: number;
     }
-    interface TextChange {
+    export interface TextChange {
         span: TextSpan;
         newText: string;
     }
-    interface FileTextChanges {
+    export interface FileTextChanges {
         fileName: string;
         textChanges: readonly TextChange[];
         isNewFile?: boolean;
     }
-    interface CodeAction {
+    export interface CodeAction {
         /** Description of the code action to display in the UI of the editor */
         description: string;
         /** Text changes to apply to each file as part of the code action */
@@ -6202,7 +10249,7 @@ declare namespace ts {
          */
         commands?: CodeActionCommand[];
     }
-    interface CodeFixAction extends CodeAction {
+    export interface CodeFixAction extends CodeAction {
         /** Short name to identify the fix, for use by telemetry. */
         fixName: string;
         /**
@@ -6212,17 +10259,17 @@ declare namespace ts {
         fixId?: {};
         fixAllDescription?: string;
     }
-    interface CombinedCodeActions {
+    export interface CombinedCodeActions {
         changes: readonly FileTextChanges[];
         commands?: readonly CodeActionCommand[];
     }
-    type CodeActionCommand = InstallPackageAction;
-    interface InstallPackageAction {
+    export type CodeActionCommand = InstallPackageAction;
+    export interface InstallPackageAction {
     }
     /**
      * A set of one or more available refactoring actions, grouped under a parent refactoring.
      */
-    interface ApplicableRefactorInfo {
+    export interface ApplicableRefactorInfo {
         /**
          * The programmatic name of the refactoring
          */
@@ -6246,7 +10293,7 @@ declare namespace ts {
      * Represents a single refactoring action - for example, the "Extract Method..." refactor might
      * offer several actions, each corresponding to a surround class or closure to extract into.
      */
-    interface RefactorActionInfo {
+    export interface RefactorActionInfo {
         /**
          * The programmatic name of the refactoring action
          */
@@ -6271,19 +10318,19 @@ declare namespace ts {
      * A set of edits to make in response to a refactor action, plus an optional
      * location where renaming should be invoked from
      */
-    interface RefactorEditInfo {
+    export interface RefactorEditInfo {
         edits: FileTextChanges[];
         renameFilename?: string;
         renameLocation?: number;
         commands?: CodeActionCommand[];
     }
-    type RefactorTriggerReason = "implicit" | "invoked";
-    interface TextInsertion {
+    export type RefactorTriggerReason = "implicit" | "invoked";
+    export interface TextInsertion {
         newText: string;
         /** The position in newText the caret should point to after the insertion. */
         caretOffset: number;
     }
-    interface DocumentSpan {
+    export interface DocumentSpan {
         textSpan: TextSpan;
         fileName: string;
         /**
@@ -6299,32 +10346,32 @@ declare namespace ts {
         contextSpan?: TextSpan;
         originalContextSpan?: TextSpan;
     }
-    interface RenameLocation extends DocumentSpan {
+    export interface RenameLocation extends DocumentSpan {
         readonly prefixText?: string;
         readonly suffixText?: string;
     }
-    interface ReferenceEntry extends DocumentSpan {
+    export interface ReferenceEntry extends DocumentSpan {
         isWriteAccess: boolean;
         isInString?: true;
     }
-    interface ImplementationLocation extends DocumentSpan {
+    export interface ImplementationLocation extends DocumentSpan {
         kind: ScriptElementKind;
         displayParts: SymbolDisplayPart[];
     }
-    enum HighlightSpanKind {
+    export enum HighlightSpanKind {
         none = "none",
         definition = "definition",
         reference = "reference",
         writtenReference = "writtenReference"
     }
-    interface HighlightSpan {
+    export interface HighlightSpan {
         fileName?: string;
         isInString?: true;
         textSpan: TextSpan;
         contextSpan?: TextSpan;
         kind: HighlightSpanKind;
     }
-    interface NavigateToItem {
+    export interface NavigateToItem {
         name: string;
         kind: ScriptElementKind;
         kindModifiers: string;
@@ -6335,18 +10382,18 @@ declare namespace ts {
         containerName: string;
         containerKind: ScriptElementKind;
     }
-    enum IndentStyle {
+    export enum IndentStyle {
         None = 0,
         Block = 1,
         Smart = 2
     }
-    enum SemicolonPreference {
+    export enum SemicolonPreference {
         Ignore = "ignore",
         Insert = "insert",
         Remove = "remove"
     }
     /** @deprecated - consider using EditorSettings instead */
-    interface EditorOptions {
+    export interface EditorOptions {
         BaseIndentSize?: number;
         IndentSize: number;
         TabSize: number;
@@ -6354,7 +10401,7 @@ declare namespace ts {
         ConvertTabsToSpaces: boolean;
         IndentStyle: IndentStyle;
     }
-    interface EditorSettings {
+    export interface EditorSettings {
         baseIndentSize?: number;
         indentSize?: number;
         tabSize?: number;
@@ -6364,7 +10411,7 @@ declare namespace ts {
         trimTrailingWhitespace?: boolean;
     }
     /** @deprecated - consider using FormatCodeSettings instead */
-    interface FormatCodeOptions extends EditorOptions {
+    export interface FormatCodeOptions extends EditorOptions {
         InsertSpaceAfterCommaDelimiter: boolean;
         InsertSpaceAfterSemicolonInForStatements: boolean;
         InsertSpaceBeforeAndAfterBinaryOperators: boolean;
@@ -6382,7 +10429,7 @@ declare namespace ts {
         PlaceOpenBraceOnNewLineForControlBlocks: boolean;
         insertSpaceBeforeTypeAnnotation?: boolean;
     }
-    interface FormatCodeSettings extends EditorSettings {
+    export interface FormatCodeSettings extends EditorSettings {
         readonly insertSpaceAfterCommaDelimiter?: boolean;
         readonly insertSpaceAfterSemicolonInForStatements?: boolean;
         readonly insertSpaceBeforeAndAfterBinaryOperators?: boolean;
@@ -6403,29 +10450,28 @@ declare namespace ts {
         readonly indentMultiLineObjectLiteralBeginningOnBlankLine?: boolean;
         readonly semicolons?: SemicolonPreference;
     }
-    function getDefaultFormatCodeSettings(newLineCharacter?: string): FormatCodeSettings;
-    interface DefinitionInfo extends DocumentSpan {
+    export interface DefinitionInfo extends DocumentSpan {
         kind: ScriptElementKind;
         name: string;
         containerKind: ScriptElementKind;
         containerName: string;
         unverified?: boolean;
     }
-    interface DefinitionInfoAndBoundSpan {
+    export interface DefinitionInfoAndBoundSpan {
         definitions?: readonly DefinitionInfo[];
         textSpan: TextSpan;
     }
-    interface ReferencedSymbolDefinitionInfo extends DefinitionInfo {
+    export interface ReferencedSymbolDefinitionInfo extends DefinitionInfo {
         displayParts: SymbolDisplayPart[];
     }
-    interface ReferencedSymbol {
+    export interface ReferencedSymbol {
         definition: ReferencedSymbolDefinitionInfo;
         references: ReferencedSymbolEntry[];
     }
-    interface ReferencedSymbolEntry extends ReferenceEntry {
+    export interface ReferencedSymbolEntry extends ReferenceEntry {
         isDefinition?: boolean;
     }
-    enum SymbolDisplayPartKind {
+    export enum SymbolDisplayPartKind {
         aliasName = 0,
         className = 1,
         enumName = 2,
@@ -6452,18 +10498,18 @@ declare namespace ts {
         linkName = 23,
         linkText = 24
     }
-    interface SymbolDisplayPart {
+    export interface SymbolDisplayPart {
         text: string;
         kind: string;
     }
-    interface JSDocLinkDisplayPart extends SymbolDisplayPart {
+    export interface JSDocLinkDisplayPart extends SymbolDisplayPart {
         target: DocumentSpan;
     }
-    interface JSDocTagInfo {
+    export interface JSDocTagInfo {
         name: string;
         text?: SymbolDisplayPart[];
     }
-    interface QuickInfo {
+    export interface QuickInfo {
         kind: ScriptElementKind;
         kindModifiers: string;
         textSpan: TextSpan;
@@ -6471,8 +10517,8 @@ declare namespace ts {
         documentation?: SymbolDisplayPart[];
         tags?: JSDocTagInfo[];
     }
-    type RenameInfo = RenameInfoSuccess | RenameInfoFailure;
-    interface RenameInfoSuccess {
+    export type RenameInfo = RenameInfoSuccess | RenameInfoFailure;
+    export interface RenameInfoSuccess {
         canRename: true;
         /**
          * File or directory to rename.
@@ -6485,27 +10531,27 @@ declare namespace ts {
         kindModifiers: string;
         triggerSpan: TextSpan;
     }
-    interface RenameInfoFailure {
+    export interface RenameInfoFailure {
         canRename: false;
         localizedErrorMessage: string;
     }
     /**
      * @deprecated Use `UserPreferences` instead.
      */
-    interface RenameInfoOptions {
+    export interface RenameInfoOptions {
         readonly allowRenameOfImportPath?: boolean;
     }
-    interface DocCommentTemplateOptions {
+    export interface DocCommentTemplateOptions {
         readonly generateReturnInDocTemplate?: boolean;
     }
-    interface SignatureHelpParameter {
+    export interface SignatureHelpParameter {
         name: string;
         documentation: SymbolDisplayPart[];
         displayParts: SymbolDisplayPart[];
         isOptional: boolean;
         isRest?: boolean;
     }
-    interface SelectionRange {
+    export interface SelectionRange {
         textSpan: TextSpan;
         parent?: SelectionRange;
     }
@@ -6516,7 +10562,7 @@ declare namespace ts {
      * an edit has happened, while signature help is still active, the host can ask important
      * questions like 'what parameter is the user currently contained within?'.
      */
-    interface SignatureHelpItem {
+    export interface SignatureHelpItem {
         isVariadic: boolean;
         prefixDisplayParts: SymbolDisplayPart[];
         suffixDisplayParts: SymbolDisplayPart[];
@@ -6528,14 +10574,14 @@ declare namespace ts {
     /**
      * Represents a set of signature help items, and the preferred item that should be selected.
      */
-    interface SignatureHelpItems {
+    export interface SignatureHelpItems {
         items: SignatureHelpItem[];
         applicableSpan: TextSpan;
         selectedItemIndex: number;
         argumentIndex: number;
         argumentCount: number;
     }
-    enum CompletionInfoFlags {
+    export enum CompletionInfoFlags {
         None = 0,
         MayIncludeAutoImports = 1,
         IsImportStatementCompletion = 2,
@@ -6544,7 +10590,7 @@ declare namespace ts {
         ResolvedModuleSpecifiersBeyondLimit = 16,
         MayIncludeMethodSnippets = 32
     }
-    interface CompletionInfo {
+    export interface CompletionInfo {
         /** For performance telemetry. */
         flags?: CompletionInfoFlags;
         /** Not true for all global completions. This will be true if the enclosing scope matches a few syntax kinds. See `isSnippetScope`. */
@@ -6566,7 +10612,7 @@ declare namespace ts {
         isIncomplete?: true;
         entries: CompletionEntry[];
     }
-    interface CompletionEntryDataAutoImport {
+    export interface CompletionEntryDataAutoImport {
         /**
          * The name of the property or export in the module's symbol table. Differs from the completion name
          * in the case of InternalSymbolName.ExportEquals and InternalSymbolName.Default.
@@ -6580,15 +10626,15 @@ declare namespace ts {
         /** True if the export was found in the package.json AutoImportProvider */
         isPackageJsonImport?: true;
     }
-    interface CompletionEntryDataUnresolved extends CompletionEntryDataAutoImport {
+    export interface CompletionEntryDataUnresolved extends CompletionEntryDataAutoImport {
         /** The key in the `ExportMapCache` where the completion entry's `SymbolExportInfo[]` is found */
         exportMapKey: string;
     }
-    interface CompletionEntryDataResolved extends CompletionEntryDataAutoImport {
+    export interface CompletionEntryDataResolved extends CompletionEntryDataAutoImport {
         moduleSpecifier: string;
     }
-    type CompletionEntryData = CompletionEntryDataUnresolved | CompletionEntryDataResolved;
-    interface CompletionEntry {
+    export type CompletionEntryData = CompletionEntryDataUnresolved | CompletionEntryDataResolved;
+    export interface CompletionEntry {
         name: string;
         kind: ScriptElementKind;
         kindModifiers?: string;
@@ -6619,11 +10665,11 @@ declare namespace ts {
          */
         data?: CompletionEntryData;
     }
-    interface CompletionEntryLabelDetails {
+    export interface CompletionEntryLabelDetails {
         detail?: string;
         description?: string;
     }
-    interface CompletionEntryDetails {
+    export interface CompletionEntryDetails {
         name: string;
         kind: ScriptElementKind;
         kindModifiers: string;
@@ -6635,7 +10681,7 @@ declare namespace ts {
         source?: SymbolDisplayPart[];
         sourceDisplay?: SymbolDisplayPart[];
     }
-    interface OutliningSpan {
+    export interface OutliningSpan {
         /** The span of the document to actually collapse. */
         textSpan: TextSpan;
         /** The span of the document to display when the user hovers over the collapsed span. */
@@ -6652,7 +10698,7 @@ declare namespace ts {
          */
         kind: OutliningSpanKind;
     }
-    enum OutliningSpanKind {
+    export enum OutliningSpanKind {
         /** Single or multi-line comments */
         Comment = "comment",
         /** Sections marked by '// #region' and '// #endregion' comments */
@@ -6662,12 +10708,12 @@ declare namespace ts {
         /** Contiguous blocks of import declarations */
         Imports = "imports"
     }
-    enum OutputFileType {
+    export enum OutputFileType {
         JavaScript = 0,
         SourceMap = 1,
         Declaration = 2
     }
-    enum EndOfLineState {
+    export enum EndOfLineState {
         None = 0,
         InMultiLineCommentTrivia = 1,
         InSingleQuoteStringLiteral = 2,
@@ -6676,7 +10722,7 @@ declare namespace ts {
         InTemplateMiddleOrTail = 5,
         InTemplateSubstitutionPosition = 6
     }
-    enum TokenClass {
+    export enum TokenClass {
         Punctuation = 0,
         Keyword = 1,
         Operator = 2,
@@ -6688,15 +10734,15 @@ declare namespace ts {
         StringLiteral = 8,
         RegExpLiteral = 9
     }
-    interface ClassificationResult {
+    export interface ClassificationResult {
         finalLexState: EndOfLineState;
         entries: ClassificationInfo[];
     }
-    interface ClassificationInfo {
+    export interface ClassificationInfo {
         length: number;
         classification: TokenClass;
     }
-    interface Classifier {
+    export interface Classifier {
         /**
          * Gives lexical classifications of tokens on a line without any syntactic context.
          * For instance, a token consisting of the text 'string' can be either an identifier
@@ -6720,7 +10766,7 @@ declare namespace ts {
         getClassificationsForLine(text: string, lexState: EndOfLineState, syntacticClassifierAbsent: boolean): ClassificationResult;
         getEncodedLexicalClassifications(text: string, endOfLineState: EndOfLineState, syntacticClassifierAbsent: boolean): Classifications;
     }
-    enum ScriptElementKind {
+    export enum ScriptElementKind {
         unknown = "",
         warning = "warning",
         /** predefined type (void) or keyword (class) */
@@ -6801,7 +10847,7 @@ declare namespace ts {
         /** Jsdoc @link: in `{@link C link text}`, the link text "link text" */
         linkText = "link text"
     }
-    enum ScriptElementKindModifier {
+    export enum ScriptElementKindModifier {
         none = "",
         publicMemberModifier = "public",
         privateMemberModifier = "private",
@@ -6825,7 +10871,7 @@ declare namespace ts {
         ctsModifier = ".cts",
         cjsModifier = ".cjs"
     }
-    enum ClassificationTypeNames {
+    export enum ClassificationTypeNames {
         comment = "comment",
         identifier = "identifier",
         keyword = "keyword",
@@ -6851,7 +10897,7 @@ declare namespace ts {
         jsxText = "jsx text",
         jsxAttributeStringLiteralValue = "jsx attribute string literal value"
     }
-    enum ClassificationType {
+    export enum ClassificationType {
         comment = 1,
         identifier = 2,
         keyword = 3,
@@ -6878,7 +10924,7 @@ declare namespace ts {
         jsxAttributeStringLiteralValue = 24,
         bigintLiteral = 25
     }
-    interface InlayHintsContext {
+    export interface InlayHintsContext {
         file: SourceFile;
         program: Program;
         cancellationToken: CancellationToken;
@@ -6886,18 +10932,13 @@ declare namespace ts {
         span: TextSpan;
         preferences: UserPreferences;
     }
-}
-declare namespace ts {
     /** The classifier is used for syntactic highlighting in editors via the TSServer */
-    function createClassifier(): Classifier;
-}
-declare namespace ts {
-    interface DocumentHighlights {
+    export function createClassifier(): Classifier;
+    export interface DocumentHighlights {
         fileName: string;
         highlightSpans: HighlightSpan[];
     }
-}
-declare namespace ts {
+    export function createDocumentRegistry(useCaseSensitiveFileNames?: boolean, currentDirectory?: string): DocumentRegistry;
     /**
      * The document registry represents a store of SourceFile objects that can be shared between
      * multiple LanguageService instances. A LanguageService instance holds on the SourceFile (AST)
@@ -6913,7 +10954,7 @@ declare namespace ts {
      * To create a default DocumentRegistry, use createDocumentRegistry to create one, and pass it
      * to all subsequent createLanguageService calls.
      */
-    interface DocumentRegistry {
+    export interface DocumentRegistry {
         /**
          * Request a stored SourceFile with a given fileName and compilationSettings.
          * The first call to acquire will call createLanguageServiceSourceFile to generate
@@ -6960,8 +11001,9 @@ declare namespace ts {
          * @param fileName The name of the file to be released
          * @param compilationSettings The compilation settings used to acquire the file
          * @param scriptKind The script kind of the file to be released
+         *
+         * @deprecated pass scriptKind and impliedNodeFormat for correctness
          */
-        /**@deprecated pass scriptKind and impliedNodeFormat for correctness */
         releaseDocument(fileName: string, compilationSettings: CompilerOptions, scriptKind?: ScriptKind): void;
         /**
          * Informs the DocumentRegistry that a file is not needed any longer.
@@ -6981,16 +11023,13 @@ declare namespace ts {
         releaseDocumentWithKey(path: Path, key: DocumentRegistryBucketKey, scriptKind: ScriptKind, impliedNodeFormat: SourceFile["impliedNodeFormat"]): void;
         reportStats(): string;
     }
-    type DocumentRegistryBucketKey = string & {
+    export type DocumentRegistryBucketKey = string & {
         __bucketKey: any;
     };
-    function createDocumentRegistry(useCaseSensitiveFileNames?: boolean, currentDirectory?: string): DocumentRegistry;
-}
-declare namespace ts {
-    function preProcessFile(sourceText: string, readImportFiles?: boolean, detectJavaScriptImports?: boolean): PreProcessedFileInfo;
-}
-declare namespace ts {
-    interface TranspileOptions {
+    export function preProcessFile(sourceText: string, readImportFiles?: boolean, detectJavaScriptImports?: boolean): PreProcessedFileInfo;
+    export function transpileModule(input: string, transpileOptions: TranspileOptions): TranspileOutput;
+    export function transpile(input: string, compilerOptions?: CompilerOptions, fileName?: string, diagnostics?: Diagnostic[], moduleName?: string): string;
+    export interface TranspileOptions {
         compilerOptions?: CompilerOptions;
         fileName?: string;
         reportDiagnostics?: boolean;
@@ -6998,4757 +11037,751 @@ declare namespace ts {
         renamedDependencies?: MapLike<string>;
         transformers?: CustomTransformers;
     }
-    interface TranspileOutput {
+    export interface TranspileOutput {
         outputText: string;
         diagnostics?: Diagnostic[];
         sourceMapText?: string;
     }
-    function transpileModule(input: string, transpileOptions: TranspileOptions): TranspileOutput;
-    function transpile(input: string, compilerOptions?: CompilerOptions, fileName?: string, diagnostics?: Diagnostic[], moduleName?: string): string;
-}
-declare namespace ts {
-    /** The version of the language service API */
-    const servicesVersion = "0.8";
-    function toEditorSettings(options: EditorOptions | EditorSettings): EditorSettings;
-    function displayPartsToString(displayParts: SymbolDisplayPart[] | undefined): string;
-    function getDefaultCompilerOptions(): CompilerOptions;
-    function getSupportedCodeFixes(): string[];
-    function createLanguageServiceSourceFile(fileName: string, scriptSnapshot: IScriptSnapshot, scriptTargetOrOptions: ScriptTarget | CreateSourceFileOptions, version: string, setNodeParents: boolean, scriptKind?: ScriptKind): SourceFile;
-    function updateLanguageServiceSourceFile(sourceFile: SourceFile, scriptSnapshot: IScriptSnapshot, version: string, textChangeRange: TextChangeRange | undefined, aggressiveChecks?: boolean): SourceFile;
-    function createLanguageService(host: LanguageServiceHost, documentRegistry?: DocumentRegistry, syntaxOnlyOrLanguageServiceMode?: boolean | LanguageServiceMode): LanguageService;
+    export function toEditorSettings(options: EditorOptions | EditorSettings): EditorSettings;
+    export function displayPartsToString(displayParts: SymbolDisplayPart[] | undefined): string;
+    export function getDefaultCompilerOptions(): CompilerOptions;
+    export function getSupportedCodeFixes(): string[];
+    export function createLanguageServiceSourceFile(fileName: string, scriptSnapshot: IScriptSnapshot, scriptTargetOrOptions: ScriptTarget | CreateSourceFileOptions, version: string, setNodeParents: boolean, scriptKind?: ScriptKind): SourceFile;
+    export function updateLanguageServiceSourceFile(sourceFile: SourceFile, scriptSnapshot: IScriptSnapshot, version: string, textChangeRange: TextChangeRange | undefined, aggressiveChecks?: boolean): SourceFile;
+    export function createLanguageService(host: LanguageServiceHost, documentRegistry?: DocumentRegistry, syntaxOnlyOrLanguageServiceMode?: boolean | LanguageServiceMode): LanguageService;
     /**
      * Get the path of the default library files (lib.d.ts) as distributed with the typescript
      * node package.
      * The functionality is not supported if the ts module is consumed outside of a node module.
      */
-    function getDefaultLibFilePath(options: CompilerOptions): string;
-}
-declare namespace ts {
+    export function getDefaultLibFilePath(options: CompilerOptions): string;
+    /** The version of the language service API */
+    export const servicesVersion = "0.8";
     /**
      * Transform one or more nodes using the supplied transformers.
      * @param source A single `Node` or an array of `Node` objects.
      * @param transformers An array of `TransformerFactory` callbacks used to process the transformation.
      * @param compilerOptions Optional compiler options.
      */
-    function transform<T extends Node>(source: T | T[], transformers: TransformerFactory<T>[], compilerOptions?: CompilerOptions): TransformationResult<T>;
-}
-declare namespace ts.server {
-    interface CompressedData {
-        length: number;
-        compressionKind: string;
-        data: any;
-    }
-    type ModuleImportResult = {
-        module: {};
-        error: undefined;
-    } | {
-        module: undefined;
-        error: {
-            stack?: string;
-            message?: string;
-        };
-    };
-    /** @deprecated Use {@link ModuleImportResult} instead. */
-    type RequireResult = ModuleImportResult;
-    interface ServerHost extends System {
-        watchFile(path: string, callback: FileWatcherCallback, pollingInterval?: number, options?: WatchOptions): FileWatcher;
-        watchDirectory(path: string, callback: DirectoryWatcherCallback, recursive?: boolean, options?: WatchOptions): FileWatcher;
-        setTimeout(callback: (...args: any[]) => void, ms: number, ...args: any[]): any;
-        clearTimeout(timeoutId: any): void;
-        setImmediate(callback: (...args: any[]) => void, ...args: any[]): any;
-        clearImmediate(timeoutId: any): void;
-        gc?(): void;
-        trace?(s: string): void;
-        require?(initialPath: string, moduleName: string): ModuleImportResult;
-    }
-}
-declare namespace ts.server {
-    enum LogLevel {
-        terse = 0,
-        normal = 1,
-        requestTime = 2,
-        verbose = 3
-    }
-    const emptyArray: SortedReadonlyArray<never>;
-    interface Logger {
-        close(): void;
-        hasLevel(level: LogLevel): boolean;
-        loggingEnabled(): boolean;
-        perftrc(s: string): void;
-        info(s: string): void;
-        startGroup(): void;
-        endGroup(): void;
-        msg(s: string, type?: Msg): void;
-        getLogFileName(): string | undefined;
-    }
-    enum Msg {
-        Err = "Err",
-        Info = "Info",
-        Perf = "Perf"
-    }
-    namespace Msg {
-        /** @deprecated Only here for backwards-compatibility. Prefer just `Msg`. */
-        type Types = Msg;
-    }
-    function createInstallTypingsRequest(project: Project, typeAcquisition: TypeAcquisition, unresolvedImports: SortedReadonlyArray<string>, cachePath?: string): DiscoverTypings;
-    namespace Errors {
-        function ThrowNoProject(): never;
-        function ThrowProjectLanguageServiceDisabled(): never;
-        function ThrowProjectDoesNotContainDocument(fileName: string, project: Project): never;
-    }
-    type NormalizedPath = string & {
-        __normalizedPathTag: any;
-    };
-    function toNormalizedPath(fileName: string): NormalizedPath;
-    function normalizedPathToPath(normalizedPath: NormalizedPath, currentDirectory: string, getCanonicalFileName: (f: string) => string): Path;
-    function asNormalizedPath(fileName: string): NormalizedPath;
-    interface NormalizedPathMap<T> {
-        get(path: NormalizedPath): T | undefined;
-        set(path: NormalizedPath, value: T): void;
-        contains(path: NormalizedPath): boolean;
-        remove(path: NormalizedPath): void;
-    }
-    function createNormalizedPathMap<T>(): NormalizedPathMap<T>;
-    function isInferredProjectName(name: string): boolean;
-    function makeInferredProjectName(counter: number): string;
-    function createSortedArray<T>(): SortedArray<T>;
-}
-/**
- * Declaration module describing the TypeScript Server protocol
- */
-declare namespace ts.server.protocol {
-    enum CommandTypes {
-        JsxClosingTag = "jsxClosingTag",
-        Brace = "brace",
-        BraceCompletion = "braceCompletion",
-        GetSpanOfEnclosingComment = "getSpanOfEnclosingComment",
-        Change = "change",
-        Close = "close",
-        /** @deprecated Prefer CompletionInfo -- see comment on CompletionsResponse */
-        Completions = "completions",
-        CompletionInfo = "completionInfo",
-        CompletionDetails = "completionEntryDetails",
-        CompileOnSaveAffectedFileList = "compileOnSaveAffectedFileList",
-        CompileOnSaveEmitFile = "compileOnSaveEmitFile",
-        Configure = "configure",
-        Definition = "definition",
-        DefinitionAndBoundSpan = "definitionAndBoundSpan",
-        Implementation = "implementation",
-        Exit = "exit",
-        FileReferences = "fileReferences",
-        Format = "format",
-        Formatonkey = "formatonkey",
-        Geterr = "geterr",
-        GeterrForProject = "geterrForProject",
-        SemanticDiagnosticsSync = "semanticDiagnosticsSync",
-        SyntacticDiagnosticsSync = "syntacticDiagnosticsSync",
-        SuggestionDiagnosticsSync = "suggestionDiagnosticsSync",
-        NavBar = "navbar",
-        Navto = "navto",
-        NavTree = "navtree",
-        NavTreeFull = "navtree-full",
-        /** @deprecated */
-        Occurrences = "occurrences",
-        DocumentHighlights = "documentHighlights",
-        Open = "open",
-        Quickinfo = "quickinfo",
-        References = "references",
-        Reload = "reload",
-        Rename = "rename",
-        Saveto = "saveto",
-        SignatureHelp = "signatureHelp",
-        FindSourceDefinition = "findSourceDefinition",
-        Status = "status",
-        TypeDefinition = "typeDefinition",
-        ProjectInfo = "projectInfo",
-        ReloadProjects = "reloadProjects",
-        Unknown = "unknown",
-        OpenExternalProject = "openExternalProject",
-        OpenExternalProjects = "openExternalProjects",
-        CloseExternalProject = "closeExternalProject",
-        UpdateOpen = "updateOpen",
-        GetOutliningSpans = "getOutliningSpans",
-        TodoComments = "todoComments",
-        Indentation = "indentation",
-        DocCommentTemplate = "docCommentTemplate",
-        CompilerOptionsForInferredProjects = "compilerOptionsForInferredProjects",
-        GetCodeFixes = "getCodeFixes",
-        GetCombinedCodeFix = "getCombinedCodeFix",
-        ApplyCodeActionCommand = "applyCodeActionCommand",
-        GetSupportedCodeFixes = "getSupportedCodeFixes",
-        GetApplicableRefactors = "getApplicableRefactors",
-        GetEditsForRefactor = "getEditsForRefactor",
-        OrganizeImports = "organizeImports",
-        GetEditsForFileRename = "getEditsForFileRename",
-        ConfigurePlugin = "configurePlugin",
-        SelectionRange = "selectionRange",
-        ToggleLineComment = "toggleLineComment",
-        ToggleMultilineComment = "toggleMultilineComment",
-        CommentSelection = "commentSelection",
-        UncommentSelection = "uncommentSelection",
-        PrepareCallHierarchy = "prepareCallHierarchy",
-        ProvideCallHierarchyIncomingCalls = "provideCallHierarchyIncomingCalls",
-        ProvideCallHierarchyOutgoingCalls = "provideCallHierarchyOutgoingCalls",
-        ProvideInlayHints = "provideInlayHints"
-    }
-    /**
-     * A TypeScript Server message
-     */
-    interface Message {
-        /**
-         * Sequence number of the message
-         */
-        seq: number;
-        /**
-         * One of "request", "response", or "event"
-         */
-        type: "request" | "response" | "event";
-    }
-    /**
-     * Client-initiated request message
-     */
-    interface Request extends Message {
-        type: "request";
-        /**
-         * The command to execute
-         */
-        command: string;
-        /**
-         * Object containing arguments for the command
-         */
-        arguments?: any;
-    }
-    /**
-     * Request to reload the project structure for all the opened files
-     */
-    interface ReloadProjectsRequest extends Message {
-        command: CommandTypes.ReloadProjects;
-    }
-    /**
-     * Server-initiated event message
-     */
-    interface Event extends Message {
-        type: "event";
-        /**
-         * Name of event
-         */
-        event: string;
-        /**
-         * Event-specific information
-         */
-        body?: any;
-    }
-    /**
-     * Response by server to client request message.
-     */
-    interface Response extends Message {
-        type: "response";
-        /**
-         * Sequence number of the request message.
-         */
-        request_seq: number;
-        /**
-         * Outcome of the request.
-         */
-        success: boolean;
-        /**
-         * The command requested.
-         */
-        command: string;
-        /**
-         * If success === false, this should always be provided.
-         * Otherwise, may (or may not) contain a success message.
-         */
-        message?: string;
-        /**
-         * Contains message body if success === true.
-         */
-        body?: any;
-        /**
-         * Contains extra information that plugin can include to be passed on
-         */
-        metadata?: unknown;
-        /**
-         * Exposes information about the performance of this request-response pair.
-         */
-        performanceData?: PerformanceData;
-    }
-    interface PerformanceData {
-        /**
-         * Time spent updating the program graph, in milliseconds.
-         */
-        updateGraphDurationMs?: number;
-        /**
-         * The time spent creating or updating the auto-import program, in milliseconds.
-         */
-        createAutoImportProviderProgramDurationMs?: number;
-    }
-    /**
-     * Arguments for FileRequest messages.
-     */
-    interface FileRequestArgs {
-        /**
-         * The file for the request (absolute pathname required).
-         */
-        file: string;
-        projectFileName?: string;
-    }
-    interface StatusRequest extends Request {
-        command: CommandTypes.Status;
-    }
-    interface StatusResponseBody {
-        /**
-         * The TypeScript version (`ts.version`).
-         */
-        version: string;
-    }
-    /**
-     * Response to StatusRequest
-     */
-    interface StatusResponse extends Response {
-        body: StatusResponseBody;
-    }
-    /**
-     * Requests a JS Doc comment template for a given position
-     */
-    interface DocCommentTemplateRequest extends FileLocationRequest {
-        command: CommandTypes.DocCommentTemplate;
-    }
-    /**
-     * Response to DocCommentTemplateRequest
-     */
-    interface DocCommandTemplateResponse extends Response {
-        body?: TextInsertion;
-    }
-    /**
-     * A request to get TODO comments from the file
-     */
-    interface TodoCommentRequest extends FileRequest {
-        command: CommandTypes.TodoComments;
-        arguments: TodoCommentRequestArgs;
-    }
-    /**
-     * Arguments for TodoCommentRequest request.
-     */
-    interface TodoCommentRequestArgs extends FileRequestArgs {
-        /**
-         * Array of target TodoCommentDescriptors that describes TODO comments to be found
-         */
-        descriptors: TodoCommentDescriptor[];
-    }
-    /**
-     * Response for TodoCommentRequest request.
-     */
-    interface TodoCommentsResponse extends Response {
-        body?: TodoComment[];
-    }
-    /**
-     * A request to determine if the caret is inside a comment.
-     */
-    interface SpanOfEnclosingCommentRequest extends FileLocationRequest {
-        command: CommandTypes.GetSpanOfEnclosingComment;
-        arguments: SpanOfEnclosingCommentRequestArgs;
-    }
-    interface SpanOfEnclosingCommentRequestArgs extends FileLocationRequestArgs {
-        /**
-         * Requires that the enclosing span be a multi-line comment, or else the request returns undefined.
-         */
-        onlyMultiLine: boolean;
-    }
-    /**
-     * Request to obtain outlining spans in file.
-     */
-    interface OutliningSpansRequest extends FileRequest {
-        command: CommandTypes.GetOutliningSpans;
-    }
-    interface OutliningSpan {
-        /** The span of the document to actually collapse. */
-        textSpan: TextSpan;
-        /** The span of the document to display when the user hovers over the collapsed span. */
-        hintSpan: TextSpan;
-        /** The text to display in the editor for the collapsed region. */
-        bannerText: string;
-        /**
-         * Whether or not this region should be automatically collapsed when
-         * the 'Collapse to Definitions' command is invoked.
-         */
-        autoCollapse: boolean;
-        /**
-         * Classification of the contents of the span
-         */
-        kind: OutliningSpanKind;
-    }
-    /**
-     * Response to OutliningSpansRequest request.
-     */
-    interface OutliningSpansResponse extends Response {
-        body?: OutliningSpan[];
-    }
-    /**
-     * A request to get indentation for a location in file
-     */
-    interface IndentationRequest extends FileLocationRequest {
-        command: CommandTypes.Indentation;
-        arguments: IndentationRequestArgs;
-    }
-    /**
-     * Response for IndentationRequest request.
-     */
-    interface IndentationResponse extends Response {
-        body?: IndentationResult;
-    }
-    /**
-     * Indentation result representing where indentation should be placed
-     */
-    interface IndentationResult {
-        /**
-         * The base position in the document that the indent should be relative to
-         */
-        position: number;
-        /**
-         * The number of columns the indent should be at relative to the position's column.
-         */
-        indentation: number;
-    }
-    /**
-     * Arguments for IndentationRequest request.
-     */
-    interface IndentationRequestArgs extends FileLocationRequestArgs {
-        /**
-         * An optional set of settings to be used when computing indentation.
-         * If argument is omitted - then it will use settings for file that were previously set via 'configure' request or global settings.
-         */
-        options?: EditorSettings;
-    }
-    /**
-     * Arguments for ProjectInfoRequest request.
-     */
-    interface ProjectInfoRequestArgs extends FileRequestArgs {
-        /**
-         * Indicate if the file name list of the project is needed
-         */
-        needFileNameList: boolean;
-    }
-    /**
-     * A request to get the project information of the current file.
-     */
-    interface ProjectInfoRequest extends Request {
-        command: CommandTypes.ProjectInfo;
-        arguments: ProjectInfoRequestArgs;
-    }
-    /**
-     * A request to retrieve compiler options diagnostics for a project
-     */
-    interface CompilerOptionsDiagnosticsRequest extends Request {
-        arguments: CompilerOptionsDiagnosticsRequestArgs;
-    }
-    /**
-     * Arguments for CompilerOptionsDiagnosticsRequest request.
-     */
-    interface CompilerOptionsDiagnosticsRequestArgs {
-        /**
-         * Name of the project to retrieve compiler options diagnostics.
-         */
-        projectFileName: string;
-    }
-    /**
-     * Response message body for "projectInfo" request
-     */
-    interface ProjectInfo {
-        /**
-         * For configured project, this is the normalized path of the 'tsconfig.json' file
-         * For inferred project, this is undefined
-         */
-        configFileName: string;
-        /**
-         * The list of normalized file name in the project, including 'lib.d.ts'
-         */
-        fileNames?: string[];
-        /**
-         * Indicates if the project has a active language service instance
-         */
-        languageServiceDisabled?: boolean;
-    }
-    /**
-     * Represents diagnostic info that includes location of diagnostic in two forms
-     * - start position and length of the error span
-     * - startLocation and endLocation - a pair of Location objects that store start/end line and offset of the error span.
-     */
-    interface DiagnosticWithLinePosition {
-        message: string;
-        start: number;
-        length: number;
-        startLocation: Location;
-        endLocation: Location;
-        category: string;
-        code: number;
-        /** May store more in future. For now, this will simply be `true` to indicate when a diagnostic is an unused-identifier diagnostic. */
-        reportsUnnecessary?: {};
-        reportsDeprecated?: {};
-        relatedInformation?: DiagnosticRelatedInformation[];
-    }
-    /**
-     * Response message for "projectInfo" request
-     */
-    interface ProjectInfoResponse extends Response {
-        body?: ProjectInfo;
-    }
-    /**
-     * Request whose sole parameter is a file name.
-     */
-    interface FileRequest extends Request {
-        arguments: FileRequestArgs;
-    }
-    /**
-     * Instances of this interface specify a location in a source file:
-     * (file, line, character offset), where line and character offset are 1-based.
-     */
-    interface FileLocationRequestArgs extends FileRequestArgs {
-        /**
-         * The line number for the request (1-based).
-         */
-        line: number;
-        /**
-         * The character offset (on the line) for the request (1-based).
-         */
-        offset: number;
-    }
-    type FileLocationOrRangeRequestArgs = FileLocationRequestArgs | FileRangeRequestArgs;
-    /**
-     * Request refactorings at a given position or selection area.
-     */
-    interface GetApplicableRefactorsRequest extends Request {
-        command: CommandTypes.GetApplicableRefactors;
-        arguments: GetApplicableRefactorsRequestArgs;
-    }
-    type GetApplicableRefactorsRequestArgs = FileLocationOrRangeRequestArgs & {
-        triggerReason?: RefactorTriggerReason;
-        kind?: string;
-    };
-    type RefactorTriggerReason = "implicit" | "invoked";
-    /**
-     * Response is a list of available refactorings.
-     * Each refactoring exposes one or more "Actions"; a user selects one action to invoke a refactoring
-     */
-    interface GetApplicableRefactorsResponse extends Response {
-        body?: ApplicableRefactorInfo[];
-    }
-    /**
-     * A set of one or more available refactoring actions, grouped under a parent refactoring.
-     */
-    interface ApplicableRefactorInfo {
-        /**
-         * The programmatic name of the refactoring
-         */
-        name: string;
-        /**
-         * A description of this refactoring category to show to the user.
-         * If the refactoring gets inlined (see below), this text will not be visible.
-         */
-        description: string;
-        /**
-         * Inlineable refactorings can have their actions hoisted out to the top level
-         * of a context menu. Non-inlineanable refactorings should always be shown inside
-         * their parent grouping.
-         *
-         * If not specified, this value is assumed to be 'true'
-         */
-        inlineable?: boolean;
-        actions: RefactorActionInfo[];
-    }
-    /**
-     * Represents a single refactoring action - for example, the "Extract Method..." refactor might
-     * offer several actions, each corresponding to a surround class or closure to extract into.
-     */
-    interface RefactorActionInfo {
-        /**
-         * The programmatic name of the refactoring action
-         */
-        name: string;
-        /**
-         * A description of this refactoring action to show to the user.
-         * If the parent refactoring is inlined away, this will be the only text shown,
-         * so this description should make sense by itself if the parent is inlineable=true
-         */
-        description: string;
-        /**
-         * A message to show to the user if the refactoring cannot be applied in
-         * the current context.
-         */
-        notApplicableReason?: string;
-        /**
-         * The hierarchical dotted name of the refactor action.
-         */
-        kind?: string;
-    }
-    interface GetEditsForRefactorRequest extends Request {
-        command: CommandTypes.GetEditsForRefactor;
-        arguments: GetEditsForRefactorRequestArgs;
-    }
-    /**
-     * Request the edits that a particular refactoring action produces.
-     * Callers must specify the name of the refactor and the name of the action.
-     */
-    type GetEditsForRefactorRequestArgs = FileLocationOrRangeRequestArgs & {
-        refactor: string;
-        action: string;
-    };
-    interface GetEditsForRefactorResponse extends Response {
-        body?: RefactorEditInfo;
-    }
-    interface RefactorEditInfo {
-        edits: FileCodeEdits[];
-        /**
-         * An optional location where the editor should start a rename operation once
-         * the refactoring edits have been applied
-         */
-        renameLocation?: Location;
-        renameFilename?: string;
-    }
-    /**
-     * Organize imports by:
-     *   1) Removing unused imports
-     *   2) Coalescing imports from the same module
-     *   3) Sorting imports
-     */
-    interface OrganizeImportsRequest extends Request {
-        command: CommandTypes.OrganizeImports;
-        arguments: OrganizeImportsRequestArgs;
-    }
-    type OrganizeImportsScope = GetCombinedCodeFixScope;
-    interface OrganizeImportsRequestArgs {
-        scope: OrganizeImportsScope;
-        skipDestructiveCodeActions?: boolean;
-    }
-    interface OrganizeImportsResponse extends Response {
-        body: readonly FileCodeEdits[];
-    }
-    interface GetEditsForFileRenameRequest extends Request {
-        command: CommandTypes.GetEditsForFileRename;
-        arguments: GetEditsForFileRenameRequestArgs;
-    }
-    /** Note: Paths may also be directories. */
-    interface GetEditsForFileRenameRequestArgs {
-        readonly oldFilePath: string;
-        readonly newFilePath: string;
-    }
-    interface GetEditsForFileRenameResponse extends Response {
-        body: readonly FileCodeEdits[];
-    }
-    /**
-     * Request for the available codefixes at a specific position.
-     */
-    interface CodeFixRequest extends Request {
-        command: CommandTypes.GetCodeFixes;
-        arguments: CodeFixRequestArgs;
-    }
-    interface GetCombinedCodeFixRequest extends Request {
-        command: CommandTypes.GetCombinedCodeFix;
-        arguments: GetCombinedCodeFixRequestArgs;
-    }
-    interface GetCombinedCodeFixResponse extends Response {
-        body: CombinedCodeActions;
-    }
-    interface ApplyCodeActionCommandRequest extends Request {
-        command: CommandTypes.ApplyCodeActionCommand;
-        arguments: ApplyCodeActionCommandRequestArgs;
-    }
-    interface ApplyCodeActionCommandResponse extends Response {
-    }
-    interface FileRangeRequestArgs extends FileRequestArgs {
-        /**
-         * The line number for the request (1-based).
-         */
-        startLine: number;
-        /**
-         * The character offset (on the line) for the request (1-based).
-         */
-        startOffset: number;
-        /**
-         * The line number for the request (1-based).
-         */
-        endLine: number;
-        /**
-         * The character offset (on the line) for the request (1-based).
-         */
-        endOffset: number;
-    }
-    /**
-     * Instances of this interface specify errorcodes on a specific location in a sourcefile.
-     */
-    interface CodeFixRequestArgs extends FileRangeRequestArgs {
-        /**
-         * Errorcodes we want to get the fixes for.
-         */
-        errorCodes: readonly number[];
-    }
-    interface GetCombinedCodeFixRequestArgs {
-        scope: GetCombinedCodeFixScope;
-        fixId: {};
-    }
-    interface GetCombinedCodeFixScope {
-        type: "file";
-        args: FileRequestArgs;
-    }
-    interface ApplyCodeActionCommandRequestArgs {
-        /** May also be an array of commands. */
-        command: {};
-    }
-    /**
-     * Response for GetCodeFixes request.
-     */
-    interface GetCodeFixesResponse extends Response {
-        body?: CodeAction[];
-    }
-    /**
-     * A request whose arguments specify a file location (file, line, col).
-     */
-    interface FileLocationRequest extends FileRequest {
-        arguments: FileLocationRequestArgs;
-    }
-    /**
-     * A request to get codes of supported code fixes.
-     */
-    interface GetSupportedCodeFixesRequest extends Request {
-        command: CommandTypes.GetSupportedCodeFixes;
-    }
-    /**
-     * A response for GetSupportedCodeFixesRequest request.
-     */
-    interface GetSupportedCodeFixesResponse extends Response {
-        /**
-         * List of error codes supported by the server.
-         */
-        body?: string[];
-    }
-    /**
-     * A request to get encoded semantic classifications for a span in the file
-     */
-    interface EncodedSemanticClassificationsRequest extends FileRequest {
-        arguments: EncodedSemanticClassificationsRequestArgs;
-    }
-    /**
-     * Arguments for EncodedSemanticClassificationsRequest request.
-     */
-    interface EncodedSemanticClassificationsRequestArgs extends FileRequestArgs {
-        /**
-         * Start position of the span.
-         */
-        start: number;
-        /**
-         * Length of the span.
-         */
-        length: number;
-        /**
-         * Optional parameter for the semantic highlighting response, if absent it
-         * defaults to "original".
-         */
-        format?: "original" | "2020";
-    }
-    /** The response for a EncodedSemanticClassificationsRequest */
-    interface EncodedSemanticClassificationsResponse extends Response {
-        body?: EncodedSemanticClassificationsResponseBody;
-    }
-    /**
-     * Implementation response message. Gives series of text spans depending on the format ar.
-     */
-    interface EncodedSemanticClassificationsResponseBody {
-        endOfLineState: EndOfLineState;
-        spans: number[];
-    }
-    /**
-     * Arguments in document highlight request; include: filesToSearch, file,
-     * line, offset.
-     */
-    interface DocumentHighlightsRequestArgs extends FileLocationRequestArgs {
-        /**
-         * List of files to search for document highlights.
-         */
-        filesToSearch: string[];
-    }
-    /**
-     * Go to definition request; value of command field is
-     * "definition". Return response giving the file locations that
-     * define the symbol found in file at location line, col.
-     */
-    interface DefinitionRequest extends FileLocationRequest {
-        command: CommandTypes.Definition;
-    }
-    interface DefinitionAndBoundSpanRequest extends FileLocationRequest {
-        readonly command: CommandTypes.DefinitionAndBoundSpan;
-    }
-    interface FindSourceDefinitionRequest extends FileLocationRequest {
-        readonly command: CommandTypes.FindSourceDefinition;
-    }
-    interface DefinitionAndBoundSpanResponse extends Response {
-        readonly body: DefinitionInfoAndBoundSpan;
-    }
-    /**
-     * Go to type request; value of command field is
-     * "typeDefinition". Return response giving the file locations that
-     * define the type for the symbol found in file at location line, col.
-     */
-    interface TypeDefinitionRequest extends FileLocationRequest {
-        command: CommandTypes.TypeDefinition;
-    }
-    /**
-     * Go to implementation request; value of command field is
-     * "implementation". Return response giving the file locations that
-     * implement the symbol found in file at location line, col.
-     */
-    interface ImplementationRequest extends FileLocationRequest {
-        command: CommandTypes.Implementation;
-    }
-    /**
-     * Location in source code expressed as (one-based) line and (one-based) column offset.
-     */
-    interface Location {
-        line: number;
-        offset: number;
-    }
-    /**
-     * Object found in response messages defining a span of text in source code.
-     */
-    interface TextSpan {
-        /**
-         * First character of the definition.
-         */
-        start: Location;
-        /**
-         * One character past last character of the definition.
-         */
-        end: Location;
-    }
-    /**
-     * Object found in response messages defining a span of text in a specific source file.
-     */
-    interface FileSpan extends TextSpan {
-        /**
-         * File containing text span.
-         */
-        file: string;
-    }
-    interface JSDocTagInfo {
-        /** Name of the JSDoc tag */
-        name: string;
-        /**
-         * Comment text after the JSDoc tag -- the text after the tag name until the next tag or end of comment
-         * Display parts when UserPreferences.displayPartsForJSDoc is true, flattened to string otherwise.
-         */
-        text?: string | SymbolDisplayPart[];
-    }
-    interface TextSpanWithContext extends TextSpan {
-        contextStart?: Location;
-        contextEnd?: Location;
-    }
-    interface FileSpanWithContext extends FileSpan, TextSpanWithContext {
-    }
-    interface DefinitionInfo extends FileSpanWithContext {
-        /**
-         * When true, the file may or may not exist.
-         */
-        unverified?: boolean;
-    }
-    interface DefinitionInfoAndBoundSpan {
-        definitions: readonly DefinitionInfo[];
-        textSpan: TextSpan;
-    }
-    /**
-     * Definition response message.  Gives text range for definition.
-     */
-    interface DefinitionResponse extends Response {
-        body?: DefinitionInfo[];
-    }
-    interface DefinitionInfoAndBoundSpanResponse extends Response {
-        body?: DefinitionInfoAndBoundSpan;
-    }
-    /** @deprecated Use `DefinitionInfoAndBoundSpanResponse` instead. */
-    type DefinitionInfoAndBoundSpanReponse = DefinitionInfoAndBoundSpanResponse;
-    /**
-     * Definition response message.  Gives text range for definition.
-     */
-    interface TypeDefinitionResponse extends Response {
-        body?: FileSpanWithContext[];
-    }
-    /**
-     * Implementation response message.  Gives text range for implementations.
-     */
-    interface ImplementationResponse extends Response {
-        body?: FileSpanWithContext[];
-    }
-    /**
-     * Request to get brace completion for a location in the file.
-     */
-    interface BraceCompletionRequest extends FileLocationRequest {
-        command: CommandTypes.BraceCompletion;
-        arguments: BraceCompletionRequestArgs;
-    }
-    /**
-     * Argument for BraceCompletionRequest request.
-     */
-    interface BraceCompletionRequestArgs extends FileLocationRequestArgs {
-        /**
-         * Kind of opening brace
-         */
-        openingBrace: string;
-    }
-    interface JsxClosingTagRequest extends FileLocationRequest {
-        readonly command: CommandTypes.JsxClosingTag;
-        readonly arguments: JsxClosingTagRequestArgs;
-    }
-    interface JsxClosingTagRequestArgs extends FileLocationRequestArgs {
-    }
-    interface JsxClosingTagResponse extends Response {
-        readonly body: TextInsertion;
-    }
-    /**
-     * @deprecated
-     * Get occurrences request; value of command field is
-     * "occurrences". Return response giving spans that are relevant
-     * in the file at a given line and column.
-     */
-    interface OccurrencesRequest extends FileLocationRequest {
-        command: CommandTypes.Occurrences;
-    }
-    /** @deprecated */
-    interface OccurrencesResponseItem extends FileSpanWithContext {
-        /**
-         * True if the occurrence is a write location, false otherwise.
-         */
-        isWriteAccess: boolean;
-        /**
-         * True if the occurrence is in a string, undefined otherwise;
-         */
-        isInString?: true;
-    }
-    /** @deprecated */
-    interface OccurrencesResponse extends Response {
-        body?: OccurrencesResponseItem[];
-    }
-    /**
-     * Get document highlights request; value of command field is
-     * "documentHighlights". Return response giving spans that are relevant
-     * in the file at a given line and column.
-     */
-    interface DocumentHighlightsRequest extends FileLocationRequest {
-        command: CommandTypes.DocumentHighlights;
-        arguments: DocumentHighlightsRequestArgs;
-    }
-    /**
-     * Span augmented with extra information that denotes the kind of the highlighting to be used for span.
-     */
-    interface HighlightSpan extends TextSpanWithContext {
-        kind: HighlightSpanKind;
-    }
-    /**
-     * Represents a set of highligh spans for a give name
-     */
-    interface DocumentHighlightsItem {
-        /**
-         * File containing highlight spans.
-         */
-        file: string;
-        /**
-         * Spans to highlight in file.
-         */
-        highlightSpans: HighlightSpan[];
-    }
-    /**
-     * Response for a DocumentHighlightsRequest request.
-     */
-    interface DocumentHighlightsResponse extends Response {
-        body?: DocumentHighlightsItem[];
-    }
-    /**
-     * Find references request; value of command field is
-     * "references". Return response giving the file locations that
-     * reference the symbol found in file at location line, col.
-     */
-    interface ReferencesRequest extends FileLocationRequest {
-        command: CommandTypes.References;
-    }
-    interface ReferencesResponseItem extends FileSpanWithContext {
-        /** Text of line containing the reference.  Including this
-         *  with the response avoids latency of editor loading files
-         * to show text of reference line (the server already has
-         * loaded the referencing files).
-         */
-        lineText: string;
-        /**
-         * True if reference is a write location, false otherwise.
-         */
-        isWriteAccess: boolean;
-        /**
-         * Present only if the search was triggered from a declaration.
-         * True indicates that the references refers to the same symbol
-         * (i.e. has the same meaning) as the declaration that began the
-         * search.
-         */
-        isDefinition?: boolean;
-    }
-    /**
-     * The body of a "references" response message.
-     */
-    interface ReferencesResponseBody {
-        /**
-         * The file locations referencing the symbol.
-         */
-        refs: readonly ReferencesResponseItem[];
-        /**
-         * The name of the symbol.
-         */
-        symbolName: string;
-        /**
-         * The start character offset of the symbol (on the line provided by the references request).
-         */
-        symbolStartOffset: number;
-        /**
-         * The full display name of the symbol.
-         */
-        symbolDisplayString: string;
-    }
-    /**
-     * Response to "references" request.
-     */
-    interface ReferencesResponse extends Response {
-        body?: ReferencesResponseBody;
-    }
-    interface FileReferencesRequest extends FileRequest {
-        command: CommandTypes.FileReferences;
-    }
-    interface FileReferencesResponseBody {
-        /**
-         * The file locations referencing the symbol.
-         */
-        refs: readonly ReferencesResponseItem[];
-        /**
-         * The name of the symbol.
-         */
-        symbolName: string;
-    }
-    interface FileReferencesResponse extends Response {
-        body?: FileReferencesResponseBody;
-    }
-    /**
-     * Argument for RenameRequest request.
-     */
-    interface RenameRequestArgs extends FileLocationRequestArgs {
-        /**
-         * Should text at specified location be found/changed in comments?
-         */
-        findInComments?: boolean;
-        /**
-         * Should text at specified location be found/changed in strings?
-         */
-        findInStrings?: boolean;
-    }
-    /**
-     * Rename request; value of command field is "rename". Return
-     * response giving the file locations that reference the symbol
-     * found in file at location line, col. Also return full display
-     * name of the symbol so that client can print it unambiguously.
-     */
-    interface RenameRequest extends FileLocationRequest {
-        command: CommandTypes.Rename;
-        arguments: RenameRequestArgs;
-    }
-    /**
-     * Information about the item to be renamed.
-     */
-    type RenameInfo = RenameInfoSuccess | RenameInfoFailure;
-    interface RenameInfoSuccess {
-        /**
-         * True if item can be renamed.
-         */
-        canRename: true;
-        /**
-         * File or directory to rename.
-         * If set, `getEditsForFileRename` should be called instead of `findRenameLocations`.
-         */
-        fileToRename?: string;
-        /**
-         * Display name of the item to be renamed.
-         */
-        displayName: string;
-        /**
-         * Full display name of item to be renamed.
-         */
-        fullDisplayName: string;
-        /**
-         * The items's kind (such as 'className' or 'parameterName' or plain 'text').
-         */
-        kind: ScriptElementKind;
-        /**
-         * Optional modifiers for the kind (such as 'public').
-         */
-        kindModifiers: string;
-        /** Span of text to rename. */
-        triggerSpan: TextSpan;
-    }
-    interface RenameInfoFailure {
-        canRename: false;
-        /**
-         * Error message if item can not be renamed.
-         */
-        localizedErrorMessage: string;
-    }
-    /**
-     *  A group of text spans, all in 'file'.
-     */
-    interface SpanGroup {
-        /** The file to which the spans apply */
-        file: string;
-        /** The text spans in this group */
-        locs: RenameTextSpan[];
-    }
-    interface RenameTextSpan extends TextSpanWithContext {
-        readonly prefixText?: string;
-        readonly suffixText?: string;
-    }
-    interface RenameResponseBody {
-        /**
-         * Information about the item to be renamed.
-         */
-        info: RenameInfo;
-        /**
-         * An array of span groups (one per file) that refer to the item to be renamed.
-         */
-        locs: readonly SpanGroup[];
-    }
-    /**
-     * Rename response message.
-     */
-    interface RenameResponse extends Response {
-        body?: RenameResponseBody;
-    }
-    /**
-     * Represents a file in external project.
-     * External project is project whose set of files, compilation options and open\close state
-     * is maintained by the client (i.e. if all this data come from .csproj file in Visual Studio).
-     * External project will exist even if all files in it are closed and should be closed explicitly.
-     * If external project includes one or more tsconfig.json/jsconfig.json files then tsserver will
-     * create configured project for every config file but will maintain a link that these projects were created
-     * as a result of opening external project so they should be removed once external project is closed.
-     */
-    interface ExternalFile {
-        /**
-         * Name of file file
-         */
-        fileName: string;
-        /**
-         * Script kind of the file
-         */
-        scriptKind?: ScriptKindName | ts.ScriptKind;
-        /**
-         * Whether file has mixed content (i.e. .cshtml file that combines html markup with C#/JavaScript)
-         */
-        hasMixedContent?: boolean;
-        /**
-         * Content of the file
-         */
-        content?: string;
-    }
-    /**
-     * Represent an external project
-     */
-    interface ExternalProject {
-        /**
-         * Project name
-         */
-        projectFileName: string;
-        /**
-         * List of root files in project
-         */
-        rootFiles: ExternalFile[];
-        /**
-         * Compiler options for the project
-         */
-        options: ExternalProjectCompilerOptions;
-        /**
-         * @deprecated typingOptions. Use typeAcquisition instead
-         */
-        typingOptions?: TypeAcquisition;
-        /**
-         * Explicitly specified type acquisition for the project
-         */
-        typeAcquisition?: TypeAcquisition;
-    }
-    interface CompileOnSaveMixin {
-        /**
-         * If compile on save is enabled for the project
-         */
-        compileOnSave?: boolean;
-    }
-    /**
-     * For external projects, some of the project settings are sent together with
-     * compiler settings.
-     */
-    type ExternalProjectCompilerOptions = CompilerOptions & CompileOnSaveMixin & WatchOptions;
-    interface FileWithProjectReferenceRedirectInfo {
-        /**
-         * Name of file
-         */
-        fileName: string;
-        /**
-         * True if the file is primarily included in a referenced project
-         */
-        isSourceOfProjectReferenceRedirect: boolean;
-    }
-    /**
-     * Represents a set of changes that happen in project
-     */
-    interface ProjectChanges {
-        /**
-         * List of added files
-         */
-        added: string[] | FileWithProjectReferenceRedirectInfo[];
-        /**
-         * List of removed files
-         */
-        removed: string[] | FileWithProjectReferenceRedirectInfo[];
-        /**
-         * List of updated files
-         */
-        updated: string[] | FileWithProjectReferenceRedirectInfo[];
-        /**
-         * List of files that have had their project reference redirect status updated
-         * Only provided when the synchronizeProjectList request has includeProjectReferenceRedirectInfo set to true
-         */
-        updatedRedirects?: FileWithProjectReferenceRedirectInfo[];
-    }
-    /**
-     * Information found in a configure request.
-     */
-    interface ConfigureRequestArguments {
-        /**
-         * Information about the host, for example 'Emacs 24.4' or
-         * 'Sublime Text version 3075'
-         */
-        hostInfo?: string;
-        /**
-         * If present, tab settings apply only to this file.
-         */
-        file?: string;
-        /**
-         * The format options to use during formatting and other code editing features.
-         */
-        formatOptions?: FormatCodeSettings;
-        preferences?: UserPreferences;
-        /**
-         * The host's additional supported .js file extensions
-         */
-        extraFileExtensions?: FileExtensionInfo[];
-        watchOptions?: WatchOptions;
-    }
-    enum WatchFileKind {
-        FixedPollingInterval = "FixedPollingInterval",
-        PriorityPollingInterval = "PriorityPollingInterval",
-        DynamicPriorityPolling = "DynamicPriorityPolling",
-        FixedChunkSizePolling = "FixedChunkSizePolling",
-        UseFsEvents = "UseFsEvents",
-        UseFsEventsOnParentDirectory = "UseFsEventsOnParentDirectory"
-    }
-    enum WatchDirectoryKind {
-        UseFsEvents = "UseFsEvents",
-        FixedPollingInterval = "FixedPollingInterval",
-        DynamicPriorityPolling = "DynamicPriorityPolling",
-        FixedChunkSizePolling = "FixedChunkSizePolling"
-    }
-    enum PollingWatchKind {
-        FixedInterval = "FixedInterval",
-        PriorityInterval = "PriorityInterval",
-        DynamicPriority = "DynamicPriority",
-        FixedChunkSize = "FixedChunkSize"
-    }
-    interface WatchOptions {
-        watchFile?: WatchFileKind | ts.WatchFileKind;
-        watchDirectory?: WatchDirectoryKind | ts.WatchDirectoryKind;
-        fallbackPolling?: PollingWatchKind | ts.PollingWatchKind;
-        synchronousWatchDirectory?: boolean;
-        excludeDirectories?: string[];
-        excludeFiles?: string[];
-        [option: string]: CompilerOptionsValue | undefined;
-    }
-    /**
-     *  Configure request; value of command field is "configure".  Specifies
-     *  host information, such as host type, tab size, and indent size.
-     */
-    interface ConfigureRequest extends Request {
-        command: CommandTypes.Configure;
-        arguments: ConfigureRequestArguments;
-    }
-    /**
-     * Response to "configure" request.  This is just an acknowledgement, so
-     * no body field is required.
-     */
-    interface ConfigureResponse extends Response {
-    }
-    interface ConfigurePluginRequestArguments {
-        pluginName: string;
-        configuration: any;
-    }
-    interface ConfigurePluginRequest extends Request {
-        command: CommandTypes.ConfigurePlugin;
-        arguments: ConfigurePluginRequestArguments;
-    }
-    interface ConfigurePluginResponse extends Response {
-    }
-    interface SelectionRangeRequest extends FileRequest {
-        command: CommandTypes.SelectionRange;
-        arguments: SelectionRangeRequestArgs;
-    }
-    interface SelectionRangeRequestArgs extends FileRequestArgs {
-        locations: Location[];
-    }
-    interface SelectionRangeResponse extends Response {
-        body?: SelectionRange[];
-    }
-    interface SelectionRange {
-        textSpan: TextSpan;
-        parent?: SelectionRange;
-    }
-    interface ToggleLineCommentRequest extends FileRequest {
-        command: CommandTypes.ToggleLineComment;
-        arguments: FileRangeRequestArgs;
-    }
-    interface ToggleMultilineCommentRequest extends FileRequest {
-        command: CommandTypes.ToggleMultilineComment;
-        arguments: FileRangeRequestArgs;
-    }
-    interface CommentSelectionRequest extends FileRequest {
-        command: CommandTypes.CommentSelection;
-        arguments: FileRangeRequestArgs;
-    }
-    interface UncommentSelectionRequest extends FileRequest {
-        command: CommandTypes.UncommentSelection;
-        arguments: FileRangeRequestArgs;
-    }
-    /**
-     *  Information found in an "open" request.
-     */
-    interface OpenRequestArgs extends FileRequestArgs {
-        /**
-         * Used when a version of the file content is known to be more up to date than the one on disk.
-         * Then the known content will be used upon opening instead of the disk copy
-         */
-        fileContent?: string;
-        /**
-         * Used to specify the script kind of the file explicitly. It could be one of the following:
-         *      "TS", "JS", "TSX", "JSX"
-         */
-        scriptKindName?: ScriptKindName;
-        /**
-         * Used to limit the searching for project config file. If given the searching will stop at this
-         * root path; otherwise it will go all the way up to the dist root path.
-         */
-        projectRootPath?: string;
-    }
-    type ScriptKindName = "TS" | "JS" | "TSX" | "JSX";
-    /**
-     * Open request; value of command field is "open". Notify the
-     * server that the client has file open.  The server will not
-     * monitor the filesystem for changes in this file and will assume
-     * that the client is updating the server (using the change and/or
-     * reload messages) when the file changes. Server does not currently
-     * send a response to an open request.
-     */
-    interface OpenRequest extends Request {
-        command: CommandTypes.Open;
-        arguments: OpenRequestArgs;
-    }
-    /**
-     * Request to open or update external project
-     */
-    interface OpenExternalProjectRequest extends Request {
-        command: CommandTypes.OpenExternalProject;
-        arguments: OpenExternalProjectArgs;
-    }
-    /**
-     * Arguments to OpenExternalProjectRequest request
-     */
-    type OpenExternalProjectArgs = ExternalProject;
-    /**
-     * Request to open multiple external projects
-     */
-    interface OpenExternalProjectsRequest extends Request {
-        command: CommandTypes.OpenExternalProjects;
-        arguments: OpenExternalProjectsArgs;
-    }
-    /**
-     * Arguments to OpenExternalProjectsRequest
-     */
-    interface OpenExternalProjectsArgs {
-        /**
-         * List of external projects to open or update
-         */
-        projects: ExternalProject[];
-    }
-    /**
-     * Response to OpenExternalProjectRequest request. This is just an acknowledgement, so
-     * no body field is required.
-     */
-    interface OpenExternalProjectResponse extends Response {
-    }
-    /**
-     * Response to OpenExternalProjectsRequest request. This is just an acknowledgement, so
-     * no body field is required.
-     */
-    interface OpenExternalProjectsResponse extends Response {
-    }
-    /**
-     * Request to close external project.
-     */
-    interface CloseExternalProjectRequest extends Request {
-        command: CommandTypes.CloseExternalProject;
-        arguments: CloseExternalProjectRequestArgs;
-    }
-    /**
-     * Arguments to CloseExternalProjectRequest request
-     */
-    interface CloseExternalProjectRequestArgs {
-        /**
-         * Name of the project to close
-         */
-        projectFileName: string;
-    }
-    /**
-     * Response to CloseExternalProjectRequest request. This is just an acknowledgement, so
-     * no body field is required.
-     */
-    interface CloseExternalProjectResponse extends Response {
-    }
-    /**
-     * Request to synchronize list of open files with the client
-     */
-    interface UpdateOpenRequest extends Request {
-        command: CommandTypes.UpdateOpen;
-        arguments: UpdateOpenRequestArgs;
-    }
-    /**
-     * Arguments to UpdateOpenRequest
-     */
-    interface UpdateOpenRequestArgs {
-        /**
-         * List of newly open files
-         */
-        openFiles?: OpenRequestArgs[];
-        /**
-         * List of open files files that were changes
-         */
-        changedFiles?: FileCodeEdits[];
-        /**
-         * List of files that were closed
-         */
-        closedFiles?: string[];
-    }
-    /**
-     * External projects have a typeAcquisition option so they need to be added separately to compiler options for inferred projects.
-     */
-    type InferredProjectCompilerOptions = ExternalProjectCompilerOptions & TypeAcquisition;
-    /**
-     * Request to set compiler options for inferred projects.
-     * External projects are opened / closed explicitly.
-     * Configured projects are opened when user opens loose file that has 'tsconfig.json' or 'jsconfig.json' anywhere in one of containing folders.
-     * This configuration file will be used to obtain a list of files and configuration settings for the project.
-     * Inferred projects are created when user opens a loose file that is not the part of external project
-     * or configured project and will contain only open file and transitive closure of referenced files if 'useOneInferredProject' is false,
-     * or all open loose files and its transitive closure of referenced files if 'useOneInferredProject' is true.
-     */
-    interface SetCompilerOptionsForInferredProjectsRequest extends Request {
-        command: CommandTypes.CompilerOptionsForInferredProjects;
-        arguments: SetCompilerOptionsForInferredProjectsArgs;
-    }
-    /**
-     * Argument for SetCompilerOptionsForInferredProjectsRequest request.
-     */
-    interface SetCompilerOptionsForInferredProjectsArgs {
-        /**
-         * Compiler options to be used with inferred projects.
-         */
-        options: InferredProjectCompilerOptions;
-        /**
-         * Specifies the project root path used to scope compiler options.
-         * It is an error to provide this property if the server has not been started with
-         * `useInferredProjectPerProjectRoot` enabled.
-         */
-        projectRootPath?: string;
-    }
-    /**
-     * Response to SetCompilerOptionsForInferredProjectsResponse request. This is just an acknowledgement, so
-     * no body field is required.
-     */
-    interface SetCompilerOptionsForInferredProjectsResponse extends Response {
-    }
-    /**
-     *  Exit request; value of command field is "exit".  Ask the server process
-     *  to exit.
-     */
-    interface ExitRequest extends Request {
-        command: CommandTypes.Exit;
-    }
-    /**
-     * Close request; value of command field is "close". Notify the
-     * server that the client has closed a previously open file.  If
-     * file is still referenced by open files, the server will resume
-     * monitoring the filesystem for changes to file.  Server does not
-     * currently send a response to a close request.
-     */
-    interface CloseRequest extends FileRequest {
-        command: CommandTypes.Close;
-    }
-    /**
-     * Request to obtain the list of files that should be regenerated if target file is recompiled.
-     * NOTE: this us query-only operation and does not generate any output on disk.
-     */
-    interface CompileOnSaveAffectedFileListRequest extends FileRequest {
-        command: CommandTypes.CompileOnSaveAffectedFileList;
-    }
-    /**
-     * Contains a list of files that should be regenerated in a project
-     */
-    interface CompileOnSaveAffectedFileListSingleProject {
-        /**
-         * Project name
-         */
-        projectFileName: string;
-        /**
-         * List of files names that should be recompiled
-         */
-        fileNames: string[];
-        /**
-         * true if project uses outFile or out compiler option
-         */
-        projectUsesOutFile: boolean;
-    }
-    /**
-     * Response for CompileOnSaveAffectedFileListRequest request;
-     */
-    interface CompileOnSaveAffectedFileListResponse extends Response {
-        body: CompileOnSaveAffectedFileListSingleProject[];
-    }
-    /**
-     * Request to recompile the file. All generated outputs (.js, .d.ts or .js.map files) is written on disk.
-     */
-    interface CompileOnSaveEmitFileRequest extends FileRequest {
-        command: CommandTypes.CompileOnSaveEmitFile;
-        arguments: CompileOnSaveEmitFileRequestArgs;
-    }
-    /**
-     * Arguments for CompileOnSaveEmitFileRequest
-     */
-    interface CompileOnSaveEmitFileRequestArgs extends FileRequestArgs {
-        /**
-         * if true - then file should be recompiled even if it does not have any changes.
-         */
-        forced?: boolean;
-        includeLinePosition?: boolean;
-        /** if true - return response as object with emitSkipped and diagnostics */
-        richResponse?: boolean;
-    }
-    interface CompileOnSaveEmitFileResponse extends Response {
-        body: boolean | EmitResult;
-    }
-    interface EmitResult {
-        emitSkipped: boolean;
-        diagnostics: Diagnostic[] | DiagnosticWithLinePosition[];
-    }
-    /**
-     * Quickinfo request; value of command field is
-     * "quickinfo". Return response giving a quick type and
-     * documentation string for the symbol found in file at location
-     * line, col.
-     */
-    interface QuickInfoRequest extends FileLocationRequest {
-        command: CommandTypes.Quickinfo;
-        arguments: FileLocationRequestArgs;
-    }
-    /**
-     * Body of QuickInfoResponse.
-     */
-    interface QuickInfoResponseBody {
-        /**
-         * The symbol's kind (such as 'className' or 'parameterName' or plain 'text').
-         */
-        kind: ScriptElementKind;
-        /**
-         * Optional modifiers for the kind (such as 'public').
-         */
-        kindModifiers: string;
-        /**
-         * Starting file location of symbol.
-         */
-        start: Location;
-        /**
-         * One past last character of symbol.
-         */
-        end: Location;
-        /**
-         * Type and kind of symbol.
-         */
-        displayString: string;
-        /**
-         * Documentation associated with symbol.
-         * Display parts when UserPreferences.displayPartsForJSDoc is true, flattened to string otherwise.
-         */
-        documentation: string | SymbolDisplayPart[];
-        /**
-         * JSDoc tags associated with symbol.
-         */
-        tags: JSDocTagInfo[];
-    }
-    /**
-     * Quickinfo response message.
-     */
-    interface QuickInfoResponse extends Response {
-        body?: QuickInfoResponseBody;
-    }
-    /**
-     * Arguments for format messages.
-     */
-    interface FormatRequestArgs extends FileLocationRequestArgs {
-        /**
-         * Last line of range for which to format text in file.
-         */
-        endLine: number;
-        /**
-         * Character offset on last line of range for which to format text in file.
-         */
-        endOffset: number;
-        /**
-         * Format options to be used.
-         */
-        options?: FormatCodeSettings;
-    }
-    /**
-     * Format request; value of command field is "format".  Return
-     * response giving zero or more edit instructions.  The edit
-     * instructions will be sorted in file order.  Applying the edit
-     * instructions in reverse to file will result in correctly
-     * reformatted text.
-     */
-    interface FormatRequest extends FileLocationRequest {
-        command: CommandTypes.Format;
-        arguments: FormatRequestArgs;
-    }
-    /**
-     * Object found in response messages defining an editing
-     * instruction for a span of text in source code.  The effect of
-     * this instruction is to replace the text starting at start and
-     * ending one character before end with newText. For an insertion,
-     * the text span is empty.  For a deletion, newText is empty.
-     */
-    interface CodeEdit {
-        /**
-         * First character of the text span to edit.
-         */
-        start: Location;
-        /**
-         * One character past last character of the text span to edit.
-         */
-        end: Location;
-        /**
-         * Replace the span defined above with this string (may be
-         * the empty string).
-         */
-        newText: string;
-    }
-    interface FileCodeEdits {
-        fileName: string;
-        textChanges: CodeEdit[];
-    }
-    interface CodeFixResponse extends Response {
-        /** The code actions that are available */
-        body?: CodeFixAction[];
-    }
-    interface CodeAction {
-        /** Description of the code action to display in the UI of the editor */
-        description: string;
-        /** Text changes to apply to each file as part of the code action */
-        changes: FileCodeEdits[];
-        /** A command is an opaque object that should be passed to `ApplyCodeActionCommandRequestArgs` without modification.  */
-        commands?: {}[];
-    }
-    interface CombinedCodeActions {
-        changes: readonly FileCodeEdits[];
-        commands?: readonly {}[];
-    }
-    interface CodeFixAction extends CodeAction {
-        /** Short name to identify the fix, for use by telemetry. */
-        fixName: string;
-        /**
-         * If present, one may call 'getCombinedCodeFix' with this fixId.
-         * This may be omitted to indicate that the code fix can't be applied in a group.
-         */
-        fixId?: {};
-        /** Should be present if and only if 'fixId' is. */
-        fixAllDescription?: string;
-    }
-    /**
-     * Format and format on key response message.
-     */
-    interface FormatResponse extends Response {
-        body?: CodeEdit[];
-    }
-    /**
-     * Arguments for format on key messages.
-     */
-    interface FormatOnKeyRequestArgs extends FileLocationRequestArgs {
-        /**
-         * Key pressed (';', '\n', or '}').
-         */
-        key: string;
-        options?: FormatCodeSettings;
-    }
-    /**
-     * Format on key request; value of command field is
-     * "formatonkey". Given file location and key typed (as string),
-     * return response giving zero or more edit instructions.  The
-     * edit instructions will be sorted in file order.  Applying the
-     * edit instructions in reverse to file will result in correctly
-     * reformatted text.
-     */
-    interface FormatOnKeyRequest extends FileLocationRequest {
-        command: CommandTypes.Formatonkey;
-        arguments: FormatOnKeyRequestArgs;
-    }
-    type CompletionsTriggerCharacter = "." | '"' | "'" | "`" | "/" | "@" | "<" | "#" | " ";
-    enum CompletionTriggerKind {
-        /** Completion was triggered by typing an identifier, manual invocation (e.g Ctrl+Space) or via API. */
-        Invoked = 1,
-        /** Completion was triggered by a trigger character. */
-        TriggerCharacter = 2,
-        /** Completion was re-triggered as the current completion list is incomplete. */
-        TriggerForIncompleteCompletions = 3
-    }
-    /**
-     * Arguments for completions messages.
-     */
-    interface CompletionsRequestArgs extends FileLocationRequestArgs {
-        /**
-         * Optional prefix to apply to possible completions.
-         */
-        prefix?: string;
-        /**
-         * Character that was responsible for triggering completion.
-         * Should be `undefined` if a user manually requested completion.
-         */
-        triggerCharacter?: CompletionsTriggerCharacter;
-        triggerKind?: CompletionTriggerKind;
-        /**
-         * @deprecated Use UserPreferences.includeCompletionsForModuleExports
-         */
-        includeExternalModuleExports?: boolean;
-        /**
-         * @deprecated Use UserPreferences.includeCompletionsWithInsertText
-         */
-        includeInsertTextCompletions?: boolean;
-    }
-    /**
-     * Completions request; value of command field is "completions".
-     * Given a file location (file, line, col) and a prefix (which may
-     * be the empty string), return the possible completions that
-     * begin with prefix.
-     */
-    interface CompletionsRequest extends FileLocationRequest {
-        command: CommandTypes.Completions | CommandTypes.CompletionInfo;
-        arguments: CompletionsRequestArgs;
-    }
-    /**
-     * Arguments for completion details request.
-     */
-    interface CompletionDetailsRequestArgs extends FileLocationRequestArgs {
-        /**
-         * Names of one or more entries for which to obtain details.
-         */
-        entryNames: (string | CompletionEntryIdentifier)[];
-    }
-    interface CompletionEntryIdentifier {
-        name: string;
-        source?: string;
-        data?: unknown;
-    }
-    /**
-     * Completion entry details request; value of command field is
-     * "completionEntryDetails".  Given a file location (file, line,
-     * col) and an array of completion entry names return more
-     * detailed information for each completion entry.
-     */
-    interface CompletionDetailsRequest extends FileLocationRequest {
-        command: CommandTypes.CompletionDetails;
-        arguments: CompletionDetailsRequestArgs;
-    }
-    /**
-     * Part of a symbol description.
-     */
-    interface SymbolDisplayPart {
-        /**
-         * Text of an item describing the symbol.
-         */
-        text: string;
-        /**
-         * The symbol's kind (such as 'className' or 'parameterName' or plain 'text').
-         */
-        kind: string;
-    }
-    /** A part of a symbol description that links from a jsdoc @link tag to a declaration */
-    interface JSDocLinkDisplayPart extends SymbolDisplayPart {
-        /** The location of the declaration that the @link tag links to. */
-        target: FileSpan;
-    }
-    /**
-     * An item found in a completion response.
-     */
-    interface CompletionEntry {
-        /**
-         * The symbol's name.
-         */
-        name: string;
-        /**
-         * The symbol's kind (such as 'className' or 'parameterName').
-         */
-        kind: ScriptElementKind;
-        /**
-         * Optional modifiers for the kind (such as 'public').
-         */
-        kindModifiers?: string;
-        /**
-         * A string that is used for comparing completion items so that they can be ordered.  This
-         * is often the same as the name but may be different in certain circumstances.
-         */
-        sortText: string;
-        /**
-         * Text to insert instead of `name`.
-         * This is used to support bracketed completions; If `name` might be "a-b" but `insertText` would be `["a-b"]`,
-         * coupled with `replacementSpan` to replace a dotted access with a bracket access.
-         */
-        insertText?: string;
-        /**
-         * `insertText` should be interpreted as a snippet if true.
-         */
-        isSnippet?: true;
-        /**
-         * An optional span that indicates the text to be replaced by this completion item.
-         * If present, this span should be used instead of the default one.
-         * It will be set if the required span differs from the one generated by the default replacement behavior.
-         */
-        replacementSpan?: TextSpan;
-        /**
-         * Indicates whether commiting this completion entry will require additional code actions to be
-         * made to avoid errors. The CompletionEntryDetails will have these actions.
-         */
-        hasAction?: true;
-        /**
-         * Identifier (not necessarily human-readable) identifying where this completion came from.
-         */
-        source?: string;
-        /**
-         * Human-readable description of the `source`.
-         */
-        sourceDisplay?: SymbolDisplayPart[];
-        /**
-         * Additional details for the label.
-         */
-        labelDetails?: CompletionEntryLabelDetails;
-        /**
-         * If true, this completion should be highlighted as recommended. There will only be one of these.
-         * This will be set when we know the user should write an expression with a certain type and that type is an enum or constructable class.
-         * Then either that enum/class or a namespace containing it will be the recommended symbol.
-         */
-        isRecommended?: true;
-        /**
-         * If true, this completion was generated from traversing the name table of an unchecked JS file,
-         * and therefore may not be accurate.
-         */
-        isFromUncheckedFile?: true;
-        /**
-         * If true, this completion was for an auto-import of a module not yet in the program, but listed
-         * in the project package.json. Used for telemetry reporting.
-         */
-        isPackageJsonImport?: true;
-        /**
-         * If true, this completion was an auto-import-style completion of an import statement (i.e., the
-         * module specifier was inserted along with the imported identifier). Used for telemetry reporting.
-         */
-        isImportStatementCompletion?: true;
-        /**
-         * A property to be sent back to TS Server in the CompletionDetailsRequest, along with `name`,
-         * that allows TS Server to look up the symbol represented by the completion item, disambiguating
-         * items with the same name.
-         */
-        data?: unknown;
-    }
-    interface CompletionEntryLabelDetails {
-        /**
-         * An optional string which is rendered less prominently directly after
-         * {@link CompletionEntry.name name}, without any spacing. Should be
-         * used for function signatures or type annotations.
-         */
-        detail?: string;
-        /**
-         * An optional string which is rendered less prominently after
-         * {@link CompletionEntryLabelDetails.detail}. Should be used for fully qualified
-         * names or file path.
-         */
-        description?: string;
-    }
-    /**
-     * Additional completion entry details, available on demand
-     */
-    interface CompletionEntryDetails {
-        /**
-         * The symbol's name.
-         */
-        name: string;
-        /**
-         * The symbol's kind (such as 'className' or 'parameterName').
-         */
-        kind: ScriptElementKind;
-        /**
-         * Optional modifiers for the kind (such as 'public').
-         */
-        kindModifiers: string;
-        /**
-         * Display parts of the symbol (similar to quick info).
-         */
-        displayParts: SymbolDisplayPart[];
-        /**
-         * Documentation strings for the symbol.
-         */
-        documentation?: SymbolDisplayPart[];
-        /**
-         * JSDoc tags for the symbol.
-         */
-        tags?: JSDocTagInfo[];
-        /**
-         * The associated code actions for this entry
-         */
-        codeActions?: CodeAction[];
-        /**
-         * @deprecated Use `sourceDisplay` instead.
-         */
-        source?: SymbolDisplayPart[];
-        /**
-         * Human-readable description of the `source` from the CompletionEntry.
-         */
-        sourceDisplay?: SymbolDisplayPart[];
-    }
-    /** @deprecated Prefer CompletionInfoResponse, which supports several top-level fields in addition to the array of entries. */
-    interface CompletionsResponse extends Response {
-        body?: CompletionEntry[];
-    }
-    interface CompletionInfoResponse extends Response {
-        body?: CompletionInfo;
-    }
-    interface CompletionInfo {
-        readonly flags?: number;
-        readonly isGlobalCompletion: boolean;
-        readonly isMemberCompletion: boolean;
-        readonly isNewIdentifierLocation: boolean;
-        /**
-         * In the absence of `CompletionEntry["replacementSpan"]`, the editor may choose whether to use
-         * this span or its default one. If `CompletionEntry["replacementSpan"]` is defined, that span
-         * must be used to commit that completion entry.
-         */
-        readonly optionalReplacementSpan?: TextSpan;
-        readonly isIncomplete?: boolean;
-        readonly entries: readonly CompletionEntry[];
-    }
-    interface CompletionDetailsResponse extends Response {
-        body?: CompletionEntryDetails[];
-    }
-    /**
-     * Signature help information for a single parameter
-     */
-    interface SignatureHelpParameter {
-        /**
-         * The parameter's name
-         */
-        name: string;
-        /**
-         * Documentation of the parameter.
-         */
-        documentation: SymbolDisplayPart[];
-        /**
-         * Display parts of the parameter.
-         */
-        displayParts: SymbolDisplayPart[];
-        /**
-         * Whether the parameter is optional or not.
-         */
-        isOptional: boolean;
-    }
-    /**
-     * Represents a single signature to show in signature help.
-     */
-    interface SignatureHelpItem {
-        /**
-         * Whether the signature accepts a variable number of arguments.
-         */
-        isVariadic: boolean;
-        /**
-         * The prefix display parts.
-         */
-        prefixDisplayParts: SymbolDisplayPart[];
-        /**
-         * The suffix display parts.
-         */
-        suffixDisplayParts: SymbolDisplayPart[];
-        /**
-         * The separator display parts.
-         */
-        separatorDisplayParts: SymbolDisplayPart[];
-        /**
-         * The signature helps items for the parameters.
-         */
-        parameters: SignatureHelpParameter[];
-        /**
-         * The signature's documentation
-         */
-        documentation: SymbolDisplayPart[];
-        /**
-         * The signature's JSDoc tags
-         */
-        tags: JSDocTagInfo[];
-    }
-    /**
-     * Signature help items found in the response of a signature help request.
-     */
-    interface SignatureHelpItems {
-        /**
-         * The signature help items.
-         */
-        items: SignatureHelpItem[];
-        /**
-         * The span for which signature help should appear on a signature
-         */
-        applicableSpan: TextSpan;
-        /**
-         * The item selected in the set of available help items.
-         */
-        selectedItemIndex: number;
-        /**
-         * The argument selected in the set of parameters.
-         */
-        argumentIndex: number;
-        /**
-         * The argument count
-         */
-        argumentCount: number;
-    }
-    type SignatureHelpTriggerCharacter = "," | "(" | "<";
-    type SignatureHelpRetriggerCharacter = SignatureHelpTriggerCharacter | ")";
-    /**
-     * Arguments of a signature help request.
-     */
-    interface SignatureHelpRequestArgs extends FileLocationRequestArgs {
-        /**
-         * Reason why signature help was invoked.
-         * See each individual possible
-         */
-        triggerReason?: SignatureHelpTriggerReason;
-    }
-    type SignatureHelpTriggerReason = SignatureHelpInvokedReason | SignatureHelpCharacterTypedReason | SignatureHelpRetriggeredReason;
-    /**
-     * Signals that the user manually requested signature help.
-     * The language service will unconditionally attempt to provide a result.
-     */
-    interface SignatureHelpInvokedReason {
-        kind: "invoked";
-        triggerCharacter?: undefined;
-    }
-    /**
-     * Signals that the signature help request came from a user typing a character.
-     * Depending on the character and the syntactic context, the request may or may not be served a result.
-     */
-    interface SignatureHelpCharacterTypedReason {
-        kind: "characterTyped";
-        /**
-         * Character that was responsible for triggering signature help.
-         */
-        triggerCharacter: SignatureHelpTriggerCharacter;
-    }
-    /**
-     * Signals that this signature help request came from typing a character or moving the cursor.
-     * This should only occur if a signature help session was already active and the editor needs to see if it should adjust.
-     * The language service will unconditionally attempt to provide a result.
-     * `triggerCharacter` can be `undefined` for a retrigger caused by a cursor move.
-     */
-    interface SignatureHelpRetriggeredReason {
-        kind: "retrigger";
-        /**
-         * Character that was responsible for triggering signature help.
-         */
-        triggerCharacter?: SignatureHelpRetriggerCharacter;
-    }
-    /**
-     * Signature help request; value of command field is "signatureHelp".
-     * Given a file location (file, line, col), return the signature
-     * help.
-     */
-    interface SignatureHelpRequest extends FileLocationRequest {
-        command: CommandTypes.SignatureHelp;
-        arguments: SignatureHelpRequestArgs;
-    }
-    /**
-     * Response object for a SignatureHelpRequest.
-     */
-    interface SignatureHelpResponse extends Response {
-        body?: SignatureHelpItems;
-    }
-    type InlayHintKind = "Type" | "Parameter" | "Enum";
-    interface InlayHintsRequestArgs extends FileRequestArgs {
-        /**
-         * Start position of the span.
-         */
-        start: number;
-        /**
-         * Length of the span.
-         */
-        length: number;
-    }
-    interface InlayHintsRequest extends Request {
-        command: CommandTypes.ProvideInlayHints;
-        arguments: InlayHintsRequestArgs;
-    }
-    interface InlayHintItem {
-        text: string;
-        position: Location;
-        kind: InlayHintKind;
-        whitespaceBefore?: boolean;
-        whitespaceAfter?: boolean;
-    }
-    interface InlayHintsResponse extends Response {
-        body?: InlayHintItem[];
-    }
-    /**
-     * Synchronous request for semantic diagnostics of one file.
-     */
-    interface SemanticDiagnosticsSyncRequest extends FileRequest {
-        command: CommandTypes.SemanticDiagnosticsSync;
-        arguments: SemanticDiagnosticsSyncRequestArgs;
-    }
-    interface SemanticDiagnosticsSyncRequestArgs extends FileRequestArgs {
-        includeLinePosition?: boolean;
-    }
-    /**
-     * Response object for synchronous sematic diagnostics request.
-     */
-    interface SemanticDiagnosticsSyncResponse extends Response {
-        body?: Diagnostic[] | DiagnosticWithLinePosition[];
-    }
-    interface SuggestionDiagnosticsSyncRequest extends FileRequest {
-        command: CommandTypes.SuggestionDiagnosticsSync;
-        arguments: SuggestionDiagnosticsSyncRequestArgs;
-    }
-    type SuggestionDiagnosticsSyncRequestArgs = SemanticDiagnosticsSyncRequestArgs;
-    type SuggestionDiagnosticsSyncResponse = SemanticDiagnosticsSyncResponse;
-    /**
-     * Synchronous request for syntactic diagnostics of one file.
-     */
-    interface SyntacticDiagnosticsSyncRequest extends FileRequest {
-        command: CommandTypes.SyntacticDiagnosticsSync;
-        arguments: SyntacticDiagnosticsSyncRequestArgs;
-    }
-    interface SyntacticDiagnosticsSyncRequestArgs extends FileRequestArgs {
-        includeLinePosition?: boolean;
-    }
-    /**
-     * Response object for synchronous syntactic diagnostics request.
-     */
-    interface SyntacticDiagnosticsSyncResponse extends Response {
-        body?: Diagnostic[] | DiagnosticWithLinePosition[];
-    }
-    /**
-     * Arguments for GeterrForProject request.
-     */
-    interface GeterrForProjectRequestArgs {
-        /**
-         * the file requesting project error list
-         */
-        file: string;
-        /**
-         * Delay in milliseconds to wait before starting to compute
-         * errors for the files in the file list
-         */
-        delay: number;
-    }
-    /**
-     * GeterrForProjectRequest request; value of command field is
-     * "geterrForProject". It works similarly with 'Geterr', only
-     * it request for every file in this project.
-     */
-    interface GeterrForProjectRequest extends Request {
-        command: CommandTypes.GeterrForProject;
-        arguments: GeterrForProjectRequestArgs;
-    }
-    /**
-     * Arguments for geterr messages.
-     */
-    interface GeterrRequestArgs {
-        /**
-         * List of file names for which to compute compiler errors.
-         * The files will be checked in list order.
-         */
-        files: string[];
-        /**
-         * Delay in milliseconds to wait before starting to compute
-         * errors for the files in the file list
-         */
-        delay: number;
-    }
-    /**
-     * Geterr request; value of command field is "geterr". Wait for
-     * delay milliseconds and then, if during the wait no change or
-     * reload messages have arrived for the first file in the files
-     * list, get the syntactic errors for the file, field requests,
-     * and then get the semantic errors for the file.  Repeat with a
-     * smaller delay for each subsequent file on the files list.  Best
-     * practice for an editor is to send a file list containing each
-     * file that is currently visible, in most-recently-used order.
-     */
-    interface GeterrRequest extends Request {
-        command: CommandTypes.Geterr;
-        arguments: GeterrRequestArgs;
-    }
-    type RequestCompletedEventName = "requestCompleted";
-    /**
-     * Event that is sent when server have finished processing request with specified id.
-     */
-    interface RequestCompletedEvent extends Event {
-        event: RequestCompletedEventName;
-        body: RequestCompletedEventBody;
-    }
-    interface RequestCompletedEventBody {
-        request_seq: number;
-    }
-    /**
-     * Item of diagnostic information found in a DiagnosticEvent message.
-     */
-    interface Diagnostic {
-        /**
-         * Starting file location at which text applies.
-         */
-        start: Location;
-        /**
-         * The last file location at which the text applies.
-         */
-        end: Location;
-        /**
-         * Text of diagnostic message.
-         */
-        text: string;
-        /**
-         * The category of the diagnostic message, e.g. "error", "warning", or "suggestion".
-         */
-        category: string;
-        reportsUnnecessary?: {};
-        reportsDeprecated?: {};
-        /**
-         * Any related spans the diagnostic may have, such as other locations relevant to an error, such as declarartion sites
-         */
-        relatedInformation?: DiagnosticRelatedInformation[];
-        /**
-         * The error code of the diagnostic message.
-         */
-        code?: number;
-        /**
-         * The name of the plugin reporting the message.
-         */
-        source?: string;
-    }
-    interface DiagnosticWithFileName extends Diagnostic {
-        /**
-         * Name of the file the diagnostic is in
-         */
-        fileName: string;
-    }
-    /**
-     * Represents additional spans returned with a diagnostic which are relevant to it
-     */
-    interface DiagnosticRelatedInformation {
-        /**
-         * The category of the related information message, e.g. "error", "warning", or "suggestion".
-         */
-        category: string;
-        /**
-         * The code used ot identify the related information
-         */
-        code: number;
-        /**
-         * Text of related or additional information.
-         */
-        message: string;
-        /**
-         * Associated location
-         */
-        span?: FileSpan;
-    }
-    interface DiagnosticEventBody {
-        /**
-         * The file for which diagnostic information is reported.
-         */
-        file: string;
-        /**
-         * An array of diagnostic information items.
-         */
-        diagnostics: Diagnostic[];
-    }
-    type DiagnosticEventKind = "semanticDiag" | "syntaxDiag" | "suggestionDiag";
-    /**
-     * Event message for DiagnosticEventKind event types.
-     * These events provide syntactic and semantic errors for a file.
-     */
-    interface DiagnosticEvent extends Event {
-        body?: DiagnosticEventBody;
-        event: DiagnosticEventKind;
-    }
-    interface ConfigFileDiagnosticEventBody {
-        /**
-         * The file which trigged the searching and error-checking of the config file
-         */
-        triggerFile: string;
-        /**
-         * The name of the found config file.
-         */
-        configFile: string;
-        /**
-         * An arry of diagnostic information items for the found config file.
-         */
-        diagnostics: DiagnosticWithFileName[];
-    }
-    /**
-     * Event message for "configFileDiag" event type.
-     * This event provides errors for a found config file.
-     */
-    interface ConfigFileDiagnosticEvent extends Event {
-        body?: ConfigFileDiagnosticEventBody;
-        event: "configFileDiag";
-    }
-    type ProjectLanguageServiceStateEventName = "projectLanguageServiceState";
-    interface ProjectLanguageServiceStateEvent extends Event {
-        event: ProjectLanguageServiceStateEventName;
-        body?: ProjectLanguageServiceStateEventBody;
-    }
-    interface ProjectLanguageServiceStateEventBody {
-        /**
-         * Project name that has changes in the state of language service.
-         * For configured projects this will be the config file path.
-         * For external projects this will be the name of the projects specified when project was open.
-         * For inferred projects this event is not raised.
-         */
-        projectName: string;
-        /**
-         * True if language service state switched from disabled to enabled
-         * and false otherwise.
-         */
-        languageServiceEnabled: boolean;
-    }
-    type ProjectsUpdatedInBackgroundEventName = "projectsUpdatedInBackground";
-    interface ProjectsUpdatedInBackgroundEvent extends Event {
-        event: ProjectsUpdatedInBackgroundEventName;
-        body: ProjectsUpdatedInBackgroundEventBody;
-    }
-    interface ProjectsUpdatedInBackgroundEventBody {
-        /**
-         * Current set of open files
-         */
-        openFiles: string[];
-    }
-    type ProjectLoadingStartEventName = "projectLoadingStart";
-    interface ProjectLoadingStartEvent extends Event {
-        event: ProjectLoadingStartEventName;
-        body: ProjectLoadingStartEventBody;
-    }
-    interface ProjectLoadingStartEventBody {
-        /** name of the project */
-        projectName: string;
-        /** reason for loading */
-        reason: string;
-    }
-    type ProjectLoadingFinishEventName = "projectLoadingFinish";
-    interface ProjectLoadingFinishEvent extends Event {
-        event: ProjectLoadingFinishEventName;
-        body: ProjectLoadingFinishEventBody;
-    }
-    interface ProjectLoadingFinishEventBody {
-        /** name of the project */
-        projectName: string;
-    }
-    type SurveyReadyEventName = "surveyReady";
-    interface SurveyReadyEvent extends Event {
-        event: SurveyReadyEventName;
-        body: SurveyReadyEventBody;
-    }
-    interface SurveyReadyEventBody {
-        /** Name of the survey. This is an internal machine- and programmer-friendly name */
-        surveyId: string;
-    }
-    type LargeFileReferencedEventName = "largeFileReferenced";
-    interface LargeFileReferencedEvent extends Event {
-        event: LargeFileReferencedEventName;
-        body: LargeFileReferencedEventBody;
-    }
-    interface LargeFileReferencedEventBody {
-        /**
-         * name of the large file being loaded
-         */
-        file: string;
-        /**
-         * size of the file
-         */
-        fileSize: number;
-        /**
-         * max file size allowed on the server
-         */
-        maxFileSize: number;
-    }
-    /**
-     * Arguments for reload request.
-     */
-    interface ReloadRequestArgs extends FileRequestArgs {
-        /**
-         * Name of temporary file from which to reload file
-         * contents. May be same as file.
-         */
-        tmpfile: string;
-    }
-    /**
-     * Reload request message; value of command field is "reload".
-     * Reload contents of file with name given by the 'file' argument
-     * from temporary file with name given by the 'tmpfile' argument.
-     * The two names can be identical.
-     */
-    interface ReloadRequest extends FileRequest {
-        command: CommandTypes.Reload;
-        arguments: ReloadRequestArgs;
-    }
-    /**
-     * Response to "reload" request. This is just an acknowledgement, so
-     * no body field is required.
-     */
-    interface ReloadResponse extends Response {
-    }
-    /**
-     * Arguments for saveto request.
-     */
-    interface SavetoRequestArgs extends FileRequestArgs {
-        /**
-         * Name of temporary file into which to save server's view of
-         * file contents.
-         */
-        tmpfile: string;
-    }
-    /**
-     * Saveto request message; value of command field is "saveto".
-     * For debugging purposes, save to a temporaryfile (named by
-     * argument 'tmpfile') the contents of file named by argument
-     * 'file'.  The server does not currently send a response to a
-     * "saveto" request.
-     */
-    interface SavetoRequest extends FileRequest {
-        command: CommandTypes.Saveto;
-        arguments: SavetoRequestArgs;
-    }
-    /**
-     * Arguments for navto request message.
-     */
-    interface NavtoRequestArgs {
-        /**
-         * Search term to navigate to from current location; term can
-         * be '.*' or an identifier prefix.
-         */
-        searchValue: string;
-        /**
-         *  Optional limit on the number of items to return.
-         */
-        maxResultCount?: number;
-        /**
-         * The file for the request (absolute pathname required).
-         */
-        file?: string;
-        /**
-         * Optional flag to indicate we want results for just the current file
-         * or the entire project.
-         */
-        currentFileOnly?: boolean;
-        projectFileName?: string;
-    }
-    /**
-     * Navto request message; value of command field is "navto".
-     * Return list of objects giving file locations and symbols that
-     * match the search term given in argument 'searchTerm'.  The
-     * context for the search is given by the named file.
-     */
-    interface NavtoRequest extends Request {
-        command: CommandTypes.Navto;
-        arguments: NavtoRequestArgs;
-    }
-    /**
-     * An item found in a navto response.
-     */
-    interface NavtoItem extends FileSpan {
-        /**
-         * The symbol's name.
-         */
-        name: string;
-        /**
-         * The symbol's kind (such as 'className' or 'parameterName').
-         */
-        kind: ScriptElementKind;
-        /**
-         * exact, substring, or prefix.
-         */
-        matchKind: string;
-        /**
-         * If this was a case sensitive or insensitive match.
-         */
-        isCaseSensitive: boolean;
-        /**
-         * Optional modifiers for the kind (such as 'public').
-         */
-        kindModifiers?: string;
-        /**
-         * Name of symbol's container symbol (if any); for example,
-         * the class name if symbol is a class member.
-         */
-        containerName?: string;
-        /**
-         * Kind of symbol's container symbol (if any).
-         */
-        containerKind?: ScriptElementKind;
-    }
-    /**
-     * Navto response message. Body is an array of navto items.  Each
-     * item gives a symbol that matched the search term.
-     */
-    interface NavtoResponse extends Response {
-        body?: NavtoItem[];
-    }
-    /**
-     * Arguments for change request message.
-     */
-    interface ChangeRequestArgs extends FormatRequestArgs {
-        /**
-         * Optional string to insert at location (file, line, offset).
-         */
-        insertString?: string;
-    }
-    /**
-     * Change request message; value of command field is "change".
-     * Update the server's view of the file named by argument 'file'.
-     * Server does not currently send a response to a change request.
-     */
-    interface ChangeRequest extends FileLocationRequest {
-        command: CommandTypes.Change;
-        arguments: ChangeRequestArgs;
-    }
-    /**
-     * Response to "brace" request.
-     */
-    interface BraceResponse extends Response {
-        body?: TextSpan[];
-    }
-    /**
-     * Brace matching request; value of command field is "brace".
-     * Return response giving the file locations of matching braces
-     * found in file at location line, offset.
-     */
-    interface BraceRequest extends FileLocationRequest {
-        command: CommandTypes.Brace;
-    }
-    /**
-     * NavBar items request; value of command field is "navbar".
-     * Return response giving the list of navigation bar entries
-     * extracted from the requested file.
-     */
-    interface NavBarRequest extends FileRequest {
-        command: CommandTypes.NavBar;
-    }
-    /**
-     * NavTree request; value of command field is "navtree".
-     * Return response giving the navigation tree of the requested file.
-     */
-    interface NavTreeRequest extends FileRequest {
-        command: CommandTypes.NavTree;
-    }
-    interface NavigationBarItem {
-        /**
-         * The item's display text.
-         */
-        text: string;
-        /**
-         * The symbol's kind (such as 'className' or 'parameterName').
-         */
-        kind: ScriptElementKind;
-        /**
-         * Optional modifiers for the kind (such as 'public').
-         */
-        kindModifiers?: string;
-        /**
-         * The definition locations of the item.
-         */
-        spans: TextSpan[];
-        /**
-         * Optional children.
-         */
-        childItems?: NavigationBarItem[];
-        /**
-         * Number of levels deep this item should appear.
-         */
-        indent: number;
-    }
-    /** protocol.NavigationTree is identical to ts.NavigationTree, except using protocol.TextSpan instead of ts.TextSpan */
-    interface NavigationTree {
-        text: string;
-        kind: ScriptElementKind;
-        kindModifiers: string;
-        spans: TextSpan[];
-        nameSpan: TextSpan | undefined;
-        childItems?: NavigationTree[];
-    }
-    type TelemetryEventName = "telemetry";
-    interface TelemetryEvent extends Event {
-        event: TelemetryEventName;
-        body: TelemetryEventBody;
-    }
-    interface TelemetryEventBody {
-        telemetryEventName: string;
-        payload: any;
-    }
-    type TypesInstallerInitializationFailedEventName = "typesInstallerInitializationFailed";
-    interface TypesInstallerInitializationFailedEvent extends Event {
-        event: TypesInstallerInitializationFailedEventName;
-        body: TypesInstallerInitializationFailedEventBody;
-    }
-    interface TypesInstallerInitializationFailedEventBody {
-        message: string;
-    }
-    type TypingsInstalledTelemetryEventName = "typingsInstalled";
-    interface TypingsInstalledTelemetryEventBody extends TelemetryEventBody {
-        telemetryEventName: TypingsInstalledTelemetryEventName;
-        payload: TypingsInstalledTelemetryEventPayload;
-    }
-    interface TypingsInstalledTelemetryEventPayload {
-        /**
-         * Comma separated list of installed typing packages
-         */
-        installedPackages: string;
-        /**
-         * true if install request succeeded, otherwise - false
-         */
-        installSuccess: boolean;
-        /**
-         * version of typings installer
-         */
-        typingsInstallerVersion: string;
-    }
-    type BeginInstallTypesEventName = "beginInstallTypes";
-    type EndInstallTypesEventName = "endInstallTypes";
-    interface BeginInstallTypesEvent extends Event {
-        event: BeginInstallTypesEventName;
-        body: BeginInstallTypesEventBody;
-    }
-    interface EndInstallTypesEvent extends Event {
-        event: EndInstallTypesEventName;
-        body: EndInstallTypesEventBody;
-    }
-    interface InstallTypesEventBody {
-        /**
-         * correlation id to match begin and end events
-         */
-        eventId: number;
-        /**
-         * list of packages to install
-         */
-        packages: readonly string[];
-    }
-    interface BeginInstallTypesEventBody extends InstallTypesEventBody {
-    }
-    interface EndInstallTypesEventBody extends InstallTypesEventBody {
-        /**
-         * true if installation succeeded, otherwise false
-         */
-        success: boolean;
-    }
-    interface NavBarResponse extends Response {
-        body?: NavigationBarItem[];
-    }
-    interface NavTreeResponse extends Response {
-        body?: NavigationTree;
-    }
-    interface CallHierarchyItem {
-        name: string;
-        kind: ScriptElementKind;
-        kindModifiers?: string;
-        file: string;
-        span: TextSpan;
-        selectionSpan: TextSpan;
-        containerName?: string;
-    }
-    interface CallHierarchyIncomingCall {
-        from: CallHierarchyItem;
-        fromSpans: TextSpan[];
-    }
-    interface CallHierarchyOutgoingCall {
-        to: CallHierarchyItem;
-        fromSpans: TextSpan[];
-    }
-    interface PrepareCallHierarchyRequest extends FileLocationRequest {
-        command: CommandTypes.PrepareCallHierarchy;
-    }
-    interface PrepareCallHierarchyResponse extends Response {
-        readonly body: CallHierarchyItem | CallHierarchyItem[];
-    }
-    interface ProvideCallHierarchyIncomingCallsRequest extends FileLocationRequest {
-        command: CommandTypes.ProvideCallHierarchyIncomingCalls;
-    }
-    interface ProvideCallHierarchyIncomingCallsResponse extends Response {
-        readonly body: CallHierarchyIncomingCall[];
-    }
-    interface ProvideCallHierarchyOutgoingCallsRequest extends FileLocationRequest {
-        command: CommandTypes.ProvideCallHierarchyOutgoingCalls;
-    }
-    interface ProvideCallHierarchyOutgoingCallsResponse extends Response {
-        readonly body: CallHierarchyOutgoingCall[];
-    }
-    enum IndentStyle {
-        None = "None",
-        Block = "Block",
-        Smart = "Smart"
-    }
-    enum SemicolonPreference {
-        Ignore = "ignore",
-        Insert = "insert",
-        Remove = "remove"
-    }
-    interface EditorSettings {
-        baseIndentSize?: number;
-        indentSize?: number;
-        tabSize?: number;
-        newLineCharacter?: string;
-        convertTabsToSpaces?: boolean;
-        indentStyle?: IndentStyle | ts.IndentStyle;
-        trimTrailingWhitespace?: boolean;
-    }
-    interface FormatCodeSettings extends EditorSettings {
-        insertSpaceAfterCommaDelimiter?: boolean;
-        insertSpaceAfterSemicolonInForStatements?: boolean;
-        insertSpaceBeforeAndAfterBinaryOperators?: boolean;
-        insertSpaceAfterConstructor?: boolean;
-        insertSpaceAfterKeywordsInControlFlowStatements?: boolean;
-        insertSpaceAfterFunctionKeywordForAnonymousFunctions?: boolean;
-        insertSpaceAfterOpeningAndBeforeClosingEmptyBraces?: boolean;
-        insertSpaceAfterOpeningAndBeforeClosingNonemptyParenthesis?: boolean;
-        insertSpaceAfterOpeningAndBeforeClosingNonemptyBrackets?: boolean;
-        insertSpaceAfterOpeningAndBeforeClosingNonemptyBraces?: boolean;
-        insertSpaceAfterOpeningAndBeforeClosingTemplateStringBraces?: boolean;
-        insertSpaceAfterOpeningAndBeforeClosingJsxExpressionBraces?: boolean;
-        insertSpaceAfterTypeAssertion?: boolean;
-        insertSpaceBeforeFunctionParenthesis?: boolean;
-        placeOpenBraceOnNewLineForFunctions?: boolean;
-        placeOpenBraceOnNewLineForControlBlocks?: boolean;
-        insertSpaceBeforeTypeAnnotation?: boolean;
-        semicolons?: SemicolonPreference;
-    }
-    interface UserPreferences {
-        readonly disableSuggestions?: boolean;
-        readonly quotePreference?: "auto" | "double" | "single";
-        /**
-         * If enabled, TypeScript will search through all external modules' exports and add them to the completions list.
-         * This affects lone identifier completions but not completions on the right hand side of `obj.`.
-         */
-        readonly includeCompletionsForModuleExports?: boolean;
-        /**
-         * Enables auto-import-style completions on partially-typed import statements. E.g., allows
-         * `import write|` to be completed to `import { writeFile } from "fs"`.
-         */
-        readonly includeCompletionsForImportStatements?: boolean;
-        /**
-         * Allows completions to be formatted with snippet text, indicated by `CompletionItem["isSnippet"]`.
-         */
-        readonly includeCompletionsWithSnippetText?: boolean;
-        /**
-         * If enabled, the completion list will include completions with invalid identifier names.
-         * For those entries, The `insertText` and `replacementSpan` properties will be set to change from `.x` property access to `["x"]`.
-         */
-        readonly includeCompletionsWithInsertText?: boolean;
-        /**
-         * Unless this option is `false`, or `includeCompletionsWithInsertText` is not enabled,
-         * member completion lists triggered with `.` will include entries on potentially-null and potentially-undefined
-         * values, with insertion text to replace preceding `.` tokens with `?.`.
-         */
-        readonly includeAutomaticOptionalChainCompletions?: boolean;
-        /**
-         * If enabled, completions for class members (e.g. methods and properties) will include
-         * a whole declaration for the member.
-         * E.g., `class A { f| }` could be completed to `class A { foo(): number {} }`, instead of
-         * `class A { foo }`.
-         */
-        readonly includeCompletionsWithClassMemberSnippets?: boolean;
-        /**
-         * If enabled, object literal methods will have a method declaration completion entry in addition
-         * to the regular completion entry containing just the method name.
-         * E.g., `const objectLiteral: T = { f| }` could be completed to `const objectLiteral: T = { foo(): void {} }`,
-         * in addition to `const objectLiteral: T = { foo }`.
-         */
-        readonly includeCompletionsWithObjectLiteralMethodSnippets?: boolean;
-        /**
-         * Indicates whether {@link CompletionEntry.labelDetails completion entry label details} are supported.
-         * If not, contents of `labelDetails` may be included in the {@link CompletionEntry.name} property.
-         */
-        readonly useLabelDetailsInCompletionEntries?: boolean;
-        readonly allowIncompleteCompletions?: boolean;
-        readonly importModuleSpecifierPreference?: "shortest" | "project-relative" | "relative" | "non-relative";
-        /** Determines whether we import `foo/index.ts` as "foo", "foo/index", or "foo/index.js" */
-        readonly importModuleSpecifierEnding?: "auto" | "minimal" | "index" | "js";
-        readonly allowTextChangesInNewFiles?: boolean;
-        readonly lazyConfiguredProjectsFromExternalProject?: boolean;
-        readonly providePrefixAndSuffixTextForRename?: boolean;
-        readonly provideRefactorNotApplicableReason?: boolean;
-        readonly allowRenameOfImportPath?: boolean;
-        readonly includePackageJsonAutoImports?: "auto" | "on" | "off";
-        readonly jsxAttributeCompletionStyle?: "auto" | "braces" | "none";
-        readonly displayPartsForJSDoc?: boolean;
-        readonly generateReturnInDocTemplate?: boolean;
-        readonly includeInlayParameterNameHints?: "none" | "literals" | "all";
-        readonly includeInlayParameterNameHintsWhenArgumentMatchesName?: boolean;
-        readonly includeInlayFunctionParameterTypeHints?: boolean;
-        readonly includeInlayVariableTypeHints?: boolean;
-        readonly includeInlayVariableTypeHintsWhenTypeMatchesName?: boolean;
-        readonly includeInlayPropertyDeclarationTypeHints?: boolean;
-        readonly includeInlayFunctionLikeReturnTypeHints?: boolean;
-        readonly includeInlayEnumMemberValueHints?: boolean;
-        readonly autoImportFileExcludePatterns?: string[];
-    }
-    interface CompilerOptions {
-        allowJs?: boolean;
-        allowSyntheticDefaultImports?: boolean;
-        allowUnreachableCode?: boolean;
-        allowUnusedLabels?: boolean;
-        alwaysStrict?: boolean;
-        baseUrl?: string;
-        charset?: string;
-        checkJs?: boolean;
-        declaration?: boolean;
-        declarationDir?: string;
-        disableSizeLimit?: boolean;
-        downlevelIteration?: boolean;
-        emitBOM?: boolean;
-        emitDecoratorMetadata?: boolean;
-        experimentalDecorators?: boolean;
-        forceConsistentCasingInFileNames?: boolean;
-        importHelpers?: boolean;
-        inlineSourceMap?: boolean;
-        inlineSources?: boolean;
-        isolatedModules?: boolean;
-        jsx?: JsxEmit | ts.JsxEmit;
-        lib?: string[];
-        locale?: string;
-        mapRoot?: string;
-        maxNodeModuleJsDepth?: number;
-        module?: ModuleKind | ts.ModuleKind;
-        moduleResolution?: ModuleResolutionKind | ts.ModuleResolutionKind;
-        newLine?: NewLineKind | ts.NewLineKind;
-        noEmit?: boolean;
-        noEmitHelpers?: boolean;
-        noEmitOnError?: boolean;
-        noErrorTruncation?: boolean;
-        noFallthroughCasesInSwitch?: boolean;
-        noImplicitAny?: boolean;
-        noImplicitReturns?: boolean;
-        noImplicitThis?: boolean;
-        noUnusedLocals?: boolean;
-        noUnusedParameters?: boolean;
-        noImplicitUseStrict?: boolean;
-        noLib?: boolean;
-        noResolve?: boolean;
-        out?: string;
-        outDir?: string;
-        outFile?: string;
-        paths?: MapLike<string[]>;
-        plugins?: PluginImport[];
-        preserveConstEnums?: boolean;
-        preserveSymlinks?: boolean;
-        project?: string;
-        reactNamespace?: string;
-        removeComments?: boolean;
-        references?: ProjectReference[];
-        rootDir?: string;
-        rootDirs?: string[];
-        skipLibCheck?: boolean;
-        skipDefaultLibCheck?: boolean;
-        sourceMap?: boolean;
-        sourceRoot?: string;
-        strict?: boolean;
-        strictNullChecks?: boolean;
-        suppressExcessPropertyErrors?: boolean;
-        suppressImplicitAnyIndexErrors?: boolean;
-        useDefineForClassFields?: boolean;
-        target?: ScriptTarget | ts.ScriptTarget;
-        traceResolution?: boolean;
-        resolveJsonModule?: boolean;
-        types?: string[];
-        /** Paths used to used to compute primary types search locations */
-        typeRoots?: string[];
-        [option: string]: CompilerOptionsValue | undefined;
-    }
-    enum JsxEmit {
-        None = "None",
-        Preserve = "Preserve",
-        ReactNative = "ReactNative",
-        React = "React"
-    }
-    enum ModuleKind {
-        None = "None",
-        CommonJS = "CommonJS",
-        AMD = "AMD",
-        UMD = "UMD",
-        System = "System",
-        ES6 = "ES6",
-        ES2015 = "ES2015",
-        ESNext = "ESNext"
-    }
-    enum ModuleResolutionKind {
-        Classic = "Classic",
-        Node = "Node"
-    }
-    enum NewLineKind {
-        Crlf = "Crlf",
-        Lf = "Lf"
-    }
-    enum ScriptTarget {
-        ES3 = "ES3",
-        ES5 = "ES5",
-        ES6 = "ES6",
-        ES2015 = "ES2015",
-        ES2016 = "ES2016",
-        ES2017 = "ES2017",
-        ES2018 = "ES2018",
-        ES2019 = "ES2019",
-        ES2020 = "ES2020",
-        ES2021 = "ES2021",
-        ES2022 = "ES2022",
-        ESNext = "ESNext"
-    }
-    enum ClassificationType {
-        comment = 1,
-        identifier = 2,
-        keyword = 3,
-        numericLiteral = 4,
-        operator = 5,
-        stringLiteral = 6,
-        regularExpressionLiteral = 7,
-        whiteSpace = 8,
-        text = 9,
-        punctuation = 10,
-        className = 11,
-        enumName = 12,
-        interfaceName = 13,
-        moduleName = 14,
-        typeParameterName = 15,
-        typeAliasName = 16,
-        parameterName = 17,
-        docCommentTagName = 18,
-        jsxOpenTagName = 19,
-        jsxCloseTagName = 20,
-        jsxSelfClosingTagName = 21,
-        jsxAttribute = 22,
-        jsxText = 23,
-        jsxAttributeStringLiteralValue = 24,
-        bigintLiteral = 25
-    }
-}
-declare namespace ts.server {
-    interface ScriptInfoVersion {
-        svc: number;
-        text: number;
-    }
-    function isDynamicFileName(fileName: NormalizedPath): boolean;
-    class ScriptInfo {
-        private readonly host;
-        readonly fileName: NormalizedPath;
-        readonly scriptKind: ScriptKind;
-        readonly hasMixedContent: boolean;
-        readonly path: Path;
-        /**
-         * All projects that include this file
-         */
-        readonly containingProjects: Project[];
-        private formatSettings;
-        private preferences;
-        private textStorage;
-        constructor(host: ServerHost, fileName: NormalizedPath, scriptKind: ScriptKind, hasMixedContent: boolean, path: Path, initialVersion?: ScriptInfoVersion);
-        isScriptOpen(): boolean;
-        open(newText: string): void;
-        close(fileExists?: boolean): void;
-        getSnapshot(): IScriptSnapshot;
-        private ensureRealPath;
-        getFormatCodeSettings(): FormatCodeSettings | undefined;
-        getPreferences(): protocol.UserPreferences | undefined;
-        attachToProject(project: Project): boolean;
-        isAttached(project: Project): boolean;
-        detachFromProject(project: Project): void;
-        detachAllProjects(): void;
-        getDefaultProject(): Project;
-        registerFileUpdate(): void;
-        setOptions(formatSettings: FormatCodeSettings, preferences: protocol.UserPreferences | undefined): void;
-        getLatestVersion(): string;
-        saveTo(fileName: string): void;
-        reloadFromFile(tempFileName?: NormalizedPath): boolean;
-        editContent(start: number, end: number, newText: string): void;
-        markContainingProjectsAsDirty(): void;
-        isOrphan(): boolean;
-        /**
-         *  @param line 1 based index
-         */
-        lineToTextSpan(line: number): TextSpan;
-        /**
-         * @param line 1 based index
-         * @param offset 1 based index
-         */
-        lineOffsetToPosition(line: number, offset: number): number;
-        positionToLineOffset(position: number): protocol.Location;
-        isJavaScript(): boolean;
-    }
-}
-declare namespace ts.server {
-    interface InstallPackageOptionsWithProject extends InstallPackageOptions {
-        projectName: string;
-        projectRootPath: Path;
-    }
-    interface ITypingsInstaller {
-        isKnownTypesPackageName(name: string): boolean;
-        installPackage(options: InstallPackageOptionsWithProject): Promise<ApplyCodeActionCommandResult>;
-        enqueueInstallTypingsRequest(p: Project, typeAcquisition: TypeAcquisition, unresolvedImports: SortedReadonlyArray<string> | undefined): void;
-        attach(projectService: ProjectService): void;
-        onProjectClosed(p: Project): void;
-        readonly globalTypingsCacheLocation: string | undefined;
-    }
-    const nullTypingsInstaller: ITypingsInstaller;
-}
-declare namespace ts.server {
-    enum ProjectKind {
-        Inferred = 0,
-        Configured = 1,
-        External = 2,
-        AutoImportProvider = 3,
-        Auxiliary = 4
-    }
-    function allRootFilesAreJsOrDts(project: Project): boolean;
-    function allFilesAreJsOrDts(project: Project): boolean;
-    interface PluginCreateInfo {
-        project: Project;
-        languageService: LanguageService;
-        languageServiceHost: LanguageServiceHost;
-        serverHost: ServerHost;
-        session?: Session<unknown>;
-        config: any;
-    }
-    interface PluginModule {
-        create(createInfo: PluginCreateInfo): LanguageService;
-        getExternalFiles?(proj: Project): string[];
-        onConfigurationChanged?(config: any): void;
-    }
-    interface PluginModuleWithName {
-        name: string;
-        module: PluginModule;
-    }
-    type PluginModuleFactory = (mod: {
-        typescript: typeof ts;
-    }) => PluginModule;
-    abstract class Project implements LanguageServiceHost, ModuleResolutionHost {
-        readonly projectName: string;
-        readonly projectKind: ProjectKind;
-        readonly projectService: ProjectService;
-        private documentRegistry;
-        private compilerOptions;
-        compileOnSaveEnabled: boolean;
-        protected watchOptions: WatchOptions | undefined;
-        private rootFiles;
-        private rootFilesMap;
-        private program;
-        private externalFiles;
-        private missingFilesMap;
-        private generatedFilesMap;
-        private plugins;
-        protected languageService: LanguageService;
-        languageServiceEnabled: boolean;
-        readonly trace?: (s: string) => void;
-        readonly realpath?: (path: string) => string;
-        private builderState;
-        /**
-         * Set of files names that were updated since the last call to getChangesSinceVersion.
-         */
-        private updatedFileNames;
-        /**
-         * Set of files that was returned from the last call to getChangesSinceVersion.
-         */
-        private lastReportedFileNames;
-        /**
-         * Last version that was reported.
-         */
-        private lastReportedVersion;
-        /**
-         * Current project's program version. (incremented everytime new program is created that is not complete reuse from the old one)
-         * This property is changed in 'updateGraph' based on the set of files in program
-         */
-        private projectProgramVersion;
-        /**
-         * Current version of the project state. It is changed when:
-         * - new root file was added/removed
-         * - edit happen in some file that is currently included in the project.
-         * This property is different from projectStructureVersion since in most cases edits don't affect set of files in the project
-         */
-        private projectStateVersion;
-        protected projectErrors: Diagnostic[] | undefined;
-        protected isInitialLoadPending: () => boolean;
-        private readonly cancellationToken;
-        isNonTsProject(): boolean;
-        isJsOnlyProject(): boolean;
-        static resolveModule(moduleName: string, initialDir: string, host: ServerHost, log: (message: string) => void, logErrors?: (message: string) => void): {} | undefined;
-        isKnownTypesPackageName(name: string): boolean;
-        installPackage(options: InstallPackageOptions): Promise<ApplyCodeActionCommandResult>;
-        private get typingsCache();
-        getCompilationSettings(): CompilerOptions;
-        getCompilerOptions(): CompilerOptions;
-        getNewLine(): string;
-        getProjectVersion(): string;
-        getProjectReferences(): readonly ProjectReference[] | undefined;
-        getScriptFileNames(): string[];
-        private getOrCreateScriptInfoAndAttachToProject;
-        getScriptKind(fileName: string): ScriptKind;
-        getScriptVersion(filename: string): string;
-        getScriptSnapshot(filename: string): IScriptSnapshot | undefined;
-        getCancellationToken(): HostCancellationToken;
-        getCurrentDirectory(): string;
-        getDefaultLibFileName(): string;
-        useCaseSensitiveFileNames(): boolean;
-        readDirectory(path: string, extensions?: readonly string[], exclude?: readonly string[], include?: readonly string[], depth?: number): string[];
-        readFile(fileName: string): string | undefined;
-        writeFile(fileName: string, content: string): void;
-        fileExists(file: string): boolean;
-        resolveModuleNames(moduleNames: string[], containingFile: string, reusedNames?: string[], redirectedReference?: ResolvedProjectReference, _options?: CompilerOptions, containingSourceFile?: SourceFile): (ResolvedModuleFull | undefined)[];
-        getModuleResolutionCache(): ModuleResolutionCache | undefined;
-        getResolvedModuleWithFailedLookupLocationsFromCache(moduleName: string, containingFile: string, resolutionMode?: ModuleKind.CommonJS | ModuleKind.ESNext): ResolvedModuleWithFailedLookupLocations | undefined;
-        resolveTypeReferenceDirectives(typeDirectiveNames: string[] | FileReference[], containingFile: string, redirectedReference?: ResolvedProjectReference, _options?: CompilerOptions, containingFileMode?: SourceFile["impliedNodeFormat"] | undefined): (ResolvedTypeReferenceDirective | undefined)[];
-        directoryExists(path: string): boolean;
-        getDirectories(path: string): string[];
-        log(s: string): void;
-        error(s: string): void;
-        private setInternalCompilerOptionsForEmittingJsFiles;
-        /**
-         * Get the errors that dont have any file name associated
-         */
-        getGlobalProjectErrors(): readonly Diagnostic[];
-        /**
-         * Get all the project errors
-         */
-        getAllProjectErrors(): readonly Diagnostic[];
-        setProjectErrors(projectErrors: Diagnostic[] | undefined): void;
-        getLanguageService(ensureSynchronized?: boolean): LanguageService;
-        getCompileOnSaveAffectedFileList(scriptInfo: ScriptInfo): string[];
-        /**
-         * Returns true if emit was conducted
-         */
-        emitFile(scriptInfo: ScriptInfo, writeFile: (path: string, data: string, writeByteOrderMark?: boolean) => void): EmitResult;
-        enableLanguageService(): void;
-        disableLanguageService(lastFileExceededProgramSize?: string): void;
-        getProjectName(): string;
-        protected removeLocalTypingsFromTypeAcquisition(newTypeAcquisition: TypeAcquisition): TypeAcquisition;
-        getExternalFiles(): SortedReadonlyArray<string>;
-        getSourceFile(path: Path): SourceFile | undefined;
-        close(): void;
-        private detachScriptInfoIfNotRoot;
-        isClosed(): boolean;
-        hasRoots(): boolean;
-        getRootFiles(): NormalizedPath[];
-        getRootScriptInfos(): ScriptInfo[];
-        getScriptInfos(): ScriptInfo[];
-        getExcludedFiles(): readonly NormalizedPath[];
-        getFileNames(excludeFilesFromExternalLibraries?: boolean, excludeConfigFiles?: boolean): NormalizedPath[];
-        hasConfigFile(configFilePath: NormalizedPath): boolean;
-        containsScriptInfo(info: ScriptInfo): boolean;
-        containsFile(filename: NormalizedPath, requireOpen?: boolean): boolean;
-        isRoot(info: ScriptInfo): boolean;
-        addRoot(info: ScriptInfo, fileName?: NormalizedPath): void;
-        addMissingFileRoot(fileName: NormalizedPath): void;
-        removeFile(info: ScriptInfo, fileExists: boolean, detachFromProject: boolean): void;
-        registerFileUpdate(fileName: string): void;
-        markAsDirty(): void;
-        /**
-         * Updates set of files that contribute to this project
-         * @returns: true if set of files in the project stays the same and false - otherwise.
-         */
-        updateGraph(): boolean;
-        protected removeExistingTypings(include: string[]): string[];
-        private updateGraphWorker;
-        private detachScriptInfoFromProject;
-        private addMissingFileWatcher;
-        private isWatchedMissingFile;
-        private createGeneratedFileWatcher;
-        private isValidGeneratedFileWatcher;
-        private clearGeneratedFileWatch;
-        getScriptInfoForNormalizedPath(fileName: NormalizedPath): ScriptInfo | undefined;
-        getScriptInfo(uncheckedFileName: string): ScriptInfo | undefined;
-        filesToString(writeProjectFileNames: boolean): string;
-        setCompilerOptions(compilerOptions: CompilerOptions): void;
-        setTypeAcquisition(newTypeAcquisition: TypeAcquisition | undefined): void;
-        getTypeAcquisition(): TypeAcquisition;
-        protected removeRoot(info: ScriptInfo): void;
-        protected enableGlobalPlugins(options: CompilerOptions, pluginConfigOverrides: Map<any> | undefined): void;
-        protected enablePlugin(pluginConfigEntry: PluginImport, searchPaths: string[], pluginConfigOverrides: Map<any> | undefined): void;
-        private enableProxy;
-        /** Starts a new check for diagnostics. Call this if some file has updated that would cause diagnostics to be changed. */
-        refreshDiagnostics(): void;
-    }
-    /**
-     * If a file is opened and no tsconfig (or jsconfig) is found,
-     * the file and its imports/references are put into an InferredProject.
-     */
-    class InferredProject extends Project {
-        private _isJsInferredProject;
-        toggleJsInferredProject(isJsInferredProject: boolean): void;
-        setCompilerOptions(options?: CompilerOptions): void;
-        /** this is canonical project root path */
-        readonly projectRootPath: string | undefined;
-        addRoot(info: ScriptInfo): void;
-        removeRoot(info: ScriptInfo): void;
-        isProjectWithSingleRoot(): boolean;
-        close(): void;
-        getTypeAcquisition(): TypeAcquisition;
-    }
-    class AutoImportProviderProject extends Project {
-        private hostProject;
-        private rootFileNames;
-        isOrphan(): boolean;
-        updateGraph(): boolean;
-        hasRoots(): boolean;
-        markAsDirty(): void;
-        getScriptFileNames(): string[];
-        getLanguageService(): never;
-        getModuleResolutionHostForAutoImportProvider(): never;
-        getProjectReferences(): readonly ProjectReference[] | undefined;
-        getTypeAcquisition(): TypeAcquisition;
-    }
-    /**
-     * If a file is opened, the server will look for a tsconfig (or jsconfig)
-     * and if successful create a ConfiguredProject for it.
-     * Otherwise it will create an InferredProject.
-     */
-    class ConfiguredProject extends Project {
-        readonly canonicalConfigFilePath: NormalizedPath;
-        /** Ref count to the project when opened from external project */
-        private externalProjectRefCount;
-        private projectReferences;
-        /**
-         * If the project has reload from disk pending, it reloads (and then updates graph as part of that) instead of just updating the graph
-         * @returns: true if set of files in the project stays the same and false - otherwise.
-         */
-        updateGraph(): boolean;
-        getConfigFilePath(): NormalizedPath;
-        getProjectReferences(): readonly ProjectReference[] | undefined;
-        updateReferences(refs: readonly ProjectReference[] | undefined): void;
-        /**
-         * Get the errors that dont have any file name associated
-         */
-        getGlobalProjectErrors(): readonly Diagnostic[];
-        /**
-         * Get all the project errors
-         */
-        getAllProjectErrors(): readonly Diagnostic[];
-        setProjectErrors(projectErrors: Diagnostic[]): void;
-        close(): void;
-        getEffectiveTypeRoots(): string[];
-    }
-    /**
-     * Project whose configuration is handled externally, such as in a '.csproj'.
-     * These are created only if a host explicitly calls `openExternalProject`.
-     */
-    class ExternalProject extends Project {
-        externalProjectName: string;
-        compileOnSaveEnabled: boolean;
-        excludedFiles: readonly NormalizedPath[];
-        updateGraph(): boolean;
-        getExcludedFiles(): readonly NormalizedPath[];
-    }
-}
-declare namespace ts.server {
-    export const maxProgramSizeForNonTsFiles: number;
-    export const ProjectsUpdatedInBackgroundEvent = "projectsUpdatedInBackground";
-    export const ProjectLoadingStartEvent = "projectLoadingStart";
-    export const ProjectLoadingFinishEvent = "projectLoadingFinish";
-    export const LargeFileReferencedEvent = "largeFileReferenced";
-    export const ConfigFileDiagEvent = "configFileDiag";
-    export const ProjectLanguageServiceStateEvent = "projectLanguageServiceState";
-    export const ProjectInfoTelemetryEvent = "projectInfo";
-    export const OpenFileInfoTelemetryEvent = "openFileInfo";
-    export interface ProjectsUpdatedInBackgroundEvent {
-        eventName: typeof ProjectsUpdatedInBackgroundEvent;
-        data: {
-            openFiles: string[];
-        };
-    }
-    export interface ProjectLoadingStartEvent {
-        eventName: typeof ProjectLoadingStartEvent;
-        data: {
-            project: Project;
-            reason: string;
-        };
-    }
-    export interface ProjectLoadingFinishEvent {
-        eventName: typeof ProjectLoadingFinishEvent;
-        data: {
-            project: Project;
-        };
-    }
-    export interface LargeFileReferencedEvent {
-        eventName: typeof LargeFileReferencedEvent;
-        data: {
-            file: string;
-            fileSize: number;
-            maxFileSize: number;
-        };
-    }
-    export interface ConfigFileDiagEvent {
-        eventName: typeof ConfigFileDiagEvent;
-        data: {
-            triggerFile: string;
-            configFileName: string;
-            diagnostics: readonly Diagnostic[];
-        };
-    }
-    export interface ProjectLanguageServiceStateEvent {
-        eventName: typeof ProjectLanguageServiceStateEvent;
-        data: {
-            project: Project;
-            languageServiceEnabled: boolean;
-        };
-    }
-    /** This will be converted to the payload of a protocol.TelemetryEvent in session.defaultEventHandler. */
-    export interface ProjectInfoTelemetryEvent {
-        readonly eventName: typeof ProjectInfoTelemetryEvent;
-        readonly data: ProjectInfoTelemetryEventData;
-    }
-    export interface ProjectInfoTelemetryEventData {
-        /** Cryptographically secure hash of project file location. */
-        readonly projectId: string;
-        /** Count of file extensions seen in the project. */
-        readonly fileStats: FileStats;
-        /**
-         * Any compiler options that might contain paths will be taken out.
-         * Enum compiler options will be converted to strings.
-         */
-        readonly compilerOptions: CompilerOptions;
-        readonly extends: boolean | undefined;
-        readonly files: boolean | undefined;
-        readonly include: boolean | undefined;
-        readonly exclude: boolean | undefined;
-        readonly compileOnSave: boolean;
-        readonly typeAcquisition: ProjectInfoTypeAcquisitionData;
-        readonly configFileName: "tsconfig.json" | "jsconfig.json" | "other";
-        readonly projectType: "external" | "configured";
-        readonly languageServiceEnabled: boolean;
-        /** TypeScript version used by the server. */
-        readonly version: string;
-    }
-    /**
-     * Info that we may send about a file that was just opened.
-     * Info about a file will only be sent once per session, even if the file changes in ways that might affect the info.
-     * Currently this is only sent for '.js' files.
-     */
-    export interface OpenFileInfoTelemetryEvent {
-        readonly eventName: typeof OpenFileInfoTelemetryEvent;
-        readonly data: OpenFileInfoTelemetryEventData;
-    }
-    export interface OpenFileInfoTelemetryEventData {
-        readonly info: OpenFileInfo;
-    }
-    export interface ProjectInfoTypeAcquisitionData {
-        readonly enable: boolean | undefined;
-        readonly include: boolean;
-        readonly exclude: boolean;
-    }
-    export interface FileStats {
-        readonly js: number;
-        readonly jsSize?: number;
-        readonly jsx: number;
-        readonly jsxSize?: number;
-        readonly ts: number;
-        readonly tsSize?: number;
-        readonly tsx: number;
-        readonly tsxSize?: number;
-        readonly dts: number;
-        readonly dtsSize?: number;
-        readonly deferred: number;
-        readonly deferredSize?: number;
-    }
-    export interface OpenFileInfo {
-        readonly checkJs: boolean;
-    }
-    export type ProjectServiceEvent = LargeFileReferencedEvent | ProjectsUpdatedInBackgroundEvent | ProjectLoadingStartEvent | ProjectLoadingFinishEvent | ConfigFileDiagEvent | ProjectLanguageServiceStateEvent | ProjectInfoTelemetryEvent | OpenFileInfoTelemetryEvent;
-    export type ProjectServiceEventHandler = (event: ProjectServiceEvent) => void;
-    export interface SafeList {
-        [name: string]: {
-            match: RegExp;
-            exclude?: (string | number)[][];
-            types?: string[];
-        };
-    }
-    export interface TypesMapFile {
-        typesMap: SafeList;
-        simpleMap: {
-            [libName: string]: string;
-        };
-    }
-    export function convertFormatOptions(protocolOptions: protocol.FormatCodeSettings): FormatCodeSettings;
-    export function convertCompilerOptions(protocolOptions: protocol.ExternalProjectCompilerOptions): CompilerOptions & protocol.CompileOnSaveMixin;
-    export function convertWatchOptions(protocolOptions: protocol.ExternalProjectCompilerOptions, currentDirectory?: string): WatchOptionsAndErrors | undefined;
-    export function convertTypeAcquisition(protocolOptions: protocol.InferredProjectCompilerOptions): TypeAcquisition | undefined;
-    export function tryConvertScriptKindName(scriptKindName: protocol.ScriptKindName | ScriptKind): ScriptKind;
-    export function convertScriptKindName(scriptKindName: protocol.ScriptKindName): ScriptKind.Unknown | ScriptKind.JS | ScriptKind.JSX | ScriptKind.TS | ScriptKind.TSX;
-    export interface HostConfiguration {
-        formatCodeOptions: FormatCodeSettings;
-        preferences: protocol.UserPreferences;
-        hostInfo: string;
-        extraFileExtensions?: FileExtensionInfo[];
-        watchOptions?: WatchOptions;
-    }
-    export interface OpenConfiguredProjectResult {
-        configFileName?: NormalizedPath;
-        configFileErrors?: readonly Diagnostic[];
-    }
-    export interface ProjectServiceOptions {
-        host: ServerHost;
-        logger: Logger;
-        cancellationToken: HostCancellationToken;
-        useSingleInferredProject: boolean;
-        useInferredProjectPerProjectRoot: boolean;
-        typingsInstaller: ITypingsInstaller;
-        eventHandler?: ProjectServiceEventHandler;
-        suppressDiagnosticEvents?: boolean;
-        throttleWaitMilliseconds?: number;
-        globalPlugins?: readonly string[];
-        pluginProbeLocations?: readonly string[];
-        allowLocalPluginLoads?: boolean;
-        typesMapLocation?: string;
-        /** @deprecated use serverMode instead */
-        syntaxOnly?: boolean;
-        serverMode?: LanguageServiceMode;
-        session: Session<unknown> | undefined;
-    }
-    export interface WatchOptionsAndErrors {
-        watchOptions: WatchOptions;
-        errors: Diagnostic[] | undefined;
-    }
-    export class ProjectService {
-        private readonly nodeModulesWatchers;
-        /**
-         * Contains all the deleted script info's version information so that
-         * it does not reset when creating script info again
-         * (and could have potentially collided with version where contents mismatch)
-         */
-        private readonly filenameToScriptInfoVersion;
-        private readonly allJsFilesForOpenFileTelemetry;
-        /**
-         * maps external project file name to list of config files that were the part of this project
-         */
-        private readonly externalProjectToConfiguredProjectMap;
-        /**
-         * external projects (configuration and list of root files is not controlled by tsserver)
-         */
-        readonly externalProjects: ExternalProject[];
-        /**
-         * projects built from openFileRoots
-         */
-        readonly inferredProjects: InferredProject[];
-        /**
-         * projects specified by a tsconfig.json file
-         */
-        readonly configuredProjects: Map<ConfiguredProject>;
-        /**
-         * Open files: with value being project root path, and key being Path of the file that is open
-         */
-        readonly openFiles: Map<NormalizedPath | undefined>;
-        /**
-         * Map of open files that are opened without complete path but have projectRoot as current directory
-         */
-        private readonly openFilesWithNonRootedDiskPath;
-        private compilerOptionsForInferredProjects;
-        private compilerOptionsForInferredProjectsPerProjectRoot;
-        private watchOptionsForInferredProjects;
-        private watchOptionsForInferredProjectsPerProjectRoot;
-        private typeAcquisitionForInferredProjects;
-        private typeAcquisitionForInferredProjectsPerProjectRoot;
-        /**
-         * Project size for configured or external projects
-         */
-        private readonly projectToSizeMap;
-        private readonly hostConfiguration;
-        private safelist;
-        private readonly legacySafelist;
-        private pendingProjectUpdates;
-        readonly currentDirectory: NormalizedPath;
-        readonly toCanonicalFileName: (f: string) => string;
-        readonly host: ServerHost;
-        readonly logger: Logger;
-        readonly cancellationToken: HostCancellationToken;
-        readonly useSingleInferredProject: boolean;
-        readonly useInferredProjectPerProjectRoot: boolean;
-        readonly typingsInstaller: ITypingsInstaller;
-        private readonly globalCacheLocationDirectoryPath;
-        readonly throttleWaitMilliseconds?: number;
-        private readonly eventHandler?;
-        private readonly suppressDiagnosticEvents?;
-        readonly globalPlugins: readonly string[];
-        readonly pluginProbeLocations: readonly string[];
-        readonly allowLocalPluginLoads: boolean;
-        private currentPluginConfigOverrides;
-        readonly typesMapLocation: string | undefined;
-        /** @deprecated use serverMode instead */
-        readonly syntaxOnly: boolean;
-        readonly serverMode: LanguageServiceMode;
-        /** Tracks projects that we have already sent telemetry for. */
-        private readonly seenProjects;
-        private performanceEventHandler?;
-        private pendingPluginEnablements?;
-        private currentPluginEnablementPromise?;
-        constructor(opts: ProjectServiceOptions);
-        toPath(fileName: string): Path;
-        private loadTypesMap;
-        updateTypingsForProject(response: SetTypings | InvalidateCachedTypings | PackageInstalledResponse): void;
-        private delayUpdateProjectGraph;
-        private delayUpdateProjectGraphs;
-        setCompilerOptionsForInferredProjects(projectCompilerOptions: protocol.InferredProjectCompilerOptions, projectRootPath?: string): void;
-        findProject(projectName: string): Project | undefined;
-        getDefaultProjectForFile(fileName: NormalizedPath, ensureProject: boolean): Project | undefined;
-        private doEnsureDefaultProjectForFile;
-        getScriptInfoEnsuringProjectsUptoDate(uncheckedFileName: string): ScriptInfo | undefined;
-        /**
-         * Ensures the project structures are upto date
-         * This means,
-         * - we go through all the projects and update them if they are dirty
-         * - if updates reflect some change in structure or there was pending request to ensure projects for open files
-         *   ensure that each open script info has project
-         */
-        private ensureProjectStructuresUptoDate;
-        getFormatCodeOptions(file: NormalizedPath): FormatCodeSettings;
-        getPreferences(file: NormalizedPath): protocol.UserPreferences;
-        getHostFormatCodeOptions(): FormatCodeSettings;
-        getHostPreferences(): protocol.UserPreferences;
-        private onSourceFileChanged;
-        private handleSourceMapProjects;
-        private delayUpdateSourceInfoProjects;
-        private delayUpdateProjectsOfScriptInfoPath;
-        private handleDeletedFile;
-        private removeProject;
-        private assignOrphanScriptInfosToInferredProject;
-        /**
-         * Remove this file from the set of open, non-configured files.
-         * @param info The file that has been closed or newly configured
-         */
-        private closeOpenFile;
-        private deleteScriptInfo;
-        private configFileExists;
-        /**
-         * Returns true if the configFileExistenceInfo is needed/impacted by open files that are root of inferred project
-         */
-        private configFileExistenceImpactsRootOfInferredProject;
-        /**
-         * This is called on file close, so that we stop watching the config file for this script info
-         */
-        private stopWatchingConfigFilesForClosedScriptInfo;
-        /**
-         * This function tries to search for a tsconfig.json for the given file.
-         * This is different from the method the compiler uses because
-         * the compiler can assume it will always start searching in the
-         * current directory (the directory in which tsc was invoked).
-         * The server must start searching from the directory containing
-         * the newly opened file.
-         */
-        private forEachConfigFileLocation;
-        /**
-         * This function tries to search for a tsconfig.json for the given file.
-         * This is different from the method the compiler uses because
-         * the compiler can assume it will always start searching in the
-         * current directory (the directory in which tsc was invoked).
-         * The server must start searching from the directory containing
-         * the newly opened file.
-         * If script info is passed in, it is asserted to be open script info
-         * otherwise just file name
-         */
-        private getConfigFileNameForFile;
-        private printProjects;
-        private getConfiguredProjectByCanonicalConfigFilePath;
-        private findExternalProjectByProjectName;
-        /** Get a filename if the language service exceeds the maximum allowed program size; otherwise returns undefined. */
-        private getFilenameForExceededTotalSizeLimitForNonTsFiles;
-        private createExternalProject;
-        private addFilesToNonInferredProject;
-        private updateNonInferredProjectFiles;
-        private updateRootAndOptionsOfNonInferredProject;
-        private sendConfigFileDiagEvent;
-        private getOrCreateInferredProjectForProjectRootPathIfEnabled;
-        private getOrCreateSingleInferredProjectIfEnabled;
-        private getOrCreateSingleInferredWithoutProjectRoot;
-        private createInferredProject;
-        getScriptInfo(uncheckedFileName: string): ScriptInfo | undefined;
-        private watchClosedScriptInfo;
-        private createNodeModulesWatcher;
-        private watchClosedScriptInfoInNodeModules;
-        private getModifiedTime;
-        private refreshScriptInfo;
-        private refreshScriptInfosInDirectory;
-        private stopWatchingScriptInfo;
-        private getOrCreateScriptInfoNotOpenedByClientForNormalizedPath;
-        private getOrCreateScriptInfoOpenedByClientForNormalizedPath;
-        getOrCreateScriptInfoForNormalizedPath(fileName: NormalizedPath, openedByClient: boolean, fileContent?: string, scriptKind?: ScriptKind, hasMixedContent?: boolean, hostToQueryFileExistsOn?: {
-            fileExists(path: string): boolean;
-        }): ScriptInfo | undefined;
-        private getOrCreateScriptInfoWorker;
-        /**
-         * This gets the script info for the normalized path. If the path is not rooted disk path then the open script info with project root context is preferred
-         */
-        getScriptInfoForNormalizedPath(fileName: NormalizedPath): ScriptInfo | undefined;
-        getScriptInfoForPath(fileName: Path): ScriptInfo | undefined;
-        private addSourceInfoToSourceMap;
-        private addMissingSourceMapFile;
-        setHostConfiguration(args: protocol.ConfigureRequestArguments): void;
-        closeLog(): void;
-        /**
-         * This function rebuilds the project for every file opened by the client
-         * This does not reload contents of open files from disk. But we could do that if needed
-         */
-        reloadProjects(): void;
-        /**
-         * This function goes through all the openFiles and tries to file the config file for them.
-         * If the config file is found and it refers to existing project, it reloads it either immediately
-         * or schedules it for reload depending on delayReload option
-         * If there is no existing project it just opens the configured project for the config file
-         * reloadForInfo provides a way to filter out files to reload configured project for
-         */
-        private reloadConfiguredProjectForFiles;
-        /**
-         * Remove the root of inferred project if script info is part of another project
-         */
-        private removeRootOfInferredProjectIfNowPartOfOtherProject;
-        /**
-         * This function is to update the project structure for every inferred project.
-         * It is called on the premise that all the configured projects are
-         * up to date.
-         * This will go through open files and assign them to inferred project if open file is not part of any other project
-         * After that all the inferred project graphs are updated
-         */
-        private ensureProjectForOpenFiles;
-        /**
-         * Open file whose contents is managed by the client
-         * @param filename is absolute pathname
-         * @param fileContent is a known version of the file content that is more up to date than the one on disk
-         */
-        openClientFile(fileName: string, fileContent?: string, scriptKind?: ScriptKind, projectRootPath?: string): OpenConfiguredProjectResult;
-        private findExternalProjectContainingOpenScriptInfo;
-        private getOrCreateOpenScriptInfo;
-        private assignProjectToOpenedScriptInfo;
-        private createAncestorProjects;
-        private ensureProjectChildren;
-        private cleanupAfterOpeningFile;
-        openClientFileWithNormalizedPath(fileName: NormalizedPath, fileContent?: string, scriptKind?: ScriptKind, hasMixedContent?: boolean, projectRootPath?: NormalizedPath): OpenConfiguredProjectResult;
-        private removeOrphanConfiguredProjects;
-        private removeOrphanScriptInfos;
-        private telemetryOnOpenFile;
-        /**
-         * Close file whose contents is managed by the client
-         * @param filename is absolute pathname
-         */
-        closeClientFile(uncheckedFileName: string): void;
-        private collectChanges;
-        private closeConfiguredProjectReferencedFromExternalProject;
-        closeExternalProject(uncheckedFileName: string): void;
-        openExternalProjects(projects: protocol.ExternalProject[]): void;
-        /** Makes a filename safe to insert in a RegExp */
-        private static readonly filenameEscapeRegexp;
-        private static escapeFilenameForRegex;
-        resetSafeList(): void;
-        applySafeList(proj: protocol.ExternalProject): NormalizedPath[];
-        openExternalProject(proj: protocol.ExternalProject): void;
-        hasDeferredExtension(): boolean;
-        private enableRequestedPluginsAsync;
-        private enableRequestedPluginsWorker;
-        private enableRequestedPluginsForProjectAsync;
-        configurePlugin(args: protocol.ConfigurePluginRequestArguments): void;
-    }
-    export {};
-}
-declare namespace ts.server {
-    interface ServerCancellationToken extends HostCancellationToken {
-        setRequest(requestId: number): void;
-        resetRequest(requestId: number): void;
-    }
-    const nullCancellationToken: ServerCancellationToken;
-    interface PendingErrorCheck {
-        fileName: NormalizedPath;
-        project: Project;
-    }
-    type CommandNames = protocol.CommandTypes;
-    const CommandNames: any;
-    function formatMessage<T extends protocol.Message>(msg: T, logger: Logger, byteLength: (s: string, encoding: string) => number, newLine: string): string;
-    type Event = <T extends object>(body: T, eventName: string) => void;
-    interface EventSender {
-        event: Event;
-    }
-    interface SessionOptions {
-        host: ServerHost;
-        cancellationToken: ServerCancellationToken;
-        useSingleInferredProject: boolean;
-        useInferredProjectPerProjectRoot: boolean;
-        typingsInstaller: ITypingsInstaller;
-        byteLength: (buf: string, encoding?: string) => number;
-        hrtime: (start?: number[]) => number[];
-        logger: Logger;
-        /**
-         * If falsy, all events are suppressed.
-         */
-        canUseEvents: boolean;
-        eventHandler?: ProjectServiceEventHandler;
-        /** Has no effect if eventHandler is also specified. */
-        suppressDiagnosticEvents?: boolean;
-        /** @deprecated use serverMode instead */
-        syntaxOnly?: boolean;
-        serverMode?: LanguageServiceMode;
-        throttleWaitMilliseconds?: number;
-        noGetErrOnBackgroundUpdate?: boolean;
-        globalPlugins?: readonly string[];
-        pluginProbeLocations?: readonly string[];
-        allowLocalPluginLoads?: boolean;
-        typesMapLocation?: string;
-    }
-    class Session<TMessage = string> implements EventSender {
-        private readonly gcTimer;
-        protected projectService: ProjectService;
-        private changeSeq;
-        private performanceData;
-        private currentRequestId;
-        private errorCheck;
-        protected host: ServerHost;
-        private readonly cancellationToken;
-        protected readonly typingsInstaller: ITypingsInstaller;
-        protected byteLength: (buf: string, encoding?: string) => number;
-        private hrtime;
-        protected logger: Logger;
-        protected canUseEvents: boolean;
-        private suppressDiagnosticEvents?;
-        private eventHandler;
-        private readonly noGetErrOnBackgroundUpdate?;
-        constructor(opts: SessionOptions);
-        private sendRequestCompletedEvent;
-        private addPerformanceData;
-        private performanceEventHandler;
-        private defaultEventHandler;
-        private projectsUpdatedInBackgroundEvent;
-        logError(err: Error, cmd: string): void;
-        private logErrorWorker;
-        send(msg: protocol.Message): void;
-        protected writeMessage(msg: protocol.Message): void;
-        event<T extends object>(body: T, eventName: string): void;
-        /** @deprecated */
-        output(info: any, cmdName: string, reqSeq?: number, errorMsg?: string): void;
-        private doOutput;
-        private semanticCheck;
-        private syntacticCheck;
-        private suggestionCheck;
-        private sendDiagnosticsEvent;
-        /** It is the caller's responsibility to verify that `!this.suppressDiagnosticEvents`. */
-        private updateErrorCheck;
-        private cleanProjects;
-        private cleanup;
-        private getEncodedSyntacticClassifications;
-        private getEncodedSemanticClassifications;
-        private getProject;
-        private getConfigFileAndProject;
-        private getConfigFileDiagnostics;
-        private convertToDiagnosticsWithLinePositionFromDiagnosticFile;
-        private getCompilerOptionsDiagnostics;
-        private convertToDiagnosticsWithLinePosition;
-        private getDiagnosticsWorker;
-        private getDefinition;
-        private mapDefinitionInfoLocations;
-        private getDefinitionAndBoundSpan;
-        private findSourceDefinition;
-        private getEmitOutput;
-        private mapJSDocTagInfo;
-        private mapDisplayParts;
-        private mapSignatureHelpItems;
-        private mapDefinitionInfo;
-        private static mapToOriginalLocation;
-        private toFileSpan;
-        private toFileSpanWithContext;
-        private getTypeDefinition;
-        private mapImplementationLocations;
-        private getImplementation;
-        private getOccurrences;
-        private getSyntacticDiagnosticsSync;
-        private getSemanticDiagnosticsSync;
-        private getSuggestionDiagnosticsSync;
-        private getJsxClosingTag;
-        private getDocumentHighlights;
-        private provideInlayHints;
-        private setCompilerOptionsForInferredProjects;
-        private getProjectInfo;
-        private getProjectInfoWorker;
-        private getRenameInfo;
-        private getProjects;
-        private getDefaultProject;
-        private getRenameLocations;
-        private mapRenameInfo;
-        private toSpanGroups;
-        private getReferences;
-        private getFileReferences;
-        /**
-         * @param fileName is the name of the file to be opened
-         * @param fileContent is a version of the file content that is known to be more up to date than the one on disk
-         */
-        private openClientFile;
-        private getPosition;
-        private getPositionInFile;
-        private getFileAndProject;
-        private getFileAndLanguageServiceForSyntacticOperation;
-        private getFileAndProjectWorker;
-        private getOutliningSpans;
-        private getTodoComments;
-        private getDocCommentTemplate;
-        private getSpanOfEnclosingComment;
-        private getIndentation;
-        private getBreakpointStatement;
-        private getNameOrDottedNameSpan;
-        private isValidBraceCompletion;
-        private getQuickInfoWorker;
-        private getFormattingEditsForRange;
-        private getFormattingEditsForRangeFull;
-        private getFormattingEditsForDocumentFull;
-        private getFormattingEditsAfterKeystrokeFull;
-        private getFormattingEditsAfterKeystroke;
-        private getCompletions;
-        private getCompletionEntryDetails;
-        private getCompileOnSaveAffectedFileList;
-        private emitFile;
-        private getSignatureHelpItems;
-        private toPendingErrorCheck;
-        private getDiagnostics;
-        private change;
-        private reload;
-        private saveToTmp;
-        private closeClientFile;
-        private mapLocationNavigationBarItems;
-        private getNavigationBarItems;
-        private toLocationNavigationTree;
-        private getNavigationTree;
-        private getNavigateToItems;
-        private getFullNavigateToItems;
-        private getSupportedCodeFixes;
-        private isLocation;
-        private extractPositionOrRange;
-        private getRange;
-        private getApplicableRefactors;
-        private getEditsForRefactor;
-        private organizeImports;
-        private getEditsForFileRename;
-        private getCodeFixes;
-        private getCombinedCodeFix;
-        private applyCodeActionCommand;
-        private getStartAndEndPosition;
-        private mapCodeAction;
-        private mapCodeFixAction;
-        private mapTextChangesToCodeEdits;
-        private mapTextChangeToCodeEdit;
-        private convertTextChangeToCodeEdit;
-        private getBraceMatching;
-        private getDiagnosticsForProject;
-        private configurePlugin;
-        private getSmartSelectionRange;
-        private toggleLineComment;
-        private toggleMultilineComment;
-        private commentSelection;
-        private uncommentSelection;
-        private mapSelectionRange;
-        private getScriptInfoFromProjectService;
-        private toProtocolCallHierarchyItem;
-        private toProtocolCallHierarchyIncomingCall;
-        private toProtocolCallHierarchyOutgoingCall;
-        private prepareCallHierarchy;
-        private provideCallHierarchyIncomingCalls;
-        private provideCallHierarchyOutgoingCalls;
-        getCanonicalFileName(fileName: string): string;
-        exit(): void;
-        private notRequired;
-        private requiredResponse;
-        private handlers;
-        addProtocolHandler(command: string, handler: (request: protocol.Request) => HandlerResponse): void;
-        private setCurrentRequest;
-        private resetCurrentRequest;
-        executeWithRequestId<T>(requestId: number, f: () => T): T;
-        executeCommand(request: protocol.Request): HandlerResponse;
-        onMessage(message: TMessage): void;
-        protected parseMessage(message: TMessage): protocol.Request;
-        protected toStringMessage(message: TMessage): string;
-        private getFormatOptions;
-        private getPreferences;
-        private getHostFormatOptions;
-        private getHostPreferences;
-    }
-    interface HandlerResponse {
-        response?: {};
-        responseRequired?: boolean;
-    }
-}
-declare namespace ts {
+    export function transform<T extends Node>(source: T | T[], transformers: TransformerFactory<T>[], compilerOptions?: CompilerOptions): TransformationResult<T>;
     /** @deprecated Use `factory.createNodeArray` or the factory supplied by your transformation context instead. */
-    const createNodeArray: <T extends Node>(elements?: readonly T[] | undefined, hasTrailingComma?: boolean | undefined) => NodeArray<T>;
+    export const createNodeArray: typeof factory.createNodeArray;
     /** @deprecated Use `factory.createNumericLiteral` or the factory supplied by your transformation context instead. */
-    const createNumericLiteral: (value: string | number, numericLiteralFlags?: TokenFlags | undefined) => NumericLiteral;
+    export const createNumericLiteral: typeof factory.createNumericLiteral;
     /** @deprecated Use `factory.createBigIntLiteral` or the factory supplied by your transformation context instead. */
-    const createBigIntLiteral: (value: string | PseudoBigInt) => BigIntLiteral;
+    export const createBigIntLiteral: typeof factory.createBigIntLiteral;
     /** @deprecated Use `factory.createStringLiteral` or the factory supplied by your transformation context instead. */
-    const createStringLiteral: {
-        (text: string, isSingleQuote?: boolean | undefined): StringLiteral;
-        (text: string, isSingleQuote?: boolean | undefined, hasExtendedUnicodeEscape?: boolean | undefined): StringLiteral;
-    };
+    export const createStringLiteral: typeof factory.createStringLiteral;
     /** @deprecated Use `factory.createStringLiteralFromNode` or the factory supplied by your transformation context instead. */
-    const createStringLiteralFromNode: (sourceNode: PrivateIdentifier | PropertyNameLiteral, isSingleQuote?: boolean | undefined) => StringLiteral;
+    export const createStringLiteralFromNode: typeof factory.createStringLiteralFromNode;
     /** @deprecated Use `factory.createRegularExpressionLiteral` or the factory supplied by your transformation context instead. */
-    const createRegularExpressionLiteral: (text: string) => RegularExpressionLiteral;
+    export const createRegularExpressionLiteral: typeof factory.createRegularExpressionLiteral;
     /** @deprecated Use `factory.createLoopVariable` or the factory supplied by your transformation context instead. */
-    const createLoopVariable: (reservedInNestedScopes?: boolean | undefined) => Identifier;
+    export const createLoopVariable: typeof factory.createLoopVariable;
     /** @deprecated Use `factory.createUniqueName` or the factory supplied by your transformation context instead. */
-    const createUniqueName: (text: string, flags?: GeneratedIdentifierFlags | undefined) => Identifier;
+    export const createUniqueName: typeof factory.createUniqueName;
     /** @deprecated Use `factory.createPrivateIdentifier` or the factory supplied by your transformation context instead. */
-    const createPrivateIdentifier: (text: string) => PrivateIdentifier;
+    export const createPrivateIdentifier: typeof factory.createPrivateIdentifier;
     /** @deprecated Use `factory.createSuper` or the factory supplied by your transformation context instead. */
-    const createSuper: () => SuperExpression;
+    export const createSuper: typeof factory.createSuper;
     /** @deprecated Use `factory.createThis` or the factory supplied by your transformation context instead. */
-    const createThis: () => ThisExpression;
+    export const createThis: typeof factory.createThis;
     /** @deprecated Use `factory.createNull` or the factory supplied by your transformation context instead. */
-    const createNull: () => NullLiteral;
+    export const createNull: typeof factory.createNull;
     /** @deprecated Use `factory.createTrue` or the factory supplied by your transformation context instead. */
-    const createTrue: () => TrueLiteral;
+    export const createTrue: typeof factory.createTrue;
     /** @deprecated Use `factory.createFalse` or the factory supplied by your transformation context instead. */
-    const createFalse: () => FalseLiteral;
+    export const createFalse: typeof factory.createFalse;
     /** @deprecated Use `factory.createModifier` or the factory supplied by your transformation context instead. */
-    const createModifier: <T extends ModifierSyntaxKind>(kind: T) => ModifierToken<T>;
+    export const createModifier: typeof factory.createModifier;
     /** @deprecated Use `factory.createModifiersFromModifierFlags` or the factory supplied by your transformation context instead. */
-    const createModifiersFromModifierFlags: (flags: ModifierFlags) => Modifier[] | undefined;
+    export const createModifiersFromModifierFlags: typeof factory.createModifiersFromModifierFlags;
     /** @deprecated Use `factory.createQualifiedName` or the factory supplied by your transformation context instead. */
-    const createQualifiedName: (left: EntityName, right: string | Identifier) => QualifiedName;
+    export const createQualifiedName: typeof factory.createQualifiedName;
     /** @deprecated Use `factory.updateQualifiedName` or the factory supplied by your transformation context instead. */
-    const updateQualifiedName: (node: QualifiedName, left: EntityName, right: Identifier) => QualifiedName;
+    export const updateQualifiedName: typeof factory.updateQualifiedName;
     /** @deprecated Use `factory.createComputedPropertyName` or the factory supplied by your transformation context instead. */
-    const createComputedPropertyName: (expression: Expression) => ComputedPropertyName;
+    export const createComputedPropertyName: typeof factory.createComputedPropertyName;
     /** @deprecated Use `factory.updateComputedPropertyName` or the factory supplied by your transformation context instead. */
-    const updateComputedPropertyName: (node: ComputedPropertyName, expression: Expression) => ComputedPropertyName;
+    export const updateComputedPropertyName: typeof factory.updateComputedPropertyName;
     /** @deprecated Use `factory.createTypeParameterDeclaration` or the factory supplied by your transformation context instead. */
-    const createTypeParameterDeclaration: {
-        (modifiers: readonly Modifier[] | undefined, name: string | Identifier, constraint?: TypeNode | undefined, defaultType?: TypeNode | undefined): TypeParameterDeclaration;
-        (name: string | Identifier, constraint?: TypeNode | undefined, defaultType?: TypeNode | undefined): TypeParameterDeclaration;
-    };
+    export const createTypeParameterDeclaration: typeof factory.createTypeParameterDeclaration;
     /** @deprecated Use `factory.updateTypeParameterDeclaration` or the factory supplied by your transformation context instead. */
-    const updateTypeParameterDeclaration: {
-        (node: TypeParameterDeclaration, modifiers: readonly Modifier[] | undefined, name: Identifier, constraint: TypeNode | undefined, defaultType: TypeNode | undefined): TypeParameterDeclaration;
-        (node: TypeParameterDeclaration, name: Identifier, constraint: TypeNode | undefined, defaultType: TypeNode | undefined): TypeParameterDeclaration;
-    };
+    export const updateTypeParameterDeclaration: typeof factory.updateTypeParameterDeclaration;
     /** @deprecated Use `factory.createParameterDeclaration` or the factory supplied by your transformation context instead. */
-    const createParameter: {
-        (modifiers: readonly ModifierLike[] | undefined, dotDotDotToken: DotDotDotToken | undefined, name: string | BindingName, questionToken?: QuestionToken | undefined, type?: TypeNode | undefined, initializer?: Expression | undefined): ParameterDeclaration;
-        (decorators: readonly Decorator[] | undefined, modifiers: readonly Modifier[] | undefined, dotDotDotToken: DotDotDotToken | undefined, name: string | BindingName, questionToken?: QuestionToken | undefined, type?: TypeNode | undefined, initializer?: Expression | undefined): ParameterDeclaration;
-    };
+    export const createParameter: typeof factory.createParameterDeclaration;
     /** @deprecated Use `factory.updateParameterDeclaration` or the factory supplied by your transformation context instead. */
-    const updateParameter: {
-        (node: ParameterDeclaration, modifiers: readonly ModifierLike[] | undefined, dotDotDotToken: DotDotDotToken | undefined, name: string | BindingName, questionToken: QuestionToken | undefined, type: TypeNode | undefined, initializer: Expression | undefined): ParameterDeclaration;
-        (node: ParameterDeclaration, decorators: readonly Decorator[] | undefined, modifiers: readonly Modifier[] | undefined, dotDotDotToken: DotDotDotToken | undefined, name: string | BindingName, questionToken: QuestionToken | undefined, type: TypeNode | undefined, initializer: Expression | undefined): ParameterDeclaration;
-    };
+    export const updateParameter: typeof factory.updateParameterDeclaration;
     /** @deprecated Use `factory.createDecorator` or the factory supplied by your transformation context instead. */
-    const createDecorator: (expression: Expression) => Decorator;
+    export const createDecorator: typeof factory.createDecorator;
     /** @deprecated Use `factory.updateDecorator` or the factory supplied by your transformation context instead. */
-    const updateDecorator: (node: Decorator, expression: Expression) => Decorator;
+    export const updateDecorator: typeof factory.updateDecorator;
     /** @deprecated Use `factory.createPropertyDeclaration` or the factory supplied by your transformation context instead. */
-    const createProperty: {
-        (modifiers: readonly ModifierLike[] | undefined, name: string | PropertyName, questionOrExclamationToken: QuestionToken | ExclamationToken | undefined, type: TypeNode | undefined, initializer: Expression | undefined): PropertyDeclaration;
-        (decorators: readonly Decorator[] | undefined, modifiers: readonly Modifier[] | undefined, name: string | PropertyName, questionOrExclamationToken: QuestionToken | ExclamationToken | undefined, type: TypeNode | undefined, initializer: Expression | undefined): PropertyDeclaration;
-    };
+    export const createProperty: typeof factory.createPropertyDeclaration;
     /** @deprecated Use `factory.updatePropertyDeclaration` or the factory supplied by your transformation context instead. */
-    const updateProperty: {
-        (node: PropertyDeclaration, modifiers: readonly ModifierLike[] | undefined, name: string | PropertyName, questionOrExclamationToken: QuestionToken | ExclamationToken | undefined, type: TypeNode | undefined, initializer: Expression | undefined): PropertyDeclaration;
-        (node: PropertyDeclaration, decorators: readonly Decorator[] | undefined, modifiers: readonly Modifier[] | undefined, name: string | PropertyName, questionOrExclamationToken: QuestionToken | ExclamationToken | undefined, type: TypeNode | undefined, initializer: Expression | undefined): PropertyDeclaration;
-    };
+    export const updateProperty: typeof factory.updatePropertyDeclaration;
     /** @deprecated Use `factory.createMethodDeclaration` or the factory supplied by your transformation context instead. */
-    const createMethod: {
-        (modifiers: readonly ModifierLike[] | undefined, asteriskToken: AsteriskToken | undefined, name: string | PropertyName, questionToken: QuestionToken | undefined, typeParameters: readonly TypeParameterDeclaration[] | undefined, parameters: readonly ParameterDeclaration[], type: TypeNode | undefined, body: Block | undefined): MethodDeclaration;
-        (decorators: readonly Decorator[] | undefined, modifiers: readonly Modifier[] | undefined, asteriskToken: AsteriskToken | undefined, name: string | PropertyName, questionToken: QuestionToken | undefined, typeParameters: readonly TypeParameterDeclaration[] | undefined, parameters: readonly ParameterDeclaration[], type: TypeNode | undefined, body: Block | undefined): MethodDeclaration;
-    };
+    export const createMethod: typeof factory.createMethodDeclaration;
     /** @deprecated Use `factory.updateMethodDeclaration` or the factory supplied by your transformation context instead. */
-    const updateMethod: {
-        (node: MethodDeclaration, modifiers: readonly ModifierLike[] | undefined, asteriskToken: AsteriskToken | undefined, name: PropertyName, questionToken: QuestionToken | undefined, typeParameters: readonly TypeParameterDeclaration[] | undefined, parameters: readonly ParameterDeclaration[], type: TypeNode | undefined, body: Block | undefined): MethodDeclaration;
-        (node: MethodDeclaration, decorators: readonly Decorator[] | undefined, modifiers: readonly Modifier[] | undefined, asteriskToken: AsteriskToken | undefined, name: PropertyName, questionToken: QuestionToken | undefined, typeParameters: readonly TypeParameterDeclaration[] | undefined, parameters: readonly ParameterDeclaration[], type: TypeNode | undefined, body: Block | undefined): MethodDeclaration;
-    };
+    export const updateMethod: typeof factory.updateMethodDeclaration;
     /** @deprecated Use `factory.createConstructorDeclaration` or the factory supplied by your transformation context instead. */
-    const createConstructor: {
-        (modifiers: readonly Modifier[] | undefined, parameters: readonly ParameterDeclaration[], body: Block | undefined): ConstructorDeclaration;
-        (decorators: readonly Decorator[] | undefined, modifiers: readonly Modifier[] | undefined, parameters: readonly ParameterDeclaration[], body: Block | undefined): ConstructorDeclaration;
-    };
+    export const createConstructor: typeof factory.createConstructorDeclaration;
     /** @deprecated Use `factory.updateConstructorDeclaration` or the factory supplied by your transformation context instead. */
-    const updateConstructor: {
-        (node: ConstructorDeclaration, modifiers: readonly Modifier[] | undefined, parameters: readonly ParameterDeclaration[], body: Block | undefined): ConstructorDeclaration;
-        (node: ConstructorDeclaration, decorators: readonly Decorator[] | undefined, modifiers: readonly Modifier[] | undefined, parameters: readonly ParameterDeclaration[], body: Block | undefined): ConstructorDeclaration;
-    };
+    export const updateConstructor: typeof factory.updateConstructorDeclaration;
     /** @deprecated Use `factory.createGetAccessorDeclaration` or the factory supplied by your transformation context instead. */
-    const createGetAccessor: {
-        (modifiers: readonly ModifierLike[] | undefined, name: string | PropertyName, parameters: readonly ParameterDeclaration[], type: TypeNode | undefined, body: Block | undefined): GetAccessorDeclaration;
-        (decorators: readonly Decorator[] | undefined, modifiers: readonly Modifier[] | undefined, name: string | PropertyName, parameters: readonly ParameterDeclaration[], type: TypeNode | undefined, body: Block | undefined): GetAccessorDeclaration;
-    };
+    export const createGetAccessor: typeof factory.createGetAccessorDeclaration;
     /** @deprecated Use `factory.updateGetAccessorDeclaration` or the factory supplied by your transformation context instead. */
-    const updateGetAccessor: {
-        (node: GetAccessorDeclaration, modifiers: readonly ModifierLike[] | undefined, name: PropertyName, parameters: readonly ParameterDeclaration[], type: TypeNode | undefined, body: Block | undefined): GetAccessorDeclaration;
-        (node: GetAccessorDeclaration, decorators: readonly Decorator[] | undefined, modifiers: readonly Modifier[] | undefined, name: PropertyName, parameters: readonly ParameterDeclaration[], type: TypeNode | undefined, body: Block | undefined): GetAccessorDeclaration;
-    };
+    export const updateGetAccessor: typeof factory.updateGetAccessorDeclaration;
     /** @deprecated Use `factory.createSetAccessorDeclaration` or the factory supplied by your transformation context instead. */
-    const createSetAccessor: {
-        (modifiers: readonly ModifierLike[] | undefined, name: string | PropertyName, parameters: readonly ParameterDeclaration[], body: Block | undefined): SetAccessorDeclaration;
-        (decorators: readonly Decorator[] | undefined, modifiers: readonly Modifier[] | undefined, name: string | PropertyName, parameters: readonly ParameterDeclaration[], body: Block | undefined): SetAccessorDeclaration;
-    };
+    export const createSetAccessor: typeof factory.createSetAccessorDeclaration;
     /** @deprecated Use `factory.updateSetAccessorDeclaration` or the factory supplied by your transformation context instead. */
-    const updateSetAccessor: {
-        (node: SetAccessorDeclaration, modifiers: readonly ModifierLike[] | undefined, name: PropertyName, parameters: readonly ParameterDeclaration[], body: Block | undefined): SetAccessorDeclaration;
-        (node: SetAccessorDeclaration, decorators: readonly Decorator[] | undefined, modifiers: readonly Modifier[] | undefined, name: PropertyName, parameters: readonly ParameterDeclaration[], body: Block | undefined): SetAccessorDeclaration;
-    };
+    export const updateSetAccessor: typeof factory.updateSetAccessorDeclaration;
     /** @deprecated Use `factory.createCallSignature` or the factory supplied by your transformation context instead. */
-    const createCallSignature: (typeParameters: readonly TypeParameterDeclaration[] | undefined, parameters: readonly ParameterDeclaration[], type: TypeNode | undefined) => CallSignatureDeclaration;
+    export const createCallSignature: typeof factory.createCallSignature;
     /** @deprecated Use `factory.updateCallSignature` or the factory supplied by your transformation context instead. */
-    const updateCallSignature: (node: CallSignatureDeclaration, typeParameters: NodeArray<TypeParameterDeclaration> | undefined, parameters: NodeArray<ParameterDeclaration>, type: TypeNode | undefined) => CallSignatureDeclaration;
+    export const updateCallSignature: typeof factory.updateCallSignature;
     /** @deprecated Use `factory.createConstructSignature` or the factory supplied by your transformation context instead. */
-    const createConstructSignature: (typeParameters: readonly TypeParameterDeclaration[] | undefined, parameters: readonly ParameterDeclaration[], type: TypeNode | undefined) => ConstructSignatureDeclaration;
+    export const createConstructSignature: typeof factory.createConstructSignature;
     /** @deprecated Use `factory.updateConstructSignature` or the factory supplied by your transformation context instead. */
-    const updateConstructSignature: (node: ConstructSignatureDeclaration, typeParameters: NodeArray<TypeParameterDeclaration> | undefined, parameters: NodeArray<ParameterDeclaration>, type: TypeNode | undefined) => ConstructSignatureDeclaration;
+    export const updateConstructSignature: typeof factory.updateConstructSignature;
     /** @deprecated Use `factory.updateIndexSignature` or the factory supplied by your transformation context instead. */
-    const updateIndexSignature: {
-        (node: IndexSignatureDeclaration, modifiers: readonly Modifier[] | undefined, parameters: readonly ParameterDeclaration[], type: TypeNode): IndexSignatureDeclaration;
-        (node: IndexSignatureDeclaration, decorators: readonly Decorator[] | undefined, modifiers: readonly Modifier[] | undefined, parameters: readonly ParameterDeclaration[], type: TypeNode): IndexSignatureDeclaration;
-    };
+    export const updateIndexSignature: typeof factory.updateIndexSignature;
     /** @deprecated Use `factory.createKeywordTypeNode` or the factory supplied by your transformation context instead. */
-    const createKeywordTypeNode: <TKind extends KeywordTypeSyntaxKind>(kind: TKind) => KeywordTypeNode<TKind>;
+    export const createKeywordTypeNode: typeof factory.createKeywordTypeNode;
     /** @deprecated Use `factory.createTypePredicateNode` or the factory supplied by your transformation context instead. */
-    const createTypePredicateNodeWithModifier: (assertsModifier: AssertsKeyword | undefined, parameterName: string | Identifier | ThisTypeNode, type: TypeNode | undefined) => TypePredicateNode;
+    export const createTypePredicateNodeWithModifier: typeof factory.createTypePredicateNode;
     /** @deprecated Use `factory.updateTypePredicateNode` or the factory supplied by your transformation context instead. */
-    const updateTypePredicateNodeWithModifier: (node: TypePredicateNode, assertsModifier: AssertsKeyword | undefined, parameterName: Identifier | ThisTypeNode, type: TypeNode | undefined) => TypePredicateNode;
+    export const updateTypePredicateNodeWithModifier: typeof factory.updateTypePredicateNode;
     /** @deprecated Use `factory.createTypeReferenceNode` or the factory supplied by your transformation context instead. */
-    const createTypeReferenceNode: (typeName: string | EntityName, typeArguments?: readonly TypeNode[] | undefined) => TypeReferenceNode;
+    export const createTypeReferenceNode: typeof factory.createTypeReferenceNode;
     /** @deprecated Use `factory.updateTypeReferenceNode` or the factory supplied by your transformation context instead. */
-    const updateTypeReferenceNode: (node: TypeReferenceNode, typeName: EntityName, typeArguments: NodeArray<TypeNode> | undefined) => TypeReferenceNode;
+    export const updateTypeReferenceNode: typeof factory.updateTypeReferenceNode;
     /** @deprecated Use `factory.createFunctionTypeNode` or the factory supplied by your transformation context instead. */
-    const createFunctionTypeNode: (typeParameters: readonly TypeParameterDeclaration[] | undefined, parameters: readonly ParameterDeclaration[], type: TypeNode) => FunctionTypeNode;
+    export const createFunctionTypeNode: typeof factory.createFunctionTypeNode;
     /** @deprecated Use `factory.updateFunctionTypeNode` or the factory supplied by your transformation context instead. */
-    const updateFunctionTypeNode: (node: FunctionTypeNode, typeParameters: NodeArray<TypeParameterDeclaration> | undefined, parameters: NodeArray<ParameterDeclaration>, type: TypeNode) => FunctionTypeNode;
+    export const updateFunctionTypeNode: typeof factory.updateFunctionTypeNode;
     /** @deprecated Use `factory.createConstructorTypeNode` or the factory supplied by your transformation context instead. */
-    const createConstructorTypeNode: (typeParameters: readonly TypeParameterDeclaration[] | undefined, parameters: readonly ParameterDeclaration[], type: TypeNode) => ConstructorTypeNode;
+    export const createConstructorTypeNode: (typeParameters: readonly TypeParameterDeclaration[] | undefined, parameters: readonly ParameterDeclaration[], type: TypeNode) => ConstructorTypeNode;
     /** @deprecated Use `factory.updateConstructorTypeNode` or the factory supplied by your transformation context instead. */
-    const updateConstructorTypeNode: (node: ConstructorTypeNode, typeParameters: NodeArray<TypeParameterDeclaration> | undefined, parameters: NodeArray<ParameterDeclaration>, type: TypeNode) => ConstructorTypeNode;
+    export const updateConstructorTypeNode: (node: ConstructorTypeNode, typeParameters: NodeArray<TypeParameterDeclaration> | undefined, parameters: NodeArray<ParameterDeclaration>, type: TypeNode) => ConstructorTypeNode;
     /** @deprecated Use `factory.createTypeQueryNode` or the factory supplied by your transformation context instead. */
-    const createTypeQueryNode: (exprName: EntityName, typeArguments?: readonly TypeNode[] | undefined) => TypeQueryNode;
+    export const createTypeQueryNode: typeof factory.createTypeQueryNode;
     /** @deprecated Use `factory.updateTypeQueryNode` or the factory supplied by your transformation context instead. */
-    const updateTypeQueryNode: (node: TypeQueryNode, exprName: EntityName, typeArguments?: readonly TypeNode[] | undefined) => TypeQueryNode;
+    export const updateTypeQueryNode: typeof factory.updateTypeQueryNode;
     /** @deprecated Use `factory.createTypeLiteralNode` or the factory supplied by your transformation context instead. */
-    const createTypeLiteralNode: (members: readonly TypeElement[] | undefined) => TypeLiteralNode;
+    export const createTypeLiteralNode: typeof factory.createTypeLiteralNode;
     /** @deprecated Use `factory.updateTypeLiteralNode` or the factory supplied by your transformation context instead. */
-    const updateTypeLiteralNode: (node: TypeLiteralNode, members: NodeArray<TypeElement>) => TypeLiteralNode;
+    export const updateTypeLiteralNode: typeof factory.updateTypeLiteralNode;
     /** @deprecated Use `factory.createArrayTypeNode` or the factory supplied by your transformation context instead. */
-    const createArrayTypeNode: (elementType: TypeNode) => ArrayTypeNode;
+    export const createArrayTypeNode: typeof factory.createArrayTypeNode;
     /** @deprecated Use `factory.updateArrayTypeNode` or the factory supplied by your transformation context instead. */
-    const updateArrayTypeNode: (node: ArrayTypeNode, elementType: TypeNode) => ArrayTypeNode;
+    export const updateArrayTypeNode: typeof factory.updateArrayTypeNode;
     /** @deprecated Use `factory.createTupleTypeNode` or the factory supplied by your transformation context instead. */
-    const createTupleTypeNode: (elements: readonly (TypeNode | NamedTupleMember)[]) => TupleTypeNode;
+    export const createTupleTypeNode: typeof factory.createTupleTypeNode;
     /** @deprecated Use `factory.updateTupleTypeNode` or the factory supplied by your transformation context instead. */
-    const updateTupleTypeNode: (node: TupleTypeNode, elements: readonly (TypeNode | NamedTupleMember)[]) => TupleTypeNode;
+    export const updateTupleTypeNode: typeof factory.updateTupleTypeNode;
     /** @deprecated Use `factory.createOptionalTypeNode` or the factory supplied by your transformation context instead. */
-    const createOptionalTypeNode: (type: TypeNode) => OptionalTypeNode;
+    export const createOptionalTypeNode: typeof factory.createOptionalTypeNode;
     /** @deprecated Use `factory.updateOptionalTypeNode` or the factory supplied by your transformation context instead. */
-    const updateOptionalTypeNode: (node: OptionalTypeNode, type: TypeNode) => OptionalTypeNode;
+    export const updateOptionalTypeNode: typeof factory.updateOptionalTypeNode;
     /** @deprecated Use `factory.createRestTypeNode` or the factory supplied by your transformation context instead. */
-    const createRestTypeNode: (type: TypeNode) => RestTypeNode;
+    export const createRestTypeNode: typeof factory.createRestTypeNode;
     /** @deprecated Use `factory.updateRestTypeNode` or the factory supplied by your transformation context instead. */
-    const updateRestTypeNode: (node: RestTypeNode, type: TypeNode) => RestTypeNode;
+    export const updateRestTypeNode: typeof factory.updateRestTypeNode;
     /** @deprecated Use `factory.createUnionTypeNode` or the factory supplied by your transformation context instead. */
-    const createUnionTypeNode: (types: readonly TypeNode[]) => UnionTypeNode;
+    export const createUnionTypeNode: typeof factory.createUnionTypeNode;
     /** @deprecated Use `factory.updateUnionTypeNode` or the factory supplied by your transformation context instead. */
-    const updateUnionTypeNode: (node: UnionTypeNode, types: NodeArray<TypeNode>) => UnionTypeNode;
+    export const updateUnionTypeNode: typeof factory.updateUnionTypeNode;
     /** @deprecated Use `factory.createIntersectionTypeNode` or the factory supplied by your transformation context instead. */
-    const createIntersectionTypeNode: (types: readonly TypeNode[]) => IntersectionTypeNode;
+    export const createIntersectionTypeNode: typeof factory.createIntersectionTypeNode;
     /** @deprecated Use `factory.updateIntersectionTypeNode` or the factory supplied by your transformation context instead. */
-    const updateIntersectionTypeNode: (node: IntersectionTypeNode, types: NodeArray<TypeNode>) => IntersectionTypeNode;
+    export const updateIntersectionTypeNode: typeof factory.updateIntersectionTypeNode;
     /** @deprecated Use `factory.createConditionalTypeNode` or the factory supplied by your transformation context instead. */
-    const createConditionalTypeNode: (checkType: TypeNode, extendsType: TypeNode, trueType: TypeNode, falseType: TypeNode) => ConditionalTypeNode;
+    export const createConditionalTypeNode: typeof factory.createConditionalTypeNode;
     /** @deprecated Use `factory.updateConditionalTypeNode` or the factory supplied by your transformation context instead. */
-    const updateConditionalTypeNode: (node: ConditionalTypeNode, checkType: TypeNode, extendsType: TypeNode, trueType: TypeNode, falseType: TypeNode) => ConditionalTypeNode;
+    export const updateConditionalTypeNode: typeof factory.updateConditionalTypeNode;
     /** @deprecated Use `factory.createInferTypeNode` or the factory supplied by your transformation context instead. */
-    const createInferTypeNode: (typeParameter: TypeParameterDeclaration) => InferTypeNode;
+    export const createInferTypeNode: typeof factory.createInferTypeNode;
     /** @deprecated Use `factory.updateInferTypeNode` or the factory supplied by your transformation context instead. */
-    const updateInferTypeNode: (node: InferTypeNode, typeParameter: TypeParameterDeclaration) => InferTypeNode;
+    export const updateInferTypeNode: typeof factory.updateInferTypeNode;
     /** @deprecated Use `factory.createImportTypeNode` or the factory supplied by your transformation context instead. */
-    const createImportTypeNode: {
-        (argument: TypeNode, assertions?: ImportTypeAssertionContainer | undefined, qualifier?: EntityName | undefined, typeArguments?: readonly TypeNode[] | undefined, isTypeOf?: boolean | undefined): ImportTypeNode;
-        (argument: TypeNode, assertions?: ImportTypeAssertionContainer | undefined, qualifier?: EntityName | undefined, typeArguments?: readonly TypeNode[] | undefined, isTypeOf?: boolean | undefined): ImportTypeNode;
-        (argument: TypeNode, qualifier?: EntityName | undefined, typeArguments?: readonly TypeNode[] | undefined, isTypeOf?: boolean | undefined): ImportTypeNode;
-    };
+    export const createImportTypeNode: typeof factory.createImportTypeNode;
     /** @deprecated Use `factory.updateImportTypeNode` or the factory supplied by your transformation context instead. */
-    const updateImportTypeNode: {
-        (node: ImportTypeNode, argument: TypeNode, assertions: ImportTypeAssertionContainer | undefined, qualifier: EntityName | undefined, typeArguments: readonly TypeNode[] | undefined, isTypeOf?: boolean | undefined): ImportTypeNode;
-        (node: ImportTypeNode, argument: TypeNode, qualifier: EntityName | undefined, typeArguments: readonly TypeNode[] | undefined, isTypeOf?: boolean | undefined): ImportTypeNode;
-    };
+    export const updateImportTypeNode: typeof factory.updateImportTypeNode;
     /** @deprecated Use `factory.createParenthesizedType` or the factory supplied by your transformation context instead. */
-    const createParenthesizedType: (type: TypeNode) => ParenthesizedTypeNode;
+    export const createParenthesizedType: typeof factory.createParenthesizedType;
     /** @deprecated Use `factory.updateParenthesizedType` or the factory supplied by your transformation context instead. */
-    const updateParenthesizedType: (node: ParenthesizedTypeNode, type: TypeNode) => ParenthesizedTypeNode;
+    export const updateParenthesizedType: typeof factory.updateParenthesizedType;
     /** @deprecated Use `factory.createThisTypeNode` or the factory supplied by your transformation context instead. */
-    const createThisTypeNode: () => ThisTypeNode;
+    export const createThisTypeNode: typeof factory.createThisTypeNode;
     /** @deprecated Use `factory.updateTypeOperatorNode` or the factory supplied by your transformation context instead. */
-    const updateTypeOperatorNode: (node: TypeOperatorNode, type: TypeNode) => TypeOperatorNode;
+    export const updateTypeOperatorNode: typeof factory.updateTypeOperatorNode;
     /** @deprecated Use `factory.createIndexedAccessTypeNode` or the factory supplied by your transformation context instead. */
-    const createIndexedAccessTypeNode: (objectType: TypeNode, indexType: TypeNode) => IndexedAccessTypeNode;
+    export const createIndexedAccessTypeNode: typeof factory.createIndexedAccessTypeNode;
     /** @deprecated Use `factory.updateIndexedAccessTypeNode` or the factory supplied by your transformation context instead. */
-    const updateIndexedAccessTypeNode: (node: IndexedAccessTypeNode, objectType: TypeNode, indexType: TypeNode) => IndexedAccessTypeNode;
+    export const updateIndexedAccessTypeNode: typeof factory.updateIndexedAccessTypeNode;
     /** @deprecated Use `factory.createMappedTypeNode` or the factory supplied by your transformation context instead. */
-    const createMappedTypeNode: (readonlyToken: ReadonlyKeyword | PlusToken | MinusToken | undefined, typeParameter: TypeParameterDeclaration, nameType: TypeNode | undefined, questionToken: QuestionToken | PlusToken | MinusToken | undefined, type: TypeNode | undefined, members: NodeArray<TypeElement> | undefined) => MappedTypeNode;
+    export const createMappedTypeNode: typeof factory.createMappedTypeNode;
     /** @deprecated Use `factory.updateMappedTypeNode` or the factory supplied by your transformation context instead. */
-    const updateMappedTypeNode: (node: MappedTypeNode, readonlyToken: ReadonlyKeyword | PlusToken | MinusToken | undefined, typeParameter: TypeParameterDeclaration, nameType: TypeNode | undefined, questionToken: QuestionToken | PlusToken | MinusToken | undefined, type: TypeNode | undefined, members: NodeArray<TypeElement> | undefined) => MappedTypeNode;
+    export const updateMappedTypeNode: typeof factory.updateMappedTypeNode;
     /** @deprecated Use `factory.createLiteralTypeNode` or the factory supplied by your transformation context instead. */
-    const createLiteralTypeNode: (literal: LiteralExpression | BooleanLiteral | PrefixUnaryExpression | NullLiteral) => LiteralTypeNode;
+    export const createLiteralTypeNode: typeof factory.createLiteralTypeNode;
     /** @deprecated Use `factory.updateLiteralTypeNode` or the factory supplied by your transformation context instead. */
-    const updateLiteralTypeNode: (node: LiteralTypeNode, literal: LiteralExpression | BooleanLiteral | PrefixUnaryExpression | NullLiteral) => LiteralTypeNode;
+    export const updateLiteralTypeNode: typeof factory.updateLiteralTypeNode;
     /** @deprecated Use `factory.createObjectBindingPattern` or the factory supplied by your transformation context instead. */
-    const createObjectBindingPattern: (elements: readonly BindingElement[]) => ObjectBindingPattern;
+    export const createObjectBindingPattern: typeof factory.createObjectBindingPattern;
     /** @deprecated Use `factory.updateObjectBindingPattern` or the factory supplied by your transformation context instead. */
-    const updateObjectBindingPattern: (node: ObjectBindingPattern, elements: readonly BindingElement[]) => ObjectBindingPattern;
+    export const updateObjectBindingPattern: typeof factory.updateObjectBindingPattern;
     /** @deprecated Use `factory.createArrayBindingPattern` or the factory supplied by your transformation context instead. */
-    const createArrayBindingPattern: (elements: readonly ArrayBindingElement[]) => ArrayBindingPattern;
+    export const createArrayBindingPattern: typeof factory.createArrayBindingPattern;
     /** @deprecated Use `factory.updateArrayBindingPattern` or the factory supplied by your transformation context instead. */
-    const updateArrayBindingPattern: (node: ArrayBindingPattern, elements: readonly ArrayBindingElement[]) => ArrayBindingPattern;
+    export const updateArrayBindingPattern: typeof factory.updateArrayBindingPattern;
     /** @deprecated Use `factory.createBindingElement` or the factory supplied by your transformation context instead. */
-    const createBindingElement: (dotDotDotToken: DotDotDotToken | undefined, propertyName: string | PropertyName | undefined, name: string | BindingName, initializer?: Expression | undefined) => BindingElement;
+    export const createBindingElement: typeof factory.createBindingElement;
     /** @deprecated Use `factory.updateBindingElement` or the factory supplied by your transformation context instead. */
-    const updateBindingElement: (node: BindingElement, dotDotDotToken: DotDotDotToken | undefined, propertyName: PropertyName | undefined, name: BindingName, initializer: Expression | undefined) => BindingElement;
+    export const updateBindingElement: typeof factory.updateBindingElement;
     /** @deprecated Use `factory.createArrayLiteralExpression` or the factory supplied by your transformation context instead. */
-    const createArrayLiteral: (elements?: readonly Expression[] | undefined, multiLine?: boolean | undefined) => ArrayLiteralExpression;
+    export const createArrayLiteral: typeof factory.createArrayLiteralExpression;
     /** @deprecated Use `factory.updateArrayLiteralExpression` or the factory supplied by your transformation context instead. */
-    const updateArrayLiteral: (node: ArrayLiteralExpression, elements: readonly Expression[]) => ArrayLiteralExpression;
+    export const updateArrayLiteral: typeof factory.updateArrayLiteralExpression;
     /** @deprecated Use `factory.createObjectLiteralExpression` or the factory supplied by your transformation context instead. */
-    const createObjectLiteral: (properties?: readonly ObjectLiteralElementLike[] | undefined, multiLine?: boolean | undefined) => ObjectLiteralExpression;
+    export const createObjectLiteral: typeof factory.createObjectLiteralExpression;
     /** @deprecated Use `factory.updateObjectLiteralExpression` or the factory supplied by your transformation context instead. */
-    const updateObjectLiteral: (node: ObjectLiteralExpression, properties: readonly ObjectLiteralElementLike[]) => ObjectLiteralExpression;
+    export const updateObjectLiteral: typeof factory.updateObjectLiteralExpression;
     /** @deprecated Use `factory.createPropertyAccessExpression` or the factory supplied by your transformation context instead. */
-    const createPropertyAccess: (expression: Expression, name: string | MemberName) => PropertyAccessExpression;
+    export const createPropertyAccess: typeof factory.createPropertyAccessExpression;
     /** @deprecated Use `factory.updatePropertyAccessExpression` or the factory supplied by your transformation context instead. */
-    const updatePropertyAccess: (node: PropertyAccessExpression, expression: Expression, name: MemberName) => PropertyAccessExpression;
+    export const updatePropertyAccess: typeof factory.updatePropertyAccessExpression;
     /** @deprecated Use `factory.createPropertyAccessChain` or the factory supplied by your transformation context instead. */
-    const createPropertyAccessChain: (expression: Expression, questionDotToken: QuestionDotToken | undefined, name: string | MemberName) => PropertyAccessChain;
+    export const createPropertyAccessChain: typeof factory.createPropertyAccessChain;
     /** @deprecated Use `factory.updatePropertyAccessChain` or the factory supplied by your transformation context instead. */
-    const updatePropertyAccessChain: (node: PropertyAccessChain, expression: Expression, questionDotToken: QuestionDotToken | undefined, name: MemberName) => PropertyAccessChain;
+    export const updatePropertyAccessChain: typeof factory.updatePropertyAccessChain;
     /** @deprecated Use `factory.createElementAccessExpression` or the factory supplied by your transformation context instead. */
-    const createElementAccess: (expression: Expression, index: number | Expression) => ElementAccessExpression;
+    export const createElementAccess: typeof factory.createElementAccessExpression;
     /** @deprecated Use `factory.updateElementAccessExpression` or the factory supplied by your transformation context instead. */
-    const updateElementAccess: (node: ElementAccessExpression, expression: Expression, argumentExpression: Expression) => ElementAccessExpression;
+    export const updateElementAccess: typeof factory.updateElementAccessExpression;
     /** @deprecated Use `factory.createElementAccessChain` or the factory supplied by your transformation context instead. */
-    const createElementAccessChain: (expression: Expression, questionDotToken: QuestionDotToken | undefined, index: number | Expression) => ElementAccessChain;
+    export const createElementAccessChain: typeof factory.createElementAccessChain;
     /** @deprecated Use `factory.updateElementAccessChain` or the factory supplied by your transformation context instead. */
-    const updateElementAccessChain: (node: ElementAccessChain, expression: Expression, questionDotToken: QuestionDotToken | undefined, argumentExpression: Expression) => ElementAccessChain;
+    export const updateElementAccessChain: typeof factory.updateElementAccessChain;
     /** @deprecated Use `factory.createCallExpression` or the factory supplied by your transformation context instead. */
-    const createCall: (expression: Expression, typeArguments: readonly TypeNode[] | undefined, argumentsArray: readonly Expression[] | undefined) => CallExpression;
+    export const createCall: typeof factory.createCallExpression;
     /** @deprecated Use `factory.updateCallExpression` or the factory supplied by your transformation context instead. */
-    const updateCall: (node: CallExpression, expression: Expression, typeArguments: readonly TypeNode[] | undefined, argumentsArray: readonly Expression[]) => CallExpression;
+    export const updateCall: typeof factory.updateCallExpression;
     /** @deprecated Use `factory.createCallChain` or the factory supplied by your transformation context instead. */
-    const createCallChain: (expression: Expression, questionDotToken: QuestionDotToken | undefined, typeArguments: readonly TypeNode[] | undefined, argumentsArray: readonly Expression[] | undefined) => CallChain;
+    export const createCallChain: typeof factory.createCallChain;
     /** @deprecated Use `factory.updateCallChain` or the factory supplied by your transformation context instead. */
-    const updateCallChain: (node: CallChain, expression: Expression, questionDotToken: QuestionDotToken | undefined, typeArguments: readonly TypeNode[] | undefined, argumentsArray: readonly Expression[]) => CallChain;
+    export const updateCallChain: typeof factory.updateCallChain;
     /** @deprecated Use `factory.createNewExpression` or the factory supplied by your transformation context instead. */
-    const createNew: (expression: Expression, typeArguments: readonly TypeNode[] | undefined, argumentsArray: readonly Expression[] | undefined) => NewExpression;
+    export const createNew: typeof factory.createNewExpression;
     /** @deprecated Use `factory.updateNewExpression` or the factory supplied by your transformation context instead. */
-    const updateNew: (node: NewExpression, expression: Expression, typeArguments: readonly TypeNode[] | undefined, argumentsArray: readonly Expression[] | undefined) => NewExpression;
+    export const updateNew: typeof factory.updateNewExpression;
     /** @deprecated Use `factory.createTypeAssertion` or the factory supplied by your transformation context instead. */
-    const createTypeAssertion: (type: TypeNode, expression: Expression) => TypeAssertion;
+    export const createTypeAssertion: typeof factory.createTypeAssertion;
     /** @deprecated Use `factory.updateTypeAssertion` or the factory supplied by your transformation context instead. */
-    const updateTypeAssertion: (node: TypeAssertion, type: TypeNode, expression: Expression) => TypeAssertion;
+    export const updateTypeAssertion: typeof factory.updateTypeAssertion;
     /** @deprecated Use `factory.createParenthesizedExpression` or the factory supplied by your transformation context instead. */
-    const createParen: (expression: Expression) => ParenthesizedExpression;
+    export const createParen: typeof factory.createParenthesizedExpression;
     /** @deprecated Use `factory.updateParenthesizedExpression` or the factory supplied by your transformation context instead. */
-    const updateParen: (node: ParenthesizedExpression, expression: Expression) => ParenthesizedExpression;
+    export const updateParen: typeof factory.updateParenthesizedExpression;
     /** @deprecated Use `factory.createFunctionExpression` or the factory supplied by your transformation context instead. */
-    const createFunctionExpression: (modifiers: readonly Modifier[] | undefined, asteriskToken: AsteriskToken | undefined, name: string | Identifier | undefined, typeParameters: readonly TypeParameterDeclaration[] | undefined, parameters: readonly ParameterDeclaration[] | undefined, type: TypeNode | undefined, body: Block) => FunctionExpression;
+    export const createFunctionExpression: typeof factory.createFunctionExpression;
     /** @deprecated Use `factory.updateFunctionExpression` or the factory supplied by your transformation context instead. */
-    const updateFunctionExpression: (node: FunctionExpression, modifiers: readonly Modifier[] | undefined, asteriskToken: AsteriskToken | undefined, name: Identifier | undefined, typeParameters: readonly TypeParameterDeclaration[] | undefined, parameters: readonly ParameterDeclaration[], type: TypeNode | undefined, body: Block) => FunctionExpression;
+    export const updateFunctionExpression: typeof factory.updateFunctionExpression;
     /** @deprecated Use `factory.createDeleteExpression` or the factory supplied by your transformation context instead. */
-    const createDelete: (expression: Expression) => DeleteExpression;
+    export const createDelete: typeof factory.createDeleteExpression;
     /** @deprecated Use `factory.updateDeleteExpression` or the factory supplied by your transformation context instead. */
-    const updateDelete: (node: DeleteExpression, expression: Expression) => DeleteExpression;
+    export const updateDelete: typeof factory.updateDeleteExpression;
     /** @deprecated Use `factory.createTypeOfExpression` or the factory supplied by your transformation context instead. */
-    const createTypeOf: (expression: Expression) => TypeOfExpression;
+    export const createTypeOf: typeof factory.createTypeOfExpression;
     /** @deprecated Use `factory.updateTypeOfExpression` or the factory supplied by your transformation context instead. */
-    const updateTypeOf: (node: TypeOfExpression, expression: Expression) => TypeOfExpression;
+    export const updateTypeOf: typeof factory.updateTypeOfExpression;
     /** @deprecated Use `factory.createVoidExpression` or the factory supplied by your transformation context instead. */
-    const createVoid: (expression: Expression) => VoidExpression;
+    export const createVoid: typeof factory.createVoidExpression;
     /** @deprecated Use `factory.updateVoidExpression` or the factory supplied by your transformation context instead. */
-    const updateVoid: (node: VoidExpression, expression: Expression) => VoidExpression;
+    export const updateVoid: typeof factory.updateVoidExpression;
     /** @deprecated Use `factory.createAwaitExpression` or the factory supplied by your transformation context instead. */
-    const createAwait: (expression: Expression) => AwaitExpression;
+    export const createAwait: typeof factory.createAwaitExpression;
     /** @deprecated Use `factory.updateAwaitExpression` or the factory supplied by your transformation context instead. */
-    const updateAwait: (node: AwaitExpression, expression: Expression) => AwaitExpression;
+    export const updateAwait: typeof factory.updateAwaitExpression;
     /** @deprecated Use `factory.createPrefixExpression` or the factory supplied by your transformation context instead. */
-    const createPrefix: (operator: PrefixUnaryOperator, operand: Expression) => PrefixUnaryExpression;
+    export const createPrefix: typeof factory.createPrefixUnaryExpression;
     /** @deprecated Use `factory.updatePrefixExpression` or the factory supplied by your transformation context instead. */
-    const updatePrefix: (node: PrefixUnaryExpression, operand: Expression) => PrefixUnaryExpression;
+    export const updatePrefix: typeof factory.updatePrefixUnaryExpression;
     /** @deprecated Use `factory.createPostfixUnaryExpression` or the factory supplied by your transformation context instead. */
-    const createPostfix: (operand: Expression, operator: PostfixUnaryOperator) => PostfixUnaryExpression;
+    export const createPostfix: typeof factory.createPostfixUnaryExpression;
     /** @deprecated Use `factory.updatePostfixUnaryExpression` or the factory supplied by your transformation context instead. */
-    const updatePostfix: (node: PostfixUnaryExpression, operand: Expression) => PostfixUnaryExpression;
+    export const updatePostfix: typeof factory.updatePostfixUnaryExpression;
     /** @deprecated Use `factory.createBinaryExpression` or the factory supplied by your transformation context instead. */
-    const createBinary: (left: Expression, operator: BinaryOperator | BinaryOperatorToken, right: Expression) => BinaryExpression;
+    export const createBinary: typeof factory.createBinaryExpression;
     /** @deprecated Use `factory.updateConditionalExpression` or the factory supplied by your transformation context instead. */
-    const updateConditional: (node: ConditionalExpression, condition: Expression, questionToken: QuestionToken, whenTrue: Expression, colonToken: ColonToken, whenFalse: Expression) => ConditionalExpression;
+    export const updateConditional: typeof factory.updateConditionalExpression;
     /** @deprecated Use `factory.createTemplateExpression` or the factory supplied by your transformation context instead. */
-    const createTemplateExpression: (head: TemplateHead, templateSpans: readonly TemplateSpan[]) => TemplateExpression;
+    export const createTemplateExpression: typeof factory.createTemplateExpression;
     /** @deprecated Use `factory.updateTemplateExpression` or the factory supplied by your transformation context instead. */
-    const updateTemplateExpression: (node: TemplateExpression, head: TemplateHead, templateSpans: readonly TemplateSpan[]) => TemplateExpression;
+    export const updateTemplateExpression: typeof factory.updateTemplateExpression;
     /** @deprecated Use `factory.createTemplateHead` or the factory supplied by your transformation context instead. */
-    const createTemplateHead: {
-        (text: string, rawText?: string | undefined, templateFlags?: TokenFlags | undefined): TemplateHead;
-        (text: string | undefined, rawText: string, templateFlags?: TokenFlags | undefined): TemplateHead;
-    };
+    export const createTemplateHead: typeof factory.createTemplateHead;
     /** @deprecated Use `factory.createTemplateMiddle` or the factory supplied by your transformation context instead. */
-    const createTemplateMiddle: {
-        (text: string, rawText?: string | undefined, templateFlags?: TokenFlags | undefined): TemplateMiddle;
-        (text: string | undefined, rawText: string, templateFlags?: TokenFlags | undefined): TemplateMiddle;
-    };
+    export const createTemplateMiddle: typeof factory.createTemplateMiddle;
     /** @deprecated Use `factory.createTemplateTail` or the factory supplied by your transformation context instead. */
-    const createTemplateTail: {
-        (text: string, rawText?: string | undefined, templateFlags?: TokenFlags | undefined): TemplateTail;
-        (text: string | undefined, rawText: string, templateFlags?: TokenFlags | undefined): TemplateTail;
-    };
+    export const createTemplateTail: typeof factory.createTemplateTail;
     /** @deprecated Use `factory.createNoSubstitutionTemplateLiteral` or the factory supplied by your transformation context instead. */
-    const createNoSubstitutionTemplateLiteral: {
-        (text: string, rawText?: string | undefined): NoSubstitutionTemplateLiteral;
-        (text: string | undefined, rawText: string): NoSubstitutionTemplateLiteral;
-    };
+    export const createNoSubstitutionTemplateLiteral: typeof factory.createNoSubstitutionTemplateLiteral;
     /** @deprecated Use `factory.updateYieldExpression` or the factory supplied by your transformation context instead. */
-    const updateYield: (node: YieldExpression, asteriskToken: AsteriskToken | undefined, expression: Expression | undefined) => YieldExpression;
+    export const updateYield: typeof factory.updateYieldExpression;
     /** @deprecated Use `factory.createSpreadExpression` or the factory supplied by your transformation context instead. */
-    const createSpread: (expression: Expression) => SpreadElement;
+    export const createSpread: typeof factory.createSpreadElement;
     /** @deprecated Use `factory.updateSpreadExpression` or the factory supplied by your transformation context instead. */
-    const updateSpread: (node: SpreadElement, expression: Expression) => SpreadElement;
+    export const updateSpread: typeof factory.updateSpreadElement;
     /** @deprecated Use `factory.createOmittedExpression` or the factory supplied by your transformation context instead. */
-    const createOmittedExpression: () => OmittedExpression;
+    export const createOmittedExpression: typeof factory.createOmittedExpression;
     /** @deprecated Use `factory.createAsExpression` or the factory supplied by your transformation context instead. */
-    const createAsExpression: (expression: Expression, type: TypeNode) => AsExpression;
+    export const createAsExpression: typeof factory.createAsExpression;
     /** @deprecated Use `factory.updateAsExpression` or the factory supplied by your transformation context instead. */
-    const updateAsExpression: (node: AsExpression, expression: Expression, type: TypeNode) => AsExpression;
+    export const updateAsExpression: typeof factory.updateAsExpression;
     /** @deprecated Use `factory.createNonNullExpression` or the factory supplied by your transformation context instead. */
-    const createNonNullExpression: (expression: Expression) => NonNullExpression;
+    export const createNonNullExpression: typeof factory.createNonNullExpression;
     /** @deprecated Use `factory.updateNonNullExpression` or the factory supplied by your transformation context instead. */
-    const updateNonNullExpression: (node: NonNullExpression, expression: Expression) => NonNullExpression;
+    export const updateNonNullExpression: typeof factory.updateNonNullExpression;
     /** @deprecated Use `factory.createNonNullChain` or the factory supplied by your transformation context instead. */
-    const createNonNullChain: (expression: Expression) => NonNullChain;
+    export const createNonNullChain: typeof factory.createNonNullChain;
     /** @deprecated Use `factory.updateNonNullChain` or the factory supplied by your transformation context instead. */
-    const updateNonNullChain: (node: NonNullChain, expression: Expression) => NonNullChain;
+    export const updateNonNullChain: typeof factory.updateNonNullChain;
     /** @deprecated Use `factory.createMetaProperty` or the factory supplied by your transformation context instead. */
-    const createMetaProperty: (keywordToken: SyntaxKind.ImportKeyword | SyntaxKind.NewKeyword, name: Identifier) => MetaProperty;
+    export const createMetaProperty: typeof factory.createMetaProperty;
     /** @deprecated Use `factory.updateMetaProperty` or the factory supplied by your transformation context instead. */
-    const updateMetaProperty: (node: MetaProperty, name: Identifier) => MetaProperty;
+    export const updateMetaProperty: typeof factory.updateMetaProperty;
     /** @deprecated Use `factory.createTemplateSpan` or the factory supplied by your transformation context instead. */
-    const createTemplateSpan: (expression: Expression, literal: TemplateMiddle | TemplateTail) => TemplateSpan;
+    export const createTemplateSpan: typeof factory.createTemplateSpan;
     /** @deprecated Use `factory.updateTemplateSpan` or the factory supplied by your transformation context instead. */
-    const updateTemplateSpan: (node: TemplateSpan, expression: Expression, literal: TemplateMiddle | TemplateTail) => TemplateSpan;
+    export const updateTemplateSpan: typeof factory.updateTemplateSpan;
     /** @deprecated Use `factory.createSemicolonClassElement` or the factory supplied by your transformation context instead. */
-    const createSemicolonClassElement: () => SemicolonClassElement;
+    export const createSemicolonClassElement: typeof factory.createSemicolonClassElement;
     /** @deprecated Use `factory.createBlock` or the factory supplied by your transformation context instead. */
-    const createBlock: (statements: readonly Statement[], multiLine?: boolean | undefined) => Block;
+    export const createBlock: typeof factory.createBlock;
     /** @deprecated Use `factory.updateBlock` or the factory supplied by your transformation context instead. */
-    const updateBlock: (node: Block, statements: readonly Statement[]) => Block;
+    export const updateBlock: typeof factory.updateBlock;
     /** @deprecated Use `factory.createVariableStatement` or the factory supplied by your transformation context instead. */
-    const createVariableStatement: (modifiers: readonly Modifier[] | undefined, declarationList: VariableDeclarationList | readonly VariableDeclaration[]) => VariableStatement;
+    export const createVariableStatement: typeof factory.createVariableStatement;
     /** @deprecated Use `factory.updateVariableStatement` or the factory supplied by your transformation context instead. */
-    const updateVariableStatement: (node: VariableStatement, modifiers: readonly Modifier[] | undefined, declarationList: VariableDeclarationList) => VariableStatement;
+    export const updateVariableStatement: typeof factory.updateVariableStatement;
     /** @deprecated Use `factory.createEmptyStatement` or the factory supplied by your transformation context instead. */
-    const createEmptyStatement: () => EmptyStatement;
+    export const createEmptyStatement: typeof factory.createEmptyStatement;
     /** @deprecated Use `factory.createExpressionStatement` or the factory supplied by your transformation context instead. */
-    const createExpressionStatement: (expression: Expression) => ExpressionStatement;
+    export const createExpressionStatement: typeof factory.createExpressionStatement;
     /** @deprecated Use `factory.updateExpressionStatement` or the factory supplied by your transformation context instead. */
-    const updateExpressionStatement: (node: ExpressionStatement, expression: Expression) => ExpressionStatement;
+    export const updateExpressionStatement: typeof factory.updateExpressionStatement;
     /** @deprecated Use `factory.createExpressionStatement` or the factory supplied by your transformation context instead. */
-    const createStatement: (expression: Expression) => ExpressionStatement;
+    export const createStatement: typeof factory.createExpressionStatement;
     /** @deprecated Use `factory.updateExpressionStatement` or the factory supplied by your transformation context instead. */
-    const updateStatement: (node: ExpressionStatement, expression: Expression) => ExpressionStatement;
+    export const updateStatement: typeof factory.updateExpressionStatement;
     /** @deprecated Use `factory.createIfStatement` or the factory supplied by your transformation context instead. */
-    const createIf: (expression: Expression, thenStatement: Statement, elseStatement?: Statement | undefined) => IfStatement;
+    export const createIf: typeof factory.createIfStatement;
     /** @deprecated Use `factory.updateIfStatement` or the factory supplied by your transformation context instead. */
-    const updateIf: (node: IfStatement, expression: Expression, thenStatement: Statement, elseStatement: Statement | undefined) => IfStatement;
+    export const updateIf: typeof factory.updateIfStatement;
     /** @deprecated Use `factory.createDoStatement` or the factory supplied by your transformation context instead. */
-    const createDo: (statement: Statement, expression: Expression) => DoStatement;
+    export const createDo: typeof factory.createDoStatement;
     /** @deprecated Use `factory.updateDoStatement` or the factory supplied by your transformation context instead. */
-    const updateDo: (node: DoStatement, statement: Statement, expression: Expression) => DoStatement;
+    export const updateDo: typeof factory.updateDoStatement;
     /** @deprecated Use `factory.createWhileStatement` or the factory supplied by your transformation context instead. */
-    const createWhile: (expression: Expression, statement: Statement) => WhileStatement;
+    export const createWhile: typeof factory.createWhileStatement;
     /** @deprecated Use `factory.updateWhileStatement` or the factory supplied by your transformation context instead. */
-    const updateWhile: (node: WhileStatement, expression: Expression, statement: Statement) => WhileStatement;
+    export const updateWhile: typeof factory.updateWhileStatement;
     /** @deprecated Use `factory.createForStatement` or the factory supplied by your transformation context instead. */
-    const createFor: (initializer: ForInitializer | undefined, condition: Expression | undefined, incrementor: Expression | undefined, statement: Statement) => ForStatement;
+    export const createFor: typeof factory.createForStatement;
     /** @deprecated Use `factory.updateForStatement` or the factory supplied by your transformation context instead. */
-    const updateFor: (node: ForStatement, initializer: ForInitializer | undefined, condition: Expression | undefined, incrementor: Expression | undefined, statement: Statement) => ForStatement;
+    export const updateFor: typeof factory.updateForStatement;
     /** @deprecated Use `factory.createForInStatement` or the factory supplied by your transformation context instead. */
-    const createForIn: (initializer: ForInitializer, expression: Expression, statement: Statement) => ForInStatement;
+    export const createForIn: typeof factory.createForInStatement;
     /** @deprecated Use `factory.updateForInStatement` or the factory supplied by your transformation context instead. */
-    const updateForIn: (node: ForInStatement, initializer: ForInitializer, expression: Expression, statement: Statement) => ForInStatement;
+    export const updateForIn: typeof factory.updateForInStatement;
     /** @deprecated Use `factory.createForOfStatement` or the factory supplied by your transformation context instead. */
-    const createForOf: (awaitModifier: AwaitKeyword | undefined, initializer: ForInitializer, expression: Expression, statement: Statement) => ForOfStatement;
+    export const createForOf: typeof factory.createForOfStatement;
     /** @deprecated Use `factory.updateForOfStatement` or the factory supplied by your transformation context instead. */
-    const updateForOf: (node: ForOfStatement, awaitModifier: AwaitKeyword | undefined, initializer: ForInitializer, expression: Expression, statement: Statement) => ForOfStatement;
+    export const updateForOf: typeof factory.updateForOfStatement;
     /** @deprecated Use `factory.createContinueStatement` or the factory supplied by your transformation context instead. */
-    const createContinue: (label?: string | Identifier | undefined) => ContinueStatement;
+    export const createContinue: typeof factory.createContinueStatement;
     /** @deprecated Use `factory.updateContinueStatement` or the factory supplied by your transformation context instead. */
-    const updateContinue: (node: ContinueStatement, label: Identifier | undefined) => ContinueStatement;
+    export const updateContinue: typeof factory.updateContinueStatement;
     /** @deprecated Use `factory.createBreakStatement` or the factory supplied by your transformation context instead. */
-    const createBreak: (label?: string | Identifier | undefined) => BreakStatement;
+    export const createBreak: typeof factory.createBreakStatement;
     /** @deprecated Use `factory.updateBreakStatement` or the factory supplied by your transformation context instead. */
-    const updateBreak: (node: BreakStatement, label: Identifier | undefined) => BreakStatement;
+    export const updateBreak: typeof factory.updateBreakStatement;
     /** @deprecated Use `factory.createReturnStatement` or the factory supplied by your transformation context instead. */
-    const createReturn: (expression?: Expression | undefined) => ReturnStatement;
+    export const createReturn: typeof factory.createReturnStatement;
     /** @deprecated Use `factory.updateReturnStatement` or the factory supplied by your transformation context instead. */
-    const updateReturn: (node: ReturnStatement, expression: Expression | undefined) => ReturnStatement;
+    export const updateReturn: typeof factory.updateReturnStatement;
     /** @deprecated Use `factory.createWithStatement` or the factory supplied by your transformation context instead. */
-    const createWith: (expression: Expression, statement: Statement) => WithStatement;
+    export const createWith: typeof factory.createWithStatement;
     /** @deprecated Use `factory.updateWithStatement` or the factory supplied by your transformation context instead. */
-    const updateWith: (node: WithStatement, expression: Expression, statement: Statement) => WithStatement;
+    export const updateWith: typeof factory.updateWithStatement;
     /** @deprecated Use `factory.createSwitchStatement` or the factory supplied by your transformation context instead. */
-    const createSwitch: (expression: Expression, caseBlock: CaseBlock) => SwitchStatement;
+    export const createSwitch: typeof factory.createSwitchStatement;
     /** @deprecated Use `factory.updateSwitchStatement` or the factory supplied by your transformation context instead. */
-    const updateSwitch: (node: SwitchStatement, expression: Expression, caseBlock: CaseBlock) => SwitchStatement;
+    export const updateSwitch: typeof factory.updateSwitchStatement;
     /** @deprecated Use `factory.createLabelStatement` or the factory supplied by your transformation context instead. */
-    const createLabel: (label: string | Identifier, statement: Statement) => LabeledStatement;
+    export const createLabel: typeof factory.createLabeledStatement;
     /** @deprecated Use `factory.updateLabelStatement` or the factory supplied by your transformation context instead. */
-    const updateLabel: (node: LabeledStatement, label: Identifier, statement: Statement) => LabeledStatement;
+    export const updateLabel: typeof factory.updateLabeledStatement;
     /** @deprecated Use `factory.createThrowStatement` or the factory supplied by your transformation context instead. */
-    const createThrow: (expression: Expression) => ThrowStatement;
+    export const createThrow: typeof factory.createThrowStatement;
     /** @deprecated Use `factory.updateThrowStatement` or the factory supplied by your transformation context instead. */
-    const updateThrow: (node: ThrowStatement, expression: Expression) => ThrowStatement;
+    export const updateThrow: typeof factory.updateThrowStatement;
     /** @deprecated Use `factory.createTryStatement` or the factory supplied by your transformation context instead. */
-    const createTry: (tryBlock: Block, catchClause: CatchClause | undefined, finallyBlock: Block | undefined) => TryStatement;
+    export const createTry: typeof factory.createTryStatement;
     /** @deprecated Use `factory.updateTryStatement` or the factory supplied by your transformation context instead. */
-    const updateTry: (node: TryStatement, tryBlock: Block, catchClause: CatchClause | undefined, finallyBlock: Block | undefined) => TryStatement;
+    export const updateTry: typeof factory.updateTryStatement;
     /** @deprecated Use `factory.createDebuggerStatement` or the factory supplied by your transformation context instead. */
-    const createDebuggerStatement: () => DebuggerStatement;
+    export const createDebuggerStatement: typeof factory.createDebuggerStatement;
     /** @deprecated Use `factory.createVariableDeclarationList` or the factory supplied by your transformation context instead. */
-    const createVariableDeclarationList: (declarations: readonly VariableDeclaration[], flags?: NodeFlags | undefined) => VariableDeclarationList;
+    export const createVariableDeclarationList: typeof factory.createVariableDeclarationList;
     /** @deprecated Use `factory.updateVariableDeclarationList` or the factory supplied by your transformation context instead. */
-    const updateVariableDeclarationList: (node: VariableDeclarationList, declarations: readonly VariableDeclaration[]) => VariableDeclarationList;
+    export const updateVariableDeclarationList: typeof factory.updateVariableDeclarationList;
     /** @deprecated Use `factory.createFunctionDeclaration` or the factory supplied by your transformation context instead. */
-    const createFunctionDeclaration: {
-        (modifiers: readonly ModifierLike[] | undefined, asteriskToken: AsteriskToken | undefined, name: string | Identifier | undefined, typeParameters: readonly TypeParameterDeclaration[] | undefined, parameters: readonly ParameterDeclaration[], type: TypeNode | undefined, body: Block | undefined): FunctionDeclaration;
-        (decorators: readonly Decorator[] | undefined, modifiers: readonly Modifier[] | undefined, asteriskToken: AsteriskToken | undefined, name: string | Identifier | undefined, typeParameters: readonly TypeParameterDeclaration[] | undefined, parameters: readonly ParameterDeclaration[], type: TypeNode | undefined, body: Block | undefined): FunctionDeclaration;
-    };
+    export const createFunctionDeclaration: typeof factory.createFunctionDeclaration;
     /** @deprecated Use `factory.updateFunctionDeclaration` or the factory supplied by your transformation context instead. */
-    const updateFunctionDeclaration: {
-        (node: FunctionDeclaration, modifiers: readonly ModifierLike[] | undefined, asteriskToken: AsteriskToken | undefined, name: Identifier | undefined, typeParameters: readonly TypeParameterDeclaration[] | undefined, parameters: readonly ParameterDeclaration[], type: TypeNode | undefined, body: Block | undefined): FunctionDeclaration;
-        (node: FunctionDeclaration, decorators: readonly Decorator[] | undefined, modifiers: readonly Modifier[] | undefined, asteriskToken: AsteriskToken | undefined, name: Identifier | undefined, typeParameters: readonly TypeParameterDeclaration[] | undefined, parameters: readonly ParameterDeclaration[], type: TypeNode | undefined, body: Block | undefined): FunctionDeclaration;
-    };
+    export const updateFunctionDeclaration: typeof factory.updateFunctionDeclaration;
     /** @deprecated Use `factory.createClassDeclaration` or the factory supplied by your transformation context instead. */
-    const createClassDeclaration: {
-        (modifiers: readonly ModifierLike[] | undefined, name: string | Identifier | undefined, typeParameters: readonly TypeParameterDeclaration[] | undefined, heritageClauses: readonly HeritageClause[] | undefined, members: readonly ClassElement[]): ClassDeclaration;
-        (decorators: readonly Decorator[] | undefined, modifiers: readonly Modifier[] | undefined, name: string | Identifier | undefined, typeParameters: readonly TypeParameterDeclaration[] | undefined, heritageClauses: readonly HeritageClause[] | undefined, members: readonly ClassElement[]): ClassDeclaration;
-    };
+    export const createClassDeclaration: typeof factory.createClassDeclaration;
     /** @deprecated Use `factory.updateClassDeclaration` or the factory supplied by your transformation context instead. */
-    const updateClassDeclaration: {
-        (node: ClassDeclaration, modifiers: readonly ModifierLike[] | undefined, name: Identifier | undefined, typeParameters: readonly TypeParameterDeclaration[] | undefined, heritageClauses: readonly HeritageClause[] | undefined, members: readonly ClassElement[]): ClassDeclaration;
-        (node: ClassDeclaration, decorators: readonly Decorator[] | undefined, modifiers: readonly Modifier[] | undefined, name: Identifier | undefined, typeParameters: readonly TypeParameterDeclaration[] | undefined, heritageClauses: readonly HeritageClause[] | undefined, members: readonly ClassElement[]): ClassDeclaration;
-    };
+    export const updateClassDeclaration: typeof factory.updateClassDeclaration;
     /** @deprecated Use `factory.createInterfaceDeclaration` or the factory supplied by your transformation context instead. */
-    const createInterfaceDeclaration: {
-        (modifiers: readonly Modifier[] | undefined, name: string | Identifier, typeParameters: readonly TypeParameterDeclaration[] | undefined, heritageClauses: readonly HeritageClause[] | undefined, members: readonly TypeElement[]): InterfaceDeclaration;
-        (decorators: readonly Decorator[] | undefined, modifiers: readonly Modifier[] | undefined, name: string | Identifier, typeParameters: readonly TypeParameterDeclaration[] | undefined, heritageClauses: readonly HeritageClause[] | undefined, members: readonly TypeElement[]): InterfaceDeclaration;
-    };
+    export const createInterfaceDeclaration: typeof factory.createInterfaceDeclaration;
     /** @deprecated Use `factory.updateInterfaceDeclaration` or the factory supplied by your transformation context instead. */
-    const updateInterfaceDeclaration: {
-        (node: InterfaceDeclaration, modifiers: readonly Modifier[] | undefined, name: Identifier, typeParameters: readonly TypeParameterDeclaration[] | undefined, heritageClauses: readonly HeritageClause[] | undefined, members: readonly TypeElement[]): InterfaceDeclaration;
-        (node: InterfaceDeclaration, decorators: readonly Decorator[] | undefined, modifiers: readonly Modifier[] | undefined, name: Identifier, typeParameters: readonly TypeParameterDeclaration[] | undefined, heritageClauses: readonly HeritageClause[] | undefined, members: readonly TypeElement[]): InterfaceDeclaration;
-    };
+    export const updateInterfaceDeclaration: typeof factory.updateInterfaceDeclaration;
     /** @deprecated Use `factory.createTypeAliasDeclaration` or the factory supplied by your transformation context instead. */
-    const createTypeAliasDeclaration: {
-        (modifiers: readonly Modifier[] | undefined, name: string | Identifier, typeParameters: readonly TypeParameterDeclaration[] | undefined, type: TypeNode): TypeAliasDeclaration;
-        (decorators: readonly Decorator[] | undefined, modifiers: readonly Modifier[] | undefined, name: string | Identifier, typeParameters: readonly TypeParameterDeclaration[] | undefined, type: TypeNode): TypeAliasDeclaration;
-    };
+    export const createTypeAliasDeclaration: typeof factory.createTypeAliasDeclaration;
     /** @deprecated Use `factory.updateTypeAliasDeclaration` or the factory supplied by your transformation context instead. */
-    const updateTypeAliasDeclaration: {
-        (node: TypeAliasDeclaration, modifiers: readonly Modifier[] | undefined, name: Identifier, typeParameters: readonly TypeParameterDeclaration[] | undefined, type: TypeNode): TypeAliasDeclaration;
-        (node: TypeAliasDeclaration, decorators: readonly Decorator[] | undefined, modifiers: readonly Modifier[] | undefined, name: Identifier, typeParameters: readonly TypeParameterDeclaration[] | undefined, type: TypeNode): TypeAliasDeclaration;
-    };
+    export const updateTypeAliasDeclaration: typeof factory.updateTypeAliasDeclaration;
     /** @deprecated Use `factory.createEnumDeclaration` or the factory supplied by your transformation context instead. */
-    const createEnumDeclaration: {
-        (modifiers: readonly Modifier[] | undefined, name: string | Identifier, members: readonly EnumMember[]): EnumDeclaration;
-        (decorators: readonly Decorator[] | undefined, modifiers: readonly Modifier[] | undefined, name: string | Identifier, members: readonly EnumMember[]): EnumDeclaration;
-    };
+    export const createEnumDeclaration: typeof factory.createEnumDeclaration;
     /** @deprecated Use `factory.updateEnumDeclaration` or the factory supplied by your transformation context instead. */
-    const updateEnumDeclaration: {
-        (node: EnumDeclaration, modifiers: readonly Modifier[] | undefined, name: Identifier, members: readonly EnumMember[]): EnumDeclaration;
-        (node: EnumDeclaration, decorators: readonly Decorator[] | undefined, modifiers: readonly Modifier[] | undefined, name: Identifier, members: readonly EnumMember[]): EnumDeclaration;
-    };
+    export const updateEnumDeclaration: typeof factory.updateEnumDeclaration;
     /** @deprecated Use `factory.createModuleDeclaration` or the factory supplied by your transformation context instead. */
-    const createModuleDeclaration: {
-        (modifiers: readonly Modifier[] | undefined, name: ModuleName, body: ModuleBody | undefined, flags?: NodeFlags | undefined): ModuleDeclaration;
-        (decorators: readonly Decorator[] | undefined, modifiers: readonly Modifier[] | undefined, name: ModuleName, body: ModuleBody | undefined, flags?: NodeFlags | undefined): ModuleDeclaration;
-    };
+    export const createModuleDeclaration: typeof factory.createModuleDeclaration;
     /** @deprecated Use `factory.updateModuleDeclaration` or the factory supplied by your transformation context instead. */
-    const updateModuleDeclaration: {
-        (node: ModuleDeclaration, modifiers: readonly Modifier[] | undefined, name: ModuleName, body: ModuleBody | undefined): ModuleDeclaration;
-        (node: ModuleDeclaration, decorators: readonly Decorator[] | undefined, modifiers: readonly Modifier[] | undefined, name: ModuleName, body: ModuleBody | undefined): ModuleDeclaration;
-    };
+    export const updateModuleDeclaration: typeof factory.updateModuleDeclaration;
     /** @deprecated Use `factory.createModuleBlock` or the factory supplied by your transformation context instead. */
-    const createModuleBlock: (statements: readonly Statement[]) => ModuleBlock;
+    export const createModuleBlock: typeof factory.createModuleBlock;
     /** @deprecated Use `factory.updateModuleBlock` or the factory supplied by your transformation context instead. */
-    const updateModuleBlock: (node: ModuleBlock, statements: readonly Statement[]) => ModuleBlock;
+    export const updateModuleBlock: typeof factory.updateModuleBlock;
     /** @deprecated Use `factory.createCaseBlock` or the factory supplied by your transformation context instead. */
-    const createCaseBlock: (clauses: readonly CaseOrDefaultClause[]) => CaseBlock;
+    export const createCaseBlock: typeof factory.createCaseBlock;
     /** @deprecated Use `factory.updateCaseBlock` or the factory supplied by your transformation context instead. */
-    const updateCaseBlock: (node: CaseBlock, clauses: readonly CaseOrDefaultClause[]) => CaseBlock;
+    export const updateCaseBlock: typeof factory.updateCaseBlock;
     /** @deprecated Use `factory.createNamespaceExportDeclaration` or the factory supplied by your transformation context instead. */
-    const createNamespaceExportDeclaration: (name: string | Identifier) => NamespaceExportDeclaration;
+    export const createNamespaceExportDeclaration: typeof factory.createNamespaceExportDeclaration;
     /** @deprecated Use `factory.updateNamespaceExportDeclaration` or the factory supplied by your transformation context instead. */
-    const updateNamespaceExportDeclaration: (node: NamespaceExportDeclaration, name: Identifier) => NamespaceExportDeclaration;
+    export const updateNamespaceExportDeclaration: typeof factory.updateNamespaceExportDeclaration;
     /** @deprecated Use `factory.createImportEqualsDeclaration` or the factory supplied by your transformation context instead. */
-    const createImportEqualsDeclaration: {
-        (modifiers: readonly Modifier[] | undefined, isTypeOnly: boolean, name: string | Identifier, moduleReference: ModuleReference): ImportEqualsDeclaration;
-        (decorators: readonly Decorator[] | undefined, modifiers: readonly Modifier[] | undefined, isTypeOnly: boolean, name: string | Identifier, moduleReference: ModuleReference): ImportEqualsDeclaration;
-    };
+    export const createImportEqualsDeclaration: typeof factory.createImportEqualsDeclaration;
     /** @deprecated Use `factory.updateImportEqualsDeclaration` or the factory supplied by your transformation context instead. */
-    const updateImportEqualsDeclaration: {
-        (node: ImportEqualsDeclaration, modifiers: readonly Modifier[] | undefined, isTypeOnly: boolean, name: Identifier, moduleReference: ModuleReference): ImportEqualsDeclaration;
-        (node: ImportEqualsDeclaration, decorators: readonly Decorator[] | undefined, modifiers: readonly Modifier[] | undefined, isTypeOnly: boolean, name: Identifier, moduleReference: ModuleReference): ImportEqualsDeclaration;
-    };
+    export const updateImportEqualsDeclaration: typeof factory.updateImportEqualsDeclaration;
     /** @deprecated Use `factory.createImportDeclaration` or the factory supplied by your transformation context instead. */
-    const createImportDeclaration: {
-        (modifiers: readonly Modifier[] | undefined, importClause: ImportClause | undefined, moduleSpecifier: Expression, assertClause?: AssertClause | undefined): ImportDeclaration;
-        (decorators: readonly Decorator[] | undefined, modifiers: readonly Modifier[] | undefined, importClause: ImportClause | undefined, moduleSpecifier: Expression, assertClause?: AssertClause | undefined): ImportDeclaration;
-    };
+    export const createImportDeclaration: typeof factory.createImportDeclaration;
     /** @deprecated Use `factory.updateImportDeclaration` or the factory supplied by your transformation context instead. */
-    const updateImportDeclaration: {
-        (node: ImportDeclaration, modifiers: readonly Modifier[] | undefined, importClause: ImportClause | undefined, moduleSpecifier: Expression, assertClause: AssertClause | undefined): ImportDeclaration;
-        (node: ImportDeclaration, decorators: readonly Decorator[] | undefined, modifiers: readonly Modifier[] | undefined, importClause: ImportClause | undefined, moduleSpecifier: Expression, assertClause: AssertClause | undefined): ImportDeclaration;
-    };
+    export const updateImportDeclaration: typeof factory.updateImportDeclaration;
     /** @deprecated Use `factory.createNamespaceImport` or the factory supplied by your transformation context instead. */
-    const createNamespaceImport: (name: Identifier) => NamespaceImport;
+    export const createNamespaceImport: typeof factory.createNamespaceImport;
     /** @deprecated Use `factory.updateNamespaceImport` or the factory supplied by your transformation context instead. */
-    const updateNamespaceImport: (node: NamespaceImport, name: Identifier) => NamespaceImport;
+    export const updateNamespaceImport: typeof factory.updateNamespaceImport;
     /** @deprecated Use `factory.createNamedImports` or the factory supplied by your transformation context instead. */
-    const createNamedImports: (elements: readonly ImportSpecifier[]) => NamedImports;
+    export const createNamedImports: typeof factory.createNamedImports;
     /** @deprecated Use `factory.updateNamedImports` or the factory supplied by your transformation context instead. */
-    const updateNamedImports: (node: NamedImports, elements: readonly ImportSpecifier[]) => NamedImports;
+    export const updateNamedImports: typeof factory.updateNamedImports;
     /** @deprecated Use `factory.createImportSpecifier` or the factory supplied by your transformation context instead. */
-    const createImportSpecifier: (isTypeOnly: boolean, propertyName: Identifier | undefined, name: Identifier) => ImportSpecifier;
+    export const createImportSpecifier: typeof factory.createImportSpecifier;
     /** @deprecated Use `factory.updateImportSpecifier` or the factory supplied by your transformation context instead. */
-    const updateImportSpecifier: (node: ImportSpecifier, isTypeOnly: boolean, propertyName: Identifier | undefined, name: Identifier) => ImportSpecifier;
+    export const updateImportSpecifier: typeof factory.updateImportSpecifier;
     /** @deprecated Use `factory.createExportAssignment` or the factory supplied by your transformation context instead. */
-    const createExportAssignment: {
-        (modifiers: readonly Modifier[] | undefined, isExportEquals: boolean | undefined, expression: Expression): ExportAssignment;
-        (decorators: readonly Decorator[] | undefined, modifiers: readonly Modifier[] | undefined, isExportEquals: boolean | undefined, expression: Expression): ExportAssignment;
-    };
+    export const createExportAssignment: typeof factory.createExportAssignment;
     /** @deprecated Use `factory.updateExportAssignment` or the factory supplied by your transformation context instead. */
-    const updateExportAssignment: {
-        (node: ExportAssignment, modifiers: readonly Modifier[] | undefined, expression: Expression): ExportAssignment;
-        (node: ExportAssignment, decorators: readonly Decorator[] | undefined, modifiers: readonly Modifier[] | undefined, expression: Expression): ExportAssignment;
-    };
+    export const updateExportAssignment: typeof factory.updateExportAssignment;
     /** @deprecated Use `factory.createNamedExports` or the factory supplied by your transformation context instead. */
-    const createNamedExports: (elements: readonly ExportSpecifier[]) => NamedExports;
+    export const createNamedExports: typeof factory.createNamedExports;
     /** @deprecated Use `factory.updateNamedExports` or the factory supplied by your transformation context instead. */
-    const updateNamedExports: (node: NamedExports, elements: readonly ExportSpecifier[]) => NamedExports;
+    export const updateNamedExports: typeof factory.updateNamedExports;
     /** @deprecated Use `factory.createExportSpecifier` or the factory supplied by your transformation context instead. */
-    const createExportSpecifier: (isTypeOnly: boolean, propertyName: string | Identifier | undefined, name: string | Identifier) => ExportSpecifier;
+    export const createExportSpecifier: typeof factory.createExportSpecifier;
     /** @deprecated Use `factory.updateExportSpecifier` or the factory supplied by your transformation context instead. */
-    const updateExportSpecifier: (node: ExportSpecifier, isTypeOnly: boolean, propertyName: Identifier | undefined, name: Identifier) => ExportSpecifier;
+    export const updateExportSpecifier: typeof factory.updateExportSpecifier;
     /** @deprecated Use `factory.createExternalModuleReference` or the factory supplied by your transformation context instead. */
-    const createExternalModuleReference: (expression: Expression) => ExternalModuleReference;
+    export const createExternalModuleReference: typeof factory.createExternalModuleReference;
     /** @deprecated Use `factory.updateExternalModuleReference` or the factory supplied by your transformation context instead. */
-    const updateExternalModuleReference: (node: ExternalModuleReference, expression: Expression) => ExternalModuleReference;
+    export const updateExternalModuleReference: typeof factory.updateExternalModuleReference;
     /** @deprecated Use `factory.createJSDocTypeExpression` or the factory supplied by your transformation context instead. */
-    const createJSDocTypeExpression: (type: TypeNode) => JSDocTypeExpression;
+    export const createJSDocTypeExpression: typeof factory.createJSDocTypeExpression;
     /** @deprecated Use `factory.createJSDocTypeTag` or the factory supplied by your transformation context instead. */
-    const createJSDocTypeTag: (tagName: Identifier | undefined, typeExpression: JSDocTypeExpression, comment?: string | NodeArray<JSDocComment> | undefined) => JSDocTypeTag;
+    export const createJSDocTypeTag: typeof factory.createJSDocTypeTag;
     /** @deprecated Use `factory.createJSDocReturnTag` or the factory supplied by your transformation context instead. */
-    const createJSDocReturnTag: (tagName: Identifier | undefined, typeExpression?: JSDocTypeExpression | undefined, comment?: string | NodeArray<JSDocComment> | undefined) => JSDocReturnTag;
+    export const createJSDocReturnTag: typeof factory.createJSDocReturnTag;
     /** @deprecated Use `factory.createJSDocThisTag` or the factory supplied by your transformation context instead. */
-    const createJSDocThisTag: (tagName: Identifier | undefined, typeExpression: JSDocTypeExpression, comment?: string | NodeArray<JSDocComment> | undefined) => JSDocThisTag;
+    export const createJSDocThisTag: typeof factory.createJSDocThisTag;
     /** @deprecated Use `factory.createJSDocComment` or the factory supplied by your transformation context instead. */
-    const createJSDocComment: (comment?: string | NodeArray<JSDocComment> | undefined, tags?: readonly JSDocTag[] | undefined) => JSDoc;
+    export const createJSDocComment: typeof factory.createJSDocComment;
     /** @deprecated Use `factory.createJSDocParameterTag` or the factory supplied by your transformation context instead. */
-    const createJSDocParameterTag: (tagName: Identifier | undefined, name: EntityName, isBracketed: boolean, typeExpression?: JSDocTypeExpression | undefined, isNameFirst?: boolean | undefined, comment?: string | NodeArray<JSDocComment> | undefined) => JSDocParameterTag;
+    export const createJSDocParameterTag: typeof factory.createJSDocParameterTag;
     /** @deprecated Use `factory.createJSDocClassTag` or the factory supplied by your transformation context instead. */
-    const createJSDocClassTag: (tagName: Identifier | undefined, comment?: string | NodeArray<JSDocComment> | undefined) => JSDocClassTag;
+    export const createJSDocClassTag: typeof factory.createJSDocClassTag;
     /** @deprecated Use `factory.createJSDocAugmentsTag` or the factory supplied by your transformation context instead. */
-    const createJSDocAugmentsTag: (tagName: Identifier | undefined, className: ExpressionWithTypeArguments & {
-        readonly expression: Identifier | PropertyAccessEntityNameExpression;
-    }, comment?: string | NodeArray<JSDocComment> | undefined) => JSDocAugmentsTag;
+    export const createJSDocAugmentsTag: typeof factory.createJSDocAugmentsTag;
     /** @deprecated Use `factory.createJSDocEnumTag` or the factory supplied by your transformation context instead. */
-    const createJSDocEnumTag: (tagName: Identifier | undefined, typeExpression: JSDocTypeExpression, comment?: string | NodeArray<JSDocComment> | undefined) => JSDocEnumTag;
+    export const createJSDocEnumTag: typeof factory.createJSDocEnumTag;
     /** @deprecated Use `factory.createJSDocTemplateTag` or the factory supplied by your transformation context instead. */
-    const createJSDocTemplateTag: (tagName: Identifier | undefined, constraint: JSDocTypeExpression | undefined, typeParameters: readonly TypeParameterDeclaration[], comment?: string | NodeArray<JSDocComment> | undefined) => JSDocTemplateTag;
+    export const createJSDocTemplateTag: typeof factory.createJSDocTemplateTag;
     /** @deprecated Use `factory.createJSDocTypedefTag` or the factory supplied by your transformation context instead. */
-    const createJSDocTypedefTag: (tagName: Identifier | undefined, typeExpression?: JSDocTypeLiteral | JSDocTypeExpression | undefined, fullName?: Identifier | JSDocNamespaceDeclaration | undefined, comment?: string | NodeArray<JSDocComment> | undefined) => JSDocTypedefTag;
+    export const createJSDocTypedefTag: typeof factory.createJSDocTypedefTag;
     /** @deprecated Use `factory.createJSDocCallbackTag` or the factory supplied by your transformation context instead. */
-    const createJSDocCallbackTag: (tagName: Identifier | undefined, typeExpression: JSDocSignature, fullName?: Identifier | JSDocNamespaceDeclaration | undefined, comment?: string | NodeArray<JSDocComment> | undefined) => JSDocCallbackTag;
+    export const createJSDocCallbackTag: typeof factory.createJSDocCallbackTag;
     /** @deprecated Use `factory.createJSDocSignature` or the factory supplied by your transformation context instead. */
-    const createJSDocSignature: (typeParameters: readonly JSDocTemplateTag[] | undefined, parameters: readonly JSDocParameterTag[], type?: JSDocReturnTag | undefined) => JSDocSignature;
+    export const createJSDocSignature: typeof factory.createJSDocSignature;
     /** @deprecated Use `factory.createJSDocPropertyTag` or the factory supplied by your transformation context instead. */
-    const createJSDocPropertyTag: (tagName: Identifier | undefined, name: EntityName, isBracketed: boolean, typeExpression?: JSDocTypeExpression | undefined, isNameFirst?: boolean | undefined, comment?: string | NodeArray<JSDocComment> | undefined) => JSDocPropertyTag;
+    export const createJSDocPropertyTag: typeof factory.createJSDocPropertyTag;
     /** @deprecated Use `factory.createJSDocTypeLiteral` or the factory supplied by your transformation context instead. */
-    const createJSDocTypeLiteral: (jsDocPropertyTags?: readonly JSDocPropertyLikeTag[] | undefined, isArrayType?: boolean | undefined) => JSDocTypeLiteral;
+    export const createJSDocTypeLiteral: typeof factory.createJSDocTypeLiteral;
     /** @deprecated Use `factory.createJSDocImplementsTag` or the factory supplied by your transformation context instead. */
-    const createJSDocImplementsTag: (tagName: Identifier | undefined, className: ExpressionWithTypeArguments & {
-        readonly expression: Identifier | PropertyAccessEntityNameExpression;
-    }, comment?: string | NodeArray<JSDocComment> | undefined) => JSDocImplementsTag;
+    export const createJSDocImplementsTag: typeof factory.createJSDocImplementsTag;
     /** @deprecated Use `factory.createJSDocAuthorTag` or the factory supplied by your transformation context instead. */
-    const createJSDocAuthorTag: (tagName: Identifier | undefined, comment?: string | NodeArray<JSDocComment> | undefined) => JSDocAuthorTag;
+    export const createJSDocAuthorTag: typeof factory.createJSDocAuthorTag;
     /** @deprecated Use `factory.createJSDocPublicTag` or the factory supplied by your transformation context instead. */
-    const createJSDocPublicTag: (tagName: Identifier | undefined, comment?: string | NodeArray<JSDocComment> | undefined) => JSDocPublicTag;
+    export const createJSDocPublicTag: typeof factory.createJSDocPublicTag;
     /** @deprecated Use `factory.createJSDocPrivateTag` or the factory supplied by your transformation context instead. */
-    const createJSDocPrivateTag: (tagName: Identifier | undefined, comment?: string | NodeArray<JSDocComment> | undefined) => JSDocPrivateTag;
+    export const createJSDocPrivateTag: typeof factory.createJSDocPrivateTag;
     /** @deprecated Use `factory.createJSDocProtectedTag` or the factory supplied by your transformation context instead. */
-    const createJSDocProtectedTag: (tagName: Identifier | undefined, comment?: string | NodeArray<JSDocComment> | undefined) => JSDocProtectedTag;
+    export const createJSDocProtectedTag: typeof factory.createJSDocProtectedTag;
     /** @deprecated Use `factory.createJSDocReadonlyTag` or the factory supplied by your transformation context instead. */
-    const createJSDocReadonlyTag: (tagName: Identifier | undefined, comment?: string | NodeArray<JSDocComment> | undefined) => JSDocReadonlyTag;
+    export const createJSDocReadonlyTag: typeof factory.createJSDocReadonlyTag;
     /** @deprecated Use `factory.createJSDocUnknownTag` or the factory supplied by your transformation context instead. */
-    const createJSDocTag: (tagName: Identifier, comment?: string | NodeArray<JSDocComment> | undefined) => JSDocUnknownTag;
+    export const createJSDocTag: typeof factory.createJSDocUnknownTag;
     /** @deprecated Use `factory.createJsxElement` or the factory supplied by your transformation context instead. */
-    const createJsxElement: (openingElement: JsxOpeningElement, children: readonly JsxChild[], closingElement: JsxClosingElement) => JsxElement;
+    export const createJsxElement: typeof factory.createJsxElement;
     /** @deprecated Use `factory.updateJsxElement` or the factory supplied by your transformation context instead. */
-    const updateJsxElement: (node: JsxElement, openingElement: JsxOpeningElement, children: readonly JsxChild[], closingElement: JsxClosingElement) => JsxElement;
+    export const updateJsxElement: typeof factory.updateJsxElement;
     /** @deprecated Use `factory.createJsxSelfClosingElement` or the factory supplied by your transformation context instead. */
-    const createJsxSelfClosingElement: (tagName: JsxTagNameExpression, typeArguments: readonly TypeNode[] | undefined, attributes: JsxAttributes) => JsxSelfClosingElement;
+    export const createJsxSelfClosingElement: typeof factory.createJsxSelfClosingElement;
     /** @deprecated Use `factory.updateJsxSelfClosingElement` or the factory supplied by your transformation context instead. */
-    const updateJsxSelfClosingElement: (node: JsxSelfClosingElement, tagName: JsxTagNameExpression, typeArguments: readonly TypeNode[] | undefined, attributes: JsxAttributes) => JsxSelfClosingElement;
+    export const updateJsxSelfClosingElement: typeof factory.updateJsxSelfClosingElement;
     /** @deprecated Use `factory.createJsxOpeningElement` or the factory supplied by your transformation context instead. */
-    const createJsxOpeningElement: (tagName: JsxTagNameExpression, typeArguments: readonly TypeNode[] | undefined, attributes: JsxAttributes) => JsxOpeningElement;
+    export const createJsxOpeningElement: typeof factory.createJsxOpeningElement;
     /** @deprecated Use `factory.updateJsxOpeningElement` or the factory supplied by your transformation context instead. */
-    const updateJsxOpeningElement: (node: JsxOpeningElement, tagName: JsxTagNameExpression, typeArguments: readonly TypeNode[] | undefined, attributes: JsxAttributes) => JsxOpeningElement;
+    export const updateJsxOpeningElement: typeof factory.updateJsxOpeningElement;
     /** @deprecated Use `factory.createJsxClosingElement` or the factory supplied by your transformation context instead. */
-    const createJsxClosingElement: (tagName: JsxTagNameExpression) => JsxClosingElement;
+    export const createJsxClosingElement: typeof factory.createJsxClosingElement;
     /** @deprecated Use `factory.updateJsxClosingElement` or the factory supplied by your transformation context instead. */
-    const updateJsxClosingElement: (node: JsxClosingElement, tagName: JsxTagNameExpression) => JsxClosingElement;
+    export const updateJsxClosingElement: typeof factory.updateJsxClosingElement;
     /** @deprecated Use `factory.createJsxFragment` or the factory supplied by your transformation context instead. */
-    const createJsxFragment: (openingFragment: JsxOpeningFragment, children: readonly JsxChild[], closingFragment: JsxClosingFragment) => JsxFragment;
+    export const createJsxFragment: typeof factory.createJsxFragment;
     /** @deprecated Use `factory.createJsxText` or the factory supplied by your transformation context instead. */
-    const createJsxText: (text: string, containsOnlyTriviaWhiteSpaces?: boolean | undefined) => JsxText;
+    export const createJsxText: typeof factory.createJsxText;
     /** @deprecated Use `factory.updateJsxText` or the factory supplied by your transformation context instead. */
-    const updateJsxText: (node: JsxText, text: string, containsOnlyTriviaWhiteSpaces?: boolean | undefined) => JsxText;
+    export const updateJsxText: typeof factory.updateJsxText;
     /** @deprecated Use `factory.createJsxOpeningFragment` or the factory supplied by your transformation context instead. */
-    const createJsxOpeningFragment: () => JsxOpeningFragment;
+    export const createJsxOpeningFragment: typeof factory.createJsxOpeningFragment;
     /** @deprecated Use `factory.createJsxJsxClosingFragment` or the factory supplied by your transformation context instead. */
-    const createJsxJsxClosingFragment: () => JsxClosingFragment;
+    export const createJsxJsxClosingFragment: typeof factory.createJsxJsxClosingFragment;
     /** @deprecated Use `factory.updateJsxFragment` or the factory supplied by your transformation context instead. */
-    const updateJsxFragment: (node: JsxFragment, openingFragment: JsxOpeningFragment, children: readonly JsxChild[], closingFragment: JsxClosingFragment) => JsxFragment;
+    export const updateJsxFragment: typeof factory.updateJsxFragment;
     /** @deprecated Use `factory.createJsxAttribute` or the factory supplied by your transformation context instead. */
-    const createJsxAttribute: (name: Identifier, initializer: JsxAttributeValue | undefined) => JsxAttribute;
+    export const createJsxAttribute: typeof factory.createJsxAttribute;
     /** @deprecated Use `factory.updateJsxAttribute` or the factory supplied by your transformation context instead. */
-    const updateJsxAttribute: (node: JsxAttribute, name: Identifier, initializer: JsxAttributeValue | undefined) => JsxAttribute;
+    export const updateJsxAttribute: typeof factory.updateJsxAttribute;
     /** @deprecated Use `factory.createJsxAttributes` or the factory supplied by your transformation context instead. */
-    const createJsxAttributes: (properties: readonly JsxAttributeLike[]) => JsxAttributes;
+    export const createJsxAttributes: typeof factory.createJsxAttributes;
     /** @deprecated Use `factory.updateJsxAttributes` or the factory supplied by your transformation context instead. */
-    const updateJsxAttributes: (node: JsxAttributes, properties: readonly JsxAttributeLike[]) => JsxAttributes;
+    export const updateJsxAttributes: typeof factory.updateJsxAttributes;
     /** @deprecated Use `factory.createJsxSpreadAttribute` or the factory supplied by your transformation context instead. */
-    const createJsxSpreadAttribute: (expression: Expression) => JsxSpreadAttribute;
+    export const createJsxSpreadAttribute: typeof factory.createJsxSpreadAttribute;
     /** @deprecated Use `factory.updateJsxSpreadAttribute` or the factory supplied by your transformation context instead. */
-    const updateJsxSpreadAttribute: (node: JsxSpreadAttribute, expression: Expression) => JsxSpreadAttribute;
+    export const updateJsxSpreadAttribute: typeof factory.updateJsxSpreadAttribute;
     /** @deprecated Use `factory.createJsxExpression` or the factory supplied by your transformation context instead. */
-    const createJsxExpression: (dotDotDotToken: DotDotDotToken | undefined, expression: Expression | undefined) => JsxExpression;
+    export const createJsxExpression: typeof factory.createJsxExpression;
     /** @deprecated Use `factory.updateJsxExpression` or the factory supplied by your transformation context instead. */
-    const updateJsxExpression: (node: JsxExpression, expression: Expression | undefined) => JsxExpression;
+    export const updateJsxExpression: typeof factory.updateJsxExpression;
     /** @deprecated Use `factory.createCaseClause` or the factory supplied by your transformation context instead. */
-    const createCaseClause: (expression: Expression, statements: readonly Statement[]) => CaseClause;
+    export const createCaseClause: typeof factory.createCaseClause;
     /** @deprecated Use `factory.updateCaseClause` or the factory supplied by your transformation context instead. */
-    const updateCaseClause: (node: CaseClause, expression: Expression, statements: readonly Statement[]) => CaseClause;
+    export const updateCaseClause: typeof factory.updateCaseClause;
     /** @deprecated Use `factory.createDefaultClause` or the factory supplied by your transformation context instead. */
-    const createDefaultClause: (statements: readonly Statement[]) => DefaultClause;
+    export const createDefaultClause: typeof factory.createDefaultClause;
     /** @deprecated Use `factory.updateDefaultClause` or the factory supplied by your transformation context instead. */
-    const updateDefaultClause: (node: DefaultClause, statements: readonly Statement[]) => DefaultClause;
+    export const updateDefaultClause: typeof factory.updateDefaultClause;
     /** @deprecated Use `factory.createHeritageClause` or the factory supplied by your transformation context instead. */
-    const createHeritageClause: (token: SyntaxKind.ExtendsKeyword | SyntaxKind.ImplementsKeyword, types: readonly ExpressionWithTypeArguments[]) => HeritageClause;
+    export const createHeritageClause: typeof factory.createHeritageClause;
     /** @deprecated Use `factory.updateHeritageClause` or the factory supplied by your transformation context instead. */
-    const updateHeritageClause: (node: HeritageClause, types: readonly ExpressionWithTypeArguments[]) => HeritageClause;
+    export const updateHeritageClause: typeof factory.updateHeritageClause;
     /** @deprecated Use `factory.createCatchClause` or the factory supplied by your transformation context instead. */
-    const createCatchClause: (variableDeclaration: string | VariableDeclaration | BindingName | undefined, block: Block) => CatchClause;
+    export const createCatchClause: typeof factory.createCatchClause;
     /** @deprecated Use `factory.updateCatchClause` or the factory supplied by your transformation context instead. */
-    const updateCatchClause: (node: CatchClause, variableDeclaration: VariableDeclaration | undefined, block: Block) => CatchClause;
+    export const updateCatchClause: typeof factory.updateCatchClause;
     /** @deprecated Use `factory.createPropertyAssignment` or the factory supplied by your transformation context instead. */
-    const createPropertyAssignment: (name: string | PropertyName, initializer: Expression) => PropertyAssignment;
+    export const createPropertyAssignment: typeof factory.createPropertyAssignment;
     /** @deprecated Use `factory.updatePropertyAssignment` or the factory supplied by your transformation context instead. */
-    const updatePropertyAssignment: (node: PropertyAssignment, name: PropertyName, initializer: Expression) => PropertyAssignment;
+    export const updatePropertyAssignment: typeof factory.updatePropertyAssignment;
     /** @deprecated Use `factory.createShorthandPropertyAssignment` or the factory supplied by your transformation context instead. */
-    const createShorthandPropertyAssignment: (name: string | Identifier, objectAssignmentInitializer?: Expression | undefined) => ShorthandPropertyAssignment;
+    export const createShorthandPropertyAssignment: typeof factory.createShorthandPropertyAssignment;
     /** @deprecated Use `factory.updateShorthandPropertyAssignment` or the factory supplied by your transformation context instead. */
-    const updateShorthandPropertyAssignment: (node: ShorthandPropertyAssignment, name: Identifier, objectAssignmentInitializer: Expression | undefined) => ShorthandPropertyAssignment;
+    export const updateShorthandPropertyAssignment: typeof factory.updateShorthandPropertyAssignment;
     /** @deprecated Use `factory.createSpreadAssignment` or the factory supplied by your transformation context instead. */
-    const createSpreadAssignment: (expression: Expression) => SpreadAssignment;
+    export const createSpreadAssignment: typeof factory.createSpreadAssignment;
     /** @deprecated Use `factory.updateSpreadAssignment` or the factory supplied by your transformation context instead. */
-    const updateSpreadAssignment: (node: SpreadAssignment, expression: Expression) => SpreadAssignment;
+    export const updateSpreadAssignment: typeof factory.updateSpreadAssignment;
     /** @deprecated Use `factory.createEnumMember` or the factory supplied by your transformation context instead. */
-    const createEnumMember: (name: string | PropertyName, initializer?: Expression | undefined) => EnumMember;
+    export const createEnumMember: typeof factory.createEnumMember;
     /** @deprecated Use `factory.updateEnumMember` or the factory supplied by your transformation context instead. */
-    const updateEnumMember: (node: EnumMember, name: PropertyName, initializer: Expression | undefined) => EnumMember;
+    export const updateEnumMember: typeof factory.updateEnumMember;
     /** @deprecated Use `factory.updateSourceFile` or the factory supplied by your transformation context instead. */
-    const updateSourceFileNode: (node: SourceFile, statements: readonly Statement[], isDeclarationFile?: boolean | undefined, referencedFiles?: readonly FileReference[] | undefined, typeReferences?: readonly FileReference[] | undefined, hasNoDefaultLib?: boolean | undefined, libReferences?: readonly FileReference[] | undefined) => SourceFile;
+    export const updateSourceFileNode: typeof factory.updateSourceFile;
     /** @deprecated Use `factory.createNotEmittedStatement` or the factory supplied by your transformation context instead. */
-    const createNotEmittedStatement: (original: Node) => NotEmittedStatement;
+    export const createNotEmittedStatement: typeof factory.createNotEmittedStatement;
     /** @deprecated Use `factory.createPartiallyEmittedExpression` or the factory supplied by your transformation context instead. */
-    const createPartiallyEmittedExpression: (expression: Expression, original?: Node | undefined) => PartiallyEmittedExpression;
+    export const createPartiallyEmittedExpression: typeof factory.createPartiallyEmittedExpression;
     /** @deprecated Use `factory.updatePartiallyEmittedExpression` or the factory supplied by your transformation context instead. */
-    const updatePartiallyEmittedExpression: (node: PartiallyEmittedExpression, expression: Expression) => PartiallyEmittedExpression;
+    export const updatePartiallyEmittedExpression: typeof factory.updatePartiallyEmittedExpression;
     /** @deprecated Use `factory.createCommaListExpression` or the factory supplied by your transformation context instead. */
-    const createCommaList: (elements: readonly Expression[]) => CommaListExpression;
+    export const createCommaList: typeof factory.createCommaListExpression;
     /** @deprecated Use `factory.updateCommaListExpression` or the factory supplied by your transformation context instead. */
-    const updateCommaList: (node: CommaListExpression, elements: readonly Expression[]) => CommaListExpression;
+    export const updateCommaList: typeof factory.updateCommaListExpression;
     /** @deprecated Use `factory.createBundle` or the factory supplied by your transformation context instead. */
-    const createBundle: (sourceFiles: readonly SourceFile[], prepends?: readonly (UnparsedSource | InputFiles)[] | undefined) => Bundle;
+    export const createBundle: typeof factory.createBundle;
     /** @deprecated Use `factory.updateBundle` or the factory supplied by your transformation context instead. */
-    const updateBundle: (node: Bundle, sourceFiles: readonly SourceFile[], prepends?: readonly (UnparsedSource | InputFiles)[] | undefined) => Bundle;
+    export const updateBundle: typeof factory.updateBundle;
     /** @deprecated Use `factory.createImmediatelyInvokedFunctionExpression` or the factory supplied by your transformation context instead. */
-    const createImmediatelyInvokedFunctionExpression: {
-        (statements: readonly Statement[]): CallExpression;
-        (statements: readonly Statement[], param: ParameterDeclaration, paramValue: Expression): CallExpression;
-    };
+    export const createImmediatelyInvokedFunctionExpression: typeof factory.createImmediatelyInvokedFunctionExpression;
     /** @deprecated Use `factory.createImmediatelyInvokedArrowFunction` or the factory supplied by your transformation context instead. */
-    const createImmediatelyInvokedArrowFunction: {
-        (statements: readonly Statement[]): CallExpression;
-        (statements: readonly Statement[], param: ParameterDeclaration, paramValue: Expression): CallExpression;
-    };
+    export const createImmediatelyInvokedArrowFunction: typeof factory.createImmediatelyInvokedArrowFunction;
     /** @deprecated Use `factory.createVoidZero` or the factory supplied by your transformation context instead. */
-    const createVoidZero: () => VoidExpression;
+    export const createVoidZero: typeof factory.createVoidZero;
     /** @deprecated Use `factory.createExportDefault` or the factory supplied by your transformation context instead. */
-    const createExportDefault: (expression: Expression) => ExportAssignment;
+    export const createExportDefault: typeof factory.createExportDefault;
     /** @deprecated Use `factory.createExternalModuleExport` or the factory supplied by your transformation context instead. */
-    const createExternalModuleExport: (exportName: Identifier) => ExportDeclaration;
+    export const createExternalModuleExport: typeof factory.createExternalModuleExport;
     /** @deprecated Use `factory.createNamespaceExport` or the factory supplied by your transformation context instead. */
-    const createNamespaceExport: (name: Identifier) => NamespaceExport;
+    export const createNamespaceExport: typeof factory.createNamespaceExport;
     /** @deprecated Use `factory.updateNamespaceExport` or the factory supplied by your transformation context instead. */
-    const updateNamespaceExport: (node: NamespaceExport, name: Identifier) => NamespaceExport;
+    export const updateNamespaceExport: typeof factory.updateNamespaceExport;
     /** @deprecated Use `factory.createToken` or the factory supplied by your transformation context instead. */
-    const createToken: <TKind extends SyntaxKind>(kind: TKind) => Token<TKind>;
+    export const createToken: <TKind extends SyntaxKind>(kind: TKind) => Token<TKind>;
     /** @deprecated Use `factory.createIdentifier` or the factory supplied by your transformation context instead. */
-    const createIdentifier: (text: string) => Identifier;
+    export const createIdentifier: (text: string) => Identifier;
     /** @deprecated Use `factory.createTempVariable` or the factory supplied by your transformation context instead. */
-    const createTempVariable: (recordTempVariable: ((node: Identifier) => void) | undefined) => Identifier;
+    export const createTempVariable: (recordTempVariable: ((node: Identifier) => void) | undefined) => Identifier;
     /** @deprecated Use `factory.getGeneratedNameForNode` or the factory supplied by your transformation context instead. */
-    const getGeneratedNameForNode: (node: Node | undefined) => Identifier;
+    export const getGeneratedNameForNode: (node: Node | undefined) => Identifier;
     /** @deprecated Use `factory.createUniqueName(text, GeneratedIdentifierFlags.Optimistic)` or the factory supplied by your transformation context instead. */
-    const createOptimisticUniqueName: (text: string) => Identifier;
+    export const createOptimisticUniqueName: (text: string) => Identifier;
     /** @deprecated Use `factory.createUniqueName(text, GeneratedIdentifierFlags.Optimistic | GeneratedIdentifierFlags.FileLevel)` or the factory supplied by your transformation context instead. */
-    const createFileLevelUniqueName: (text: string) => Identifier;
+    export const createFileLevelUniqueName: (text: string) => Identifier;
     /** @deprecated Use `factory.createIndexSignature` or the factory supplied by your transformation context instead. */
-    const createIndexSignature: (decorators: readonly Decorator[] | undefined, modifiers: readonly Modifier[] | undefined, parameters: readonly ParameterDeclaration[], type: TypeNode) => IndexSignatureDeclaration;
+    export const createIndexSignature: (decorators: readonly Decorator[] | undefined, modifiers: readonly Modifier[] | undefined, parameters: readonly ParameterDeclaration[], type: TypeNode) => IndexSignatureDeclaration;
     /** @deprecated Use `factory.createTypePredicateNode` or the factory supplied by your transformation context instead. */
-    const createTypePredicateNode: (parameterName: Identifier | ThisTypeNode | string, type: TypeNode) => TypePredicateNode;
+    export const createTypePredicateNode: (parameterName: Identifier | ThisTypeNode | string, type: TypeNode) => TypePredicateNode;
     /** @deprecated Use `factory.updateTypePredicateNode` or the factory supplied by your transformation context instead. */
-    const updateTypePredicateNode: (node: TypePredicateNode, parameterName: Identifier | ThisTypeNode, type: TypeNode) => TypePredicateNode;
+    export const updateTypePredicateNode: (node: TypePredicateNode, parameterName: Identifier | ThisTypeNode, type: TypeNode) => TypePredicateNode;
     /** @deprecated Use `factory.createStringLiteral`, `factory.createStringLiteralFromNode`, `factory.createNumericLiteral`, `factory.createBigIntLiteral`, `factory.createTrue`, `factory.createFalse`, or the factory supplied by your transformation context instead. */
-    const createLiteral: {
+    export const createLiteral: {
         (value: string | StringLiteral | NoSubstitutionTemplateLiteral | NumericLiteral | Identifier): StringLiteral;
         (value: number | PseudoBigInt): NumericLiteral;
         (value: boolean): BooleanLiteral;
         (value: string | number | PseudoBigInt | boolean): PrimaryExpression;
     };
     /** @deprecated Use `factory.createMethodSignature` or the factory supplied by your transformation context instead. */
-    const createMethodSignature: (typeParameters: readonly TypeParameterDeclaration[] | undefined, parameters: readonly ParameterDeclaration[], type: TypeNode | undefined, name: string | PropertyName, questionToken: QuestionToken | undefined) => MethodSignature;
+    export const createMethodSignature: (typeParameters: readonly TypeParameterDeclaration[] | undefined, parameters: readonly ParameterDeclaration[], type: TypeNode | undefined, name: string | PropertyName, questionToken: QuestionToken | undefined) => MethodSignature;
     /** @deprecated Use `factory.updateMethodSignature` or the factory supplied by your transformation context instead. */
-    const updateMethodSignature: (node: MethodSignature, typeParameters: NodeArray<TypeParameterDeclaration> | undefined, parameters: NodeArray<ParameterDeclaration>, type: TypeNode | undefined, name: PropertyName, questionToken: QuestionToken | undefined) => MethodSignature;
+    export const updateMethodSignature: (node: MethodSignature, typeParameters: NodeArray<TypeParameterDeclaration> | undefined, parameters: NodeArray<ParameterDeclaration>, type: TypeNode | undefined, name: PropertyName, questionToken: QuestionToken | undefined) => MethodSignature;
     /** @deprecated Use `factory.createTypeOperatorNode` or the factory supplied by your transformation context instead. */
-    const createTypeOperatorNode: {
+    export const createTypeOperatorNode: {
         (type: TypeNode): TypeOperatorNode;
         (operator: SyntaxKind.KeyOfKeyword | SyntaxKind.UniqueKeyword | SyntaxKind.ReadonlyKeyword, type: TypeNode): TypeOperatorNode;
     };
     /** @deprecated Use `factory.createTaggedTemplate` or the factory supplied by your transformation context instead. */
-    const createTaggedTemplate: {
+    export const createTaggedTemplate: {
         (tag: Expression, template: TemplateLiteral): TaggedTemplateExpression;
         (tag: Expression, typeArguments: readonly TypeNode[] | undefined, template: TemplateLiteral): TaggedTemplateExpression;
     };
     /** @deprecated Use `factory.updateTaggedTemplate` or the factory supplied by your transformation context instead. */
-    const updateTaggedTemplate: {
+    export const updateTaggedTemplate: {
         (node: TaggedTemplateExpression, tag: Expression, template: TemplateLiteral): TaggedTemplateExpression;
         (node: TaggedTemplateExpression, tag: Expression, typeArguments: readonly TypeNode[] | undefined, template: TemplateLiteral): TaggedTemplateExpression;
     };
     /** @deprecated Use `factory.updateBinary` or the factory supplied by your transformation context instead. */
-    const updateBinary: (node: BinaryExpression, left: Expression, right: Expression, operator?: BinaryOperator | BinaryOperatorToken) => BinaryExpression;
+    export const updateBinary: (node: BinaryExpression, left: Expression, right: Expression, operator?: BinaryOperator | BinaryOperatorToken) => BinaryExpression;
     /** @deprecated Use `factory.createConditional` or the factory supplied by your transformation context instead. */
-    const createConditional: {
+    export const createConditional: {
         (condition: Expression, whenTrue: Expression, whenFalse: Expression): ConditionalExpression;
         (condition: Expression, questionToken: QuestionToken, whenTrue: Expression, colonToken: ColonToken, whenFalse: Expression): ConditionalExpression;
     };
     /** @deprecated Use `factory.createYield` or the factory supplied by your transformation context instead. */
-    const createYield: {
+    export const createYield: {
         (expression?: Expression | undefined): YieldExpression;
         (asteriskToken: AsteriskToken | undefined, expression: Expression): YieldExpression;
     };
     /** @deprecated Use `factory.createClassExpression` or the factory supplied by your transformation context instead. */
-    const createClassExpression: (modifiers: readonly Modifier[] | undefined, name: string | Identifier | undefined, typeParameters: readonly TypeParameterDeclaration[] | undefined, heritageClauses: readonly HeritageClause[] | undefined, members: readonly ClassElement[]) => ClassExpression;
+    export const createClassExpression: (modifiers: readonly Modifier[] | undefined, name: string | Identifier | undefined, typeParameters: readonly TypeParameterDeclaration[] | undefined, heritageClauses: readonly HeritageClause[] | undefined, members: readonly ClassElement[]) => ClassExpression;
     /** @deprecated Use `factory.updateClassExpression` or the factory supplied by your transformation context instead. */
-    const updateClassExpression: (node: ClassExpression, modifiers: readonly Modifier[] | undefined, name: Identifier | undefined, typeParameters: readonly TypeParameterDeclaration[] | undefined, heritageClauses: readonly HeritageClause[] | undefined, members: readonly ClassElement[]) => ClassExpression;
+    export const updateClassExpression: (node: ClassExpression, modifiers: readonly Modifier[] | undefined, name: Identifier | undefined, typeParameters: readonly TypeParameterDeclaration[] | undefined, heritageClauses: readonly HeritageClause[] | undefined, members: readonly ClassElement[]) => ClassExpression;
     /** @deprecated Use `factory.createPropertySignature` or the factory supplied by your transformation context instead. */
-    const createPropertySignature: (modifiers: readonly Modifier[] | undefined, name: PropertyName | string, questionToken: QuestionToken | undefined, type: TypeNode | undefined, initializer?: Expression | undefined) => PropertySignature;
+    export const createPropertySignature: (modifiers: readonly Modifier[] | undefined, name: PropertyName | string, questionToken: QuestionToken | undefined, type: TypeNode | undefined, initializer?: Expression | undefined) => PropertySignature;
     /** @deprecated Use `factory.updatePropertySignature` or the factory supplied by your transformation context instead. */
-    const updatePropertySignature: (node: PropertySignature, modifiers: readonly Modifier[] | undefined, name: PropertyName, questionToken: QuestionToken | undefined, type: TypeNode | undefined, initializer: Expression | undefined) => PropertySignature;
+    export const updatePropertySignature: (node: PropertySignature, modifiers: readonly Modifier[] | undefined, name: PropertyName, questionToken: QuestionToken | undefined, type: TypeNode | undefined, initializer: Expression | undefined) => PropertySignature;
     /** @deprecated Use `factory.createExpressionWithTypeArguments` or the factory supplied by your transformation context instead. */
-    const createExpressionWithTypeArguments: (typeArguments: readonly TypeNode[] | undefined, expression: Expression) => ExpressionWithTypeArguments;
+    export const createExpressionWithTypeArguments: (typeArguments: readonly TypeNode[] | undefined, expression: Expression) => ExpressionWithTypeArguments;
     /** @deprecated Use `factory.updateExpressionWithTypeArguments` or the factory supplied by your transformation context instead. */
-    const updateExpressionWithTypeArguments: (node: ExpressionWithTypeArguments, typeArguments: readonly TypeNode[] | undefined, expression: Expression) => ExpressionWithTypeArguments;
+    export const updateExpressionWithTypeArguments: (node: ExpressionWithTypeArguments, typeArguments: readonly TypeNode[] | undefined, expression: Expression) => ExpressionWithTypeArguments;
     /** @deprecated Use `factory.createArrowFunction` or the factory supplied by your transformation context instead. */
-    const createArrowFunction: {
+    export const createArrowFunction: {
         (modifiers: readonly Modifier[] | undefined, typeParameters: readonly TypeParameterDeclaration[] | undefined, parameters: readonly ParameterDeclaration[], type: TypeNode | undefined, equalsGreaterThanToken: EqualsGreaterThanToken | undefined, body: ConciseBody): ArrowFunction;
         (modifiers: readonly Modifier[] | undefined, typeParameters: readonly TypeParameterDeclaration[] | undefined, parameters: readonly ParameterDeclaration[], type: TypeNode | undefined, body: ConciseBody): ArrowFunction;
     };
     /** @deprecated Use `factory.updateArrowFunction` or the factory supplied by your transformation context instead. */
-    const updateArrowFunction: {
+    export const updateArrowFunction: {
         (node: ArrowFunction, modifiers: readonly Modifier[] | undefined, typeParameters: readonly TypeParameterDeclaration[] | undefined, parameters: readonly ParameterDeclaration[], type: TypeNode | undefined, equalsGreaterThanToken: EqualsGreaterThanToken, body: ConciseBody): ArrowFunction;
         (node: ArrowFunction, modifiers: readonly Modifier[] | undefined, typeParameters: readonly TypeParameterDeclaration[] | undefined, parameters: readonly ParameterDeclaration[], type: TypeNode | undefined, body: ConciseBody): ArrowFunction;
     };
     /** @deprecated Use `factory.createVariableDeclaration` or the factory supplied by your transformation context instead. */
-    const createVariableDeclaration: {
+    export const createVariableDeclaration: {
         (name: string | BindingName, type?: TypeNode | undefined, initializer?: Expression | undefined): VariableDeclaration;
         (name: string | BindingName, exclamationToken: ExclamationToken | undefined, type: TypeNode | undefined, initializer: Expression | undefined): VariableDeclaration;
     };
     /** @deprecated Use `factory.updateVariableDeclaration` or the factory supplied by your transformation context instead. */
-    const updateVariableDeclaration: {
+    export const updateVariableDeclaration: {
         (node: VariableDeclaration, name: BindingName, type: TypeNode | undefined, initializer: Expression | undefined): VariableDeclaration;
         (node: VariableDeclaration, name: BindingName, exclamationToken: ExclamationToken | undefined, type: TypeNode | undefined, initializer: Expression | undefined): VariableDeclaration;
     };
     /** @deprecated Use `factory.createImportClause` or the factory supplied by your transformation context instead. */
-    const createImportClause: (name: Identifier | undefined, namedBindings: NamedImportBindings | undefined, isTypeOnly?: any) => ImportClause;
+    export const createImportClause: (name: Identifier | undefined, namedBindings: NamedImportBindings | undefined, isTypeOnly?: any) => ImportClause;
     /** @deprecated Use `factory.updateImportClause` or the factory supplied by your transformation context instead. */
-    const updateImportClause: (node: ImportClause, name: Identifier | undefined, namedBindings: NamedImportBindings | undefined, isTypeOnly: boolean) => ImportClause;
+    export const updateImportClause: (node: ImportClause, name: Identifier | undefined, namedBindings: NamedImportBindings | undefined, isTypeOnly: boolean) => ImportClause;
     /** @deprecated Use `factory.createExportDeclaration` or the factory supplied by your transformation context instead. */
-    const createExportDeclaration: (decorators: readonly Decorator[] | undefined, modifiers: readonly Modifier[] | undefined, exportClause: NamedExportBindings | undefined, moduleSpecifier?: Expression | undefined, isTypeOnly?: any) => ExportDeclaration;
+    export const createExportDeclaration: (decorators: readonly Decorator[] | undefined, modifiers: readonly Modifier[] | undefined, exportClause: NamedExportBindings | undefined, moduleSpecifier?: Expression | undefined, isTypeOnly?: any) => ExportDeclaration;
     /** @deprecated Use `factory.updateExportDeclaration` or the factory supplied by your transformation context instead. */
-    const updateExportDeclaration: (node: ExportDeclaration, decorators: readonly Decorator[] | undefined, modifiers: readonly Modifier[] | undefined, exportClause: NamedExportBindings | undefined, moduleSpecifier: Expression | undefined, isTypeOnly: boolean) => ExportDeclaration;
+    export const updateExportDeclaration: (node: ExportDeclaration, decorators: readonly Decorator[] | undefined, modifiers: readonly Modifier[] | undefined, exportClause: NamedExportBindings | undefined, moduleSpecifier: Expression | undefined, isTypeOnly: boolean) => ExportDeclaration;
     /** @deprecated Use `factory.createJSDocParameterTag` or the factory supplied by your transformation context instead. */
-    const createJSDocParamTag: (name: EntityName, isBracketed: boolean, typeExpression?: JSDocTypeExpression | undefined, comment?: string | undefined) => JSDocParameterTag;
+    export const createJSDocParamTag: (name: EntityName, isBracketed: boolean, typeExpression?: JSDocTypeExpression | undefined, comment?: string | undefined) => JSDocParameterTag;
     /** @deprecated Use `factory.createComma` or the factory supplied by your transformation context instead. */
-    const createComma: (left: Expression, right: Expression) => Expression;
+    export const createComma: (left: Expression, right: Expression) => Expression;
     /** @deprecated Use `factory.createLessThan` or the factory supplied by your transformation context instead. */
-    const createLessThan: (left: Expression, right: Expression) => Expression;
+    export const createLessThan: (left: Expression, right: Expression) => Expression;
     /** @deprecated Use `factory.createAssignment` or the factory supplied by your transformation context instead. */
-    const createAssignment: (left: Expression, right: Expression) => BinaryExpression;
+    export const createAssignment: (left: Expression, right: Expression) => BinaryExpression;
     /** @deprecated Use `factory.createStrictEquality` or the factory supplied by your transformation context instead. */
-    const createStrictEquality: (left: Expression, right: Expression) => BinaryExpression;
+    export const createStrictEquality: (left: Expression, right: Expression) => BinaryExpression;
     /** @deprecated Use `factory.createStrictInequality` or the factory supplied by your transformation context instead. */
-    const createStrictInequality: (left: Expression, right: Expression) => BinaryExpression;
+    export const createStrictInequality: (left: Expression, right: Expression) => BinaryExpression;
     /** @deprecated Use `factory.createAdd` or the factory supplied by your transformation context instead. */
-    const createAdd: (left: Expression, right: Expression) => BinaryExpression;
+    export const createAdd: (left: Expression, right: Expression) => BinaryExpression;
     /** @deprecated Use `factory.createSubtract` or the factory supplied by your transformation context instead. */
-    const createSubtract: (left: Expression, right: Expression) => BinaryExpression;
+    export const createSubtract: (left: Expression, right: Expression) => BinaryExpression;
     /** @deprecated Use `factory.createLogicalAnd` or the factory supplied by your transformation context instead. */
-    const createLogicalAnd: (left: Expression, right: Expression) => BinaryExpression;
+    export const createLogicalAnd: (left: Expression, right: Expression) => BinaryExpression;
     /** @deprecated Use `factory.createLogicalOr` or the factory supplied by your transformation context instead. */
-    const createLogicalOr: (left: Expression, right: Expression) => BinaryExpression;
+    export const createLogicalOr: (left: Expression, right: Expression) => BinaryExpression;
     /** @deprecated Use `factory.createPostfixIncrement` or the factory supplied by your transformation context instead. */
-    const createPostfixIncrement: (operand: Expression) => PostfixUnaryExpression;
+    export const createPostfixIncrement: (operand: Expression) => PostfixUnaryExpression;
     /** @deprecated Use `factory.createLogicalNot` or the factory supplied by your transformation context instead. */
-    const createLogicalNot: (operand: Expression) => PrefixUnaryExpression;
+    export const createLogicalNot: (operand: Expression) => PrefixUnaryExpression;
     /** @deprecated Use an appropriate `factory` method instead. */
-    const createNode: (kind: SyntaxKind, pos?: any, end?: any) => Node;
+    export const createNode: (kind: SyntaxKind, pos?: any, end?: any) => Node;
     /**
      * Creates a shallow, memberwise clone of a node ~for mutation~ with its `pos`, `end`, and `parent` set.
      *
@@ -11757,257 +11790,12 @@ declare namespace ts {
      *
      * @deprecated Use an appropriate `factory.update...` method instead, use `setCommentRange` or `setSourceMapRange`, and avoid setting `parent`.
      */
-    const getMutableClone: <T extends Node>(node: T) => T;
-}
-declare namespace ts {
+    export const getMutableClone: <T extends Node>(node: T) => T;
     /** @deprecated Use `isTypeAssertionExpression` instead. */
-    const isTypeAssertion: (node: Node) => node is TypeAssertion;
-}
-declare namespace ts {
-    /**
-     * @deprecated Use `ts.ReadonlyESMap<K, V>` instead.
-     */
-    interface ReadonlyMap<T> extends ReadonlyESMap<string, T> {
-    }
-    /**
-     * @deprecated Use `ts.ESMap<K, V>` instead.
-     */
-    interface Map<T> extends ESMap<string, T> {
-    }
-}
-declare namespace ts {
+    export const isTypeAssertion: (node: Node) => node is TypeAssertion;
     /**
      * @deprecated Use `isMemberName` instead.
      */
-    const isIdentifierOrPrivateIdentifier: (node: Node) => node is MemberName;
-}
-declare namespace ts {
-    interface NodeFactory {
-        /** @deprecated Use the overload that accepts 'modifiers' */
-        createConstructorTypeNode(typeParameters: readonly TypeParameterDeclaration[] | undefined, parameters: readonly ParameterDeclaration[], type: TypeNode): ConstructorTypeNode;
-        /** @deprecated Use the overload that accepts 'modifiers' */
-        updateConstructorTypeNode(node: ConstructorTypeNode, typeParameters: NodeArray<TypeParameterDeclaration> | undefined, parameters: NodeArray<ParameterDeclaration>, type: TypeNode): ConstructorTypeNode;
-    }
-}
-declare namespace ts {
-    interface NodeFactory {
-        createImportTypeNode(argument: TypeNode, assertions?: ImportTypeAssertionContainer, qualifier?: EntityName, typeArguments?: readonly TypeNode[], isTypeOf?: boolean): ImportTypeNode;
-        /** @deprecated Use the overload that accepts 'assertions' */
-        createImportTypeNode(argument: TypeNode, qualifier?: EntityName, typeArguments?: readonly TypeNode[], isTypeOf?: boolean): ImportTypeNode;
-        /** @deprecated Use the overload that accepts 'assertions' */
-        updateImportTypeNode(node: ImportTypeNode, argument: TypeNode, qualifier: EntityName | undefined, typeArguments: readonly TypeNode[] | undefined, isTypeOf?: boolean): ImportTypeNode;
-    }
-}
-declare namespace ts {
-    interface NodeFactory {
-        /** @deprecated Use the overload that accepts 'modifiers' */
-        createTypeParameterDeclaration(name: string | Identifier, constraint?: TypeNode, defaultType?: TypeNode): TypeParameterDeclaration;
-        /** @deprecated Use the overload that accepts 'modifiers' */
-        updateTypeParameterDeclaration(node: TypeParameterDeclaration, name: Identifier, constraint: TypeNode | undefined, defaultType: TypeNode | undefined): TypeParameterDeclaration;
-    }
-}
-declare namespace ts {
-    interface Node {
-        /**
-         * @deprecated `decorators` has been removed from `Node` and merged with `modifiers` on the `Node` subtypes that support them.
-         * Use `ts.canHaveDecorators()` to test whether a `Node` can have decorators.
-         * Use `ts.getDecorators()` to get the decorators of a `Node`.
-         *
-         * For example:
-         * ```ts
-         * const decorators = ts.canHaveDecorators(node) ? ts.getDecorators(node) : undefined;
-         * ```
-         */
-        readonly decorators?: undefined;
-        /**
-         * @deprecated `modifiers` has been removed from `Node` and moved to the `Node` subtypes that support them.
-         * Use `ts.canHaveModifiers()` to test whether a `Node` can have modifiers.
-         * Use `ts.getModifiers()` to get the modifiers of a `Node`.
-         *
-         * For example:
-         * ```ts
-         * const modifiers = ts.canHaveModifiers(node) ? ts.getModifiers(node) : undefined;
-         * ```
-         */
-        readonly modifiers?: NodeArray<ModifierLike> | undefined;
-    }
-    interface PropertySignature {
-        /** @deprecated A property signature cannot have an initializer */
-        readonly initializer?: Expression | undefined;
-    }
-    interface PropertyAssignment {
-        /** @deprecated A property assignment cannot have a question token */
-        readonly questionToken?: QuestionToken | undefined;
-        /** @deprecated A property assignment cannot have an exclamation token */
-        readonly exclamationToken?: ExclamationToken | undefined;
-    }
-    interface ShorthandPropertyAssignment {
-        /** @deprecated A shorthand property assignment cannot have modifiers */
-        readonly modifiers?: NodeArray<Modifier> | undefined;
-        /** @deprecated A shorthand property assignment cannot have a question token */
-        readonly questionToken?: QuestionToken | undefined;
-        /** @deprecated A shorthand property assignment cannot have an exclamation token */
-        readonly exclamationToken?: ExclamationToken | undefined;
-    }
-    interface FunctionTypeNode {
-        /** @deprecated A function type cannot have modifiers */
-        readonly modifiers?: NodeArray<Modifier> | undefined;
-    }
-    interface NodeFactory {
-        /**
-         * @deprecated Decorators have been combined with modifiers. Callers should use an overload that does not accept a `decorators` parameter.
-         */
-        createParameterDeclaration(decorators: readonly Decorator[] | undefined, modifiers: readonly Modifier[] | undefined, dotDotDotToken: DotDotDotToken | undefined, name: string | BindingName, questionToken?: QuestionToken, type?: TypeNode, initializer?: Expression): ParameterDeclaration;
-        /**
-         * @deprecated Decorators have been combined with modifiers. Callers should use an overload that does not accept a `decorators` parameter.
-         */
-        updateParameterDeclaration(node: ParameterDeclaration, decorators: readonly Decorator[] | undefined, modifiers: readonly Modifier[] | undefined, dotDotDotToken: DotDotDotToken | undefined, name: string | BindingName, questionToken: QuestionToken | undefined, type: TypeNode | undefined, initializer: Expression | undefined): ParameterDeclaration;
-        /**
-         * @deprecated Decorators have been combined with modifiers. Callers should use an overload that does not accept a `decorators` parameter.
-         */
-        createPropertyDeclaration(decorators: readonly Decorator[] | undefined, modifiers: readonly Modifier[] | undefined, name: string | PropertyName, questionOrExclamationToken: QuestionToken | ExclamationToken | undefined, type: TypeNode | undefined, initializer: Expression | undefined): PropertyDeclaration;
-        /**
-         * @deprecated Decorators have been combined with modifiers. Callers should use an overload that does not accept a `decorators` parameter.
-         */
-        updatePropertyDeclaration(node: PropertyDeclaration, decorators: readonly Decorator[] | undefined, modifiers: readonly Modifier[] | undefined, name: string | PropertyName, questionOrExclamationToken: QuestionToken | ExclamationToken | undefined, type: TypeNode | undefined, initializer: Expression | undefined): PropertyDeclaration;
-        /**
-         * @deprecated Decorators have been combined with modifiers. Callers should use an overload that does not accept a `decorators` parameter.
-         */
-        createMethodDeclaration(decorators: readonly Decorator[] | undefined, modifiers: readonly Modifier[] | undefined, asteriskToken: AsteriskToken | undefined, name: string | PropertyName, questionToken: QuestionToken | undefined, typeParameters: readonly TypeParameterDeclaration[] | undefined, parameters: readonly ParameterDeclaration[], type: TypeNode | undefined, body: Block | undefined): MethodDeclaration;
-        /**
-         * @deprecated Decorators have been combined with modifiers. Callers should use an overload that does not accept a `decorators` parameter.
-         */
-        updateMethodDeclaration(node: MethodDeclaration, decorators: readonly Decorator[] | undefined, modifiers: readonly Modifier[] | undefined, asteriskToken: AsteriskToken | undefined, name: PropertyName, questionToken: QuestionToken | undefined, typeParameters: readonly TypeParameterDeclaration[] | undefined, parameters: readonly ParameterDeclaration[], type: TypeNode | undefined, body: Block | undefined): MethodDeclaration;
-        /**
-         * @deprecated This node does not support Decorators. Callers should use an overload that does not accept a `decorators` parameter.
-         */
-        createConstructorDeclaration(decorators: readonly Decorator[] | undefined, modifiers: readonly Modifier[] | undefined, parameters: readonly ParameterDeclaration[], body: Block | undefined): ConstructorDeclaration;
-        /**
-         * @deprecated This node does not support Decorators. Callers should use an overload that does not accept a `decorators` parameter.
-         */
-        updateConstructorDeclaration(node: ConstructorDeclaration, decorators: readonly Decorator[] | undefined, modifiers: readonly Modifier[] | undefined, parameters: readonly ParameterDeclaration[], body: Block | undefined): ConstructorDeclaration;
-        /**
-         * @deprecated Decorators have been combined with modifiers. Callers should use an overload that does not accept a `decorators` parameter.
-         */
-        createGetAccessorDeclaration(decorators: readonly Decorator[] | undefined, modifiers: readonly Modifier[] | undefined, name: string | PropertyName, parameters: readonly ParameterDeclaration[], type: TypeNode | undefined, body: Block | undefined): GetAccessorDeclaration;
-        /**
-         * @deprecated Decorators have been combined with modifiers. Callers should use an overload that does not accept a `decorators` parameter.
-         */
-        updateGetAccessorDeclaration(node: GetAccessorDeclaration, decorators: readonly Decorator[] | undefined, modifiers: readonly Modifier[] | undefined, name: PropertyName, parameters: readonly ParameterDeclaration[], type: TypeNode | undefined, body: Block | undefined): GetAccessorDeclaration;
-        /**
-         * @deprecated Decorators have been combined with modifiers. Callers should use an overload that does not accept a `decorators` parameter.
-         */
-        createSetAccessorDeclaration(decorators: readonly Decorator[] | undefined, modifiers: readonly Modifier[] | undefined, name: string | PropertyName, parameters: readonly ParameterDeclaration[], body: Block | undefined): SetAccessorDeclaration;
-        /**
-         * @deprecated Decorators have been combined with modifiers. Callers should use an overload that does not accept a `decorators` parameter.
-         */
-        updateSetAccessorDeclaration(node: SetAccessorDeclaration, decorators: readonly Decorator[] | undefined, modifiers: readonly Modifier[] | undefined, name: PropertyName, parameters: readonly ParameterDeclaration[], body: Block | undefined): SetAccessorDeclaration;
-        /**
-         * @deprecated Decorators are no longer supported for this function. Callers should use an overload that does not accept a `decorators` parameter.
-         */
-        createIndexSignature(decorators: readonly Decorator[] | undefined, modifiers: readonly Modifier[] | undefined, parameters: readonly ParameterDeclaration[], type: TypeNode): IndexSignatureDeclaration;
-        /**
-         * @deprecated Decorators and modifiers are no longer supported for this function. Callers should use an overload that does not accept the `decorators` and `modifiers` parameters.
-         */
-        updateIndexSignature(node: IndexSignatureDeclaration, decorators: readonly Decorator[] | undefined, modifiers: readonly Modifier[] | undefined, parameters: readonly ParameterDeclaration[], type: TypeNode): IndexSignatureDeclaration;
-        /**
-         * @deprecated Decorators and modifiers are no longer supported for this function. Callers should use an overload that does not accept the `decorators` and `modifiers` parameters.
-         */
-        createClassStaticBlockDeclaration(decorators: readonly Decorator[] | undefined, modifiers: readonly Modifier[] | undefined, body: Block): ClassStaticBlockDeclaration;
-        /**
-         * @deprecated Decorators are no longer supported for this function. Callers should use an overload that does not accept a `decorators` parameter.
-         */
-        updateClassStaticBlockDeclaration(node: ClassStaticBlockDeclaration, decorators: readonly Decorator[] | undefined, modifiers: readonly Modifier[] | undefined, body: Block): ClassStaticBlockDeclaration;
-        /**
-         * @deprecated Decorators have been combined with modifiers. Callers should use an overload that does not accept a `decorators` parameter.
-         */
-        createClassExpression(decorators: readonly Decorator[] | undefined, modifiers: readonly Modifier[] | undefined, name: string | Identifier | undefined, typeParameters: readonly TypeParameterDeclaration[] | undefined, heritageClauses: readonly HeritageClause[] | undefined, members: readonly ClassElement[]): ClassExpression;
-        /**
-         * @deprecated Decorators have been combined with modifiers. Callers should use an overload that does not accept a `decorators` parameter.
-         */
-        updateClassExpression(node: ClassExpression, decorators: readonly Decorator[] | undefined, modifiers: readonly Modifier[] | undefined, name: Identifier | undefined, typeParameters: readonly TypeParameterDeclaration[] | undefined, heritageClauses: readonly HeritageClause[] | undefined, members: readonly ClassElement[]): ClassExpression;
-        /**
-         * @deprecated Decorators are no longer supported for this function. Callers should use an overload that does not accept a `decorators` parameter.
-         */
-        createFunctionDeclaration(decorators: readonly Decorator[] | undefined, modifiers: readonly Modifier[] | undefined, asteriskToken: AsteriskToken | undefined, name: string | Identifier | undefined, typeParameters: readonly TypeParameterDeclaration[] | undefined, parameters: readonly ParameterDeclaration[], type: TypeNode | undefined, body: Block | undefined): FunctionDeclaration;
-        /**
-         * @deprecated Decorators are no longer supported for this function. Callers should use an overload that does not accept a `decorators` parameter.
-         */
-        updateFunctionDeclaration(node: FunctionDeclaration, decorators: readonly Decorator[] | undefined, modifiers: readonly Modifier[] | undefined, asteriskToken: AsteriskToken | undefined, name: Identifier | undefined, typeParameters: readonly TypeParameterDeclaration[] | undefined, parameters: readonly ParameterDeclaration[], type: TypeNode | undefined, body: Block | undefined): FunctionDeclaration;
-        /**
-         * @deprecated Decorators have been combined with modifiers. Callers should use an overload that does not accept a `decorators` parameter.
-         */
-        createClassDeclaration(decorators: readonly Decorator[] | undefined, modifiers: readonly Modifier[] | undefined, name: string | Identifier | undefined, typeParameters: readonly TypeParameterDeclaration[] | undefined, heritageClauses: readonly HeritageClause[] | undefined, members: readonly ClassElement[]): ClassDeclaration;
-        /**
-         * @deprecated Decorators have been combined with modifiers. Callers should use an overload that does not accept a `decorators` parameter.
-         */
-        updateClassDeclaration(node: ClassDeclaration, decorators: readonly Decorator[] | undefined, modifiers: readonly Modifier[] | undefined, name: Identifier | undefined, typeParameters: readonly TypeParameterDeclaration[] | undefined, heritageClauses: readonly HeritageClause[] | undefined, members: readonly ClassElement[]): ClassDeclaration;
-        /**
-         * @deprecated Decorators are no longer supported for this function. Callers should use an overload that does not accept a `decorators` parameter.
-         */
-        createInterfaceDeclaration(decorators: readonly Decorator[] | undefined, modifiers: readonly Modifier[] | undefined, name: string | Identifier, typeParameters: readonly TypeParameterDeclaration[] | undefined, heritageClauses: readonly HeritageClause[] | undefined, members: readonly TypeElement[]): InterfaceDeclaration;
-        /**
-         * @deprecated Decorators are no longer supported for this function. Callers should use an overload that does not accept a `decorators` parameter.
-         */
-        updateInterfaceDeclaration(node: InterfaceDeclaration, decorators: readonly Decorator[] | undefined, modifiers: readonly Modifier[] | undefined, name: Identifier, typeParameters: readonly TypeParameterDeclaration[] | undefined, heritageClauses: readonly HeritageClause[] | undefined, members: readonly TypeElement[]): InterfaceDeclaration;
-        /**
-         * @deprecated Decorators are no longer supported for this function. Callers should use an overload that does not accept a `decorators` parameter.
-         */
-        createTypeAliasDeclaration(decorators: readonly Decorator[] | undefined, modifiers: readonly Modifier[] | undefined, name: string | Identifier, typeParameters: readonly TypeParameterDeclaration[] | undefined, type: TypeNode): TypeAliasDeclaration;
-        /**
-         * @deprecated Decorators are no longer supported for this function. Callers should use an overload that does not accept a `decorators` parameter.
-         */
-        updateTypeAliasDeclaration(node: TypeAliasDeclaration, decorators: readonly Decorator[] | undefined, modifiers: readonly Modifier[] | undefined, name: Identifier, typeParameters: readonly TypeParameterDeclaration[] | undefined, type: TypeNode): TypeAliasDeclaration;
-        /**
-         * @deprecated Decorators are no longer supported for this function. Callers should use an overload that does not accept a `decorators` parameter.
-         */
-        createEnumDeclaration(decorators: readonly Decorator[] | undefined, modifiers: readonly Modifier[] | undefined, name: string | Identifier, members: readonly EnumMember[]): EnumDeclaration;
-        /**
-         * @deprecated Decorators are no longer supported for this function. Callers should use an overload that does not accept a `decorators` parameter.
-         */
-        updateEnumDeclaration(node: EnumDeclaration, decorators: readonly Decorator[] | undefined, modifiers: readonly Modifier[] | undefined, name: Identifier, members: readonly EnumMember[]): EnumDeclaration;
-        /**
-         * @deprecated Decorators are no longer supported for this function. Callers should use an overload that does not accept a `decorators` parameter.
-         */
-        createModuleDeclaration(decorators: readonly Decorator[] | undefined, modifiers: readonly Modifier[] | undefined, name: ModuleName, body: ModuleBody | undefined, flags?: NodeFlags): ModuleDeclaration;
-        /**
-         * @deprecated Decorators are no longer supported for this function. Callers should use an overload that does not accept a `decorators` parameter.
-         */
-        updateModuleDeclaration(node: ModuleDeclaration, decorators: readonly Decorator[] | undefined, modifiers: readonly Modifier[] | undefined, name: ModuleName, body: ModuleBody | undefined): ModuleDeclaration;
-        /**
-         * @deprecated Decorators are no longer supported for this function. Callers should use an overload that does not accept a `decorators` parameter.
-         */
-        createImportEqualsDeclaration(decorators: readonly Decorator[] | undefined, modifiers: readonly Modifier[] | undefined, isTypeOnly: boolean, name: string | Identifier, moduleReference: ModuleReference): ImportEqualsDeclaration;
-        /**
-         * @deprecated Decorators are no longer supported for this function. Callers should use an overload that does not accept a `decorators` parameter.
-         */
-        updateImportEqualsDeclaration(node: ImportEqualsDeclaration, decorators: readonly Decorator[] | undefined, modifiers: readonly Modifier[] | undefined, isTypeOnly: boolean, name: Identifier, moduleReference: ModuleReference): ImportEqualsDeclaration;
-        /**
-         * @deprecated Decorators are no longer supported for this function. Callers should use an overload that does not accept a `decorators` parameter.
-         */
-        createImportDeclaration(decorators: readonly Decorator[] | undefined, modifiers: readonly Modifier[] | undefined, importClause: ImportClause | undefined, moduleSpecifier: Expression, assertClause?: AssertClause): ImportDeclaration;
-        /**
-         * @deprecated Decorators are no longer supported for this function. Callers should use an overload that does not accept a `decorators` parameter.
-         */
-        updateImportDeclaration(node: ImportDeclaration, decorators: readonly Decorator[] | undefined, modifiers: readonly Modifier[] | undefined, importClause: ImportClause | undefined, moduleSpecifier: Expression, assertClause: AssertClause | undefined): ImportDeclaration;
-        /**
-         * @deprecated Decorators are no longer supported for this function. Callers should use an overload that does not accept a `decorators` parameter.
-         */
-        createExportAssignment(decorators: readonly Decorator[] | undefined, modifiers: readonly Modifier[] | undefined, isExportEquals: boolean | undefined, expression: Expression): ExportAssignment;
-        /**
-         * @deprecated Decorators are no longer supported for this function. Callers should use an overload that does not accept a `decorators` parameter.
-         */
-        updateExportAssignment(node: ExportAssignment, decorators: readonly Decorator[] | undefined, modifiers: readonly Modifier[] | undefined, expression: Expression): ExportAssignment;
-        /**
-         * @deprecated Decorators are no longer supported for this function. Callers should use an overload that does not accept a `decorators` parameter.
-         */
-        createExportDeclaration(decorators: readonly Decorator[] | undefined, modifiers: readonly Modifier[] | undefined, isTypeOnly: boolean, exportClause: NamedExportBindings | undefined, moduleSpecifier?: Expression, assertClause?: AssertClause): ExportDeclaration;
-        /**
-         * @deprecated Decorators are no longer supported for this function. Callers should use an overload that does not accept a `decorators` parameter.
-         */
-        updateExportDeclaration(node: ExportDeclaration, decorators: readonly Decorator[] | undefined, modifiers: readonly Modifier[] | undefined, isTypeOnly: boolean, exportClause: NamedExportBindings | undefined, moduleSpecifier: Expression | undefined, assertClause: AssertClause | undefined): ExportDeclaration;
-    }
+    export const isIdentifierOrPrivateIdentifier: (node: Node) => node is MemberName;
 }
-
-export = ts;
-export as namespace ts;
\ No newline at end of file
+export = ts;
\ No newline at end of file
diff --git a/tests/baselines/reference/api/typescript.d.ts b/tests/baselines/reference/api/typescript.d.ts
index 0e6b2559af..1a16b04f03 100644
--- a/tests/baselines/reference/api/typescript.d.ts
+++ b/tests/baselines/reference/api/typescript.d.ts
@@ -14,69 +14,85 @@ and limitations under the License.
 ***************************************************************************** */
 
 declare namespace ts {
-    const versionMajorMinor = "4.9";
+    export const versionMajorMinor = "4.9";
     /** The version of the TypeScript compiler release */
-    const version: string;
+    export const version: string;
     /**
      * Type of objects whose values are all of the same type.
      * The `in` and `for-in` operators can *not* be safely used,
      * since `Object.prototype` may be modified by outside code.
      */
-    interface MapLike<T> {
+    export interface MapLike<T> {
         [index: string]: T;
     }
-    interface SortedReadonlyArray<T> extends ReadonlyArray<T> {
+    export interface SortedReadonlyArray<T> extends ReadonlyArray<T> {
         " __sortedArrayBrand": any;
     }
-    interface SortedArray<T> extends Array<T> {
+    export interface SortedArray<T> extends Array<T> {
         " __sortedArrayBrand": any;
     }
     /** Common read methods for ES6 Map/Set. */
-    interface ReadonlyCollection<K> {
+    export interface ReadonlyCollection<K> {
         readonly size: number;
         has(key: K): boolean;
         keys(): Iterator<K>;
     }
     /** Common write methods for ES6 Map/Set. */
-    interface Collection<K> extends ReadonlyCollection<K> {
+    export interface Collection<K> extends ReadonlyCollection<K> {
         delete(key: K): boolean;
         clear(): void;
     }
     /** ES6 Map interface, only read methods included. */
-    interface ReadonlyESMap<K, V> extends ReadonlyCollection<K> {
+    export interface ReadonlyESMap<K, V> extends ReadonlyCollection<K> {
         get(key: K): V | undefined;
         values(): Iterator<V>;
-        entries(): Iterator<[K, V]>;
+        entries(): Iterator<[
+            K,
+            V
+        ]>;
         forEach(action: (value: V, key: K) => void): void;
     }
     /**
      * ES6 Map interface, only read methods included.
      */
+    export interface ReadonlyMap<T> extends ReadonlyESMap<string, T> {
+    }
+    /**
+     * @deprecated Use `ts.ReadonlyESMap<K, V>` instead.
+     */
     interface ReadonlyMap<T> extends ReadonlyESMap<string, T> {
     }
     /** ES6 Map interface. */
-    interface ESMap<K, V> extends ReadonlyESMap<K, V>, Collection<K> {
+    export interface ESMap<K, V> extends ReadonlyESMap<K, V>, Collection<K> {
         set(key: K, value: V): this;
     }
     /**
      * ES6 Map interface.
      */
+    export interface Map<T> extends ESMap<string, T> {
+    }
+    /**
+     * @deprecated Use `ts.ESMap<K, V>` instead.
+     */
     interface Map<T> extends ESMap<string, T> {
     }
     /** ES6 Set interface, only read methods included. */
-    interface ReadonlySet<T> extends ReadonlyCollection<T> {
+    export interface ReadonlySet<T> extends ReadonlyCollection<T> {
         has(value: T): boolean;
         values(): Iterator<T>;
-        entries(): Iterator<[T, T]>;
+        entries(): Iterator<[
+            T,
+            T
+        ]>;
         forEach(action: (value: T, key: T) => void): void;
     }
     /** ES6 Set interface. */
-    interface Set<T> extends ReadonlySet<T>, Collection<T> {
+    export interface Set<T> extends ReadonlySet<T>, Collection<T> {
         add(value: T): this;
         delete(value: T): boolean;
     }
     /** ES6 Iterator type. */
-    interface Iterator<T> {
+    export interface Iterator<T> {
         next(): {
             value: T;
             done?: false;
@@ -86,11 +102,9 @@ declare namespace ts {
         };
     }
     /** Array that is only intended to be pushed to, never read. */
-    interface Push<T> {
+    export interface Push<T> {
         push(...values: T[]): void;
     }
-}
-declare namespace ts {
     export type Path = string & {
         __pathBrand: any;
     };
@@ -496,7 +510,7 @@ declare namespace ts {
         FirstJSDocNode = 312,
         LastJSDocNode = 350,
         FirstJSDocTagNode = 330,
-        LastJSDocTagNode = 350,
+        LastJSDocTagNode = 350
     }
     export type TriviaSyntaxKind = SyntaxKind.SingleLineCommentTrivia | SyntaxKind.MultiLineCommentTrivia | SyntaxKind.NewLineTrivia | SyntaxKind.WhitespaceTrivia | SyntaxKind.ShebangTrivia | SyntaxKind.ConflictMarkerTrivia;
     export type LiteralSyntaxKind = SyntaxKind.NumericLiteral | SyntaxKind.BigIntLiteral | SyntaxKind.StringLiteral | SyntaxKind.JsxText | SyntaxKind.JsxTextAllWhiteSpaces | SyntaxKind.RegularExpressionLiteral | SyntaxKind.NoSubstitutionTemplateLiteral;
@@ -537,7 +551,7 @@ declare namespace ts {
         ReachabilityCheckFlags = 768,
         ReachabilityAndEmitFlags = 2816,
         ContextFlags = 50720768,
-        TypeExcludesFlags = 40960,
+        TypeExcludesFlags = 40960
     }
     export enum ModifierFlags {
         None = 0,
@@ -581,6 +595,47 @@ declare namespace ts {
         readonly flags: NodeFlags;
         readonly parent: Node;
     }
+    interface Node {
+        getSourceFile(): SourceFile;
+        getChildCount(sourceFile?: SourceFile): number;
+        getChildAt(index: number, sourceFile?: SourceFile): Node;
+        getChildren(sourceFile?: SourceFile): Node[];
+        getStart(sourceFile?: SourceFile, includeJsDocComment?: boolean): number;
+        getFullStart(): number;
+        getEnd(): number;
+        getWidth(sourceFile?: SourceFileLike): number;
+        getFullWidth(): number;
+        getLeadingTriviaWidth(sourceFile?: SourceFile): number;
+        getFullText(sourceFile?: SourceFile): string;
+        getText(sourceFile?: SourceFile): string;
+        getFirstToken(sourceFile?: SourceFile): Node | undefined;
+        getLastToken(sourceFile?: SourceFile): Node | undefined;
+        forEachChild<T>(cbNode: (node: Node) => T | undefined, cbNodeArray?: (nodes: NodeArray<Node>) => T | undefined): T | undefined;
+    }
+    interface Node {
+        /**
+         * @deprecated `decorators` has been removed from `Node` and merged with `modifiers` on the `Node` subtypes that support them.
+         * Use `ts.canHaveDecorators()` to test whether a `Node` can have decorators.
+         * Use `ts.getDecorators()` to get the decorators of a `Node`.
+         *
+         * For example:
+         * ```ts
+         * const decorators = ts.canHaveDecorators(node) ? ts.getDecorators(node) : undefined;
+         * ```
+         */
+        readonly decorators?: undefined;
+        /**
+         * @deprecated `modifiers` has been removed from `Node` and moved to the `Node` subtypes that support them.
+         * Use `ts.canHaveModifiers()` to test whether a `Node` can have modifiers.
+         * Use `ts.getModifiers()` to get the modifiers of a `Node`.
+         *
+         * For example:
+         * ```ts
+         * const modifiers = ts.canHaveModifiers(node) ? ts.getModifiers(node) : undefined;
+         * ```
+         */
+        readonly modifiers?: NodeArray<ModifierLike> | undefined;
+    }
     export interface JSDocContainer {
     }
     export type HasJSDoc = ParameterDeclaration | CallSignatureDeclaration | ClassStaticBlockDeclaration | ConstructSignatureDeclaration | MethodSignature | PropertySignature | ArrowFunction | ParenthesizedExpression | SpreadAssignment | ShorthandPropertyAssignment | PropertyAssignment | FunctionExpression | EmptyStatement | DebuggerStatement | Block | VariableStatement | ExpressionStatement | IfStatement | DoStatement | WhileStatement | ForStatement | ForInStatement | ForOfStatement | BreakStatement | ContinueStatement | ReturnStatement | WithStatement | SwitchStatement | LabeledStatement | ThrowStatement | TryStatement | FunctionDeclaration | ConstructorDeclaration | MethodDeclaration | VariableDeclaration | PropertyDeclaration | AccessorDeclaration | ClassLikeDeclaration | InterfaceDeclaration | TypeAliasDeclaration | EnumMember | EnumDeclaration | ModuleDeclaration | ImportEqualsDeclaration | ImportDeclaration | NamespaceExportDeclaration | ExportAssignment | IndexSignatureDeclaration | FunctionTypeNode | ConstructorTypeNode | JSDocFunctionType | ExportDeclaration | NamedTupleMember | ExportSpecifier | CaseClause | EndOfFileToken;
@@ -661,6 +716,9 @@ declare namespace ts {
         readonly originalKeywordKind?: SyntaxKind;
         isInJSDocNamespace?: boolean;
     }
+    interface Identifier {
+        readonly text: string;
+    }
     export interface TransientIdentifier extends Identifier {
         resolvedSymbol: Symbol;
     }
@@ -691,6 +749,9 @@ declare namespace ts {
         readonly kind: SyntaxKind.PrivateIdentifier;
         readonly escapedText: __String;
     }
+    interface PrivateIdentifier {
+        readonly text: string;
+    }
     export interface Decorator extends Node {
         readonly kind: SyntaxKind.Decorator;
         readonly parent: NamedDeclaration;
@@ -759,6 +820,10 @@ declare namespace ts {
         readonly questionToken?: QuestionToken;
         readonly type?: TypeNode;
     }
+    interface PropertySignature {
+        /** @deprecated A property signature cannot have an initializer */
+        readonly initializer?: Expression | undefined;
+    }
     export interface PropertyDeclaration extends ClassElement, JSDocContainer {
         readonly kind: SyntaxKind.PropertyDeclaration;
         readonly parent: ClassLikeDeclaration;
@@ -784,6 +849,12 @@ declare namespace ts {
         readonly name: PropertyName;
         readonly initializer: Expression;
     }
+    interface PropertyAssignment {
+        /** @deprecated A property assignment cannot have a question token */
+        readonly questionToken?: QuestionToken | undefined;
+        /** @deprecated A property assignment cannot have an exclamation token */
+        readonly exclamationToken?: ExclamationToken | undefined;
+    }
     export interface ShorthandPropertyAssignment extends ObjectLiteralElement, JSDocContainer {
         readonly kind: SyntaxKind.ShorthandPropertyAssignment;
         readonly parent: ObjectLiteralExpression;
@@ -791,6 +862,14 @@ declare namespace ts {
         readonly equalsToken?: EqualsToken;
         readonly objectAssignmentInitializer?: Expression;
     }
+    interface ShorthandPropertyAssignment {
+        /** @deprecated A shorthand property assignment cannot have modifiers */
+        readonly modifiers?: NodeArray<Modifier> | undefined;
+        /** @deprecated A shorthand property assignment cannot have a question token */
+        readonly questionToken?: QuestionToken | undefined;
+        /** @deprecated A shorthand property assignment cannot have an exclamation token */
+        readonly exclamationToken?: ExclamationToken | undefined;
+    }
     export interface SpreadAssignment extends ObjectLiteralElement, JSDocContainer {
         readonly kind: SyntaxKind.SpreadAssignment;
         readonly parent: ObjectLiteralExpression;
@@ -916,6 +995,10 @@ declare namespace ts {
     export interface FunctionTypeNode extends FunctionOrConstructorTypeNodeBase {
         readonly kind: SyntaxKind.FunctionType;
     }
+    interface FunctionTypeNode {
+        /** @deprecated A function type cannot have modifiers */
+        readonly modifiers?: NodeArray<Modifier> | undefined;
+    }
     export interface ConstructorTypeNode extends FunctionOrConstructorTypeNodeBase {
         readonly kind: SyntaxKind.ConstructorType;
         readonly modifiers?: NodeArray<Modifier>;
@@ -1209,7 +1292,7 @@ declare namespace ts {
         Octal = 32,
         HexSpecifier = 64,
         BinarySpecifier = 128,
-        OctalSpecifier = 256,
+        OctalSpecifier = 256
     }
     export interface NumericLiteral extends LiteralExpression, Declaration {
         readonly kind: SyntaxKind.NumericLiteral;
@@ -2076,6 +2159,9 @@ declare namespace ts {
     export interface SourceFileLike {
         readonly text: string;
     }
+    interface SourceFileLike {
+        getLineAndCharacterOfPosition(pos: number): LineAndCharacter;
+    }
     export interface SourceFile extends Declaration {
         readonly kind: SyntaxKind.SourceFile;
         readonly statements: NodeArray<Statement>;
@@ -2118,6 +2204,13 @@ declare namespace ts {
          */
         impliedNodeFormat?: ModuleKind.ESNext | ModuleKind.CommonJS;
     }
+    interface SourceFile {
+        getLineAndCharacterOfPosition(pos: number): LineAndCharacter;
+        getLineEndOfPosition(pos: number): number;
+        getLineStarts(): readonly number[];
+        getPositionOfLineAndCharacter(line: number, character: number): number;
+        update(newText: string, textChangeRange: TextChangeRange): SourceFile;
+    }
     export interface Bundle extends Node {
         readonly kind: SyntaxKind.Bundle;
         readonly prepends: readonly (InputFiles | UnparsedSource)[];
@@ -2487,7 +2580,7 @@ declare namespace ts {
         WriteTypeParametersOrArguments = 1,
         UseOnlyExternalAliasing = 2,
         AllowAnyNodeKind = 4,
-        UseAliasDefinedOutsideCurrentScope = 8,
+        UseAliasDefinedOutsideCurrentScope = 8
     }
     export enum TypePredicateKind {
         This = 0,
@@ -2584,7 +2677,7 @@ declare namespace ts {
         ExportHasLocal = 944,
         BlockScoped = 418,
         PropertyOrAccessor = 98308,
-        ClassMember = 106500,
+        ClassMember = 106500
     }
     export interface Symbol {
         flags: SymbolFlags;
@@ -2595,6 +2688,15 @@ declare namespace ts {
         exports?: SymbolTable;
         globalExports?: SymbolTable;
     }
+    interface Symbol {
+        readonly name: string;
+        getFlags(): SymbolFlags;
+        getEscapedName(): __String;
+        getName(): string;
+        getDeclarations(): Declaration[] | undefined;
+        getDocumentationComment(typeChecker: TypeChecker | undefined): SymbolDisplayPart[];
+        getJsDocTags(checker?: TypeChecker): JSDocTagInfo[];
+    }
     export enum InternalSymbolName {
         Call = "__call",
         Constructor = "__constructor",
@@ -2683,7 +2785,7 @@ declare namespace ts {
         InstantiablePrimitive = 406847488,
         Instantiable = 465829888,
         StructuredOrInstantiable = 469499904,
-        Narrowable = 536624127,
+        Narrowable = 536624127
     }
     export type DestructuringPattern = BindingPattern | ObjectLiteralExpression | ArrayLiteralExpression;
     export interface Type {
@@ -2693,6 +2795,31 @@ declare namespace ts {
         aliasSymbol?: Symbol;
         aliasTypeArguments?: readonly Type[];
     }
+    interface Type {
+        getFlags(): TypeFlags;
+        getSymbol(): Symbol | undefined;
+        getProperties(): Symbol[];
+        getProperty(propertyName: string): Symbol | undefined;
+        getApparentProperties(): Symbol[];
+        getCallSignatures(): readonly Signature[];
+        getConstructSignatures(): readonly Signature[];
+        getStringIndexType(): Type | undefined;
+        getNumberIndexType(): Type | undefined;
+        getBaseTypes(): BaseType[] | undefined;
+        getNonNullableType(): Type;
+        getConstraint(): Type | undefined;
+        getDefault(): Type | undefined;
+        isUnion(): this is UnionType;
+        isIntersection(): this is IntersectionType;
+        isUnionOrIntersection(): this is UnionOrIntersectionType;
+        isLiteral(): this is LiteralType;
+        isStringLiteral(): this is StringLiteralType;
+        isNumberLiteral(): this is NumberLiteralType;
+        isTypeParameter(): this is TypeParameter;
+        isClassOrInterface(): this is InterfaceType;
+        isClass(): this is InterfaceType;
+        isIndexType(): this is IndexType;
+    }
     export interface LiteralType extends Type {
         value: string | number | PseudoBigInt;
         freshType: LiteralType;
@@ -2732,7 +2859,7 @@ declare namespace ts {
         ClassOrInterface = 3,
         ContainsSpread = 2097152,
         ObjectRestType = 4194304,
-        InstantiationExpressionType = 8388608,
+        InstantiationExpressionType = 8388608
     }
     export interface ObjectType extends Type {
         objectFlags: ObjectFlags;
@@ -2765,6 +2892,9 @@ declare namespace ts {
         target: GenericType;
         node?: TypeReferenceNode | ArrayTypeNode | TupleTypeNode;
     }
+    interface TypeReference {
+        typeArguments?: readonly Type[];
+    }
     export interface DeferredTypeReference extends TypeReference {
     }
     export interface GenericType extends InterfaceType, TypeReference {
@@ -2858,6 +2988,15 @@ declare namespace ts {
         typeParameters?: readonly TypeParameter[];
         parameters: readonly Symbol[];
     }
+    interface Signature {
+        getDeclaration(): SignatureDeclaration;
+        getTypeParameters(): TypeParameter[] | undefined;
+        getParameters(): Symbol[];
+        getTypeParameterAtPosition(pos: number): Type;
+        getReturnType(): Type;
+        getDocumentationComment(typeChecker: TypeChecker | undefined): SymbolDisplayPart[];
+        getJsDocTags(): JSDocTagInfo[];
+    }
     export enum IndexKind {
         String = 0,
         Number = 1
@@ -3333,6 +3472,9 @@ declare namespace ts {
         text: string;
         skipTrivia?: (pos: number) => number;
     }
+    interface SourceMapSource {
+        getLineAndCharacterOfPosition(pos: number): LineAndCharacter;
+    }
     export enum EmitFlags {
         None = 0,
         SingleLine = 1,
@@ -3362,7 +3504,7 @@ declare namespace ts {
         NoHoisting = 2097152,
         HasEndOfDeclarationMarker = 4194304,
         Iterator = 8388608,
-        NoAsciiEscaping = 16777216,
+        NoAsciiEscaping = 16777216
     }
     export interface EmitHelperBase {
         readonly name: string;
@@ -3864,107 +4006,280 @@ declare namespace ts {
         createExternalModuleExport(exportName: Identifier): ExportDeclaration;
         restoreOuterExpressions(outerExpression: Expression | undefined, innerExpression: Expression, kinds?: OuterExpressionKinds): Expression;
     }
-    export interface CoreTransformationContext {
-        readonly factory: NodeFactory;
-        /** Gets the compiler options supplied to the transformer. */
-        getCompilerOptions(): CompilerOptions;
-        /** Starts a new lexical environment. */
-        startLexicalEnvironment(): void;
-        /** Suspends the current lexical environment, usually after visiting a parameter list. */
-        suspendLexicalEnvironment(): void;
-        /** Resumes a suspended lexical environment, usually before visiting a function body. */
-        resumeLexicalEnvironment(): void;
-        /** Ends a lexical environment, returning any declarations. */
-        endLexicalEnvironment(): Statement[] | undefined;
-        /** Hoists a function declaration to the containing scope. */
-        hoistFunctionDeclaration(node: FunctionDeclaration): void;
-        /** Hoists a variable declaration to the containing scope. */
-        hoistVariableDeclaration(node: Identifier): void;
+    interface NodeFactory {
+        /** @deprecated Use the overload that accepts 'modifiers' */
+        createConstructorTypeNode(typeParameters: readonly TypeParameterDeclaration[] | undefined, parameters: readonly ParameterDeclaration[], type: TypeNode): ConstructorTypeNode;
+        /** @deprecated Use the overload that accepts 'modifiers' */
+        updateConstructorTypeNode(node: ConstructorTypeNode, typeParameters: NodeArray<TypeParameterDeclaration> | undefined, parameters: NodeArray<ParameterDeclaration>, type: TypeNode): ConstructorTypeNode;
     }
-    export interface TransformationContext extends CoreTransformationContext {
-        /** Records a request for a non-scoped emit helper in the current context. */
-        requestEmitHelper(helper: EmitHelper): void;
-        /** Gets and resets the requested non-scoped emit helpers. */
-        readEmitHelpers(): EmitHelper[] | undefined;
-        /** Enables expression substitutions in the pretty printer for the provided SyntaxKind. */
-        enableSubstitution(kind: SyntaxKind): void;
-        /** Determines whether expression substitutions are enabled for the provided node. */
-        isSubstitutionEnabled(node: Node): boolean;
+    interface NodeFactory {
+        createImportTypeNode(argument: TypeNode, assertions?: ImportTypeAssertionContainer, qualifier?: EntityName, typeArguments?: readonly TypeNode[], isTypeOf?: boolean): ImportTypeNode;
+        /** @deprecated Use the overload that accepts 'assertions' */
+        createImportTypeNode(argument: TypeNode, qualifier?: EntityName, typeArguments?: readonly TypeNode[], isTypeOf?: boolean): ImportTypeNode;
+        /** @deprecated Use the overload that accepts 'assertions' */
+        updateImportTypeNode(node: ImportTypeNode, argument: TypeNode, qualifier: EntityName | undefined, typeArguments: readonly TypeNode[] | undefined, isTypeOf?: boolean): ImportTypeNode;
+    }
+    interface NodeFactory {
+        /** @deprecated Use the overload that accepts 'modifiers' */
+        createTypeParameterDeclaration(name: string | Identifier, constraint?: TypeNode, defaultType?: TypeNode): TypeParameterDeclaration;
+        /** @deprecated Use the overload that accepts 'modifiers' */
+        updateTypeParameterDeclaration(node: TypeParameterDeclaration, name: Identifier, constraint: TypeNode | undefined, defaultType: TypeNode | undefined): TypeParameterDeclaration;
+    }
+    interface NodeFactory {
         /**
-         * Hook used by transformers to substitute expressions just before they
-         * are emitted by the pretty printer.
-         *
-         * NOTE: Transformation hooks should only be modified during `Transformer` initialization,
-         * before returning the `NodeTransformer` callback.
+         * @deprecated Decorators have been combined with modifiers. Callers should use an overload that does not accept a `decorators` parameter.
          */
-        onSubstituteNode: (hint: EmitHint, node: Node) => Node;
+        createParameterDeclaration(decorators: readonly Decorator[] | undefined, modifiers: readonly Modifier[] | undefined, dotDotDotToken: DotDotDotToken | undefined, name: string | BindingName, questionToken?: QuestionToken, type?: TypeNode, initializer?: Expression): ParameterDeclaration;
         /**
-         * Enables before/after emit notifications in the pretty printer for the provided
-         * SyntaxKind.
+         * @deprecated Decorators have been combined with modifiers. Callers should use an overload that does not accept a `decorators` parameter.
          */
-        enableEmitNotification(kind: SyntaxKind): void;
+        updateParameterDeclaration(node: ParameterDeclaration, decorators: readonly Decorator[] | undefined, modifiers: readonly Modifier[] | undefined, dotDotDotToken: DotDotDotToken | undefined, name: string | BindingName, questionToken: QuestionToken | undefined, type: TypeNode | undefined, initializer: Expression | undefined): ParameterDeclaration;
         /**
-         * Determines whether before/after emit notifications should be raised in the pretty
-         * printer when it emits a node.
+         * @deprecated Decorators have been combined with modifiers. Callers should use an overload that does not accept a `decorators` parameter.
          */
-        isEmitNotificationEnabled(node: Node): boolean;
+        createPropertyDeclaration(decorators: readonly Decorator[] | undefined, modifiers: readonly Modifier[] | undefined, name: string | PropertyName, questionOrExclamationToken: QuestionToken | ExclamationToken | undefined, type: TypeNode | undefined, initializer: Expression | undefined): PropertyDeclaration;
         /**
-         * Hook used to allow transformers to capture state before or after
-         * the printer emits a node.
-         *
-         * NOTE: Transformation hooks should only be modified during `Transformer` initialization,
-         * before returning the `NodeTransformer` callback.
+         * @deprecated Decorators have been combined with modifiers. Callers should use an overload that does not accept a `decorators` parameter.
          */
-        onEmitNode: (hint: EmitHint, node: Node, emitCallback: (hint: EmitHint, node: Node) => void) => void;
-    }
-    export interface TransformationResult<T extends Node> {
-        /** Gets the transformed source files. */
-        transformed: T[];
-        /** Gets diagnostics for the transformation. */
-        diagnostics?: DiagnosticWithLocation[];
+        updatePropertyDeclaration(node: PropertyDeclaration, decorators: readonly Decorator[] | undefined, modifiers: readonly Modifier[] | undefined, name: string | PropertyName, questionOrExclamationToken: QuestionToken | ExclamationToken | undefined, type: TypeNode | undefined, initializer: Expression | undefined): PropertyDeclaration;
         /**
-         * Gets a substitute for a node, if one is available; otherwise, returns the original node.
-         *
-         * @param hint A hint as to the intended usage of the node.
-         * @param node The node to substitute.
+         * @deprecated Decorators have been combined with modifiers. Callers should use an overload that does not accept a `decorators` parameter.
          */
-        substituteNode(hint: EmitHint, node: Node): Node;
+        createMethodDeclaration(decorators: readonly Decorator[] | undefined, modifiers: readonly Modifier[] | undefined, asteriskToken: AsteriskToken | undefined, name: string | PropertyName, questionToken: QuestionToken | undefined, typeParameters: readonly TypeParameterDeclaration[] | undefined, parameters: readonly ParameterDeclaration[], type: TypeNode | undefined, body: Block | undefined): MethodDeclaration;
         /**
-         * Emits a node with possible notification.
-         *
-         * @param hint A hint as to the intended usage of the node.
-         * @param node The node to emit.
-         * @param emitCallback A callback used to emit the node.
+         * @deprecated Decorators have been combined with modifiers. Callers should use an overload that does not accept a `decorators` parameter.
          */
-        emitNodeWithNotification(hint: EmitHint, node: Node, emitCallback: (hint: EmitHint, node: Node) => void): void;
+        updateMethodDeclaration(node: MethodDeclaration, decorators: readonly Decorator[] | undefined, modifiers: readonly Modifier[] | undefined, asteriskToken: AsteriskToken | undefined, name: PropertyName, questionToken: QuestionToken | undefined, typeParameters: readonly TypeParameterDeclaration[] | undefined, parameters: readonly ParameterDeclaration[], type: TypeNode | undefined, body: Block | undefined): MethodDeclaration;
         /**
-         * Indicates if a given node needs an emit notification
-         *
-         * @param node The node to emit.
+         * @deprecated This node does not support Decorators. Callers should use an overload that does not accept a `decorators` parameter.
          */
-        isEmitNotificationEnabled?(node: Node): boolean;
+        createConstructorDeclaration(decorators: readonly Decorator[] | undefined, modifiers: readonly Modifier[] | undefined, parameters: readonly ParameterDeclaration[], body: Block | undefined): ConstructorDeclaration;
         /**
-         * Clean up EmitNode entries on any parse-tree nodes.
+         * @deprecated This node does not support Decorators. Callers should use an overload that does not accept a `decorators` parameter.
          */
-        dispose(): void;
-    }
-    /**
-     * A function that is used to initialize and return a `Transformer` callback, which in turn
-     * will be used to transform one or more nodes.
-     */
-    export type TransformerFactory<T extends Node> = (context: TransformationContext) => Transformer<T>;
-    /**
-     * A function that transforms a node.
-     */
-    export type Transformer<T extends Node> = (node: T) => T;
-    /**
-     * A function that accepts and possibly transforms a node.
-     */
-    export type Visitor = (node: Node) => VisitResult<Node>;
-    export interface NodeVisitor {
-        <T extends Node>(nodes: T, visitor: Visitor | undefined, test?: (node: Node) => boolean, lift?: (node: readonly Node[]) => T): T;
-        <T extends Node>(nodes: T | undefined, visitor: Visitor | undefined, test?: (node: Node) => boolean, lift?: (node: readonly Node[]) => T): T | undefined;
-    }
+        updateConstructorDeclaration(node: ConstructorDeclaration, decorators: readonly Decorator[] | undefined, modifiers: readonly Modifier[] | undefined, parameters: readonly ParameterDeclaration[], body: Block | undefined): ConstructorDeclaration;
+        /**
+         * @deprecated Decorators have been combined with modifiers. Callers should use an overload that does not accept a `decorators` parameter.
+         */
+        createGetAccessorDeclaration(decorators: readonly Decorator[] | undefined, modifiers: readonly Modifier[] | undefined, name: string | PropertyName, parameters: readonly ParameterDeclaration[], type: TypeNode | undefined, body: Block | undefined): GetAccessorDeclaration;
+        /**
+         * @deprecated Decorators have been combined with modifiers. Callers should use an overload that does not accept a `decorators` parameter.
+         */
+        updateGetAccessorDeclaration(node: GetAccessorDeclaration, decorators: readonly Decorator[] | undefined, modifiers: readonly Modifier[] | undefined, name: PropertyName, parameters: readonly ParameterDeclaration[], type: TypeNode | undefined, body: Block | undefined): GetAccessorDeclaration;
+        /**
+         * @deprecated Decorators have been combined with modifiers. Callers should use an overload that does not accept a `decorators` parameter.
+         */
+        createSetAccessorDeclaration(decorators: readonly Decorator[] | undefined, modifiers: readonly Modifier[] | undefined, name: string | PropertyName, parameters: readonly ParameterDeclaration[], body: Block | undefined): SetAccessorDeclaration;
+        /**
+         * @deprecated Decorators have been combined with modifiers. Callers should use an overload that does not accept a `decorators` parameter.
+         */
+        updateSetAccessorDeclaration(node: SetAccessorDeclaration, decorators: readonly Decorator[] | undefined, modifiers: readonly Modifier[] | undefined, name: PropertyName, parameters: readonly ParameterDeclaration[], body: Block | undefined): SetAccessorDeclaration;
+        /**
+         * @deprecated Decorators are no longer supported for this function. Callers should use an overload that does not accept a `decorators` parameter.
+         */
+        createIndexSignature(decorators: readonly Decorator[] | undefined, modifiers: readonly Modifier[] | undefined, parameters: readonly ParameterDeclaration[], type: TypeNode): IndexSignatureDeclaration;
+        /**
+         * @deprecated Decorators and modifiers are no longer supported for this function. Callers should use an overload that does not accept the `decorators` and `modifiers` parameters.
+         */
+        updateIndexSignature(node: IndexSignatureDeclaration, decorators: readonly Decorator[] | undefined, modifiers: readonly Modifier[] | undefined, parameters: readonly ParameterDeclaration[], type: TypeNode): IndexSignatureDeclaration;
+        /**
+         * @deprecated Decorators and modifiers are no longer supported for this function. Callers should use an overload that does not accept the `decorators` and `modifiers` parameters.
+         */
+        createClassStaticBlockDeclaration(decorators: readonly Decorator[] | undefined, modifiers: readonly Modifier[] | undefined, body: Block): ClassStaticBlockDeclaration;
+        /**
+         * @deprecated Decorators are no longer supported for this function. Callers should use an overload that does not accept a `decorators` parameter.
+         */
+        updateClassStaticBlockDeclaration(node: ClassStaticBlockDeclaration, decorators: readonly Decorator[] | undefined, modifiers: readonly Modifier[] | undefined, body: Block): ClassStaticBlockDeclaration;
+        /**
+         * @deprecated Decorators have been combined with modifiers. Callers should use an overload that does not accept a `decorators` parameter.
+         */
+        createClassExpression(decorators: readonly Decorator[] | undefined, modifiers: readonly Modifier[] | undefined, name: string | Identifier | undefined, typeParameters: readonly TypeParameterDeclaration[] | undefined, heritageClauses: readonly HeritageClause[] | undefined, members: readonly ClassElement[]): ClassExpression;
+        /**
+         * @deprecated Decorators have been combined with modifiers. Callers should use an overload that does not accept a `decorators` parameter.
+         */
+        updateClassExpression(node: ClassExpression, decorators: readonly Decorator[] | undefined, modifiers: readonly Modifier[] | undefined, name: Identifier | undefined, typeParameters: readonly TypeParameterDeclaration[] | undefined, heritageClauses: readonly HeritageClause[] | undefined, members: readonly ClassElement[]): ClassExpression;
+        /**
+         * @deprecated Decorators are no longer supported for this function. Callers should use an overload that does not accept a `decorators` parameter.
+         */
+        createFunctionDeclaration(decorators: readonly Decorator[] | undefined, modifiers: readonly Modifier[] | undefined, asteriskToken: AsteriskToken | undefined, name: string | Identifier | undefined, typeParameters: readonly TypeParameterDeclaration[] | undefined, parameters: readonly ParameterDeclaration[], type: TypeNode | undefined, body: Block | undefined): FunctionDeclaration;
+        /**
+         * @deprecated Decorators are no longer supported for this function. Callers should use an overload that does not accept a `decorators` parameter.
+         */
+        updateFunctionDeclaration(node: FunctionDeclaration, decorators: readonly Decorator[] | undefined, modifiers: readonly Modifier[] | undefined, asteriskToken: AsteriskToken | undefined, name: Identifier | undefined, typeParameters: readonly TypeParameterDeclaration[] | undefined, parameters: readonly ParameterDeclaration[], type: TypeNode | undefined, body: Block | undefined): FunctionDeclaration;
+        /**
+         * @deprecated Decorators have been combined with modifiers. Callers should use an overload that does not accept a `decorators` parameter.
+         */
+        createClassDeclaration(decorators: readonly Decorator[] | undefined, modifiers: readonly Modifier[] | undefined, name: string | Identifier | undefined, typeParameters: readonly TypeParameterDeclaration[] | undefined, heritageClauses: readonly HeritageClause[] | undefined, members: readonly ClassElement[]): ClassDeclaration;
+        /**
+         * @deprecated Decorators have been combined with modifiers. Callers should use an overload that does not accept a `decorators` parameter.
+         */
+        updateClassDeclaration(node: ClassDeclaration, decorators: readonly Decorator[] | undefined, modifiers: readonly Modifier[] | undefined, name: Identifier | undefined, typeParameters: readonly TypeParameterDeclaration[] | undefined, heritageClauses: readonly HeritageClause[] | undefined, members: readonly ClassElement[]): ClassDeclaration;
+        /**
+         * @deprecated Decorators are no longer supported for this function. Callers should use an overload that does not accept a `decorators` parameter.
+         */
+        createInterfaceDeclaration(decorators: readonly Decorator[] | undefined, modifiers: readonly Modifier[] | undefined, name: string | Identifier, typeParameters: readonly TypeParameterDeclaration[] | undefined, heritageClauses: readonly HeritageClause[] | undefined, members: readonly TypeElement[]): InterfaceDeclaration;
+        /**
+         * @deprecated Decorators are no longer supported for this function. Callers should use an overload that does not accept a `decorators` parameter.
+         */
+        updateInterfaceDeclaration(node: InterfaceDeclaration, decorators: readonly Decorator[] | undefined, modifiers: readonly Modifier[] | undefined, name: Identifier, typeParameters: readonly TypeParameterDeclaration[] | undefined, heritageClauses: readonly HeritageClause[] | undefined, members: readonly TypeElement[]): InterfaceDeclaration;
+        /**
+         * @deprecated Decorators are no longer supported for this function. Callers should use an overload that does not accept a `decorators` parameter.
+         */
+        createTypeAliasDeclaration(decorators: readonly Decorator[] | undefined, modifiers: readonly Modifier[] | undefined, name: string | Identifier, typeParameters: readonly TypeParameterDeclaration[] | undefined, type: TypeNode): TypeAliasDeclaration;
+        /**
+         * @deprecated Decorators are no longer supported for this function. Callers should use an overload that does not accept a `decorators` parameter.
+         */
+        updateTypeAliasDeclaration(node: TypeAliasDeclaration, decorators: readonly Decorator[] | undefined, modifiers: readonly Modifier[] | undefined, name: Identifier, typeParameters: readonly TypeParameterDeclaration[] | undefined, type: TypeNode): TypeAliasDeclaration;
+        /**
+         * @deprecated Decorators are no longer supported for this function. Callers should use an overload that does not accept a `decorators` parameter.
+         */
+        createEnumDeclaration(decorators: readonly Decorator[] | undefined, modifiers: readonly Modifier[] | undefined, name: string | Identifier, members: readonly EnumMember[]): EnumDeclaration;
+        /**
+         * @deprecated Decorators are no longer supported for this function. Callers should use an overload that does not accept a `decorators` parameter.
+         */
+        updateEnumDeclaration(node: EnumDeclaration, decorators: readonly Decorator[] | undefined, modifiers: readonly Modifier[] | undefined, name: Identifier, members: readonly EnumMember[]): EnumDeclaration;
+        /**
+         * @deprecated Decorators are no longer supported for this function. Callers should use an overload that does not accept a `decorators` parameter.
+         */
+        createModuleDeclaration(decorators: readonly Decorator[] | undefined, modifiers: readonly Modifier[] | undefined, name: ModuleName, body: ModuleBody | undefined, flags?: NodeFlags): ModuleDeclaration;
+        /**
+         * @deprecated Decorators are no longer supported for this function. Callers should use an overload that does not accept a `decorators` parameter.
+         */
+        updateModuleDeclaration(node: ModuleDeclaration, decorators: readonly Decorator[] | undefined, modifiers: readonly Modifier[] | undefined, name: ModuleName, body: ModuleBody | undefined): ModuleDeclaration;
+        /**
+         * @deprecated Decorators are no longer supported for this function. Callers should use an overload that does not accept a `decorators` parameter.
+         */
+        createImportEqualsDeclaration(decorators: readonly Decorator[] | undefined, modifiers: readonly Modifier[] | undefined, isTypeOnly: boolean, name: string | Identifier, moduleReference: ModuleReference): ImportEqualsDeclaration;
+        /**
+         * @deprecated Decorators are no longer supported for this function. Callers should use an overload that does not accept a `decorators` parameter.
+         */
+        updateImportEqualsDeclaration(node: ImportEqualsDeclaration, decorators: readonly Decorator[] | undefined, modifiers: readonly Modifier[] | undefined, isTypeOnly: boolean, name: Identifier, moduleReference: ModuleReference): ImportEqualsDeclaration;
+        /**
+         * @deprecated Decorators are no longer supported for this function. Callers should use an overload that does not accept a `decorators` parameter.
+         */
+        createImportDeclaration(decorators: readonly Decorator[] | undefined, modifiers: readonly Modifier[] | undefined, importClause: ImportClause | undefined, moduleSpecifier: Expression, assertClause?: AssertClause): ImportDeclaration;
+        /**
+         * @deprecated Decorators are no longer supported for this function. Callers should use an overload that does not accept a `decorators` parameter.
+         */
+        updateImportDeclaration(node: ImportDeclaration, decorators: readonly Decorator[] | undefined, modifiers: readonly Modifier[] | undefined, importClause: ImportClause | undefined, moduleSpecifier: Expression, assertClause: AssertClause | undefined): ImportDeclaration;
+        /**
+         * @deprecated Decorators are no longer supported for this function. Callers should use an overload that does not accept a `decorators` parameter.
+         */
+        createExportAssignment(decorators: readonly Decorator[] | undefined, modifiers: readonly Modifier[] | undefined, isExportEquals: boolean | undefined, expression: Expression): ExportAssignment;
+        /**
+         * @deprecated Decorators are no longer supported for this function. Callers should use an overload that does not accept a `decorators` parameter.
+         */
+        updateExportAssignment(node: ExportAssignment, decorators: readonly Decorator[] | undefined, modifiers: readonly Modifier[] | undefined, expression: Expression): ExportAssignment;
+        /**
+         * @deprecated Decorators are no longer supported for this function. Callers should use an overload that does not accept a `decorators` parameter.
+         */
+        createExportDeclaration(decorators: readonly Decorator[] | undefined, modifiers: readonly Modifier[] | undefined, isTypeOnly: boolean, exportClause: NamedExportBindings | undefined, moduleSpecifier?: Expression, assertClause?: AssertClause): ExportDeclaration;
+        /**
+         * @deprecated Decorators are no longer supported for this function. Callers should use an overload that does not accept a `decorators` parameter.
+         */
+        updateExportDeclaration(node: ExportDeclaration, decorators: readonly Decorator[] | undefined, modifiers: readonly Modifier[] | undefined, isTypeOnly: boolean, exportClause: NamedExportBindings | undefined, moduleSpecifier: Expression | undefined, assertClause: AssertClause | undefined): ExportDeclaration;
+    }
+    export interface CoreTransformationContext {
+        readonly factory: NodeFactory;
+        /** Gets the compiler options supplied to the transformer. */
+        getCompilerOptions(): CompilerOptions;
+        /** Starts a new lexical environment. */
+        startLexicalEnvironment(): void;
+        /** Suspends the current lexical environment, usually after visiting a parameter list. */
+        suspendLexicalEnvironment(): void;
+        /** Resumes a suspended lexical environment, usually before visiting a function body. */
+        resumeLexicalEnvironment(): void;
+        /** Ends a lexical environment, returning any declarations. */
+        endLexicalEnvironment(): Statement[] | undefined;
+        /** Hoists a function declaration to the containing scope. */
+        hoistFunctionDeclaration(node: FunctionDeclaration): void;
+        /** Hoists a variable declaration to the containing scope. */
+        hoistVariableDeclaration(node: Identifier): void;
+    }
+    export interface TransformationContext extends CoreTransformationContext {
+        /** Records a request for a non-scoped emit helper in the current context. */
+        requestEmitHelper(helper: EmitHelper): void;
+        /** Gets and resets the requested non-scoped emit helpers. */
+        readEmitHelpers(): EmitHelper[] | undefined;
+        /** Enables expression substitutions in the pretty printer for the provided SyntaxKind. */
+        enableSubstitution(kind: SyntaxKind): void;
+        /** Determines whether expression substitutions are enabled for the provided node. */
+        isSubstitutionEnabled(node: Node): boolean;
+        /**
+         * Hook used by transformers to substitute expressions just before they
+         * are emitted by the pretty printer.
+         *
+         * NOTE: Transformation hooks should only be modified during `Transformer` initialization,
+         * before returning the `NodeTransformer` callback.
+         */
+        onSubstituteNode: (hint: EmitHint, node: Node) => Node;
+        /**
+         * Enables before/after emit notifications in the pretty printer for the provided
+         * SyntaxKind.
+         */
+        enableEmitNotification(kind: SyntaxKind): void;
+        /**
+         * Determines whether before/after emit notifications should be raised in the pretty
+         * printer when it emits a node.
+         */
+        isEmitNotificationEnabled(node: Node): boolean;
+        /**
+         * Hook used to allow transformers to capture state before or after
+         * the printer emits a node.
+         *
+         * NOTE: Transformation hooks should only be modified during `Transformer` initialization,
+         * before returning the `NodeTransformer` callback.
+         */
+        onEmitNode: (hint: EmitHint, node: Node, emitCallback: (hint: EmitHint, node: Node) => void) => void;
+    }
+    export interface TransformationResult<T extends Node> {
+        /** Gets the transformed source files. */
+        transformed: T[];
+        /** Gets diagnostics for the transformation. */
+        diagnostics?: DiagnosticWithLocation[];
+        /**
+         * Gets a substitute for a node, if one is available; otherwise, returns the original node.
+         *
+         * @param hint A hint as to the intended usage of the node.
+         * @param node The node to substitute.
+         */
+        substituteNode(hint: EmitHint, node: Node): Node;
+        /**
+         * Emits a node with possible notification.
+         *
+         * @param hint A hint as to the intended usage of the node.
+         * @param node The node to emit.
+         * @param emitCallback A callback used to emit the node.
+         */
+        emitNodeWithNotification(hint: EmitHint, node: Node, emitCallback: (hint: EmitHint, node: Node) => void): void;
+        /**
+         * Indicates if a given node needs an emit notification
+         *
+         * @param node The node to emit.
+         */
+        isEmitNotificationEnabled?(node: Node): boolean;
+        /**
+         * Clean up EmitNode entries on any parse-tree nodes.
+         */
+        dispose(): void;
+    }
+    /**
+     * A function that is used to initialize and return a `Transformer` callback, which in turn
+     * will be used to transform one or more nodes.
+     */
+    export type TransformerFactory<T extends Node> = (context: TransformationContext) => Transformer<T>;
+    /**
+     * A function that transforms a node.
+     */
+    export type Transformer<T extends Node> = (node: T) => T;
+    /**
+     * A function that accepts and possibly transforms a node.
+     */
+    export type Visitor = (node: Node) => VisitResult<Node>;
+    export interface NodeVisitor {
+        <T extends Node>(nodes: T, visitor: Visitor | undefined, test?: (node: Node) => boolean, lift?: (node: readonly Node[]) => T): T;
+        <T extends Node>(nodes: T | undefined, visitor: Visitor | undefined, test?: (node: Node) => boolean, lift?: (node: readonly Node[]) => T): T | undefined;
+    }
     export interface NodesVisitor {
         <T extends Node>(nodes: NodeArray<T>, visitor: Visitor | undefined, test?: (node: Node) => boolean, start?: number, count?: number): NodeArray<T>;
         <T extends Node>(nodes: NodeArray<T> | undefined, visitor: Visitor | undefined, test?: (node: Node) => boolean, start?: number, count?: number): NodeArray<T> | undefined;
@@ -4174,11 +4489,7 @@ declare namespace ts {
         negative: boolean;
         base10Value: string;
     }
-    export {};
-}
-declare function setTimeout(handler: (...args: any[]) => void, timeout: number): any;
-declare function clearTimeout(handle: any): void;
-declare namespace ts {
+    export function getNodeMajorVersion(): number | undefined;
     export enum FileWatcherEventKind {
         Created = 0,
         Changed = 1,
@@ -4231,13 +4542,30 @@ declare namespace ts {
     export interface FileWatcher {
         close(): void;
     }
-    export function getNodeMajorVersion(): number | undefined;
     export let sys: System;
-    export {};
-}
-declare namespace ts {
-    type ErrorCallback = (message: DiagnosticMessage, length: number) => void;
-    interface Scanner {
+    export function tokenToString(t: SyntaxKind): string | undefined;
+    export function getPositionOfLineAndCharacter(sourceFile: SourceFileLike, line: number, character: number): number;
+    export function getLineAndCharacterOfPosition(sourceFile: SourceFileLike, position: number): LineAndCharacter;
+    export function isWhiteSpaceLike(ch: number): boolean;
+    /** Does not include line breaks. For that, see isWhiteSpaceLike. */
+    export function isWhiteSpaceSingleLine(ch: number): boolean;
+    export function isLineBreak(ch: number): boolean;
+    export function couldStartTrivia(text: string, pos: number): boolean;
+    export function forEachLeadingCommentRange<U>(text: string, pos: number, cb: (pos: number, end: number, kind: CommentKind, hasTrailingNewLine: boolean) => U): U | undefined;
+    export function forEachLeadingCommentRange<T, U>(text: string, pos: number, cb: (pos: number, end: number, kind: CommentKind, hasTrailingNewLine: boolean, state: T) => U, state: T): U | undefined;
+    export function forEachTrailingCommentRange<U>(text: string, pos: number, cb: (pos: number, end: number, kind: CommentKind, hasTrailingNewLine: boolean) => U): U | undefined;
+    export function forEachTrailingCommentRange<T, U>(text: string, pos: number, cb: (pos: number, end: number, kind: CommentKind, hasTrailingNewLine: boolean, state: T) => U, state: T): U | undefined;
+    export function reduceEachLeadingCommentRange<T, U>(text: string, pos: number, cb: (pos: number, end: number, kind: CommentKind, hasTrailingNewLine: boolean, state: T, memo: U) => U, state: T, initial: U): U | undefined;
+    export function reduceEachTrailingCommentRange<T, U>(text: string, pos: number, cb: (pos: number, end: number, kind: CommentKind, hasTrailingNewLine: boolean, state: T, memo: U) => U, state: T, initial: U): U | undefined;
+    export function getLeadingCommentRanges(text: string, pos: number): CommentRange[] | undefined;
+    export function getTrailingCommentRanges(text: string, pos: number): CommentRange[] | undefined;
+    /** Optionally, get the shebang */
+    export function getShebang(text: string): string | undefined;
+    export function isIdentifierStart(ch: number, languageVersion: ScriptTarget | undefined): boolean;
+    export function isIdentifierPart(ch: number, languageVersion: ScriptTarget | undefined, identifierVariant?: LanguageVariant): boolean;
+    export function createScanner(languageVersion: ScriptTarget, skipTrivia: boolean, languageVariant?: LanguageVariant, textInitial?: string, onError?: ErrorCallback, start?: number, length?: number): Scanner;
+    export type ErrorCallback = (message: DiagnosticMessage, length: number) => void;
+    export interface Scanner {
         getStartPos(): number;
         getToken(): SyntaxKind;
         getTextPos(): number;
@@ -4276,49 +4604,25 @@ declare namespace ts {
         scanRange<T>(start: number, length: number, callback: () => T): T;
         tryScan<T>(callback: () => T): T;
     }
-    function tokenToString(t: SyntaxKind): string | undefined;
-    function getPositionOfLineAndCharacter(sourceFile: SourceFileLike, line: number, character: number): number;
-    function getLineAndCharacterOfPosition(sourceFile: SourceFileLike, position: number): LineAndCharacter;
-    function isWhiteSpaceLike(ch: number): boolean;
-    /** Does not include line breaks. For that, see isWhiteSpaceLike. */
-    function isWhiteSpaceSingleLine(ch: number): boolean;
-    function isLineBreak(ch: number): boolean;
-    function couldStartTrivia(text: string, pos: number): boolean;
-    function forEachLeadingCommentRange<U>(text: string, pos: number, cb: (pos: number, end: number, kind: CommentKind, hasTrailingNewLine: boolean) => U): U | undefined;
-    function forEachLeadingCommentRange<T, U>(text: string, pos: number, cb: (pos: number, end: number, kind: CommentKind, hasTrailingNewLine: boolean, state: T) => U, state: T): U | undefined;
-    function forEachTrailingCommentRange<U>(text: string, pos: number, cb: (pos: number, end: number, kind: CommentKind, hasTrailingNewLine: boolean) => U): U | undefined;
-    function forEachTrailingCommentRange<T, U>(text: string, pos: number, cb: (pos: number, end: number, kind: CommentKind, hasTrailingNewLine: boolean, state: T) => U, state: T): U | undefined;
-    function reduceEachLeadingCommentRange<T, U>(text: string, pos: number, cb: (pos: number, end: number, kind: CommentKind, hasTrailingNewLine: boolean, state: T, memo: U) => U, state: T, initial: U): U | undefined;
-    function reduceEachTrailingCommentRange<T, U>(text: string, pos: number, cb: (pos: number, end: number, kind: CommentKind, hasTrailingNewLine: boolean, state: T, memo: U) => U, state: T, initial: U): U | undefined;
-    function getLeadingCommentRanges(text: string, pos: number): CommentRange[] | undefined;
-    function getTrailingCommentRanges(text: string, pos: number): CommentRange[] | undefined;
-    /** Optionally, get the shebang */
-    function getShebang(text: string): string | undefined;
-    function isIdentifierStart(ch: number, languageVersion: ScriptTarget | undefined): boolean;
-    function isIdentifierPart(ch: number, languageVersion: ScriptTarget | undefined, identifierVariant?: LanguageVariant): boolean;
-    function createScanner(languageVersion: ScriptTarget, skipTrivia: boolean, languageVariant?: LanguageVariant, textInitial?: string, onError?: ErrorCallback, start?: number, length?: number): Scanner;
-}
-declare namespace ts {
-    function isExternalModuleNameRelative(moduleName: string): boolean;
-    function sortAndDeduplicateDiagnostics<T extends Diagnostic>(diagnostics: readonly T[]): SortedReadonlyArray<T>;
-    function getDefaultLibFileName(options: CompilerOptions): string;
-    function textSpanEnd(span: TextSpan): number;
-    function textSpanIsEmpty(span: TextSpan): boolean;
-    function textSpanContainsPosition(span: TextSpan, position: number): boolean;
-    function textSpanContainsTextSpan(span: TextSpan, other: TextSpan): boolean;
-    function textSpanOverlapsWith(span: TextSpan, other: TextSpan): boolean;
-    function textSpanOverlap(span1: TextSpan, span2: TextSpan): TextSpan | undefined;
-    function textSpanIntersectsWithTextSpan(span: TextSpan, other: TextSpan): boolean;
-    function textSpanIntersectsWith(span: TextSpan, start: number, length: number): boolean;
-    function decodedTextSpanIntersectsWith(start1: number, length1: number, start2: number, length2: number): boolean;
-    function textSpanIntersectsWithPosition(span: TextSpan, position: number): boolean;
-    function textSpanIntersection(span1: TextSpan, span2: TextSpan): TextSpan | undefined;
-    function createTextSpan(start: number, length: number): TextSpan;
-    function createTextSpanFromBounds(start: number, end: number): TextSpan;
-    function textChangeRangeNewSpan(range: TextChangeRange): TextSpan;
-    function textChangeRangeIsUnchanged(range: TextChangeRange): boolean;
-    function createTextChangeRange(span: TextSpan, newLength: number): TextChangeRange;
-    let unchangedTextChangeRange: TextChangeRange;
+    export function isExternalModuleNameRelative(moduleName: string): boolean;
+    export function sortAndDeduplicateDiagnostics<T extends Diagnostic>(diagnostics: readonly T[]): SortedReadonlyArray<T>;
+    export function getDefaultLibFileName(options: CompilerOptions): string;
+    export function textSpanEnd(span: TextSpan): number;
+    export function textSpanIsEmpty(span: TextSpan): boolean;
+    export function textSpanContainsPosition(span: TextSpan, position: number): boolean;
+    export function textSpanContainsTextSpan(span: TextSpan, other: TextSpan): boolean;
+    export function textSpanOverlapsWith(span: TextSpan, other: TextSpan): boolean;
+    export function textSpanOverlap(span1: TextSpan, span2: TextSpan): TextSpan | undefined;
+    export function textSpanIntersectsWithTextSpan(span: TextSpan, other: TextSpan): boolean;
+    export function textSpanIntersectsWith(span: TextSpan, start: number, length: number): boolean;
+    export function decodedTextSpanIntersectsWith(start1: number, length1: number, start2: number, length2: number): boolean;
+    export function textSpanIntersectsWithPosition(span: TextSpan, position: number): boolean;
+    export function textSpanIntersection(span1: TextSpan, span2: TextSpan): TextSpan | undefined;
+    export function createTextSpan(start: number, length: number): TextSpan;
+    export function createTextSpanFromBounds(start: number, end: number): TextSpan;
+    export function textChangeRangeNewSpan(range: TextChangeRange): TextSpan;
+    export function textChangeRangeIsUnchanged(range: TextChangeRange): boolean;
+    export function createTextChangeRange(span: TextSpan, newLength: number): TextChangeRange;
     /**
      * Called to merge all the changes that occurred across several versions of a script snapshot
      * into a single change.  i.e. if a user keeps making successive edits to a script we will
@@ -4327,53 +4631,49 @@ declare namespace ts {
      * This function will then merge those changes into a single change range valid between V1 and
      * Vn.
      */
-    function collapseTextChangeRangesAcrossMultipleVersions(changes: readonly TextChangeRange[]): TextChangeRange;
-    function getTypeParameterOwner(d: Declaration): Declaration | undefined;
-    type ParameterPropertyDeclaration = ParameterDeclaration & {
-        parent: ConstructorDeclaration;
-        name: Identifier;
-    };
-    function isParameterPropertyDeclaration(node: Node, parent: Node): node is ParameterPropertyDeclaration;
-    function isEmptyBindingPattern(node: BindingName): node is BindingPattern;
-    function isEmptyBindingElement(node: BindingElement): boolean;
-    function walkUpBindingElementsAndPatterns(binding: BindingElement): VariableDeclaration | ParameterDeclaration;
-    function getCombinedModifierFlags(node: Declaration): ModifierFlags;
-    function getCombinedNodeFlags(node: Node): NodeFlags;
+    export function collapseTextChangeRangesAcrossMultipleVersions(changes: readonly TextChangeRange[]): TextChangeRange;
+    export function getTypeParameterOwner(d: Declaration): Declaration | undefined;
+    export function isParameterPropertyDeclaration(node: Node, parent: Node): node is ParameterPropertyDeclaration;
+    export function isEmptyBindingPattern(node: BindingName): node is BindingPattern;
+    export function isEmptyBindingElement(node: BindingElement): boolean;
+    export function walkUpBindingElementsAndPatterns(binding: BindingElement): VariableDeclaration | ParameterDeclaration;
+    export function getCombinedModifierFlags(node: Declaration): ModifierFlags;
+    export function getCombinedNodeFlags(node: Node): NodeFlags;
     /**
      * Checks to see if the locale is in the appropriate format,
      * and if it is, attempts to set the appropriate language.
      */
-    function validateLocaleAndSetLanguage(locale: string, sys: {
+    export function validateLocaleAndSetLanguage(locale: string, sys: {
         getExecutingFilePath(): string;
         resolvePath(path: string): string;
         fileExists(fileName: string): boolean;
         readFile(fileName: string): string | undefined;
     }, errors?: Push<Diagnostic>): void;
-    function getOriginalNode(node: Node): Node;
-    function getOriginalNode<T extends Node>(node: Node, nodeTest: (node: Node) => node is T): T;
-    function getOriginalNode(node: Node | undefined): Node | undefined;
-    function getOriginalNode<T extends Node>(node: Node | undefined, nodeTest: (node: Node | undefined) => node is T): T | undefined;
+    export function getOriginalNode(node: Node): Node;
+    export function getOriginalNode<T extends Node>(node: Node, nodeTest: (node: Node) => node is T): T;
+    export function getOriginalNode(node: Node | undefined): Node | undefined;
+    export function getOriginalNode<T extends Node>(node: Node | undefined, nodeTest: (node: Node | undefined) => node is T): T | undefined;
     /**
      * Iterates through the parent chain of a node and performs the callback on each parent until the callback
      * returns a truthy value, then returns that value.
      * If no such value is found, it applies the callback until the parent pointer is undefined or the callback returns "quit"
      * At that point findAncestor returns undefined.
      */
-    function findAncestor<T extends Node>(node: Node | undefined, callback: (element: Node) => element is T): T | undefined;
-    function findAncestor(node: Node | undefined, callback: (element: Node) => boolean | "quit"): Node | undefined;
+    export function findAncestor<T extends Node>(node: Node | undefined, callback: (element: Node) => element is T): T | undefined;
+    export function findAncestor(node: Node | undefined, callback: (element: Node) => boolean | "quit"): Node | undefined;
     /**
      * Gets a value indicating whether a node originated in the parse tree.
      *
      * @param node The node to test.
      */
-    function isParseTreeNode(node: Node): boolean;
+    export function isParseTreeNode(node: Node): boolean;
     /**
      * Gets the original parse tree node for a node.
      *
      * @param node The original node.
      * @returns The original parse tree node if found; otherwise, undefined.
      */
-    function getParseTreeNode(node: Node | undefined): Node | undefined;
+    export function getParseTreeNode(node: Node | undefined): Node | undefined;
     /**
      * Gets the original parse tree node for a node.
      *
@@ -4381,22 +4681,22 @@ declare namespace ts {
      * @param nodeTest A callback used to ensure the correct type of parse tree node is returned.
      * @returns The original parse tree node if found; otherwise, undefined.
      */
-    function getParseTreeNode<T extends Node>(node: T | undefined, nodeTest?: (node: Node) => node is T): T | undefined;
+    export function getParseTreeNode<T extends Node>(node: T | undefined, nodeTest?: (node: Node) => node is T): T | undefined;
     /** Add an extra underscore to identifiers that start with two underscores to avoid issues with magic names like '__proto__' */
-    function escapeLeadingUnderscores(identifier: string): __String;
+    export function escapeLeadingUnderscores(identifier: string): __String;
     /**
      * Remove extra underscore from escaped identifier text content.
      *
      * @param identifier The escaped identifier text.
      * @returns The unescaped identifier text.
      */
-    function unescapeLeadingUnderscores(identifier: __String): string;
-    function idText(identifierOrPrivateName: Identifier | PrivateIdentifier): string;
-    function symbolName(symbol: Symbol): string;
-    function getNameOfJSDocTypedef(declaration: JSDocTypedefTag): Identifier | PrivateIdentifier | undefined;
-    function getNameOfDeclaration(declaration: Declaration | Expression | undefined): DeclarationName | undefined;
-    function getDecorators(node: HasDecorators): readonly Decorator[] | undefined;
-    function getModifiers(node: HasModifiers): readonly Modifier[] | undefined;
+    export function unescapeLeadingUnderscores(identifier: __String): string;
+    export function idText(identifierOrPrivateName: Identifier | PrivateIdentifier): string;
+    export function symbolName(symbol: Symbol): string;
+    export function getNameOfJSDocTypedef(declaration: JSDocTypedefTag): Identifier | PrivateIdentifier | undefined;
+    export function getNameOfDeclaration(declaration: Declaration | Expression | undefined): DeclarationName | undefined;
+    export function getDecorators(node: HasDecorators): readonly Decorator[] | undefined;
+    export function getModifiers(node: HasModifiers): readonly Modifier[] | undefined;
     /**
      * Gets the JSDoc parameter tags for the node if present.
      *
@@ -4409,7 +4709,7 @@ declare namespace ts {
      *
      * For binding patterns, parameter tags are matched by position.
      */
-    function getJSDocParameterTags(param: ParameterDeclaration): readonly JSDocParameterTag[];
+    export function getJSDocParameterTags(param: ParameterDeclaration): readonly JSDocParameterTag[];
     /**
      * Gets the JSDoc type parameter tags for the node if present.
      *
@@ -4420,41 +4720,41 @@ declare namespace ts {
      * node are returned first, so in the previous example, the template
      * tag on the containing function expression would be first.
      */
-    function getJSDocTypeParameterTags(param: TypeParameterDeclaration): readonly JSDocTemplateTag[];
+    export function getJSDocTypeParameterTags(param: TypeParameterDeclaration): readonly JSDocTemplateTag[];
     /**
      * Return true if the node has JSDoc parameter tags.
      *
      * @remarks Includes parameter tags that are not directly on the node,
      * for example on a variable declaration whose initializer is a function expression.
      */
-    function hasJSDocParameterTags(node: FunctionLikeDeclaration | SignatureDeclaration): boolean;
+    export function hasJSDocParameterTags(node: FunctionLikeDeclaration | SignatureDeclaration): boolean;
     /** Gets the JSDoc augments tag for the node if present */
-    function getJSDocAugmentsTag(node: Node): JSDocAugmentsTag | undefined;
+    export function getJSDocAugmentsTag(node: Node): JSDocAugmentsTag | undefined;
     /** Gets the JSDoc implements tags for the node if present */
-    function getJSDocImplementsTags(node: Node): readonly JSDocImplementsTag[];
+    export function getJSDocImplementsTags(node: Node): readonly JSDocImplementsTag[];
     /** Gets the JSDoc class tag for the node if present */
-    function getJSDocClassTag(node: Node): JSDocClassTag | undefined;
+    export function getJSDocClassTag(node: Node): JSDocClassTag | undefined;
     /** Gets the JSDoc public tag for the node if present */
-    function getJSDocPublicTag(node: Node): JSDocPublicTag | undefined;
+    export function getJSDocPublicTag(node: Node): JSDocPublicTag | undefined;
     /** Gets the JSDoc private tag for the node if present */
-    function getJSDocPrivateTag(node: Node): JSDocPrivateTag | undefined;
+    export function getJSDocPrivateTag(node: Node): JSDocPrivateTag | undefined;
     /** Gets the JSDoc protected tag for the node if present */
-    function getJSDocProtectedTag(node: Node): JSDocProtectedTag | undefined;
+    export function getJSDocProtectedTag(node: Node): JSDocProtectedTag | undefined;
     /** Gets the JSDoc protected tag for the node if present */
-    function getJSDocReadonlyTag(node: Node): JSDocReadonlyTag | undefined;
-    function getJSDocOverrideTagNoCache(node: Node): JSDocOverrideTag | undefined;
+    export function getJSDocReadonlyTag(node: Node): JSDocReadonlyTag | undefined;
+    export function getJSDocOverrideTagNoCache(node: Node): JSDocOverrideTag | undefined;
     /** Gets the JSDoc deprecated tag for the node if present */
-    function getJSDocDeprecatedTag(node: Node): JSDocDeprecatedTag | undefined;
+    export function getJSDocDeprecatedTag(node: Node): JSDocDeprecatedTag | undefined;
     /** Gets the JSDoc enum tag for the node if present */
-    function getJSDocEnumTag(node: Node): JSDocEnumTag | undefined;
+    export function getJSDocEnumTag(node: Node): JSDocEnumTag | undefined;
     /** Gets the JSDoc this tag for the node if present */
-    function getJSDocThisTag(node: Node): JSDocThisTag | undefined;
+    export function getJSDocThisTag(node: Node): JSDocThisTag | undefined;
     /** Gets the JSDoc return tag for the node if present */
-    function getJSDocReturnTag(node: Node): JSDocReturnTag | undefined;
+    export function getJSDocReturnTag(node: Node): JSDocReturnTag | undefined;
     /** Gets the JSDoc template tag for the node if present */
-    function getJSDocTemplateTag(node: Node): JSDocTemplateTag | undefined;
+    export function getJSDocTemplateTag(node: Node): JSDocTemplateTag | undefined;
     /** Gets the JSDoc type tag for the node if present and valid */
-    function getJSDocTypeTag(node: Node): JSDocTypeTag | undefined;
+    export function getJSDocTypeTag(node: Node): JSDocTypeTag | undefined;
     /**
      * Gets the type node for the node if provided via JSDoc.
      *
@@ -4466,22 +4766,22 @@ declare namespace ts {
      * node are examined first, so in the previous example, the type
      * tag directly on the node would be returned.
      */
-    function getJSDocType(node: Node): TypeNode | undefined;
+    export function getJSDocType(node: Node): TypeNode | undefined;
     /**
      * Gets the return type node for the node if provided via JSDoc return tag or type tag.
      *
      * @remarks `getJSDocReturnTag` just gets the whole JSDoc tag. This function
      * gets the type from inside the braces, after the fat arrow, etc.
      */
-    function getJSDocReturnType(node: Node): TypeNode | undefined;
+    export function getJSDocReturnType(node: Node): TypeNode | undefined;
     /** Get all JSDoc tags related to a node, including those on parent nodes. */
-    function getJSDocTags(node: Node): readonly JSDocTag[];
+    export function getJSDocTags(node: Node): readonly JSDocTag[];
     /** Gets all JSDoc tags that match a specified predicate */
-    function getAllJSDocTags<T extends JSDocTag>(node: Node, predicate: (tag: JSDocTag) => tag is T): readonly T[];
+    export function getAllJSDocTags<T extends JSDocTag>(node: Node, predicate: (tag: JSDocTag) => tag is T): readonly T[];
     /** Gets all JSDoc tags of a specified kind */
-    function getAllJSDocTagsOfKind(node: Node, kind: SyntaxKind): readonly JSDocTag[];
+    export function getAllJSDocTagsOfKind(node: Node, kind: SyntaxKind): readonly JSDocTag[];
     /** Gets the text of a jsdoc comment, flattening links to their text. */
-    function getTextOfJSDocComment(comment?: string | NodeArray<JSDocComment>): string | undefined;
+    export function getTextOfJSDocComment(comment?: string | NodeArray<JSDocComment>): string | undefined;
     /**
      * Gets the effective type parameters. If the node was parsed in a
      * JavaScript file, gets the type parameters from the `@template` tag from JSDoc.
@@ -4492,375 +4792,370 @@ declare namespace ts {
      * /** @type {Id} /
      * function id(x) { return x }
      */
-    function getEffectiveTypeParameterDeclarations(node: DeclarationWithTypeParameters): readonly TypeParameterDeclaration[];
-    function getEffectiveConstraintOfTypeParameter(node: TypeParameterDeclaration): TypeNode | undefined;
-    function isMemberName(node: Node): node is MemberName;
-    function isPropertyAccessChain(node: Node): node is PropertyAccessChain;
-    function isElementAccessChain(node: Node): node is ElementAccessChain;
-    function isCallChain(node: Node): node is CallChain;
-    function isOptionalChain(node: Node): node is PropertyAccessChain | ElementAccessChain | CallChain | NonNullChain;
-    function isNullishCoalesce(node: Node): boolean;
-    function isConstTypeReference(node: Node): boolean;
-    function skipPartiallyEmittedExpressions(node: Expression): Expression;
-    function skipPartiallyEmittedExpressions(node: Node): Node;
-    function isNonNullChain(node: Node): node is NonNullChain;
-    function isBreakOrContinueStatement(node: Node): node is BreakOrContinueStatement;
-    function isNamedExportBindings(node: Node): node is NamedExportBindings;
-    function isUnparsedTextLike(node: Node): node is UnparsedTextLike;
-    function isUnparsedNode(node: Node): node is UnparsedNode;
-    function isJSDocPropertyLikeTag(node: Node): node is JSDocPropertyLikeTag;
+    export function getEffectiveTypeParameterDeclarations(node: DeclarationWithTypeParameters): readonly TypeParameterDeclaration[];
+    export function getEffectiveConstraintOfTypeParameter(node: TypeParameterDeclaration): TypeNode | undefined;
+    export function isMemberName(node: Node): node is MemberName;
+    export function isPropertyAccessChain(node: Node): node is PropertyAccessChain;
+    export function isElementAccessChain(node: Node): node is ElementAccessChain;
+    export function isCallChain(node: Node): node is CallChain;
+    export function isOptionalChain(node: Node): node is PropertyAccessChain | ElementAccessChain | CallChain | NonNullChain;
+    export function isNullishCoalesce(node: Node): boolean;
+    export function isConstTypeReference(node: Node): boolean;
+    export function skipPartiallyEmittedExpressions(node: Expression): Expression;
+    export function skipPartiallyEmittedExpressions(node: Node): Node;
+    export function isNonNullChain(node: Node): node is NonNullChain;
+    export function isBreakOrContinueStatement(node: Node): node is BreakOrContinueStatement;
+    export function isNamedExportBindings(node: Node): node is NamedExportBindings;
+    export function isUnparsedTextLike(node: Node): node is UnparsedTextLike;
+    export function isUnparsedNode(node: Node): node is UnparsedNode;
+    export function isJSDocPropertyLikeTag(node: Node): node is JSDocPropertyLikeTag;
     /**
      * True if kind is of some token syntax kind.
      * For example, this is true for an IfKeyword but not for an IfStatement.
      * Literals are considered tokens, except TemplateLiteral, but does include TemplateHead/Middle/Tail.
      */
-    function isTokenKind(kind: SyntaxKind): boolean;
+    export function isTokenKind(kind: SyntaxKind): boolean;
     /**
      * True if node is of some token syntax kind.
      * For example, this is true for an IfKeyword but not for an IfStatement.
      * Literals are considered tokens, except TemplateLiteral, but does include TemplateHead/Middle/Tail.
      */
-    function isToken(n: Node): boolean;
-    function isLiteralExpression(node: Node): node is LiteralExpression;
-    function isTemplateLiteralToken(node: Node): node is TemplateLiteralToken;
-    function isTemplateMiddleOrTemplateTail(node: Node): node is TemplateMiddle | TemplateTail;
-    function isImportOrExportSpecifier(node: Node): node is ImportSpecifier | ExportSpecifier;
-    function isTypeOnlyImportOrExportDeclaration(node: Node): node is TypeOnlyAliasDeclaration;
-    function isAssertionKey(node: Node): node is AssertionKey;
-    function isStringTextContainingNode(node: Node): node is StringLiteral | TemplateLiteralToken;
-    function isModifier(node: Node): node is Modifier;
-    function isEntityName(node: Node): node is EntityName;
-    function isPropertyName(node: Node): node is PropertyName;
-    function isBindingName(node: Node): node is BindingName;
-    function isFunctionLike(node: Node | undefined): node is SignatureDeclaration;
-    function isClassElement(node: Node): node is ClassElement;
-    function isClassLike(node: Node): node is ClassLikeDeclaration;
-    function isAccessor(node: Node): node is AccessorDeclaration;
-    function isAutoAccessorPropertyDeclaration(node: Node): node is AutoAccessorPropertyDeclaration;
-    function isModifierLike(node: Node): node is ModifierLike;
-    function isTypeElement(node: Node): node is TypeElement;
-    function isClassOrTypeElement(node: Node): node is ClassElement | TypeElement;
-    function isObjectLiteralElementLike(node: Node): node is ObjectLiteralElementLike;
+    export function isToken(n: Node): boolean;
+    export function isLiteralExpression(node: Node): node is LiteralExpression;
+    export function isTemplateLiteralToken(node: Node): node is TemplateLiteralToken;
+    export function isTemplateMiddleOrTemplateTail(node: Node): node is TemplateMiddle | TemplateTail;
+    export function isImportOrExportSpecifier(node: Node): node is ImportSpecifier | ExportSpecifier;
+    export function isTypeOnlyImportOrExportDeclaration(node: Node): node is TypeOnlyAliasDeclaration;
+    export function isAssertionKey(node: Node): node is AssertionKey;
+    export function isStringTextContainingNode(node: Node): node is StringLiteral | TemplateLiteralToken;
+    export function isModifier(node: Node): node is Modifier;
+    export function isEntityName(node: Node): node is EntityName;
+    export function isPropertyName(node: Node): node is PropertyName;
+    export function isBindingName(node: Node): node is BindingName;
+    export function isFunctionLike(node: Node | undefined): node is SignatureDeclaration;
+    export function isClassElement(node: Node): node is ClassElement;
+    export function isClassLike(node: Node): node is ClassLikeDeclaration;
+    export function isAccessor(node: Node): node is AccessorDeclaration;
+    export function isAutoAccessorPropertyDeclaration(node: Node): node is AutoAccessorPropertyDeclaration;
+    export function isModifierLike(node: Node): node is ModifierLike;
+    export function isTypeElement(node: Node): node is TypeElement;
+    export function isClassOrTypeElement(node: Node): node is ClassElement | TypeElement;
+    export function isObjectLiteralElementLike(node: Node): node is ObjectLiteralElementLike;
     /**
      * Node test that determines whether a node is a valid type node.
      * This differs from the `isPartOfTypeNode` function which determines whether a node is *part*
      * of a TypeNode.
      */
-    function isTypeNode(node: Node): node is TypeNode;
-    function isFunctionOrConstructorTypeNode(node: Node): node is FunctionTypeNode | ConstructorTypeNode;
-    function isPropertyAccessOrQualifiedName(node: Node): node is PropertyAccessExpression | QualifiedName;
-    function isCallLikeExpression(node: Node): node is CallLikeExpression;
-    function isCallOrNewExpression(node: Node): node is CallExpression | NewExpression;
-    function isTemplateLiteral(node: Node): node is TemplateLiteral;
-    function isAssertionExpression(node: Node): node is AssertionExpression;
-    function isIterationStatement(node: Node, lookInLabeledStatements: false): node is IterationStatement;
-    function isIterationStatement(node: Node, lookInLabeledStatements: boolean): node is IterationStatement | LabeledStatement;
-    function isJsxOpeningLikeElement(node: Node): node is JsxOpeningLikeElement;
-    function isCaseOrDefaultClause(node: Node): node is CaseOrDefaultClause;
+    export function isTypeNode(node: Node): node is TypeNode;
+    export function isFunctionOrConstructorTypeNode(node: Node): node is FunctionTypeNode | ConstructorTypeNode;
+    export function isPropertyAccessOrQualifiedName(node: Node): node is PropertyAccessExpression | QualifiedName;
+    export function isCallLikeExpression(node: Node): node is CallLikeExpression;
+    export function isCallOrNewExpression(node: Node): node is CallExpression | NewExpression;
+    export function isTemplateLiteral(node: Node): node is TemplateLiteral;
+    export function isAssertionExpression(node: Node): node is AssertionExpression;
+    export function isIterationStatement(node: Node, lookInLabeledStatements: false): node is IterationStatement;
+    export function isIterationStatement(node: Node, lookInLabeledStatements: boolean): node is IterationStatement | LabeledStatement;
+    export function isJsxOpeningLikeElement(node: Node): node is JsxOpeningLikeElement;
+    export function isCaseOrDefaultClause(node: Node): node is CaseOrDefaultClause;
     /** True if node is of a kind that may contain comment text. */
-    function isJSDocCommentContainingNode(node: Node): boolean;
-    function isSetAccessor(node: Node): node is SetAccessorDeclaration;
-    function isGetAccessor(node: Node): node is GetAccessorDeclaration;
+    export function isJSDocCommentContainingNode(node: Node): boolean;
+    export function isSetAccessor(node: Node): node is SetAccessorDeclaration;
+    export function isGetAccessor(node: Node): node is GetAccessorDeclaration;
     /** True if has initializer node attached to it. */
-    function hasOnlyExpressionInitializer(node: Node): node is HasExpressionInitializer;
-    function isObjectLiteralElement(node: Node): node is ObjectLiteralElement;
-    function isStringLiteralLike(node: Node): node is StringLiteralLike;
-    function isJSDocLinkLike(node: Node): node is JSDocLink | JSDocLinkCode | JSDocLinkPlain;
-    function hasRestParameter(s: SignatureDeclaration | JSDocSignature): boolean;
-    function isRestParameter(node: ParameterDeclaration | JSDocParameterTag): boolean;
-}
-declare namespace ts {
-    const factory: NodeFactory;
-    function createUnparsedSourceFile(text: string): UnparsedSource;
-    function createUnparsedSourceFile(inputFile: InputFiles, type: "js" | "dts", stripInternal?: boolean): UnparsedSource;
-    function createUnparsedSourceFile(text: string, mapPath: string | undefined, map: string | undefined): UnparsedSource;
-    function createInputFiles(javascriptText: string, declarationText: string): InputFiles;
-    function createInputFiles(readFileText: (path: string) => string | undefined, javascriptPath: string, javascriptMapPath: string | undefined, declarationPath: string, declarationMapPath: string | undefined, buildInfoPath: string | undefined): InputFiles;
-    function createInputFiles(javascriptText: string, declarationText: string, javascriptMapPath: string | undefined, javascriptMapText: string | undefined, declarationMapPath: string | undefined, declarationMapText: string | undefined): InputFiles;
+    export function hasOnlyExpressionInitializer(node: Node): node is HasExpressionInitializer;
+    export function isObjectLiteralElement(node: Node): node is ObjectLiteralElement;
+    export function isStringLiteralLike(node: Node): node is StringLiteralLike;
+    export function isJSDocLinkLike(node: Node): node is JSDocLink | JSDocLinkCode | JSDocLinkPlain;
+    export function hasRestParameter(s: SignatureDeclaration | JSDocSignature): boolean;
+    export function isRestParameter(node: ParameterDeclaration | JSDocParameterTag): boolean;
+    export let unchangedTextChangeRange: TextChangeRange;
+    export type ParameterPropertyDeclaration = ParameterDeclaration & {
+        parent: ConstructorDeclaration;
+        name: Identifier;
+    };
+    export function createUnparsedSourceFile(text: string): UnparsedSource;
+    export function createUnparsedSourceFile(inputFile: InputFiles, type: "js" | "dts", stripInternal?: boolean): UnparsedSource;
+    export function createUnparsedSourceFile(text: string, mapPath: string | undefined, map: string | undefined): UnparsedSource;
+    export function createInputFiles(javascriptText: string, declarationText: string): InputFiles;
+    export function createInputFiles(readFileText: (path: string) => string | undefined, javascriptPath: string, javascriptMapPath: string | undefined, declarationPath: string, declarationMapPath: string | undefined, buildInfoPath: string | undefined): InputFiles;
+    export function createInputFiles(javascriptText: string, declarationText: string, javascriptMapPath: string | undefined, javascriptMapText: string | undefined, declarationMapPath: string | undefined, declarationMapText: string | undefined): InputFiles;
     /**
      * Create an external source map source file reference
      */
-    function createSourceMapSource(fileName: string, text: string, skipTrivia?: (pos: number) => number): SourceMapSource;
-    function setOriginalNode<T extends Node>(node: T, original: Node | undefined): T;
-}
-declare namespace ts {
+    export function createSourceMapSource(fileName: string, text: string, skipTrivia?: (pos: number) => number): SourceMapSource;
+    export function setOriginalNode<T extends Node>(node: T, original: Node | undefined): T;
+    export const factory: NodeFactory;
     /**
      * Clears any `EmitNode` entries from parse-tree nodes.
      * @param sourceFile A source file.
      */
-    function disposeEmitNodes(sourceFile: SourceFile | undefined): void;
+    export function disposeEmitNodes(sourceFile: SourceFile | undefined): void;
     /**
      * Sets flags that control emit behavior of a node.
      */
-    function setEmitFlags<T extends Node>(node: T, emitFlags: EmitFlags): T;
+    export function setEmitFlags<T extends Node>(node: T, emitFlags: EmitFlags): T;
     /**
      * Gets a custom text range to use when emitting source maps.
      */
-    function getSourceMapRange(node: Node): SourceMapRange;
+    export function getSourceMapRange(node: Node): SourceMapRange;
     /**
      * Sets a custom text range to use when emitting source maps.
      */
-    function setSourceMapRange<T extends Node>(node: T, range: SourceMapRange | undefined): T;
+    export function setSourceMapRange<T extends Node>(node: T, range: SourceMapRange | undefined): T;
     /**
      * Gets the TextRange to use for source maps for a token of a node.
      */
-    function getTokenSourceMapRange(node: Node, token: SyntaxKind): SourceMapRange | undefined;
+    export function getTokenSourceMapRange(node: Node, token: SyntaxKind): SourceMapRange | undefined;
     /**
      * Sets the TextRange to use for source maps for a token of a node.
      */
-    function setTokenSourceMapRange<T extends Node>(node: T, token: SyntaxKind, range: SourceMapRange | undefined): T;
+    export function setTokenSourceMapRange<T extends Node>(node: T, token: SyntaxKind, range: SourceMapRange | undefined): T;
     /**
      * Gets a custom text range to use when emitting comments.
      */
-    function getCommentRange(node: Node): TextRange;
+    export function getCommentRange(node: Node): TextRange;
     /**
      * Sets a custom text range to use when emitting comments.
      */
-    function setCommentRange<T extends Node>(node: T, range: TextRange): T;
-    function getSyntheticLeadingComments(node: Node): SynthesizedComment[] | undefined;
-    function setSyntheticLeadingComments<T extends Node>(node: T, comments: SynthesizedComment[] | undefined): T;
-    function addSyntheticLeadingComment<T extends Node>(node: T, kind: SyntaxKind.SingleLineCommentTrivia | SyntaxKind.MultiLineCommentTrivia, text: string, hasTrailingNewLine?: boolean): T;
-    function getSyntheticTrailingComments(node: Node): SynthesizedComment[] | undefined;
-    function setSyntheticTrailingComments<T extends Node>(node: T, comments: SynthesizedComment[] | undefined): T;
-    function addSyntheticTrailingComment<T extends Node>(node: T, kind: SyntaxKind.SingleLineCommentTrivia | SyntaxKind.MultiLineCommentTrivia, text: string, hasTrailingNewLine?: boolean): T;
-    function moveSyntheticComments<T extends Node>(node: T, original: Node): T;
+    export function setCommentRange<T extends Node>(node: T, range: TextRange): T;
+    export function getSyntheticLeadingComments(node: Node): SynthesizedComment[] | undefined;
+    export function setSyntheticLeadingComments<T extends Node>(node: T, comments: SynthesizedComment[] | undefined): T;
+    export function addSyntheticLeadingComment<T extends Node>(node: T, kind: SyntaxKind.SingleLineCommentTrivia | SyntaxKind.MultiLineCommentTrivia, text: string, hasTrailingNewLine?: boolean): T;
+    export function getSyntheticTrailingComments(node: Node): SynthesizedComment[] | undefined;
+    export function setSyntheticTrailingComments<T extends Node>(node: T, comments: SynthesizedComment[] | undefined): T;
+    export function addSyntheticTrailingComment<T extends Node>(node: T, kind: SyntaxKind.SingleLineCommentTrivia | SyntaxKind.MultiLineCommentTrivia, text: string, hasTrailingNewLine?: boolean): T;
+    export function moveSyntheticComments<T extends Node>(node: T, original: Node): T;
     /**
      * Gets the constant value to emit for an expression representing an enum.
      */
-    function getConstantValue(node: AccessExpression): string | number | undefined;
+    export function getConstantValue(node: AccessExpression): string | number | undefined;
     /**
      * Sets the constant value to emit for an expression.
      */
-    function setConstantValue(node: AccessExpression, value: string | number): AccessExpression;
+    export function setConstantValue(node: AccessExpression, value: string | number): AccessExpression;
     /**
      * Adds an EmitHelper to a node.
      */
-    function addEmitHelper<T extends Node>(node: T, helper: EmitHelper): T;
+    export function addEmitHelper<T extends Node>(node: T, helper: EmitHelper): T;
     /**
      * Add EmitHelpers to a node.
      */
-    function addEmitHelpers<T extends Node>(node: T, helpers: EmitHelper[] | undefined): T;
+    export function addEmitHelpers<T extends Node>(node: T, helpers: EmitHelper[] | undefined): T;
     /**
      * Removes an EmitHelper from a node.
      */
-    function removeEmitHelper(node: Node, helper: EmitHelper): boolean;
+    export function removeEmitHelper(node: Node, helper: EmitHelper): boolean;
     /**
      * Gets the EmitHelpers of a node.
      */
-    function getEmitHelpers(node: Node): EmitHelper[] | undefined;
+    export function getEmitHelpers(node: Node): EmitHelper[] | undefined;
     /**
      * Moves matching emit helpers from a source node to a target node.
      */
-    function moveEmitHelpers(source: Node, target: Node, predicate: (helper: EmitHelper) => boolean): void;
-}
-declare namespace ts {
-    function isNumericLiteral(node: Node): node is NumericLiteral;
-    function isBigIntLiteral(node: Node): node is BigIntLiteral;
-    function isStringLiteral(node: Node): node is StringLiteral;
-    function isJsxText(node: Node): node is JsxText;
-    function isRegularExpressionLiteral(node: Node): node is RegularExpressionLiteral;
-    function isNoSubstitutionTemplateLiteral(node: Node): node is NoSubstitutionTemplateLiteral;
-    function isTemplateHead(node: Node): node is TemplateHead;
-    function isTemplateMiddle(node: Node): node is TemplateMiddle;
-    function isTemplateTail(node: Node): node is TemplateTail;
-    function isDotDotDotToken(node: Node): node is DotDotDotToken;
-    function isPlusToken(node: Node): node is PlusToken;
-    function isMinusToken(node: Node): node is MinusToken;
-    function isAsteriskToken(node: Node): node is AsteriskToken;
-    function isIdentifier(node: Node): node is Identifier;
-    function isPrivateIdentifier(node: Node): node is PrivateIdentifier;
-    function isQualifiedName(node: Node): node is QualifiedName;
-    function isComputedPropertyName(node: Node): node is ComputedPropertyName;
-    function isTypeParameterDeclaration(node: Node): node is TypeParameterDeclaration;
-    function isParameter(node: Node): node is ParameterDeclaration;
-    function isDecorator(node: Node): node is Decorator;
-    function isPropertySignature(node: Node): node is PropertySignature;
-    function isPropertyDeclaration(node: Node): node is PropertyDeclaration;
-    function isMethodSignature(node: Node): node is MethodSignature;
-    function isMethodDeclaration(node: Node): node is MethodDeclaration;
-    function isClassStaticBlockDeclaration(node: Node): node is ClassStaticBlockDeclaration;
-    function isConstructorDeclaration(node: Node): node is ConstructorDeclaration;
-    function isGetAccessorDeclaration(node: Node): node is GetAccessorDeclaration;
-    function isSetAccessorDeclaration(node: Node): node is SetAccessorDeclaration;
-    function isCallSignatureDeclaration(node: Node): node is CallSignatureDeclaration;
-    function isConstructSignatureDeclaration(node: Node): node is ConstructSignatureDeclaration;
-    function isIndexSignatureDeclaration(node: Node): node is IndexSignatureDeclaration;
-    function isTypePredicateNode(node: Node): node is TypePredicateNode;
-    function isTypeReferenceNode(node: Node): node is TypeReferenceNode;
-    function isFunctionTypeNode(node: Node): node is FunctionTypeNode;
-    function isConstructorTypeNode(node: Node): node is ConstructorTypeNode;
-    function isTypeQueryNode(node: Node): node is TypeQueryNode;
-    function isTypeLiteralNode(node: Node): node is TypeLiteralNode;
-    function isArrayTypeNode(node: Node): node is ArrayTypeNode;
-    function isTupleTypeNode(node: Node): node is TupleTypeNode;
-    function isNamedTupleMember(node: Node): node is NamedTupleMember;
-    function isOptionalTypeNode(node: Node): node is OptionalTypeNode;
-    function isRestTypeNode(node: Node): node is RestTypeNode;
-    function isUnionTypeNode(node: Node): node is UnionTypeNode;
-    function isIntersectionTypeNode(node: Node): node is IntersectionTypeNode;
-    function isConditionalTypeNode(node: Node): node is ConditionalTypeNode;
-    function isInferTypeNode(node: Node): node is InferTypeNode;
-    function isParenthesizedTypeNode(node: Node): node is ParenthesizedTypeNode;
-    function isThisTypeNode(node: Node): node is ThisTypeNode;
-    function isTypeOperatorNode(node: Node): node is TypeOperatorNode;
-    function isIndexedAccessTypeNode(node: Node): node is IndexedAccessTypeNode;
-    function isMappedTypeNode(node: Node): node is MappedTypeNode;
-    function isLiteralTypeNode(node: Node): node is LiteralTypeNode;
-    function isImportTypeNode(node: Node): node is ImportTypeNode;
-    function isTemplateLiteralTypeSpan(node: Node): node is TemplateLiteralTypeSpan;
-    function isTemplateLiteralTypeNode(node: Node): node is TemplateLiteralTypeNode;
-    function isObjectBindingPattern(node: Node): node is ObjectBindingPattern;
-    function isArrayBindingPattern(node: Node): node is ArrayBindingPattern;
-    function isBindingElement(node: Node): node is BindingElement;
-    function isArrayLiteralExpression(node: Node): node is ArrayLiteralExpression;
-    function isObjectLiteralExpression(node: Node): node is ObjectLiteralExpression;
-    function isPropertyAccessExpression(node: Node): node is PropertyAccessExpression;
-    function isElementAccessExpression(node: Node): node is ElementAccessExpression;
-    function isCallExpression(node: Node): node is CallExpression;
-    function isNewExpression(node: Node): node is NewExpression;
-    function isTaggedTemplateExpression(node: Node): node is TaggedTemplateExpression;
-    function isTypeAssertionExpression(node: Node): node is TypeAssertion;
-    function isParenthesizedExpression(node: Node): node is ParenthesizedExpression;
-    function isFunctionExpression(node: Node): node is FunctionExpression;
-    function isArrowFunction(node: Node): node is ArrowFunction;
-    function isDeleteExpression(node: Node): node is DeleteExpression;
-    function isTypeOfExpression(node: Node): node is TypeOfExpression;
-    function isVoidExpression(node: Node): node is VoidExpression;
-    function isAwaitExpression(node: Node): node is AwaitExpression;
-    function isPrefixUnaryExpression(node: Node): node is PrefixUnaryExpression;
-    function isPostfixUnaryExpression(node: Node): node is PostfixUnaryExpression;
-    function isBinaryExpression(node: Node): node is BinaryExpression;
-    function isConditionalExpression(node: Node): node is ConditionalExpression;
-    function isTemplateExpression(node: Node): node is TemplateExpression;
-    function isYieldExpression(node: Node): node is YieldExpression;
-    function isSpreadElement(node: Node): node is SpreadElement;
-    function isClassExpression(node: Node): node is ClassExpression;
-    function isOmittedExpression(node: Node): node is OmittedExpression;
-    function isExpressionWithTypeArguments(node: Node): node is ExpressionWithTypeArguments;
-    function isAsExpression(node: Node): node is AsExpression;
-    function isSatisfiesExpression(node: Node): node is SatisfiesExpression;
-    function isNonNullExpression(node: Node): node is NonNullExpression;
-    function isMetaProperty(node: Node): node is MetaProperty;
-    function isSyntheticExpression(node: Node): node is SyntheticExpression;
-    function isPartiallyEmittedExpression(node: Node): node is PartiallyEmittedExpression;
-    function isCommaListExpression(node: Node): node is CommaListExpression;
-    function isTemplateSpan(node: Node): node is TemplateSpan;
-    function isSemicolonClassElement(node: Node): node is SemicolonClassElement;
-    function isBlock(node: Node): node is Block;
-    function isVariableStatement(node: Node): node is VariableStatement;
-    function isEmptyStatement(node: Node): node is EmptyStatement;
-    function isExpressionStatement(node: Node): node is ExpressionStatement;
-    function isIfStatement(node: Node): node is IfStatement;
-    function isDoStatement(node: Node): node is DoStatement;
-    function isWhileStatement(node: Node): node is WhileStatement;
-    function isForStatement(node: Node): node is ForStatement;
-    function isForInStatement(node: Node): node is ForInStatement;
-    function isForOfStatement(node: Node): node is ForOfStatement;
-    function isContinueStatement(node: Node): node is ContinueStatement;
-    function isBreakStatement(node: Node): node is BreakStatement;
-    function isReturnStatement(node: Node): node is ReturnStatement;
-    function isWithStatement(node: Node): node is WithStatement;
-    function isSwitchStatement(node: Node): node is SwitchStatement;
-    function isLabeledStatement(node: Node): node is LabeledStatement;
-    function isThrowStatement(node: Node): node is ThrowStatement;
-    function isTryStatement(node: Node): node is TryStatement;
-    function isDebuggerStatement(node: Node): node is DebuggerStatement;
-    function isVariableDeclaration(node: Node): node is VariableDeclaration;
-    function isVariableDeclarationList(node: Node): node is VariableDeclarationList;
-    function isFunctionDeclaration(node: Node): node is FunctionDeclaration;
-    function isClassDeclaration(node: Node): node is ClassDeclaration;
-    function isInterfaceDeclaration(node: Node): node is InterfaceDeclaration;
-    function isTypeAliasDeclaration(node: Node): node is TypeAliasDeclaration;
-    function isEnumDeclaration(node: Node): node is EnumDeclaration;
-    function isModuleDeclaration(node: Node): node is ModuleDeclaration;
-    function isModuleBlock(node: Node): node is ModuleBlock;
-    function isCaseBlock(node: Node): node is CaseBlock;
-    function isNamespaceExportDeclaration(node: Node): node is NamespaceExportDeclaration;
-    function isImportEqualsDeclaration(node: Node): node is ImportEqualsDeclaration;
-    function isImportDeclaration(node: Node): node is ImportDeclaration;
-    function isImportClause(node: Node): node is ImportClause;
-    function isImportTypeAssertionContainer(node: Node): node is ImportTypeAssertionContainer;
-    function isAssertClause(node: Node): node is AssertClause;
-    function isAssertEntry(node: Node): node is AssertEntry;
-    function isNamespaceImport(node: Node): node is NamespaceImport;
-    function isNamespaceExport(node: Node): node is NamespaceExport;
-    function isNamedImports(node: Node): node is NamedImports;
-    function isImportSpecifier(node: Node): node is ImportSpecifier;
-    function isExportAssignment(node: Node): node is ExportAssignment;
-    function isExportDeclaration(node: Node): node is ExportDeclaration;
-    function isNamedExports(node: Node): node is NamedExports;
-    function isExportSpecifier(node: Node): node is ExportSpecifier;
-    function isMissingDeclaration(node: Node): node is MissingDeclaration;
-    function isNotEmittedStatement(node: Node): node is NotEmittedStatement;
-    function isExternalModuleReference(node: Node): node is ExternalModuleReference;
-    function isJsxElement(node: Node): node is JsxElement;
-    function isJsxSelfClosingElement(node: Node): node is JsxSelfClosingElement;
-    function isJsxOpeningElement(node: Node): node is JsxOpeningElement;
-    function isJsxClosingElement(node: Node): node is JsxClosingElement;
-    function isJsxFragment(node: Node): node is JsxFragment;
-    function isJsxOpeningFragment(node: Node): node is JsxOpeningFragment;
-    function isJsxClosingFragment(node: Node): node is JsxClosingFragment;
-    function isJsxAttribute(node: Node): node is JsxAttribute;
-    function isJsxAttributes(node: Node): node is JsxAttributes;
-    function isJsxSpreadAttribute(node: Node): node is JsxSpreadAttribute;
-    function isJsxExpression(node: Node): node is JsxExpression;
-    function isCaseClause(node: Node): node is CaseClause;
-    function isDefaultClause(node: Node): node is DefaultClause;
-    function isHeritageClause(node: Node): node is HeritageClause;
-    function isCatchClause(node: Node): node is CatchClause;
-    function isPropertyAssignment(node: Node): node is PropertyAssignment;
-    function isShorthandPropertyAssignment(node: Node): node is ShorthandPropertyAssignment;
-    function isSpreadAssignment(node: Node): node is SpreadAssignment;
-    function isEnumMember(node: Node): node is EnumMember;
-    function isUnparsedPrepend(node: Node): node is UnparsedPrepend;
-    function isSourceFile(node: Node): node is SourceFile;
-    function isBundle(node: Node): node is Bundle;
-    function isUnparsedSource(node: Node): node is UnparsedSource;
-    function isJSDocTypeExpression(node: Node): node is JSDocTypeExpression;
-    function isJSDocNameReference(node: Node): node is JSDocNameReference;
-    function isJSDocMemberName(node: Node): node is JSDocMemberName;
-    function isJSDocLink(node: Node): node is JSDocLink;
-    function isJSDocLinkCode(node: Node): node is JSDocLinkCode;
-    function isJSDocLinkPlain(node: Node): node is JSDocLinkPlain;
-    function isJSDocAllType(node: Node): node is JSDocAllType;
-    function isJSDocUnknownType(node: Node): node is JSDocUnknownType;
-    function isJSDocNullableType(node: Node): node is JSDocNullableType;
-    function isJSDocNonNullableType(node: Node): node is JSDocNonNullableType;
-    function isJSDocOptionalType(node: Node): node is JSDocOptionalType;
-    function isJSDocFunctionType(node: Node): node is JSDocFunctionType;
-    function isJSDocVariadicType(node: Node): node is JSDocVariadicType;
-    function isJSDocNamepathType(node: Node): node is JSDocNamepathType;
-    function isJSDoc(node: Node): node is JSDoc;
-    function isJSDocTypeLiteral(node: Node): node is JSDocTypeLiteral;
-    function isJSDocSignature(node: Node): node is JSDocSignature;
-    function isJSDocAugmentsTag(node: Node): node is JSDocAugmentsTag;
-    function isJSDocAuthorTag(node: Node): node is JSDocAuthorTag;
-    function isJSDocClassTag(node: Node): node is JSDocClassTag;
-    function isJSDocCallbackTag(node: Node): node is JSDocCallbackTag;
-    function isJSDocPublicTag(node: Node): node is JSDocPublicTag;
-    function isJSDocPrivateTag(node: Node): node is JSDocPrivateTag;
-    function isJSDocProtectedTag(node: Node): node is JSDocProtectedTag;
-    function isJSDocReadonlyTag(node: Node): node is JSDocReadonlyTag;
-    function isJSDocOverrideTag(node: Node): node is JSDocOverrideTag;
-    function isJSDocDeprecatedTag(node: Node): node is JSDocDeprecatedTag;
-    function isJSDocSeeTag(node: Node): node is JSDocSeeTag;
-    function isJSDocEnumTag(node: Node): node is JSDocEnumTag;
-    function isJSDocParameterTag(node: Node): node is JSDocParameterTag;
-    function isJSDocReturnTag(node: Node): node is JSDocReturnTag;
-    function isJSDocThisTag(node: Node): node is JSDocThisTag;
-    function isJSDocTypeTag(node: Node): node is JSDocTypeTag;
-    function isJSDocTemplateTag(node: Node): node is JSDocTemplateTag;
-    function isJSDocTypedefTag(node: Node): node is JSDocTypedefTag;
-    function isJSDocUnknownTag(node: Node): node is JSDocUnknownTag;
-    function isJSDocPropertyTag(node: Node): node is JSDocPropertyTag;
-    function isJSDocImplementsTag(node: Node): node is JSDocImplementsTag;
-}
-declare namespace ts {
-    function setTextRange<T extends TextRange>(range: T, location: TextRange | undefined): T;
-    function canHaveModifiers(node: Node): node is HasModifiers;
-    function canHaveDecorators(node: Node): node is HasDecorators;
-}
-declare namespace ts {
+    export function moveEmitHelpers(source: Node, target: Node, predicate: (helper: EmitHelper) => boolean): void;
+    export function isNumericLiteral(node: Node): node is NumericLiteral;
+    export function isBigIntLiteral(node: Node): node is BigIntLiteral;
+    export function isStringLiteral(node: Node): node is StringLiteral;
+    export function isJsxText(node: Node): node is JsxText;
+    export function isRegularExpressionLiteral(node: Node): node is RegularExpressionLiteral;
+    export function isNoSubstitutionTemplateLiteral(node: Node): node is NoSubstitutionTemplateLiteral;
+    export function isTemplateHead(node: Node): node is TemplateHead;
+    export function isTemplateMiddle(node: Node): node is TemplateMiddle;
+    export function isTemplateTail(node: Node): node is TemplateTail;
+    export function isDotDotDotToken(node: Node): node is DotDotDotToken;
+    export function isPlusToken(node: Node): node is PlusToken;
+    export function isMinusToken(node: Node): node is MinusToken;
+    export function isAsteriskToken(node: Node): node is AsteriskToken;
+    export function isIdentifier(node: Node): node is Identifier;
+    export function isPrivateIdentifier(node: Node): node is PrivateIdentifier;
+    export function isQualifiedName(node: Node): node is QualifiedName;
+    export function isComputedPropertyName(node: Node): node is ComputedPropertyName;
+    export function isTypeParameterDeclaration(node: Node): node is TypeParameterDeclaration;
+    export function isParameter(node: Node): node is ParameterDeclaration;
+    export function isDecorator(node: Node): node is Decorator;
+    export function isPropertySignature(node: Node): node is PropertySignature;
+    export function isPropertyDeclaration(node: Node): node is PropertyDeclaration;
+    export function isMethodSignature(node: Node): node is MethodSignature;
+    export function isMethodDeclaration(node: Node): node is MethodDeclaration;
+    export function isClassStaticBlockDeclaration(node: Node): node is ClassStaticBlockDeclaration;
+    export function isConstructorDeclaration(node: Node): node is ConstructorDeclaration;
+    export function isGetAccessorDeclaration(node: Node): node is GetAccessorDeclaration;
+    export function isSetAccessorDeclaration(node: Node): node is SetAccessorDeclaration;
+    export function isCallSignatureDeclaration(node: Node): node is CallSignatureDeclaration;
+    export function isConstructSignatureDeclaration(node: Node): node is ConstructSignatureDeclaration;
+    export function isIndexSignatureDeclaration(node: Node): node is IndexSignatureDeclaration;
+    export function isTypePredicateNode(node: Node): node is TypePredicateNode;
+    export function isTypeReferenceNode(node: Node): node is TypeReferenceNode;
+    export function isFunctionTypeNode(node: Node): node is FunctionTypeNode;
+    export function isConstructorTypeNode(node: Node): node is ConstructorTypeNode;
+    export function isTypeQueryNode(node: Node): node is TypeQueryNode;
+    export function isTypeLiteralNode(node: Node): node is TypeLiteralNode;
+    export function isArrayTypeNode(node: Node): node is ArrayTypeNode;
+    export function isTupleTypeNode(node: Node): node is TupleTypeNode;
+    export function isNamedTupleMember(node: Node): node is NamedTupleMember;
+    export function isOptionalTypeNode(node: Node): node is OptionalTypeNode;
+    export function isRestTypeNode(node: Node): node is RestTypeNode;
+    export function isUnionTypeNode(node: Node): node is UnionTypeNode;
+    export function isIntersectionTypeNode(node: Node): node is IntersectionTypeNode;
+    export function isConditionalTypeNode(node: Node): node is ConditionalTypeNode;
+    export function isInferTypeNode(node: Node): node is InferTypeNode;
+    export function isParenthesizedTypeNode(node: Node): node is ParenthesizedTypeNode;
+    export function isThisTypeNode(node: Node): node is ThisTypeNode;
+    export function isTypeOperatorNode(node: Node): node is TypeOperatorNode;
+    export function isIndexedAccessTypeNode(node: Node): node is IndexedAccessTypeNode;
+    export function isMappedTypeNode(node: Node): node is MappedTypeNode;
+    export function isLiteralTypeNode(node: Node): node is LiteralTypeNode;
+    export function isImportTypeNode(node: Node): node is ImportTypeNode;
+    export function isTemplateLiteralTypeSpan(node: Node): node is TemplateLiteralTypeSpan;
+    export function isTemplateLiteralTypeNode(node: Node): node is TemplateLiteralTypeNode;
+    export function isObjectBindingPattern(node: Node): node is ObjectBindingPattern;
+    export function isArrayBindingPattern(node: Node): node is ArrayBindingPattern;
+    export function isBindingElement(node: Node): node is BindingElement;
+    export function isArrayLiteralExpression(node: Node): node is ArrayLiteralExpression;
+    export function isObjectLiteralExpression(node: Node): node is ObjectLiteralExpression;
+    export function isPropertyAccessExpression(node: Node): node is PropertyAccessExpression;
+    export function isElementAccessExpression(node: Node): node is ElementAccessExpression;
+    export function isCallExpression(node: Node): node is CallExpression;
+    export function isNewExpression(node: Node): node is NewExpression;
+    export function isTaggedTemplateExpression(node: Node): node is TaggedTemplateExpression;
+    export function isTypeAssertionExpression(node: Node): node is TypeAssertion;
+    export function isParenthesizedExpression(node: Node): node is ParenthesizedExpression;
+    export function isFunctionExpression(node: Node): node is FunctionExpression;
+    export function isArrowFunction(node: Node): node is ArrowFunction;
+    export function isDeleteExpression(node: Node): node is DeleteExpression;
+    export function isTypeOfExpression(node: Node): node is TypeOfExpression;
+    export function isVoidExpression(node: Node): node is VoidExpression;
+    export function isAwaitExpression(node: Node): node is AwaitExpression;
+    export function isPrefixUnaryExpression(node: Node): node is PrefixUnaryExpression;
+    export function isPostfixUnaryExpression(node: Node): node is PostfixUnaryExpression;
+    export function isBinaryExpression(node: Node): node is BinaryExpression;
+    export function isConditionalExpression(node: Node): node is ConditionalExpression;
+    export function isTemplateExpression(node: Node): node is TemplateExpression;
+    export function isYieldExpression(node: Node): node is YieldExpression;
+    export function isSpreadElement(node: Node): node is SpreadElement;
+    export function isClassExpression(node: Node): node is ClassExpression;
+    export function isOmittedExpression(node: Node): node is OmittedExpression;
+    export function isExpressionWithTypeArguments(node: Node): node is ExpressionWithTypeArguments;
+    export function isAsExpression(node: Node): node is AsExpression;
+    export function isSatisfiesExpression(node: Node): node is SatisfiesExpression;
+    export function isNonNullExpression(node: Node): node is NonNullExpression;
+    export function isMetaProperty(node: Node): node is MetaProperty;
+    export function isSyntheticExpression(node: Node): node is SyntheticExpression;
+    export function isPartiallyEmittedExpression(node: Node): node is PartiallyEmittedExpression;
+    export function isCommaListExpression(node: Node): node is CommaListExpression;
+    export function isTemplateSpan(node: Node): node is TemplateSpan;
+    export function isSemicolonClassElement(node: Node): node is SemicolonClassElement;
+    export function isBlock(node: Node): node is Block;
+    export function isVariableStatement(node: Node): node is VariableStatement;
+    export function isEmptyStatement(node: Node): node is EmptyStatement;
+    export function isExpressionStatement(node: Node): node is ExpressionStatement;
+    export function isIfStatement(node: Node): node is IfStatement;
+    export function isDoStatement(node: Node): node is DoStatement;
+    export function isWhileStatement(node: Node): node is WhileStatement;
+    export function isForStatement(node: Node): node is ForStatement;
+    export function isForInStatement(node: Node): node is ForInStatement;
+    export function isForOfStatement(node: Node): node is ForOfStatement;
+    export function isContinueStatement(node: Node): node is ContinueStatement;
+    export function isBreakStatement(node: Node): node is BreakStatement;
+    export function isReturnStatement(node: Node): node is ReturnStatement;
+    export function isWithStatement(node: Node): node is WithStatement;
+    export function isSwitchStatement(node: Node): node is SwitchStatement;
+    export function isLabeledStatement(node: Node): node is LabeledStatement;
+    export function isThrowStatement(node: Node): node is ThrowStatement;
+    export function isTryStatement(node: Node): node is TryStatement;
+    export function isDebuggerStatement(node: Node): node is DebuggerStatement;
+    export function isVariableDeclaration(node: Node): node is VariableDeclaration;
+    export function isVariableDeclarationList(node: Node): node is VariableDeclarationList;
+    export function isFunctionDeclaration(node: Node): node is FunctionDeclaration;
+    export function isClassDeclaration(node: Node): node is ClassDeclaration;
+    export function isInterfaceDeclaration(node: Node): node is InterfaceDeclaration;
+    export function isTypeAliasDeclaration(node: Node): node is TypeAliasDeclaration;
+    export function isEnumDeclaration(node: Node): node is EnumDeclaration;
+    export function isModuleDeclaration(node: Node): node is ModuleDeclaration;
+    export function isModuleBlock(node: Node): node is ModuleBlock;
+    export function isCaseBlock(node: Node): node is CaseBlock;
+    export function isNamespaceExportDeclaration(node: Node): node is NamespaceExportDeclaration;
+    export function isImportEqualsDeclaration(node: Node): node is ImportEqualsDeclaration;
+    export function isImportDeclaration(node: Node): node is ImportDeclaration;
+    export function isImportClause(node: Node): node is ImportClause;
+    export function isImportTypeAssertionContainer(node: Node): node is ImportTypeAssertionContainer;
+    export function isAssertClause(node: Node): node is AssertClause;
+    export function isAssertEntry(node: Node): node is AssertEntry;
+    export function isNamespaceImport(node: Node): node is NamespaceImport;
+    export function isNamespaceExport(node: Node): node is NamespaceExport;
+    export function isNamedImports(node: Node): node is NamedImports;
+    export function isImportSpecifier(node: Node): node is ImportSpecifier;
+    export function isExportAssignment(node: Node): node is ExportAssignment;
+    export function isExportDeclaration(node: Node): node is ExportDeclaration;
+    export function isNamedExports(node: Node): node is NamedExports;
+    export function isExportSpecifier(node: Node): node is ExportSpecifier;
+    export function isMissingDeclaration(node: Node): node is MissingDeclaration;
+    export function isNotEmittedStatement(node: Node): node is NotEmittedStatement;
+    export function isExternalModuleReference(node: Node): node is ExternalModuleReference;
+    export function isJsxElement(node: Node): node is JsxElement;
+    export function isJsxSelfClosingElement(node: Node): node is JsxSelfClosingElement;
+    export function isJsxOpeningElement(node: Node): node is JsxOpeningElement;
+    export function isJsxClosingElement(node: Node): node is JsxClosingElement;
+    export function isJsxFragment(node: Node): node is JsxFragment;
+    export function isJsxOpeningFragment(node: Node): node is JsxOpeningFragment;
+    export function isJsxClosingFragment(node: Node): node is JsxClosingFragment;
+    export function isJsxAttribute(node: Node): node is JsxAttribute;
+    export function isJsxAttributes(node: Node): node is JsxAttributes;
+    export function isJsxSpreadAttribute(node: Node): node is JsxSpreadAttribute;
+    export function isJsxExpression(node: Node): node is JsxExpression;
+    export function isCaseClause(node: Node): node is CaseClause;
+    export function isDefaultClause(node: Node): node is DefaultClause;
+    export function isHeritageClause(node: Node): node is HeritageClause;
+    export function isCatchClause(node: Node): node is CatchClause;
+    export function isPropertyAssignment(node: Node): node is PropertyAssignment;
+    export function isShorthandPropertyAssignment(node: Node): node is ShorthandPropertyAssignment;
+    export function isSpreadAssignment(node: Node): node is SpreadAssignment;
+    export function isEnumMember(node: Node): node is EnumMember;
+    export function isUnparsedPrepend(node: Node): node is UnparsedPrepend;
+    export function isSourceFile(node: Node): node is SourceFile;
+    export function isBundle(node: Node): node is Bundle;
+    export function isUnparsedSource(node: Node): node is UnparsedSource;
+    export function isJSDocTypeExpression(node: Node): node is JSDocTypeExpression;
+    export function isJSDocNameReference(node: Node): node is JSDocNameReference;
+    export function isJSDocMemberName(node: Node): node is JSDocMemberName;
+    export function isJSDocLink(node: Node): node is JSDocLink;
+    export function isJSDocLinkCode(node: Node): node is JSDocLinkCode;
+    export function isJSDocLinkPlain(node: Node): node is JSDocLinkPlain;
+    export function isJSDocAllType(node: Node): node is JSDocAllType;
+    export function isJSDocUnknownType(node: Node): node is JSDocUnknownType;
+    export function isJSDocNullableType(node: Node): node is JSDocNullableType;
+    export function isJSDocNonNullableType(node: Node): node is JSDocNonNullableType;
+    export function isJSDocOptionalType(node: Node): node is JSDocOptionalType;
+    export function isJSDocFunctionType(node: Node): node is JSDocFunctionType;
+    export function isJSDocVariadicType(node: Node): node is JSDocVariadicType;
+    export function isJSDocNamepathType(node: Node): node is JSDocNamepathType;
+    export function isJSDoc(node: Node): node is JSDoc;
+    export function isJSDocTypeLiteral(node: Node): node is JSDocTypeLiteral;
+    export function isJSDocSignature(node: Node): node is JSDocSignature;
+    export function isJSDocAugmentsTag(node: Node): node is JSDocAugmentsTag;
+    export function isJSDocAuthorTag(node: Node): node is JSDocAuthorTag;
+    export function isJSDocClassTag(node: Node): node is JSDocClassTag;
+    export function isJSDocCallbackTag(node: Node): node is JSDocCallbackTag;
+    export function isJSDocPublicTag(node: Node): node is JSDocPublicTag;
+    export function isJSDocPrivateTag(node: Node): node is JSDocPrivateTag;
+    export function isJSDocProtectedTag(node: Node): node is JSDocProtectedTag;
+    export function isJSDocReadonlyTag(node: Node): node is JSDocReadonlyTag;
+    export function isJSDocOverrideTag(node: Node): node is JSDocOverrideTag;
+    export function isJSDocDeprecatedTag(node: Node): node is JSDocDeprecatedTag;
+    export function isJSDocSeeTag(node: Node): node is JSDocSeeTag;
+    export function isJSDocEnumTag(node: Node): node is JSDocEnumTag;
+    export function isJSDocParameterTag(node: Node): node is JSDocParameterTag;
+    export function isJSDocReturnTag(node: Node): node is JSDocReturnTag;
+    export function isJSDocThisTag(node: Node): node is JSDocThisTag;
+    export function isJSDocTypeTag(node: Node): node is JSDocTypeTag;
+    export function isJSDocTemplateTag(node: Node): node is JSDocTemplateTag;
+    export function isJSDocTypedefTag(node: Node): node is JSDocTypedefTag;
+    export function isJSDocUnknownTag(node: Node): node is JSDocUnknownTag;
+    export function isJSDocPropertyTag(node: Node): node is JSDocPropertyTag;
+    export function isJSDocImplementsTag(node: Node): node is JSDocImplementsTag;
+    export function setTextRange<T extends TextRange>(range: T, location: TextRange | undefined): T;
+    export function canHaveModifiers(node: Node): node is HasModifiers;
+    export function canHaveDecorators(node: Node): node is HasDecorators;
     /**
      * Invokes a callback for each child of the given node. The 'cbNode' callback is invoked for all child nodes
      * stored in properties. If a 'cbNodes' callback is specified, it is invoked for embedded arrays; otherwise,
@@ -4875,21 +5170,6 @@ declare namespace ts {
      * that they appear in the source code. The language service depends on this property to locate nodes by position.
      */
     export function forEachChild<T>(node: Node, cbNode: (node: Node) => T | undefined, cbNodes?: (nodes: NodeArray<Node>) => T | undefined): T | undefined;
-    export interface CreateSourceFileOptions {
-        languageVersion: ScriptTarget;
-        /**
-         * Controls the format the file is detected as - this can be derived from only the path
-         * and files on disk, but needs to be done with a module resolution cache in scope to be performant.
-         * This is usually `undefined` for compilations that do not have `moduleResolution` values of `node16` or `nodenext`.
-         */
-        impliedNodeFormat?: ModuleKind.ESNext | ModuleKind.CommonJS;
-        /**
-         * Controls how module-y-ness is set for the given file. Usually the result of calling
-         * `getSetExternalModuleIndicator` on a valid `CompilerOptions` object. If not present, the default
-         * check specified by `isFileProbablyExternalModule` will be used to set the field.
-         */
-        setExternalModuleIndicator?: (file: SourceFile) => void;
-    }
     export function createSourceFile(fileName: string, sourceText: string, languageVersionOrOptions: ScriptTarget | CreateSourceFileOptions, setParentNodes?: boolean, scriptKind?: ScriptKind): SourceFile;
     export function parseIsolatedEntityName(text: string, languageVersion: ScriptTarget): EntityName | undefined;
     /**
@@ -4900,26 +5180,22 @@ declare namespace ts {
     export function parseJsonText(fileName: string, sourceText: string): JsonSourceFile;
     export function isExternalModule(file: SourceFile): boolean;
     export function updateSourceFile(sourceFile: SourceFile, newText: string, textChangeRange: TextChangeRange, aggressiveChecks?: boolean): SourceFile;
-    export {};
-}
-declare namespace ts {
-    export function parseCommandLine(commandLine: readonly string[], readFile?: (path: string) => string | undefined): ParsedCommandLine;
-    export type DiagnosticReporter = (diagnostic: Diagnostic) => void;
-    /**
-     * Reports config file diagnostics
-     */
-    export interface ConfigFileDiagnosticsReporter {
+    export interface CreateSourceFileOptions {
+        languageVersion: ScriptTarget;
         /**
-         * Reports unrecoverable error when parsing config file
+         * Controls the format the file is detected as - this can be derived from only the path
+         * and files on disk, but needs to be done with a module resolution cache in scope to be performant.
+         * This is usually `undefined` for compilations that do not have `moduleResolution` values of `node16` or `nodenext`.
          */
-        onUnRecoverableConfigFileDiagnostic: DiagnosticReporter;
-    }
-    /**
-     * Interface extending ParseConfigHost to support ParseConfigFile that reads config file and reports errors
-     */
-    export interface ParseConfigFileHost extends ParseConfigHost, ConfigFileDiagnosticsReporter {
-        getCurrentDirectory(): string;
+        impliedNodeFormat?: ModuleKind.ESNext | ModuleKind.CommonJS;
+        /**
+         * Controls how module-y-ness is set for the given file. Usually the result of calling
+         * `getSetExternalModuleIndicator` on a valid `CompilerOptions` object. If not present, the default
+         * check specified by `isFileProbablyExternalModule` will be used to set the field.
+         */
+        setExternalModuleIndicator?: (file: SourceFile) => void;
     }
+    export function parseCommandLine(commandLine: readonly string[], readFile?: (path: string) => string | undefined): ParsedCommandLine;
     /**
      * Reads the config file, reports errors if any and exits if the config file cannot be found
      */
@@ -4966,6 +5242,30 @@ declare namespace ts {
      *    file to. e.g. outDir
      */
     export function parseJsonSourceFileConfigFileContent(sourceFile: TsConfigSourceFile, host: ParseConfigHost, basePath: string, existingOptions?: CompilerOptions, configFileName?: string, resolutionStack?: Path[], extraFileExtensions?: readonly FileExtensionInfo[], extendedConfigCache?: Map<ExtendedConfigCacheEntry>, existingWatchOptions?: WatchOptions): ParsedCommandLine;
+    export function convertCompilerOptionsFromJson(jsonOptions: any, basePath: string, configFileName?: string): {
+        options: CompilerOptions;
+        errors: Diagnostic[];
+    };
+    export function convertTypeAcquisitionFromJson(jsonOptions: any, basePath: string, configFileName?: string): {
+        options: TypeAcquisition;
+        errors: Diagnostic[];
+    };
+    export type DiagnosticReporter = (diagnostic: Diagnostic) => void;
+    /**
+     * Reports config file diagnostics
+     */
+    export interface ConfigFileDiagnosticsReporter {
+        /**
+         * Reports unrecoverable error when parsing config file
+         */
+        onUnRecoverableConfigFileDiagnostic: DiagnosticReporter;
+    }
+    /**
+     * Interface extending ParseConfigHost to support ParseConfigFile that reads config file and reports errors
+     */
+    export interface ParseConfigFileHost extends ParseConfigHost, ConfigFileDiagnosticsReporter {
+        getCurrentDirectory(): string;
+    }
     export interface ParsedTsconfig {
         raw: any;
         options?: CompilerOptions;
@@ -4980,17 +5280,6 @@ declare namespace ts {
         extendedResult: TsConfigSourceFile;
         extendedConfig: ParsedTsconfig | undefined;
     }
-    export function convertCompilerOptionsFromJson(jsonOptions: any, basePath: string, configFileName?: string): {
-        options: CompilerOptions;
-        errors: Diagnostic[];
-    };
-    export function convertTypeAcquisitionFromJson(jsonOptions: any, basePath: string, configFileName?: string): {
-        options: TypeAcquisition;
-        errors: Diagnostic[];
-    };
-    export {};
-}
-declare namespace ts {
     export function getEffectiveTypeRoots(options: CompilerOptions, host: GetEffectiveTypeRootsHost): string[] | undefined;
     /**
      * @param {string | undefined} containingFile - file that contains type reference directive, can be undefined if containing file is unknown.
@@ -5007,6 +5296,12 @@ declare namespace ts {
      *   this list is only the set of defaults that are implicitly included.
      */
     export function getAutomaticTypeDirectiveNames(options: CompilerOptions, host: ModuleResolutionHost): string[];
+    export function createModuleResolutionCache(currentDirectory: string, getCanonicalFileName: (s: string) => string, options?: CompilerOptions): ModuleResolutionCache;
+    export function createTypeReferenceDirectiveResolutionCache(currentDirectory: string, getCanonicalFileName: (s: string) => string, options?: CompilerOptions, packageJsonInfoCache?: PackageJsonInfoCache): TypeReferenceDirectiveResolutionCache;
+    export function resolveModuleNameFromCache(moduleName: string, containingFile: string, cache: ModuleResolutionCache, mode?: ModuleKind.CommonJS | ModuleKind.ESNext): ResolvedModuleWithFailedLookupLocations | undefined;
+    export function resolveModuleName(moduleName: string, containingFile: string, compilerOptions: CompilerOptions, host: ModuleResolutionHost, cache?: ModuleResolutionCache, redirectedReference?: ResolvedProjectReference, resolutionMode?: ModuleKind.CommonJS | ModuleKind.ESNext): ResolvedModuleWithFailedLookupLocations;
+    export function nodeModuleNameResolver(moduleName: string, containingFile: string, compilerOptions: CompilerOptions, host: ModuleResolutionHost, cache?: ModuleResolutionCache, redirectedReference?: ResolvedProjectReference): ResolvedModuleWithFailedLookupLocations;
+    export function classicNameResolver(moduleName: string, containingFile: string, compilerOptions: CompilerOptions, host: ModuleResolutionHost, cache?: NonRelativeModuleNameResolutionCache, redirectedReference?: ResolvedProjectReference): ResolvedModuleWithFailedLookupLocations;
     export interface TypeReferenceDirectiveResolutionCache extends PerDirectoryResolutionCache<ResolvedTypeReferenceDirectiveWithFailedLookupLocations>, PackageJsonInfoCache {
     }
     export interface ModeAwareCache<T> {
@@ -5047,15 +5342,6 @@ declare namespace ts {
         get(directory: string): ResolvedModuleWithFailedLookupLocations | undefined;
         set(directory: string, result: ResolvedModuleWithFailedLookupLocations): void;
     }
-    export function createModuleResolutionCache(currentDirectory: string, getCanonicalFileName: (s: string) => string, options?: CompilerOptions): ModuleResolutionCache;
-    export function createTypeReferenceDirectiveResolutionCache(currentDirectory: string, getCanonicalFileName: (s: string) => string, options?: CompilerOptions, packageJsonInfoCache?: PackageJsonInfoCache): TypeReferenceDirectiveResolutionCache;
-    export function resolveModuleNameFromCache(moduleName: string, containingFile: string, cache: ModuleResolutionCache, mode?: ModuleKind.CommonJS | ModuleKind.ESNext): ResolvedModuleWithFailedLookupLocations | undefined;
-    export function resolveModuleName(moduleName: string, containingFile: string, compilerOptions: CompilerOptions, host: ModuleResolutionHost, cache?: ModuleResolutionCache, redirectedReference?: ResolvedProjectReference, resolutionMode?: ModuleKind.CommonJS | ModuleKind.ESNext): ResolvedModuleWithFailedLookupLocations;
-    export function nodeModuleNameResolver(moduleName: string, containingFile: string, compilerOptions: CompilerOptions, host: ModuleResolutionHost, cache?: ModuleResolutionCache, redirectedReference?: ResolvedProjectReference): ResolvedModuleWithFailedLookupLocations;
-    export function classicNameResolver(moduleName: string, containingFile: string, compilerOptions: CompilerOptions, host: ModuleResolutionHost, cache?: NonRelativeModuleNameResolutionCache, redirectedReference?: ResolvedProjectReference): ResolvedModuleWithFailedLookupLocations;
-    export {};
-}
-declare namespace ts {
     /**
      * Visits a Node using the supplied visitor, possibly returning a new Node in its place.
      *
@@ -5064,7 +5350,7 @@ declare namespace ts {
      * @param test A callback to execute to verify the Node is valid.
      * @param lift An optional callback to execute to lift a NodeArray into a valid Node.
      */
-    function visitNode<T extends Node>(node: T, visitor: Visitor | undefined, test?: (node: Node) => boolean, lift?: (node: readonly Node[]) => T): T;
+    export function visitNode<T extends Node>(node: T, visitor: Visitor | undefined, test?: (node: Node) => boolean, lift?: (node: readonly Node[]) => T): T;
     /**
      * Visits a Node using the supplied visitor, possibly returning a new Node in its place.
      *
@@ -5073,7 +5359,7 @@ declare namespace ts {
      * @param test A callback to execute to verify the Node is valid.
      * @param lift An optional callback to execute to lift a NodeArray into a valid Node.
      */
-    function visitNode<T extends Node>(node: T | undefined, visitor: Visitor | undefined, test?: (node: Node) => boolean, lift?: (node: readonly Node[]) => T): T | undefined;
+    export function visitNode<T extends Node>(node: T | undefined, visitor: Visitor | undefined, test?: (node: Node) => boolean, lift?: (node: readonly Node[]) => T): T | undefined;
     /**
      * Visits a NodeArray using the supplied visitor, possibly returning a new NodeArray in its place.
      *
@@ -5083,7 +5369,7 @@ declare namespace ts {
      * @param start An optional value indicating the starting offset at which to start visiting.
      * @param count An optional value indicating the maximum number of nodes to visit.
      */
-    function visitNodes<T extends Node>(nodes: NodeArray<T>, visitor: Visitor | undefined, test?: (node: Node) => boolean, start?: number, count?: number): NodeArray<T>;
+    export function visitNodes<T extends Node>(nodes: NodeArray<T>, visitor: Visitor | undefined, test?: (node: Node) => boolean, start?: number, count?: number): NodeArray<T>;
     /**
      * Visits a NodeArray using the supplied visitor, possibly returning a new NodeArray in its place.
      *
@@ -5093,37 +5379,37 @@ declare namespace ts {
      * @param start An optional value indicating the starting offset at which to start visiting.
      * @param count An optional value indicating the maximum number of nodes to visit.
      */
-    function visitNodes<T extends Node>(nodes: NodeArray<T> | undefined, visitor: Visitor | undefined, test?: (node: Node) => boolean, start?: number, count?: number): NodeArray<T> | undefined;
+    export function visitNodes<T extends Node>(nodes: NodeArray<T> | undefined, visitor: Visitor | undefined, test?: (node: Node) => boolean, start?: number, count?: number): NodeArray<T> | undefined;
     /**
      * Starts a new lexical environment and visits a statement list, ending the lexical environment
      * and merging hoisted declarations upon completion.
      */
-    function visitLexicalEnvironment(statements: NodeArray<Statement>, visitor: Visitor, context: TransformationContext, start?: number, ensureUseStrict?: boolean, nodesVisitor?: NodesVisitor): NodeArray<Statement>;
+    export function visitLexicalEnvironment(statements: NodeArray<Statement>, visitor: Visitor, context: TransformationContext, start?: number, ensureUseStrict?: boolean, nodesVisitor?: NodesVisitor): NodeArray<Statement>;
     /**
      * Starts a new lexical environment and visits a parameter list, suspending the lexical
      * environment upon completion.
      */
-    function visitParameterList(nodes: NodeArray<ParameterDeclaration>, visitor: Visitor, context: TransformationContext, nodesVisitor?: NodesVisitor): NodeArray<ParameterDeclaration>;
-    function visitParameterList(nodes: NodeArray<ParameterDeclaration> | undefined, visitor: Visitor, context: TransformationContext, nodesVisitor?: NodesVisitor): NodeArray<ParameterDeclaration> | undefined;
+    export function visitParameterList(nodes: NodeArray<ParameterDeclaration>, visitor: Visitor, context: TransformationContext, nodesVisitor?: NodesVisitor): NodeArray<ParameterDeclaration>;
+    export function visitParameterList(nodes: NodeArray<ParameterDeclaration> | undefined, visitor: Visitor, context: TransformationContext, nodesVisitor?: NodesVisitor): NodeArray<ParameterDeclaration> | undefined;
     /**
      * Resumes a suspended lexical environment and visits a function body, ending the lexical
      * environment and merging hoisted declarations upon completion.
      */
-    function visitFunctionBody(node: FunctionBody, visitor: Visitor, context: TransformationContext): FunctionBody;
+    export function visitFunctionBody(node: FunctionBody, visitor: Visitor, context: TransformationContext): FunctionBody;
     /**
      * Resumes a suspended lexical environment and visits a function body, ending the lexical
      * environment and merging hoisted declarations upon completion.
      */
-    function visitFunctionBody(node: FunctionBody | undefined, visitor: Visitor, context: TransformationContext): FunctionBody | undefined;
+    export function visitFunctionBody(node: FunctionBody | undefined, visitor: Visitor, context: TransformationContext): FunctionBody | undefined;
     /**
      * Resumes a suspended lexical environment and visits a concise body, ending the lexical
      * environment and merging hoisted declarations upon completion.
      */
-    function visitFunctionBody(node: ConciseBody, visitor: Visitor, context: TransformationContext): ConciseBody;
+    export function visitFunctionBody(node: ConciseBody, visitor: Visitor, context: TransformationContext): ConciseBody;
     /**
      * Visits an iteration body, adding any block-scoped variables required by the transformation.
      */
-    function visitIterationBody(body: Statement, visitor: Visitor, context: TransformationContext): Statement;
+    export function visitIterationBody(body: Statement, visitor: Visitor, context: TransformationContext): Statement;
     /**
      * Visits each child of a Node using the supplied visitor, possibly returning a new Node of the same kind in its place.
      *
@@ -5131,7 +5417,7 @@ declare namespace ts {
      * @param visitor The callback used to visit each child.
      * @param context A lexical environment context for the visitor.
      */
-    function visitEachChild<T extends Node>(node: T, visitor: Visitor, context: TransformationContext): T;
+    export function visitEachChild<T extends Node>(node: T, visitor: Visitor, context: TransformationContext): T;
     /**
      * Visits each child of a Node using the supplied visitor, possibly returning a new Node of the same kind in its place.
      *
@@ -5139,23 +5425,14 @@ declare namespace ts {
      * @param visitor The callback used to visit each child.
      * @param context A lexical environment context for the visitor.
      */
-    function visitEachChild<T extends Node>(node: T | undefined, visitor: Visitor, context: TransformationContext, nodesVisitor?: typeof visitNodes, tokenVisitor?: Visitor): T | undefined;
-}
-declare namespace ts {
-    function getTsBuildInfoEmitOutputFilePath(options: CompilerOptions): string | undefined;
-    function getOutputFileNames(commandLine: ParsedCommandLine, inputFileName: string, ignoreCase: boolean): readonly string[];
-    function createPrinter(printerOptions?: PrinterOptions, handlers?: PrintHandlers): Printer;
-}
-declare namespace ts {
+    export function visitEachChild<T extends Node>(node: T | undefined, visitor: Visitor, context: TransformationContext, nodesVisitor?: typeof visitNodes, tokenVisitor?: Visitor): T | undefined;
+    export function getTsBuildInfoEmitOutputFilePath(options: CompilerOptions): string | undefined;
+    export function getOutputFileNames(commandLine: ParsedCommandLine, inputFileName: string, ignoreCase: boolean): readonly string[];
+    export function createPrinter(printerOptions?: PrinterOptions, handlers?: PrintHandlers): Printer;
     export function findConfigFile(searchPath: string, fileExists: (fileName: string) => boolean, configName?: string): string | undefined;
     export function resolveTripleslashReference(moduleName: string, containingFile: string): string;
     export function createCompilerHost(options: CompilerOptions, setParentNodes?: boolean): CompilerHost;
     export function getPreEmitDiagnostics(program: Program, sourceFile?: SourceFile, cancellationToken?: CancellationToken): readonly Diagnostic[];
-    export interface FormatDiagnosticsHost {
-        getCurrentDirectory(): string;
-        getCanonicalFileName(fileName: string): string;
-        getNewLine(): string;
-    }
     export function formatDiagnostics(diagnostics: readonly Diagnostic[], host: FormatDiagnosticsHost): string;
     export function formatDiagnostic(diagnostic: Diagnostic, host: FormatDiagnosticsHost): string;
     export function formatDiagnosticsWithColorAndContext(diagnostics: readonly Diagnostic[], host: FormatDiagnosticsHost): string;
@@ -5223,34 +5500,50 @@ declare namespace ts {
      * @returns A 'Program' object.
      */
     export function createProgram(rootNames: readonly string[], options: CompilerOptions, host?: CompilerHost, oldProgram?: Program, configFileParsingDiagnostics?: readonly Diagnostic[]): Program;
-    /** @deprecated */ export interface ResolveProjectReferencePathHost {
-        fileExists(fileName: string): boolean;
-    }
     /**
      * Returns the target config filename of a project reference.
      * Note: The file might not exist.
      */
     export function resolveProjectReferencePath(ref: ProjectReference): ResolvedConfigFileName;
     /** @deprecated */ export function resolveProjectReferencePath(host: ResolveProjectReferencePathHost, ref: ProjectReference): ResolvedConfigFileName;
-    export {};
-}
-declare namespace ts {
-    interface EmitOutput {
+    export interface FormatDiagnosticsHost {
+        getCurrentDirectory(): string;
+        getCanonicalFileName(fileName: string): string;
+        getNewLine(): string;
+    }
+    /** @deprecated */ export interface ResolveProjectReferencePathHost {
+        fileExists(fileName: string): boolean;
+    }
+    export interface EmitOutput {
         outputFiles: OutputFile[];
         emitSkipped: boolean;
     }
-    interface OutputFile {
+    export interface OutputFile {
         name: string;
         writeByteOrderMark: boolean;
         text: string;
     }
-}
-declare namespace ts {
-    type AffectedFileResult<T> = {
+    /**
+     * Create the builder to manage semantic diagnostics and cache them
+     */
+    export function createSemanticDiagnosticsBuilderProgram(newProgram: Program, host: BuilderProgramHost, oldProgram?: SemanticDiagnosticsBuilderProgram, configFileParsingDiagnostics?: readonly Diagnostic[]): SemanticDiagnosticsBuilderProgram;
+    export function createSemanticDiagnosticsBuilderProgram(rootNames: readonly string[] | undefined, options: CompilerOptions | undefined, host?: CompilerHost, oldProgram?: SemanticDiagnosticsBuilderProgram, configFileParsingDiagnostics?: readonly Diagnostic[], projectReferences?: readonly ProjectReference[]): SemanticDiagnosticsBuilderProgram;
+    /**
+     * Create the builder that can handle the changes in program and iterate through changed files
+     * to emit the those files and manage semantic diagnostics cache as well
+     */
+    export function createEmitAndSemanticDiagnosticsBuilderProgram(newProgram: Program, host: BuilderProgramHost, oldProgram?: EmitAndSemanticDiagnosticsBuilderProgram, configFileParsingDiagnostics?: readonly Diagnostic[]): EmitAndSemanticDiagnosticsBuilderProgram;
+    export function createEmitAndSemanticDiagnosticsBuilderProgram(rootNames: readonly string[] | undefined, options: CompilerOptions | undefined, host?: CompilerHost, oldProgram?: EmitAndSemanticDiagnosticsBuilderProgram, configFileParsingDiagnostics?: readonly Diagnostic[], projectReferences?: readonly ProjectReference[]): EmitAndSemanticDiagnosticsBuilderProgram;
+    /**
+     * Creates a builder thats just abstraction over program and can be used with watch
+     */
+    export function createAbstractBuilder(newProgram: Program, host: BuilderProgramHost, oldProgram?: BuilderProgram, configFileParsingDiagnostics?: readonly Diagnostic[]): BuilderProgram;
+    export function createAbstractBuilder(rootNames: readonly string[] | undefined, options: CompilerOptions | undefined, host?: CompilerHost, oldProgram?: BuilderProgram, configFileParsingDiagnostics?: readonly Diagnostic[], projectReferences?: readonly ProjectReference[]): BuilderProgram;
+    export type AffectedFileResult<T> = {
         result: T;
         affected: SourceFile | Program;
     } | undefined;
-    interface BuilderProgramHost {
+    export interface BuilderProgramHost {
         /**
          * return true if file names are treated with case sensitivity
          */
@@ -5268,7 +5561,7 @@ declare namespace ts {
     /**
      * Builder to manage the program state changes
      */
-    interface BuilderProgram {
+    export interface BuilderProgram {
         /**
          * Returns current program
          */
@@ -5338,7 +5631,7 @@ declare namespace ts {
     /**
      * The builder that caches the semantic diagnostics for the program and handles the changed files and affected files
      */
-    interface SemanticDiagnosticsBuilderProgram extends BuilderProgram {
+    export interface SemanticDiagnosticsBuilderProgram extends BuilderProgram {
         /**
          * Gets the semantic diagnostics from the program for the next affected file and caches it
          * Returns undefined if the iteration is complete
@@ -5349,7 +5642,7 @@ declare namespace ts {
      * The builder that can handle the changes in program and iterate through changed file to emit the files
      * The semantic diagnostics are cached per file and managed by clearing for the changed/affected files
      */
-    interface EmitAndSemanticDiagnosticsBuilderProgram extends SemanticDiagnosticsBuilderProgram {
+    export interface EmitAndSemanticDiagnosticsBuilderProgram extends SemanticDiagnosticsBuilderProgram {
         /**
          * Emits the next affected file's emit result (EmitResult and sourceFiles emitted) or returns undefined if iteration is complete
          * The first of writeFile if provided, writeFile of BuilderProgramHost if provided, writeFile of compiler host
@@ -5357,32 +5650,28 @@ declare namespace ts {
          */
         emitNextAffectedFile(writeFile?: WriteFileCallback, cancellationToken?: CancellationToken, emitOnlyDtsFiles?: boolean, customTransformers?: CustomTransformers): AffectedFileResult<EmitResult>;
     }
+    export function readBuilderProgram(compilerOptions: CompilerOptions, host: ReadBuildProgramHost): EmitAndSemanticDiagnosticsBuilderProgram | undefined;
+    export function createIncrementalCompilerHost(options: CompilerOptions, system?: System): CompilerHost;
+    export function createIncrementalProgram<T extends BuilderProgram = EmitAndSemanticDiagnosticsBuilderProgram>({ rootNames, options, configFileParsingDiagnostics, projectReferences, host, createProgram }: IncrementalProgramOptions<T>): T;
     /**
-     * Create the builder to manage semantic diagnostics and cache them
+     * Create the watch compiler host for either configFile or fileNames and its options
      */
-    function createSemanticDiagnosticsBuilderProgram(newProgram: Program, host: BuilderProgramHost, oldProgram?: SemanticDiagnosticsBuilderProgram, configFileParsingDiagnostics?: readonly Diagnostic[]): SemanticDiagnosticsBuilderProgram;
-    function createSemanticDiagnosticsBuilderProgram(rootNames: readonly string[] | undefined, options: CompilerOptions | undefined, host?: CompilerHost, oldProgram?: SemanticDiagnosticsBuilderProgram, configFileParsingDiagnostics?: readonly Diagnostic[], projectReferences?: readonly ProjectReference[]): SemanticDiagnosticsBuilderProgram;
+    export function createWatchCompilerHost<T extends BuilderProgram>(configFileName: string, optionsToExtend: CompilerOptions | undefined, system: System, createProgram?: CreateProgram<T>, reportDiagnostic?: DiagnosticReporter, reportWatchStatus?: WatchStatusReporter, watchOptionsToExtend?: WatchOptions, extraFileExtensions?: readonly FileExtensionInfo[]): WatchCompilerHostOfConfigFile<T>;
+    export function createWatchCompilerHost<T extends BuilderProgram>(rootFiles: string[], options: CompilerOptions, system: System, createProgram?: CreateProgram<T>, reportDiagnostic?: DiagnosticReporter, reportWatchStatus?: WatchStatusReporter, projectReferences?: readonly ProjectReference[], watchOptions?: WatchOptions): WatchCompilerHostOfFilesAndCompilerOptions<T>;
     /**
-     * Create the builder that can handle the changes in program and iterate through changed files
-     * to emit the those files and manage semantic diagnostics cache as well
+     * Creates the watch from the host for root files and compiler options
      */
-    function createEmitAndSemanticDiagnosticsBuilderProgram(newProgram: Program, host: BuilderProgramHost, oldProgram?: EmitAndSemanticDiagnosticsBuilderProgram, configFileParsingDiagnostics?: readonly Diagnostic[]): EmitAndSemanticDiagnosticsBuilderProgram;
-    function createEmitAndSemanticDiagnosticsBuilderProgram(rootNames: readonly string[] | undefined, options: CompilerOptions | undefined, host?: CompilerHost, oldProgram?: EmitAndSemanticDiagnosticsBuilderProgram, configFileParsingDiagnostics?: readonly Diagnostic[], projectReferences?: readonly ProjectReference[]): EmitAndSemanticDiagnosticsBuilderProgram;
+    export function createWatchProgram<T extends BuilderProgram>(host: WatchCompilerHostOfFilesAndCompilerOptions<T>): WatchOfFilesAndCompilerOptions<T>;
     /**
-     * Creates a builder thats just abstraction over program and can be used with watch
+     * Creates the watch from the host for config file
      */
-    function createAbstractBuilder(newProgram: Program, host: BuilderProgramHost, oldProgram?: BuilderProgram, configFileParsingDiagnostics?: readonly Diagnostic[]): BuilderProgram;
-    function createAbstractBuilder(rootNames: readonly string[] | undefined, options: CompilerOptions | undefined, host?: CompilerHost, oldProgram?: BuilderProgram, configFileParsingDiagnostics?: readonly Diagnostic[], projectReferences?: readonly ProjectReference[]): BuilderProgram;
-}
-declare namespace ts {
-    interface ReadBuildProgramHost {
+    export function createWatchProgram<T extends BuilderProgram>(host: WatchCompilerHostOfConfigFile<T>): WatchOfConfigFile<T>;
+    export interface ReadBuildProgramHost {
         useCaseSensitiveFileNames(): boolean;
         getCurrentDirectory(): string;
         readFile(fileName: string): string | undefined;
     }
-    function readBuilderProgram(compilerOptions: CompilerOptions, host: ReadBuildProgramHost): EmitAndSemanticDiagnosticsBuilderProgram | undefined;
-    function createIncrementalCompilerHost(options: CompilerOptions, system?: System): CompilerHost;
-    interface IncrementalProgramOptions<T extends BuilderProgram> {
+    export interface IncrementalProgramOptions<T extends BuilderProgram> {
         rootNames: readonly string[];
         options: CompilerOptions;
         configFileParsingDiagnostics?: readonly Diagnostic[];
@@ -5390,12 +5679,11 @@ declare namespace ts {
         host?: CompilerHost;
         createProgram?: CreateProgram<T>;
     }
-    function createIncrementalProgram<T extends BuilderProgram = EmitAndSemanticDiagnosticsBuilderProgram>({ rootNames, options, configFileParsingDiagnostics, projectReferences, host, createProgram }: IncrementalProgramOptions<T>): T;
-    type WatchStatusReporter = (diagnostic: Diagnostic, newLine: string, options: CompilerOptions, errorCount?: number) => void;
+    export type WatchStatusReporter = (diagnostic: Diagnostic, newLine: string, options: CompilerOptions, errorCount?: number) => void;
     /** Create the program with rootNames and options, if they are undefined, oldProgram and new configFile diagnostics create new program */
-    type CreateProgram<T extends BuilderProgram> = (rootNames: readonly string[] | undefined, options: CompilerOptions | undefined, host?: CompilerHost, oldProgram?: T, configFileParsingDiagnostics?: readonly Diagnostic[], projectReferences?: readonly ProjectReference[] | undefined) => T;
+    export type CreateProgram<T extends BuilderProgram> = (rootNames: readonly string[] | undefined, options: CompilerOptions | undefined, host?: CompilerHost, oldProgram?: T, configFileParsingDiagnostics?: readonly Diagnostic[], projectReferences?: readonly ProjectReference[] | undefined) => T;
     /** Host that has watch functionality used in --watch mode */
-    interface WatchHost {
+    export interface WatchHost {
         /** If provided, called with Diagnostic message that informs about change in watch status */
         onWatchStatusChange?(diagnostic: Diagnostic, newLine: string, options: CompilerOptions, errorCount?: number): void;
         /** Used to watch changes in source files, missing files needed to update the program or config file */
@@ -5407,7 +5695,7 @@ declare namespace ts {
         /** If provided, will be used to reset existing delayed compilation */
         clearTimeout?(timeoutId: any): void;
     }
-    interface ProgramHost<T extends BuilderProgram> {
+    export interface ProgramHost<T extends BuilderProgram> {
         /**
          * Used to create the program when need for program creation or recreation detected
          */
@@ -5451,7 +5739,7 @@ declare namespace ts {
          */
         getModuleResolutionCache?(): ModuleResolutionCache | undefined;
     }
-    interface WatchCompilerHost<T extends BuilderProgram> extends ProgramHost<T>, WatchHost {
+    export interface WatchCompilerHost<T extends BuilderProgram> extends ProgramHost<T>, WatchHost {
         /** Instead of using output d.ts file from project reference, use its source file */
         useSourceOfProjectReferenceRedirect?(): boolean;
         /** If provided, use this method to get parsed command lines for referenced projects */
@@ -5462,7 +5750,7 @@ declare namespace ts {
     /**
      * Host to create watch with root files and options
      */
-    interface WatchCompilerHostOfFilesAndCompilerOptions<T extends BuilderProgram> extends WatchCompilerHost<T> {
+    export interface WatchCompilerHostOfFilesAndCompilerOptions<T extends BuilderProgram> extends WatchCompilerHost<T> {
         /** root files to use to generate program */
         rootFiles: string[];
         /** Compiler options */
@@ -5474,7 +5762,7 @@ declare namespace ts {
     /**
      * Host to create watch with config file
      */
-    interface WatchCompilerHostOfConfigFile<T extends BuilderProgram> extends WatchCompilerHost<T>, ConfigFileDiagnosticsReporter {
+    export interface WatchCompilerHostOfConfigFile<T extends BuilderProgram> extends WatchCompilerHost<T>, ConfigFileDiagnosticsReporter {
         /** Name of the config file to compile */
         configFileName: string;
         /** Options to extend */
@@ -5487,7 +5775,7 @@ declare namespace ts {
          */
         readDirectory(path: string, extensions?: readonly string[], exclude?: readonly string[], include?: readonly string[], depth?: number): string[];
     }
-    interface Watch<T> {
+    export interface Watch<T> {
         /** Synchronize with host and get updated program */
         getProgram(): T;
         /** Closes the watch */
@@ -5496,31 +5784,24 @@ declare namespace ts {
     /**
      * Creates the watch what generates program using the config file
      */
-    interface WatchOfConfigFile<T> extends Watch<T> {
+    export interface WatchOfConfigFile<T> extends Watch<T> {
     }
     /**
      * Creates the watch that generates program using the root files and compiler options
      */
-    interface WatchOfFilesAndCompilerOptions<T> extends Watch<T> {
+    export interface WatchOfFilesAndCompilerOptions<T> extends Watch<T> {
         /** Updates the root files in the program, only if this is not config file compilation */
         updateRootFileNames(fileNames: string[]): void;
     }
     /**
-     * Create the watch compiler host for either configFile or fileNames and its options
-     */
-    function createWatchCompilerHost<T extends BuilderProgram>(configFileName: string, optionsToExtend: CompilerOptions | undefined, system: System, createProgram?: CreateProgram<T>, reportDiagnostic?: DiagnosticReporter, reportWatchStatus?: WatchStatusReporter, watchOptionsToExtend?: WatchOptions, extraFileExtensions?: readonly FileExtensionInfo[]): WatchCompilerHostOfConfigFile<T>;
-    function createWatchCompilerHost<T extends BuilderProgram>(rootFiles: string[], options: CompilerOptions, system: System, createProgram?: CreateProgram<T>, reportDiagnostic?: DiagnosticReporter, reportWatchStatus?: WatchStatusReporter, projectReferences?: readonly ProjectReference[], watchOptions?: WatchOptions): WatchCompilerHostOfFilesAndCompilerOptions<T>;
-    /**
-     * Creates the watch from the host for root files and compiler options
-     */
-    function createWatchProgram<T extends BuilderProgram>(host: WatchCompilerHostOfFilesAndCompilerOptions<T>): WatchOfFilesAndCompilerOptions<T>;
-    /**
-     * Creates the watch from the host for config file
+     * Create a function that reports watch status by writing to the system and handles the formating of the diagnostic
      */
-    function createWatchProgram<T extends BuilderProgram>(host: WatchCompilerHostOfConfigFile<T>): WatchOfConfigFile<T>;
-}
-declare namespace ts {
-    interface BuildOptions {
+    export function createBuilderStatusReporter(system: System, pretty?: boolean): DiagnosticReporter;
+    export function createSolutionBuilderHost<T extends BuilderProgram = EmitAndSemanticDiagnosticsBuilderProgram>(system?: System, createProgram?: CreateProgram<T>, reportDiagnostic?: DiagnosticReporter, reportSolutionBuilderStatus?: DiagnosticReporter, reportErrorSummary?: ReportEmitErrorSummary): SolutionBuilderHost<T>;
+    export function createSolutionBuilderWithWatchHost<T extends BuilderProgram = EmitAndSemanticDiagnosticsBuilderProgram>(system?: System, createProgram?: CreateProgram<T>, reportDiagnostic?: DiagnosticReporter, reportSolutionBuilderStatus?: DiagnosticReporter, reportWatchStatus?: WatchStatusReporter): SolutionBuilderWithWatchHost<T>;
+    export function createSolutionBuilder<T extends BuilderProgram>(host: SolutionBuilderHost<T>, rootNames: readonly string[], defaultOptions: BuildOptions): SolutionBuilder<T>;
+    export function createSolutionBuilderWithWatch<T extends BuilderProgram>(host: SolutionBuilderWithWatchHost<T>, rootNames: readonly string[], defaultOptions: BuildOptions, baseWatchOptions?: WatchOptions): SolutionBuilder<T>;
+    export interface BuildOptions {
         dry?: boolean;
         force?: boolean;
         verbose?: boolean;
@@ -5529,12 +5810,12 @@ declare namespace ts {
         traceResolution?: boolean;
         [option: string]: CompilerOptionsValue | undefined;
     }
-    type ReportEmitErrorSummary = (errorCount: number, filesInError: (ReportFileInError | undefined)[]) => void;
-    interface ReportFileInError {
+    export type ReportEmitErrorSummary = (errorCount: number, filesInError: (ReportFileInError | undefined)[]) => void;
+    export interface ReportFileInError {
         fileName: string;
         line: number;
     }
-    interface SolutionBuilderHostBase<T extends BuilderProgram> extends ProgramHost<T> {
+    export interface SolutionBuilderHostBase<T extends BuilderProgram> extends ProgramHost<T> {
         createDirectory?(path: string): void;
         /**
          * Should provide create directory and writeFile if done of invalidatedProjects is not invoked with
@@ -5550,32 +5831,24 @@ declare namespace ts {
         reportSolutionBuilderStatus: DiagnosticReporter;
         afterProgramEmitAndDiagnostics?(program: T): void;
     }
-    interface SolutionBuilderHost<T extends BuilderProgram> extends SolutionBuilderHostBase<T> {
+    export interface SolutionBuilderHost<T extends BuilderProgram> extends SolutionBuilderHostBase<T> {
         reportErrorSummary?: ReportEmitErrorSummary;
     }
-    interface SolutionBuilderWithWatchHost<T extends BuilderProgram> extends SolutionBuilderHostBase<T>, WatchHost {
+    export interface SolutionBuilderWithWatchHost<T extends BuilderProgram> extends SolutionBuilderHostBase<T>, WatchHost {
     }
-    interface SolutionBuilder<T extends BuilderProgram> {
+    export interface SolutionBuilder<T extends BuilderProgram> {
         build(project?: string, cancellationToken?: CancellationToken, writeFile?: WriteFileCallback, getCustomTransformers?: (project: string) => CustomTransformers): ExitStatus;
         clean(project?: string): ExitStatus;
         buildReferences(project: string, cancellationToken?: CancellationToken, writeFile?: WriteFileCallback, getCustomTransformers?: (project: string) => CustomTransformers): ExitStatus;
         cleanReferences(project?: string): ExitStatus;
         getNextInvalidatedProject(cancellationToken?: CancellationToken): InvalidatedProject<T> | undefined;
     }
-    /**
-     * Create a function that reports watch status by writing to the system and handles the formating of the diagnostic
-     */
-    function createBuilderStatusReporter(system: System, pretty?: boolean): DiagnosticReporter;
-    function createSolutionBuilderHost<T extends BuilderProgram = EmitAndSemanticDiagnosticsBuilderProgram>(system?: System, createProgram?: CreateProgram<T>, reportDiagnostic?: DiagnosticReporter, reportSolutionBuilderStatus?: DiagnosticReporter, reportErrorSummary?: ReportEmitErrorSummary): SolutionBuilderHost<T>;
-    function createSolutionBuilderWithWatchHost<T extends BuilderProgram = EmitAndSemanticDiagnosticsBuilderProgram>(system?: System, createProgram?: CreateProgram<T>, reportDiagnostic?: DiagnosticReporter, reportSolutionBuilderStatus?: DiagnosticReporter, reportWatchStatus?: WatchStatusReporter): SolutionBuilderWithWatchHost<T>;
-    function createSolutionBuilder<T extends BuilderProgram>(host: SolutionBuilderHost<T>, rootNames: readonly string[], defaultOptions: BuildOptions): SolutionBuilder<T>;
-    function createSolutionBuilderWithWatch<T extends BuilderProgram>(host: SolutionBuilderWithWatchHost<T>, rootNames: readonly string[], defaultOptions: BuildOptions, baseWatchOptions?: WatchOptions): SolutionBuilder<T>;
-    enum InvalidatedProjectKind {
+    export enum InvalidatedProjectKind {
         Build = 0,
         UpdateBundle = 1,
         UpdateOutputFileStamps = 2
     }
-    interface InvalidatedProjectBase {
+    export interface InvalidatedProjectBase {
         readonly kind: InvalidatedProjectKind;
         readonly project: ResolvedConfigFileName;
         /**
@@ -5585,11 +5858,11 @@ declare namespace ts {
         getCompilerOptions(): CompilerOptions;
         getCurrentDirectory(): string;
     }
-    interface UpdateOutputFileStampsProject extends InvalidatedProjectBase {
+    export interface UpdateOutputFileStampsProject extends InvalidatedProjectBase {
         readonly kind: InvalidatedProjectKind.UpdateOutputFileStamps;
         updateOutputFileStatmps(): void;
     }
-    interface BuildInvalidedProject<T extends BuilderProgram> extends InvalidatedProjectBase {
+    export interface BuildInvalidedProject<T extends BuilderProgram> extends InvalidatedProjectBase {
         readonly kind: InvalidatedProjectKind.Build;
         getBuilderProgram(): T | undefined;
         getProgram(): Program | undefined;
@@ -5604,176 +5877,99 @@ declare namespace ts {
         getSemanticDiagnosticsOfNextAffectedFile(cancellationToken?: CancellationToken, ignoreSourceFile?: (sourceFile: SourceFile) => boolean): AffectedFileResult<readonly Diagnostic[]>;
         emit(targetSourceFile?: SourceFile, writeFile?: WriteFileCallback, cancellationToken?: CancellationToken, emitOnlyDtsFiles?: boolean, customTransformers?: CustomTransformers): EmitResult | undefined;
     }
-    interface UpdateBundleProject<T extends BuilderProgram> extends InvalidatedProjectBase {
+    export interface UpdateBundleProject<T extends BuilderProgram> extends InvalidatedProjectBase {
         readonly kind: InvalidatedProjectKind.UpdateBundle;
         emit(writeFile?: WriteFileCallback, customTransformers?: CustomTransformers): EmitResult | BuildInvalidedProject<T> | undefined;
     }
-    type InvalidatedProject<T extends BuilderProgram> = UpdateOutputFileStampsProject | BuildInvalidedProject<T> | UpdateBundleProject<T>;
-}
-declare namespace ts.server {
-    type ActionSet = "action::set";
-    type ActionInvalidate = "action::invalidate";
-    type ActionPackageInstalled = "action::packageInstalled";
-    type EventTypesRegistry = "event::typesRegistry";
-    type EventBeginInstallTypes = "event::beginInstallTypes";
-    type EventEndInstallTypes = "event::endInstallTypes";
-    type EventInitializationFailed = "event::initializationFailed";
-}
-declare namespace ts.server {
-    interface TypingInstallerResponse {
-        readonly kind: ActionSet | ActionInvalidate | EventTypesRegistry | ActionPackageInstalled | EventBeginInstallTypes | EventEndInstallTypes | EventInitializationFailed;
-    }
-    interface TypingInstallerRequestWithProjectName {
-        readonly projectName: string;
-    }
-    interface DiscoverTypings extends TypingInstallerRequestWithProjectName {
-        readonly fileNames: string[];
-        readonly projectRootPath: Path;
-        readonly compilerOptions: CompilerOptions;
-        readonly watchOptions?: WatchOptions;
-        readonly typeAcquisition: TypeAcquisition;
-        readonly unresolvedImports: SortedReadonlyArray<string>;
-        readonly cachePath?: string;
-        readonly kind: "discover";
-    }
-    interface CloseProject extends TypingInstallerRequestWithProjectName {
-        readonly kind: "closeProject";
-    }
-    interface TypesRegistryRequest {
-        readonly kind: "typesRegistry";
-    }
-    interface InstallPackageRequest extends TypingInstallerRequestWithProjectName {
-        readonly kind: "installPackage";
-        readonly fileName: Path;
-        readonly packageName: string;
-        readonly projectRootPath: Path;
-    }
-    interface PackageInstalledResponse extends ProjectResponse {
-        readonly kind: ActionPackageInstalled;
-        readonly success: boolean;
-        readonly message: string;
-    }
-    interface InitializationFailedResponse extends TypingInstallerResponse {
-        readonly kind: EventInitializationFailed;
-        readonly message: string;
-        readonly stack?: string;
-    }
-    interface ProjectResponse extends TypingInstallerResponse {
-        readonly projectName: string;
-    }
-    interface InvalidateCachedTypings extends ProjectResponse {
-        readonly kind: ActionInvalidate;
-    }
-    interface InstallTypes extends ProjectResponse {
-        readonly kind: EventBeginInstallTypes | EventEndInstallTypes;
-        readonly eventId: number;
-        readonly typingsInstallerVersion: string;
-        readonly packagesToInstall: readonly string[];
-    }
-    interface BeginInstallTypes extends InstallTypes {
-        readonly kind: EventBeginInstallTypes;
-    }
-    interface EndInstallTypes extends InstallTypes {
-        readonly kind: EventEndInstallTypes;
-        readonly installSuccess: boolean;
-    }
-    interface SetTypings extends ProjectResponse {
-        readonly typeAcquisition: TypeAcquisition;
-        readonly compilerOptions: CompilerOptions;
-        readonly typings: string[];
-        readonly unresolvedImports: SortedReadonlyArray<string>;
-        readonly kind: ActionSet;
-    }
-}
-declare namespace ts {
-    interface Node {
-        getSourceFile(): SourceFile;
-        getChildCount(sourceFile?: SourceFile): number;
-        getChildAt(index: number, sourceFile?: SourceFile): Node;
-        getChildren(sourceFile?: SourceFile): Node[];
-        getStart(sourceFile?: SourceFile, includeJsDocComment?: boolean): number;
-        getFullStart(): number;
-        getEnd(): number;
-        getWidth(sourceFile?: SourceFileLike): number;
-        getFullWidth(): number;
-        getLeadingTriviaWidth(sourceFile?: SourceFile): number;
-        getFullText(sourceFile?: SourceFile): string;
-        getText(sourceFile?: SourceFile): string;
-        getFirstToken(sourceFile?: SourceFile): Node | undefined;
-        getLastToken(sourceFile?: SourceFile): Node | undefined;
-        forEachChild<T>(cbNode: (node: Node) => T | undefined, cbNodeArray?: (nodes: NodeArray<Node>) => T | undefined): T | undefined;
-    }
-    interface Identifier {
-        readonly text: string;
-    }
-    interface PrivateIdentifier {
-        readonly text: string;
-    }
-    interface Symbol {
-        readonly name: string;
-        getFlags(): SymbolFlags;
-        getEscapedName(): __String;
-        getName(): string;
-        getDeclarations(): Declaration[] | undefined;
-        getDocumentationComment(typeChecker: TypeChecker | undefined): SymbolDisplayPart[];
-        getJsDocTags(checker?: TypeChecker): JSDocTagInfo[];
-    }
-    interface Type {
-        getFlags(): TypeFlags;
-        getSymbol(): Symbol | undefined;
-        getProperties(): Symbol[];
-        getProperty(propertyName: string): Symbol | undefined;
-        getApparentProperties(): Symbol[];
-        getCallSignatures(): readonly Signature[];
-        getConstructSignatures(): readonly Signature[];
-        getStringIndexType(): Type | undefined;
-        getNumberIndexType(): Type | undefined;
-        getBaseTypes(): BaseType[] | undefined;
-        getNonNullableType(): Type;
-        getConstraint(): Type | undefined;
-        getDefault(): Type | undefined;
-        isUnion(): this is UnionType;
-        isIntersection(): this is IntersectionType;
-        isUnionOrIntersection(): this is UnionOrIntersectionType;
-        isLiteral(): this is LiteralType;
-        isStringLiteral(): this is StringLiteralType;
-        isNumberLiteral(): this is NumberLiteralType;
-        isTypeParameter(): this is TypeParameter;
-        isClassOrInterface(): this is InterfaceType;
-        isClass(): this is InterfaceType;
-        isIndexType(): this is IndexType;
-    }
-    interface TypeReference {
-        typeArguments?: readonly Type[];
-    }
-    interface Signature {
-        getDeclaration(): SignatureDeclaration;
-        getTypeParameters(): TypeParameter[] | undefined;
-        getParameters(): Symbol[];
-        getTypeParameterAtPosition(pos: number): Type;
-        getReturnType(): Type;
-        getDocumentationComment(typeChecker: TypeChecker | undefined): SymbolDisplayPart[];
-        getJsDocTags(): JSDocTagInfo[];
-    }
-    interface SourceFile {
-        getLineAndCharacterOfPosition(pos: number): LineAndCharacter;
-        getLineEndOfPosition(pos: number): number;
-        getLineStarts(): readonly number[];
-        getPositionOfLineAndCharacter(line: number, character: number): number;
-        update(newText: string, textChangeRange: TextChangeRange): SourceFile;
-    }
-    interface SourceFileLike {
-        getLineAndCharacterOfPosition(pos: number): LineAndCharacter;
-    }
-    interface SourceMapSource {
-        getLineAndCharacterOfPosition(pos: number): LineAndCharacter;
-    }
+    export type InvalidatedProject<T extends BuilderProgram> = UpdateOutputFileStampsProject | BuildInvalidedProject<T> | UpdateBundleProject<T>;
+    export namespace server {
+        export type ActionSet = "action::set";
+        export type ActionInvalidate = "action::invalidate";
+        export type ActionPackageInstalled = "action::packageInstalled";
+        export type EventTypesRegistry = "event::typesRegistry";
+        export type EventBeginInstallTypes = "event::beginInstallTypes";
+        export type EventEndInstallTypes = "event::endInstallTypes";
+        export type EventInitializationFailed = "event::initializationFailed";
+        export interface TypingInstallerResponse {
+            readonly kind: ActionSet | ActionInvalidate | EventTypesRegistry | ActionPackageInstalled | EventBeginInstallTypes | EventEndInstallTypes | EventInitializationFailed;
+        }
+        export interface TypingInstallerRequestWithProjectName {
+            readonly projectName: string;
+        }
+        export interface DiscoverTypings extends TypingInstallerRequestWithProjectName {
+            readonly fileNames: string[];
+            readonly projectRootPath: Path;
+            readonly compilerOptions: CompilerOptions;
+            readonly watchOptions?: WatchOptions;
+            readonly typeAcquisition: TypeAcquisition;
+            readonly unresolvedImports: SortedReadonlyArray<string>;
+            readonly cachePath?: string;
+            readonly kind: "discover";
+        }
+        export interface CloseProject extends TypingInstallerRequestWithProjectName {
+            readonly kind: "closeProject";
+        }
+        export interface TypesRegistryRequest {
+            readonly kind: "typesRegistry";
+        }
+        export interface InstallPackageRequest extends TypingInstallerRequestWithProjectName {
+            readonly kind: "installPackage";
+            readonly fileName: Path;
+            readonly packageName: string;
+            readonly projectRootPath: Path;
+        }
+        export interface PackageInstalledResponse extends ProjectResponse {
+            readonly kind: ActionPackageInstalled;
+            readonly success: boolean;
+            readonly message: string;
+        }
+        export interface InitializationFailedResponse extends TypingInstallerResponse {
+            readonly kind: EventInitializationFailed;
+            readonly message: string;
+            readonly stack?: string;
+        }
+        export interface ProjectResponse extends TypingInstallerResponse {
+            readonly projectName: string;
+        }
+        export interface InvalidateCachedTypings extends ProjectResponse {
+            readonly kind: ActionInvalidate;
+        }
+        export interface InstallTypes extends ProjectResponse {
+            readonly kind: EventBeginInstallTypes | EventEndInstallTypes;
+            readonly eventId: number;
+            readonly typingsInstallerVersion: string;
+            readonly packagesToInstall: readonly string[];
+        }
+        export interface BeginInstallTypes extends InstallTypes {
+            readonly kind: EventBeginInstallTypes;
+        }
+        export interface EndInstallTypes extends InstallTypes {
+            readonly kind: EventEndInstallTypes;
+            readonly installSuccess: boolean;
+        }
+        export interface SetTypings extends ProjectResponse {
+            readonly typeAcquisition: TypeAcquisition;
+            readonly compilerOptions: CompilerOptions;
+            readonly typings: string[];
+            readonly unresolvedImports: SortedReadonlyArray<string>;
+            readonly kind: ActionSet;
+        }
+    }
+    export namespace FindAllReferences {
+    }
+    export namespace refactor {
+        export namespace extractSymbol {
+        }
+    }
+    export namespace formatting {
+    }
+    export function getDefaultFormatCodeSettings(newLineCharacter?: string): FormatCodeSettings;
     /**
      * Represents an immutable snapshot of a script at a specified time.Once acquired, the
      * snapshot is observably immutable. i.e. the same calls with the same parameters will return
      * the same values.
      */
-    interface IScriptSnapshot {
+    export interface IScriptSnapshot {
         /** Gets a portion of the script snapshot specified by [start, end). */
         getText(start: number, end: number): string;
         /** Gets the length of this script snapshot. */
@@ -5789,10 +5985,10 @@ declare namespace ts {
         /** Releases all resources held by this script snapshot */
         dispose?(): void;
     }
-    namespace ScriptSnapshot {
+    export namespace ScriptSnapshot {
         function fromString(text: string): IScriptSnapshot;
     }
-    interface PreProcessedFileInfo {
+    export interface PreProcessedFileInfo {
         referencedFiles: FileReference[];
         typeReferenceDirectives: FileReference[];
         libReferenceDirectives: FileReference[];
@@ -5800,28 +5996,28 @@ declare namespace ts {
         ambientExternalModules?: string[];
         isLibFile: boolean;
     }
-    interface HostCancellationToken {
+    export interface HostCancellationToken {
         isCancellationRequested(): boolean;
     }
-    interface InstallPackageOptions {
+    export interface InstallPackageOptions {
         fileName: Path;
         packageName: string;
     }
-    interface PerformanceEvent {
+    export interface PerformanceEvent {
         kind: "UpdateGraph" | "CreatePackageJsonAutoImportProvider";
         durationMs: number;
     }
-    enum LanguageServiceMode {
+    export enum LanguageServiceMode {
         Semantic = 0,
         PartialSemantic = 1,
         Syntactic = 2
     }
-    interface IncompleteCompletionsCache {
+    export interface IncompleteCompletionsCache {
         get(): CompletionInfo | undefined;
         set(response: CompletionInfo): void;
         clear(): void;
     }
-    interface LanguageServiceHost extends GetEffectiveTypeRootsHost, MinimalResolutionCacheHost {
+    export interface LanguageServiceHost extends GetEffectiveTypeRootsHost, MinimalResolutionCacheHost {
         getCompilationSettings(): CompilerOptions;
         getNewLine?(): string;
         getProjectVersion?(): string;
@@ -5856,14 +6052,14 @@ declare namespace ts {
         writeFile?(fileName: string, content: string): void;
         getParsedCommandLine?(fileName: string): ParsedCommandLine | undefined;
     }
-    type WithMetadata<T> = T & {
+    export type WithMetadata<T> = T & {
         metadata?: unknown;
     };
-    enum SemanticClassificationFormat {
+    export enum SemanticClassificationFormat {
         Original = "original",
         TwentyTwenty = "2020"
     }
-    interface LanguageService {
+    export interface LanguageService {
         /** This is used as a part of restarting the language service. */
         cleanupSemanticCache(): void;
         /**
@@ -6025,18 +6221,18 @@ declare namespace ts {
         uncommentSelection(fileName: string, textRange: TextRange): TextChange[];
         dispose(): void;
     }
-    interface JsxClosingTagInfo {
+    export interface JsxClosingTagInfo {
         readonly newText: string;
     }
-    interface CombinedCodeFixScope {
+    export interface CombinedCodeFixScope {
         type: "file";
         fileName: string;
     }
-    interface OrganizeImportsArgs extends CombinedCodeFixScope {
+    export interface OrganizeImportsArgs extends CombinedCodeFixScope {
         skipDestructiveCodeActions?: boolean;
     }
-    type CompletionsTriggerCharacter = "." | '"' | "'" | "`" | "/" | "@" | "<" | "#" | " ";
-    enum CompletionTriggerKind {
+    export type CompletionsTriggerCharacter = "." | '"' | "'" | "`" | "/" | "@" | "<" | "#" | " ";
+    export enum CompletionTriggerKind {
         /** Completion was triggered by typing an identifier, manual invocation (e.g Ctrl+Space) or via API. */
         Invoked = 1,
         /** Completion was triggered by a trigger character. */
@@ -6044,7 +6240,7 @@ declare namespace ts {
         /** Completion was re-triggered as the current completion list is incomplete. */
         TriggerForIncompleteCompletions = 3
     }
-    interface GetCompletionsAtPositionOptions extends UserPreferences {
+    export interface GetCompletionsAtPositionOptions extends UserPreferences {
         /**
          * If the editor is asking for completions because a certain character was typed
          * (as opposed to when the user explicitly requested them) this should be set.
@@ -6056,17 +6252,17 @@ declare namespace ts {
         /** @deprecated Use includeCompletionsWithInsertText */
         includeInsertTextCompletions?: boolean;
     }
-    type SignatureHelpTriggerCharacter = "," | "(" | "<";
-    type SignatureHelpRetriggerCharacter = SignatureHelpTriggerCharacter | ")";
-    interface SignatureHelpItemsOptions {
+    export type SignatureHelpTriggerCharacter = "," | "(" | "<";
+    export type SignatureHelpRetriggerCharacter = SignatureHelpTriggerCharacter | ")";
+    export interface SignatureHelpItemsOptions {
         triggerReason?: SignatureHelpTriggerReason;
     }
-    type SignatureHelpTriggerReason = SignatureHelpInvokedReason | SignatureHelpCharacterTypedReason | SignatureHelpRetriggeredReason;
+    export type SignatureHelpTriggerReason = SignatureHelpInvokedReason | SignatureHelpCharacterTypedReason | SignatureHelpRetriggeredReason;
     /**
      * Signals that the user manually requested signature help.
      * The language service will unconditionally attempt to provide a result.
      */
-    interface SignatureHelpInvokedReason {
+    export interface SignatureHelpInvokedReason {
         kind: "invoked";
         triggerCharacter?: undefined;
     }
@@ -6074,7 +6270,7 @@ declare namespace ts {
      * Signals that the signature help request came from a user typing a character.
      * Depending on the character and the syntactic context, the request may or may not be served a result.
      */
-    interface SignatureHelpCharacterTypedReason {
+    export interface SignatureHelpCharacterTypedReason {
         kind: "characterTyped";
         /**
          * Character that was responsible for triggering signature help.
@@ -6087,25 +6283,25 @@ declare namespace ts {
      * The language service will unconditionally attempt to provide a result.
      * `triggerCharacter` can be `undefined` for a retrigger caused by a cursor move.
      */
-    interface SignatureHelpRetriggeredReason {
+    export interface SignatureHelpRetriggeredReason {
         kind: "retrigger";
         /**
          * Character that was responsible for triggering signature help.
          */
         triggerCharacter?: SignatureHelpRetriggerCharacter;
     }
-    interface ApplyCodeActionCommandResult {
+    export interface ApplyCodeActionCommandResult {
         successMessage: string;
     }
-    interface Classifications {
+    export interface Classifications {
         spans: number[];
         endOfLineState: EndOfLineState;
     }
-    interface ClassifiedSpan {
+    export interface ClassifiedSpan {
         textSpan: TextSpan;
         classificationType: ClassificationTypeNames;
     }
-    interface ClassifiedSpan2020 {
+    export interface ClassifiedSpan2020 {
         textSpan: TextSpan;
         classificationType: number;
     }
@@ -6115,7 +6311,7 @@ declare namespace ts {
      * The navbar is returned as a list of top-level items, each of which has a list of child items.
      * Child items always have an empty array for their `childItems`.
      */
-    interface NavigationBarItem {
+    export interface NavigationBarItem {
         text: string;
         kind: ScriptElementKind;
         kindModifiers: string;
@@ -6129,7 +6325,7 @@ declare namespace ts {
      * Node in a tree of nested declarations in a file.
      * The top node is always a script or module node.
      */
-    interface NavigationTree {
+    export interface NavigationTree {
         /** Name of the declaration, or a short description, e.g. "<class>". */
         text: string;
         kind: ScriptElementKind;
@@ -6144,7 +6340,7 @@ declare namespace ts {
         /** Present if non-empty */
         childItems?: NavigationTree[];
     }
-    interface CallHierarchyItem {
+    export interface CallHierarchyItem {
         name: string;
         kind: ScriptElementKind;
         kindModifiers?: string;
@@ -6153,45 +6349,45 @@ declare namespace ts {
         selectionSpan: TextSpan;
         containerName?: string;
     }
-    interface CallHierarchyIncomingCall {
+    export interface CallHierarchyIncomingCall {
         from: CallHierarchyItem;
         fromSpans: TextSpan[];
     }
-    interface CallHierarchyOutgoingCall {
+    export interface CallHierarchyOutgoingCall {
         to: CallHierarchyItem;
         fromSpans: TextSpan[];
     }
-    enum InlayHintKind {
+    export enum InlayHintKind {
         Type = "Type",
         Parameter = "Parameter",
         Enum = "Enum"
     }
-    interface InlayHint {
+    export interface InlayHint {
         text: string;
         position: number;
         kind: InlayHintKind;
         whitespaceBefore?: boolean;
         whitespaceAfter?: boolean;
     }
-    interface TodoCommentDescriptor {
+    export interface TodoCommentDescriptor {
         text: string;
         priority: number;
     }
-    interface TodoComment {
+    export interface TodoComment {
         descriptor: TodoCommentDescriptor;
         message: string;
         position: number;
     }
-    interface TextChange {
+    export interface TextChange {
         span: TextSpan;
         newText: string;
     }
-    interface FileTextChanges {
+    export interface FileTextChanges {
         fileName: string;
         textChanges: readonly TextChange[];
         isNewFile?: boolean;
     }
-    interface CodeAction {
+    export interface CodeAction {
         /** Description of the code action to display in the UI of the editor */
         description: string;
         /** Text changes to apply to each file as part of the code action */
@@ -6202,7 +6398,7 @@ declare namespace ts {
          */
         commands?: CodeActionCommand[];
     }
-    interface CodeFixAction extends CodeAction {
+    export interface CodeFixAction extends CodeAction {
         /** Short name to identify the fix, for use by telemetry. */
         fixName: string;
         /**
@@ -6212,17 +6408,17 @@ declare namespace ts {
         fixId?: {};
         fixAllDescription?: string;
     }
-    interface CombinedCodeActions {
+    export interface CombinedCodeActions {
         changes: readonly FileTextChanges[];
         commands?: readonly CodeActionCommand[];
     }
-    type CodeActionCommand = InstallPackageAction;
-    interface InstallPackageAction {
+    export type CodeActionCommand = InstallPackageAction;
+    export interface InstallPackageAction {
     }
     /**
      * A set of one or more available refactoring actions, grouped under a parent refactoring.
      */
-    interface ApplicableRefactorInfo {
+    export interface ApplicableRefactorInfo {
         /**
          * The programmatic name of the refactoring
          */
@@ -6246,7 +6442,7 @@ declare namespace ts {
      * Represents a single refactoring action - for example, the "Extract Method..." refactor might
      * offer several actions, each corresponding to a surround class or closure to extract into.
      */
-    interface RefactorActionInfo {
+    export interface RefactorActionInfo {
         /**
          * The programmatic name of the refactoring action
          */
@@ -6271,19 +6467,19 @@ declare namespace ts {
      * A set of edits to make in response to a refactor action, plus an optional
      * location where renaming should be invoked from
      */
-    interface RefactorEditInfo {
+    export interface RefactorEditInfo {
         edits: FileTextChanges[];
         renameFilename?: string;
         renameLocation?: number;
         commands?: CodeActionCommand[];
     }
-    type RefactorTriggerReason = "implicit" | "invoked";
-    interface TextInsertion {
+    export type RefactorTriggerReason = "implicit" | "invoked";
+    export interface TextInsertion {
         newText: string;
         /** The position in newText the caret should point to after the insertion. */
         caretOffset: number;
     }
-    interface DocumentSpan {
+    export interface DocumentSpan {
         textSpan: TextSpan;
         fileName: string;
         /**
@@ -6299,32 +6495,32 @@ declare namespace ts {
         contextSpan?: TextSpan;
         originalContextSpan?: TextSpan;
     }
-    interface RenameLocation extends DocumentSpan {
+    export interface RenameLocation extends DocumentSpan {
         readonly prefixText?: string;
         readonly suffixText?: string;
     }
-    interface ReferenceEntry extends DocumentSpan {
+    export interface ReferenceEntry extends DocumentSpan {
         isWriteAccess: boolean;
         isInString?: true;
     }
-    interface ImplementationLocation extends DocumentSpan {
+    export interface ImplementationLocation extends DocumentSpan {
         kind: ScriptElementKind;
         displayParts: SymbolDisplayPart[];
     }
-    enum HighlightSpanKind {
+    export enum HighlightSpanKind {
         none = "none",
         definition = "definition",
         reference = "reference",
         writtenReference = "writtenReference"
     }
-    interface HighlightSpan {
+    export interface HighlightSpan {
         fileName?: string;
         isInString?: true;
         textSpan: TextSpan;
         contextSpan?: TextSpan;
         kind: HighlightSpanKind;
     }
-    interface NavigateToItem {
+    export interface NavigateToItem {
         name: string;
         kind: ScriptElementKind;
         kindModifiers: string;
@@ -6335,18 +6531,18 @@ declare namespace ts {
         containerName: string;
         containerKind: ScriptElementKind;
     }
-    enum IndentStyle {
+    export enum IndentStyle {
         None = 0,
         Block = 1,
         Smart = 2
     }
-    enum SemicolonPreference {
+    export enum SemicolonPreference {
         Ignore = "ignore",
         Insert = "insert",
         Remove = "remove"
     }
     /** @deprecated - consider using EditorSettings instead */
-    interface EditorOptions {
+    export interface EditorOptions {
         BaseIndentSize?: number;
         IndentSize: number;
         TabSize: number;
@@ -6354,7 +6550,7 @@ declare namespace ts {
         ConvertTabsToSpaces: boolean;
         IndentStyle: IndentStyle;
     }
-    interface EditorSettings {
+    export interface EditorSettings {
         baseIndentSize?: number;
         indentSize?: number;
         tabSize?: number;
@@ -6364,7 +6560,7 @@ declare namespace ts {
         trimTrailingWhitespace?: boolean;
     }
     /** @deprecated - consider using FormatCodeSettings instead */
-    interface FormatCodeOptions extends EditorOptions {
+    export interface FormatCodeOptions extends EditorOptions {
         InsertSpaceAfterCommaDelimiter: boolean;
         InsertSpaceAfterSemicolonInForStatements: boolean;
         InsertSpaceBeforeAndAfterBinaryOperators: boolean;
@@ -6382,7 +6578,7 @@ declare namespace ts {
         PlaceOpenBraceOnNewLineForControlBlocks: boolean;
         insertSpaceBeforeTypeAnnotation?: boolean;
     }
-    interface FormatCodeSettings extends EditorSettings {
+    export interface FormatCodeSettings extends EditorSettings {
         readonly insertSpaceAfterCommaDelimiter?: boolean;
         readonly insertSpaceAfterSemicolonInForStatements?: boolean;
         readonly insertSpaceBeforeAndAfterBinaryOperators?: boolean;
@@ -6403,29 +6599,28 @@ declare namespace ts {
         readonly indentMultiLineObjectLiteralBeginningOnBlankLine?: boolean;
         readonly semicolons?: SemicolonPreference;
     }
-    function getDefaultFormatCodeSettings(newLineCharacter?: string): FormatCodeSettings;
-    interface DefinitionInfo extends DocumentSpan {
+    export interface DefinitionInfo extends DocumentSpan {
         kind: ScriptElementKind;
         name: string;
         containerKind: ScriptElementKind;
         containerName: string;
         unverified?: boolean;
     }
-    interface DefinitionInfoAndBoundSpan {
+    export interface DefinitionInfoAndBoundSpan {
         definitions?: readonly DefinitionInfo[];
         textSpan: TextSpan;
     }
-    interface ReferencedSymbolDefinitionInfo extends DefinitionInfo {
+    export interface ReferencedSymbolDefinitionInfo extends DefinitionInfo {
         displayParts: SymbolDisplayPart[];
     }
-    interface ReferencedSymbol {
+    export interface ReferencedSymbol {
         definition: ReferencedSymbolDefinitionInfo;
         references: ReferencedSymbolEntry[];
     }
-    interface ReferencedSymbolEntry extends ReferenceEntry {
+    export interface ReferencedSymbolEntry extends ReferenceEntry {
         isDefinition?: boolean;
     }
-    enum SymbolDisplayPartKind {
+    export enum SymbolDisplayPartKind {
         aliasName = 0,
         className = 1,
         enumName = 2,
@@ -6452,18 +6647,18 @@ declare namespace ts {
         linkName = 23,
         linkText = 24
     }
-    interface SymbolDisplayPart {
+    export interface SymbolDisplayPart {
         text: string;
         kind: string;
     }
-    interface JSDocLinkDisplayPart extends SymbolDisplayPart {
+    export interface JSDocLinkDisplayPart extends SymbolDisplayPart {
         target: DocumentSpan;
     }
-    interface JSDocTagInfo {
+    export interface JSDocTagInfo {
         name: string;
         text?: SymbolDisplayPart[];
     }
-    interface QuickInfo {
+    export interface QuickInfo {
         kind: ScriptElementKind;
         kindModifiers: string;
         textSpan: TextSpan;
@@ -6471,8 +6666,8 @@ declare namespace ts {
         documentation?: SymbolDisplayPart[];
         tags?: JSDocTagInfo[];
     }
-    type RenameInfo = RenameInfoSuccess | RenameInfoFailure;
-    interface RenameInfoSuccess {
+    export type RenameInfo = RenameInfoSuccess | RenameInfoFailure;
+    export interface RenameInfoSuccess {
         canRename: true;
         /**
          * File or directory to rename.
@@ -6485,27 +6680,27 @@ declare namespace ts {
         kindModifiers: string;
         triggerSpan: TextSpan;
     }
-    interface RenameInfoFailure {
+    export interface RenameInfoFailure {
         canRename: false;
         localizedErrorMessage: string;
     }
     /**
      * @deprecated Use `UserPreferences` instead.
      */
-    interface RenameInfoOptions {
+    export interface RenameInfoOptions {
         readonly allowRenameOfImportPath?: boolean;
     }
-    interface DocCommentTemplateOptions {
+    export interface DocCommentTemplateOptions {
         readonly generateReturnInDocTemplate?: boolean;
     }
-    interface SignatureHelpParameter {
+    export interface SignatureHelpParameter {
         name: string;
         documentation: SymbolDisplayPart[];
         displayParts: SymbolDisplayPart[];
         isOptional: boolean;
         isRest?: boolean;
     }
-    interface SelectionRange {
+    export interface SelectionRange {
         textSpan: TextSpan;
         parent?: SelectionRange;
     }
@@ -6516,7 +6711,7 @@ declare namespace ts {
      * an edit has happened, while signature help is still active, the host can ask important
      * questions like 'what parameter is the user currently contained within?'.
      */
-    interface SignatureHelpItem {
+    export interface SignatureHelpItem {
         isVariadic: boolean;
         prefixDisplayParts: SymbolDisplayPart[];
         suffixDisplayParts: SymbolDisplayPart[];
@@ -6528,14 +6723,14 @@ declare namespace ts {
     /**
      * Represents a set of signature help items, and the preferred item that should be selected.
      */
-    interface SignatureHelpItems {
+    export interface SignatureHelpItems {
         items: SignatureHelpItem[];
         applicableSpan: TextSpan;
         selectedItemIndex: number;
         argumentIndex: number;
         argumentCount: number;
     }
-    enum CompletionInfoFlags {
+    export enum CompletionInfoFlags {
         None = 0,
         MayIncludeAutoImports = 1,
         IsImportStatementCompletion = 2,
@@ -6544,7 +6739,7 @@ declare namespace ts {
         ResolvedModuleSpecifiersBeyondLimit = 16,
         MayIncludeMethodSnippets = 32
     }
-    interface CompletionInfo {
+    export interface CompletionInfo {
         /** For performance telemetry. */
         flags?: CompletionInfoFlags;
         /** Not true for all global completions. This will be true if the enclosing scope matches a few syntax kinds. See `isSnippetScope`. */
@@ -6566,7 +6761,7 @@ declare namespace ts {
         isIncomplete?: true;
         entries: CompletionEntry[];
     }
-    interface CompletionEntryDataAutoImport {
+    export interface CompletionEntryDataAutoImport {
         /**
          * The name of the property or export in the module's symbol table. Differs from the completion name
          * in the case of InternalSymbolName.ExportEquals and InternalSymbolName.Default.
@@ -6580,15 +6775,15 @@ declare namespace ts {
         /** True if the export was found in the package.json AutoImportProvider */
         isPackageJsonImport?: true;
     }
-    interface CompletionEntryDataUnresolved extends CompletionEntryDataAutoImport {
+    export interface CompletionEntryDataUnresolved extends CompletionEntryDataAutoImport {
         /** The key in the `ExportMapCache` where the completion entry's `SymbolExportInfo[]` is found */
         exportMapKey: string;
     }
-    interface CompletionEntryDataResolved extends CompletionEntryDataAutoImport {
+    export interface CompletionEntryDataResolved extends CompletionEntryDataAutoImport {
         moduleSpecifier: string;
     }
-    type CompletionEntryData = CompletionEntryDataUnresolved | CompletionEntryDataResolved;
-    interface CompletionEntry {
+    export type CompletionEntryData = CompletionEntryDataUnresolved | CompletionEntryDataResolved;
+    export interface CompletionEntry {
         name: string;
         kind: ScriptElementKind;
         kindModifiers?: string;
@@ -6619,11 +6814,11 @@ declare namespace ts {
          */
         data?: CompletionEntryData;
     }
-    interface CompletionEntryLabelDetails {
+    export interface CompletionEntryLabelDetails {
         detail?: string;
         description?: string;
     }
-    interface CompletionEntryDetails {
+    export interface CompletionEntryDetails {
         name: string;
         kind: ScriptElementKind;
         kindModifiers: string;
@@ -6635,7 +6830,7 @@ declare namespace ts {
         source?: SymbolDisplayPart[];
         sourceDisplay?: SymbolDisplayPart[];
     }
-    interface OutliningSpan {
+    export interface OutliningSpan {
         /** The span of the document to actually collapse. */
         textSpan: TextSpan;
         /** The span of the document to display when the user hovers over the collapsed span. */
@@ -6652,7 +6847,7 @@ declare namespace ts {
          */
         kind: OutliningSpanKind;
     }
-    enum OutliningSpanKind {
+    export enum OutliningSpanKind {
         /** Single or multi-line comments */
         Comment = "comment",
         /** Sections marked by '// #region' and '// #endregion' comments */
@@ -6662,12 +6857,12 @@ declare namespace ts {
         /** Contiguous blocks of import declarations */
         Imports = "imports"
     }
-    enum OutputFileType {
+    export enum OutputFileType {
         JavaScript = 0,
         SourceMap = 1,
         Declaration = 2
     }
-    enum EndOfLineState {
+    export enum EndOfLineState {
         None = 0,
         InMultiLineCommentTrivia = 1,
         InSingleQuoteStringLiteral = 2,
@@ -6676,7 +6871,7 @@ declare namespace ts {
         InTemplateMiddleOrTail = 5,
         InTemplateSubstitutionPosition = 6
     }
-    enum TokenClass {
+    export enum TokenClass {
         Punctuation = 0,
         Keyword = 1,
         Operator = 2,
@@ -6688,15 +6883,15 @@ declare namespace ts {
         StringLiteral = 8,
         RegExpLiteral = 9
     }
-    interface ClassificationResult {
+    export interface ClassificationResult {
         finalLexState: EndOfLineState;
         entries: ClassificationInfo[];
     }
-    interface ClassificationInfo {
+    export interface ClassificationInfo {
         length: number;
         classification: TokenClass;
     }
-    interface Classifier {
+    export interface Classifier {
         /**
          * Gives lexical classifications of tokens on a line without any syntactic context.
          * For instance, a token consisting of the text 'string' can be either an identifier
@@ -6720,7 +6915,7 @@ declare namespace ts {
         getClassificationsForLine(text: string, lexState: EndOfLineState, syntacticClassifierAbsent: boolean): ClassificationResult;
         getEncodedLexicalClassifications(text: string, endOfLineState: EndOfLineState, syntacticClassifierAbsent: boolean): Classifications;
     }
-    enum ScriptElementKind {
+    export enum ScriptElementKind {
         unknown = "",
         warning = "warning",
         /** predefined type (void) or keyword (class) */
@@ -6801,7 +6996,7 @@ declare namespace ts {
         /** Jsdoc @link: in `{@link C link text}`, the link text "link text" */
         linkText = "link text"
     }
-    enum ScriptElementKindModifier {
+    export enum ScriptElementKindModifier {
         none = "",
         publicMemberModifier = "public",
         privateMemberModifier = "private",
@@ -6825,7 +7020,7 @@ declare namespace ts {
         ctsModifier = ".cts",
         cjsModifier = ".cjs"
     }
-    enum ClassificationTypeNames {
+    export enum ClassificationTypeNames {
         comment = "comment",
         identifier = "identifier",
         keyword = "keyword",
@@ -6851,7 +7046,7 @@ declare namespace ts {
         jsxText = "jsx text",
         jsxAttributeStringLiteralValue = "jsx attribute string literal value"
     }
-    enum ClassificationType {
+    export enum ClassificationType {
         comment = 1,
         identifier = 2,
         keyword = 3,
@@ -6878,7 +7073,7 @@ declare namespace ts {
         jsxAttributeStringLiteralValue = 24,
         bigintLiteral = 25
     }
-    interface InlayHintsContext {
+    export interface InlayHintsContext {
         file: SourceFile;
         program: Program;
         cancellationToken: CancellationToken;
@@ -6886,18 +7081,13 @@ declare namespace ts {
         span: TextSpan;
         preferences: UserPreferences;
     }
-}
-declare namespace ts {
     /** The classifier is used for syntactic highlighting in editors via the TSServer */
-    function createClassifier(): Classifier;
-}
-declare namespace ts {
-    interface DocumentHighlights {
+    export function createClassifier(): Classifier;
+    export interface DocumentHighlights {
         fileName: string;
         highlightSpans: HighlightSpan[];
     }
-}
-declare namespace ts {
+    export function createDocumentRegistry(useCaseSensitiveFileNames?: boolean, currentDirectory?: string): DocumentRegistry;
     /**
      * The document registry represents a store of SourceFile objects that can be shared between
      * multiple LanguageService instances. A LanguageService instance holds on the SourceFile (AST)
@@ -6913,7 +7103,7 @@ declare namespace ts {
      * To create a default DocumentRegistry, use createDocumentRegistry to create one, and pass it
      * to all subsequent createLanguageService calls.
      */
-    interface DocumentRegistry {
+    export interface DocumentRegistry {
         /**
          * Request a stored SourceFile with a given fileName and compilationSettings.
          * The first call to acquire will call createLanguageServiceSourceFile to generate
@@ -6960,8 +7150,9 @@ declare namespace ts {
          * @param fileName The name of the file to be released
          * @param compilationSettings The compilation settings used to acquire the file
          * @param scriptKind The script kind of the file to be released
+         *
+         * @deprecated pass scriptKind and impliedNodeFormat for correctness
          */
-        /**@deprecated pass scriptKind and impliedNodeFormat for correctness */
         releaseDocument(fileName: string, compilationSettings: CompilerOptions, scriptKind?: ScriptKind): void;
         /**
          * Informs the DocumentRegistry that a file is not needed any longer.
@@ -6981,16 +7172,13 @@ declare namespace ts {
         releaseDocumentWithKey(path: Path, key: DocumentRegistryBucketKey, scriptKind: ScriptKind, impliedNodeFormat: SourceFile["impliedNodeFormat"]): void;
         reportStats(): string;
     }
-    type DocumentRegistryBucketKey = string & {
+    export type DocumentRegistryBucketKey = string & {
         __bucketKey: any;
     };
-    function createDocumentRegistry(useCaseSensitiveFileNames?: boolean, currentDirectory?: string): DocumentRegistry;
-}
-declare namespace ts {
-    function preProcessFile(sourceText: string, readImportFiles?: boolean, detectJavaScriptImports?: boolean): PreProcessedFileInfo;
-}
-declare namespace ts {
-    interface TranspileOptions {
+    export function preProcessFile(sourceText: string, readImportFiles?: boolean, detectJavaScriptImports?: boolean): PreProcessedFileInfo;
+    export function transpileModule(input: string, transpileOptions: TranspileOptions): TranspileOutput;
+    export function transpile(input: string, compilerOptions?: CompilerOptions, fileName?: string, diagnostics?: Diagnostic[], moduleName?: string): string;
+    export interface TranspileOptions {
         compilerOptions?: CompilerOptions;
         fileName?: string;
         reportDiagnostics?: boolean;
@@ -6998,890 +7186,751 @@ declare namespace ts {
         renamedDependencies?: MapLike<string>;
         transformers?: CustomTransformers;
     }
-    interface TranspileOutput {
+    export interface TranspileOutput {
         outputText: string;
         diagnostics?: Diagnostic[];
         sourceMapText?: string;
     }
-    function transpileModule(input: string, transpileOptions: TranspileOptions): TranspileOutput;
-    function transpile(input: string, compilerOptions?: CompilerOptions, fileName?: string, diagnostics?: Diagnostic[], moduleName?: string): string;
-}
-declare namespace ts {
-    /** The version of the language service API */
-    const servicesVersion = "0.8";
-    function toEditorSettings(options: EditorOptions | EditorSettings): EditorSettings;
-    function displayPartsToString(displayParts: SymbolDisplayPart[] | undefined): string;
-    function getDefaultCompilerOptions(): CompilerOptions;
-    function getSupportedCodeFixes(): string[];
-    function createLanguageServiceSourceFile(fileName: string, scriptSnapshot: IScriptSnapshot, scriptTargetOrOptions: ScriptTarget | CreateSourceFileOptions, version: string, setNodeParents: boolean, scriptKind?: ScriptKind): SourceFile;
-    function updateLanguageServiceSourceFile(sourceFile: SourceFile, scriptSnapshot: IScriptSnapshot, version: string, textChangeRange: TextChangeRange | undefined, aggressiveChecks?: boolean): SourceFile;
-    function createLanguageService(host: LanguageServiceHost, documentRegistry?: DocumentRegistry, syntaxOnlyOrLanguageServiceMode?: boolean | LanguageServiceMode): LanguageService;
+    export function toEditorSettings(options: EditorOptions | EditorSettings): EditorSettings;
+    export function displayPartsToString(displayParts: SymbolDisplayPart[] | undefined): string;
+    export function getDefaultCompilerOptions(): CompilerOptions;
+    export function getSupportedCodeFixes(): string[];
+    export function createLanguageServiceSourceFile(fileName: string, scriptSnapshot: IScriptSnapshot, scriptTargetOrOptions: ScriptTarget | CreateSourceFileOptions, version: string, setNodeParents: boolean, scriptKind?: ScriptKind): SourceFile;
+    export function updateLanguageServiceSourceFile(sourceFile: SourceFile, scriptSnapshot: IScriptSnapshot, version: string, textChangeRange: TextChangeRange | undefined, aggressiveChecks?: boolean): SourceFile;
+    export function createLanguageService(host: LanguageServiceHost, documentRegistry?: DocumentRegistry, syntaxOnlyOrLanguageServiceMode?: boolean | LanguageServiceMode): LanguageService;
     /**
      * Get the path of the default library files (lib.d.ts) as distributed with the typescript
      * node package.
      * The functionality is not supported if the ts module is consumed outside of a node module.
      */
-    function getDefaultLibFilePath(options: CompilerOptions): string;
-}
-declare namespace ts {
+    export function getDefaultLibFilePath(options: CompilerOptions): string;
+    /** The version of the language service API */
+    export const servicesVersion = "0.8";
     /**
      * Transform one or more nodes using the supplied transformers.
      * @param source A single `Node` or an array of `Node` objects.
      * @param transformers An array of `TransformerFactory` callbacks used to process the transformation.
      * @param compilerOptions Optional compiler options.
      */
-    function transform<T extends Node>(source: T | T[], transformers: TransformerFactory<T>[], compilerOptions?: CompilerOptions): TransformationResult<T>;
-}
-declare namespace ts {
+    export function transform<T extends Node>(source: T | T[], transformers: TransformerFactory<T>[], compilerOptions?: CompilerOptions): TransformationResult<T>;
     /** @deprecated Use `factory.createNodeArray` or the factory supplied by your transformation context instead. */
-    const createNodeArray: <T extends Node>(elements?: readonly T[] | undefined, hasTrailingComma?: boolean | undefined) => NodeArray<T>;
+    export const createNodeArray: typeof factory.createNodeArray;
     /** @deprecated Use `factory.createNumericLiteral` or the factory supplied by your transformation context instead. */
-    const createNumericLiteral: (value: string | number, numericLiteralFlags?: TokenFlags | undefined) => NumericLiteral;
+    export const createNumericLiteral: typeof factory.createNumericLiteral;
     /** @deprecated Use `factory.createBigIntLiteral` or the factory supplied by your transformation context instead. */
-    const createBigIntLiteral: (value: string | PseudoBigInt) => BigIntLiteral;
+    export const createBigIntLiteral: typeof factory.createBigIntLiteral;
     /** @deprecated Use `factory.createStringLiteral` or the factory supplied by your transformation context instead. */
-    const createStringLiteral: {
-        (text: string, isSingleQuote?: boolean | undefined): StringLiteral;
-        (text: string, isSingleQuote?: boolean | undefined, hasExtendedUnicodeEscape?: boolean | undefined): StringLiteral;
-    };
+    export const createStringLiteral: typeof factory.createStringLiteral;
     /** @deprecated Use `factory.createStringLiteralFromNode` or the factory supplied by your transformation context instead. */
-    const createStringLiteralFromNode: (sourceNode: PrivateIdentifier | PropertyNameLiteral, isSingleQuote?: boolean | undefined) => StringLiteral;
+    export const createStringLiteralFromNode: typeof factory.createStringLiteralFromNode;
     /** @deprecated Use `factory.createRegularExpressionLiteral` or the factory supplied by your transformation context instead. */
-    const createRegularExpressionLiteral: (text: string) => RegularExpressionLiteral;
+    export const createRegularExpressionLiteral: typeof factory.createRegularExpressionLiteral;
     /** @deprecated Use `factory.createLoopVariable` or the factory supplied by your transformation context instead. */
-    const createLoopVariable: (reservedInNestedScopes?: boolean | undefined) => Identifier;
+    export const createLoopVariable: typeof factory.createLoopVariable;
     /** @deprecated Use `factory.createUniqueName` or the factory supplied by your transformation context instead. */
-    const createUniqueName: (text: string, flags?: GeneratedIdentifierFlags | undefined) => Identifier;
+    export const createUniqueName: typeof factory.createUniqueName;
     /** @deprecated Use `factory.createPrivateIdentifier` or the factory supplied by your transformation context instead. */
-    const createPrivateIdentifier: (text: string) => PrivateIdentifier;
+    export const createPrivateIdentifier: typeof factory.createPrivateIdentifier;
     /** @deprecated Use `factory.createSuper` or the factory supplied by your transformation context instead. */
-    const createSuper: () => SuperExpression;
+    export const createSuper: typeof factory.createSuper;
     /** @deprecated Use `factory.createThis` or the factory supplied by your transformation context instead. */
-    const createThis: () => ThisExpression;
+    export const createThis: typeof factory.createThis;
     /** @deprecated Use `factory.createNull` or the factory supplied by your transformation context instead. */
-    const createNull: () => NullLiteral;
+    export const createNull: typeof factory.createNull;
     /** @deprecated Use `factory.createTrue` or the factory supplied by your transformation context instead. */
-    const createTrue: () => TrueLiteral;
+    export const createTrue: typeof factory.createTrue;
     /** @deprecated Use `factory.createFalse` or the factory supplied by your transformation context instead. */
-    const createFalse: () => FalseLiteral;
+    export const createFalse: typeof factory.createFalse;
     /** @deprecated Use `factory.createModifier` or the factory supplied by your transformation context instead. */
-    const createModifier: <T extends ModifierSyntaxKind>(kind: T) => ModifierToken<T>;
+    export const createModifier: typeof factory.createModifier;
     /** @deprecated Use `factory.createModifiersFromModifierFlags` or the factory supplied by your transformation context instead. */
-    const createModifiersFromModifierFlags: (flags: ModifierFlags) => Modifier[] | undefined;
+    export const createModifiersFromModifierFlags: typeof factory.createModifiersFromModifierFlags;
     /** @deprecated Use `factory.createQualifiedName` or the factory supplied by your transformation context instead. */
-    const createQualifiedName: (left: EntityName, right: string | Identifier) => QualifiedName;
+    export const createQualifiedName: typeof factory.createQualifiedName;
     /** @deprecated Use `factory.updateQualifiedName` or the factory supplied by your transformation context instead. */
-    const updateQualifiedName: (node: QualifiedName, left: EntityName, right: Identifier) => QualifiedName;
+    export const updateQualifiedName: typeof factory.updateQualifiedName;
     /** @deprecated Use `factory.createComputedPropertyName` or the factory supplied by your transformation context instead. */
-    const createComputedPropertyName: (expression: Expression) => ComputedPropertyName;
+    export const createComputedPropertyName: typeof factory.createComputedPropertyName;
     /** @deprecated Use `factory.updateComputedPropertyName` or the factory supplied by your transformation context instead. */
-    const updateComputedPropertyName: (node: ComputedPropertyName, expression: Expression) => ComputedPropertyName;
+    export const updateComputedPropertyName: typeof factory.updateComputedPropertyName;
     /** @deprecated Use `factory.createTypeParameterDeclaration` or the factory supplied by your transformation context instead. */
-    const createTypeParameterDeclaration: {
-        (modifiers: readonly Modifier[] | undefined, name: string | Identifier, constraint?: TypeNode | undefined, defaultType?: TypeNode | undefined): TypeParameterDeclaration;
-        (name: string | Identifier, constraint?: TypeNode | undefined, defaultType?: TypeNode | undefined): TypeParameterDeclaration;
-    };
+    export const createTypeParameterDeclaration: typeof factory.createTypeParameterDeclaration;
     /** @deprecated Use `factory.updateTypeParameterDeclaration` or the factory supplied by your transformation context instead. */
-    const updateTypeParameterDeclaration: {
-        (node: TypeParameterDeclaration, modifiers: readonly Modifier[] | undefined, name: Identifier, constraint: TypeNode | undefined, defaultType: TypeNode | undefined): TypeParameterDeclaration;
-        (node: TypeParameterDeclaration, name: Identifier, constraint: TypeNode | undefined, defaultType: TypeNode | undefined): TypeParameterDeclaration;
-    };
+    export const updateTypeParameterDeclaration: typeof factory.updateTypeParameterDeclaration;
     /** @deprecated Use `factory.createParameterDeclaration` or the factory supplied by your transformation context instead. */
-    const createParameter: {
-        (modifiers: readonly ModifierLike[] | undefined, dotDotDotToken: DotDotDotToken | undefined, name: string | BindingName, questionToken?: QuestionToken | undefined, type?: TypeNode | undefined, initializer?: Expression | undefined): ParameterDeclaration;
-        (decorators: readonly Decorator[] | undefined, modifiers: readonly Modifier[] | undefined, dotDotDotToken: DotDotDotToken | undefined, name: string | BindingName, questionToken?: QuestionToken | undefined, type?: TypeNode | undefined, initializer?: Expression | undefined): ParameterDeclaration;
-    };
+    export const createParameter: typeof factory.createParameterDeclaration;
     /** @deprecated Use `factory.updateParameterDeclaration` or the factory supplied by your transformation context instead. */
-    const updateParameter: {
-        (node: ParameterDeclaration, modifiers: readonly ModifierLike[] | undefined, dotDotDotToken: DotDotDotToken | undefined, name: string | BindingName, questionToken: QuestionToken | undefined, type: TypeNode | undefined, initializer: Expression | undefined): ParameterDeclaration;
-        (node: ParameterDeclaration, decorators: readonly Decorator[] | undefined, modifiers: readonly Modifier[] | undefined, dotDotDotToken: DotDotDotToken | undefined, name: string | BindingName, questionToken: QuestionToken | undefined, type: TypeNode | undefined, initializer: Expression | undefined): ParameterDeclaration;
-    };
+    export const updateParameter: typeof factory.updateParameterDeclaration;
     /** @deprecated Use `factory.createDecorator` or the factory supplied by your transformation context instead. */
-    const createDecorator: (expression: Expression) => Decorator;
+    export const createDecorator: typeof factory.createDecorator;
     /** @deprecated Use `factory.updateDecorator` or the factory supplied by your transformation context instead. */
-    const updateDecorator: (node: Decorator, expression: Expression) => Decorator;
+    export const updateDecorator: typeof factory.updateDecorator;
     /** @deprecated Use `factory.createPropertyDeclaration` or the factory supplied by your transformation context instead. */
-    const createProperty: {
-        (modifiers: readonly ModifierLike[] | undefined, name: string | PropertyName, questionOrExclamationToken: QuestionToken | ExclamationToken | undefined, type: TypeNode | undefined, initializer: Expression | undefined): PropertyDeclaration;
-        (decorators: readonly Decorator[] | undefined, modifiers: readonly Modifier[] | undefined, name: string | PropertyName, questionOrExclamationToken: QuestionToken | ExclamationToken | undefined, type: TypeNode | undefined, initializer: Expression | undefined): PropertyDeclaration;
-    };
+    export const createProperty: typeof factory.createPropertyDeclaration;
     /** @deprecated Use `factory.updatePropertyDeclaration` or the factory supplied by your transformation context instead. */
-    const updateProperty: {
-        (node: PropertyDeclaration, modifiers: readonly ModifierLike[] | undefined, name: string | PropertyName, questionOrExclamationToken: QuestionToken | ExclamationToken | undefined, type: TypeNode | undefined, initializer: Expression | undefined): PropertyDeclaration;
-        (node: PropertyDeclaration, decorators: readonly Decorator[] | undefined, modifiers: readonly Modifier[] | undefined, name: string | PropertyName, questionOrExclamationToken: QuestionToken | ExclamationToken | undefined, type: TypeNode | undefined, initializer: Expression | undefined): PropertyDeclaration;
-    };
+    export const updateProperty: typeof factory.updatePropertyDeclaration;
     /** @deprecated Use `factory.createMethodDeclaration` or the factory supplied by your transformation context instead. */
-    const createMethod: {
-        (modifiers: readonly ModifierLike[] | undefined, asteriskToken: AsteriskToken | undefined, name: string | PropertyName, questionToken: QuestionToken | undefined, typeParameters: readonly TypeParameterDeclaration[] | undefined, parameters: readonly ParameterDeclaration[], type: TypeNode | undefined, body: Block | undefined): MethodDeclaration;
-        (decorators: readonly Decorator[] | undefined, modifiers: readonly Modifier[] | undefined, asteriskToken: AsteriskToken | undefined, name: string | PropertyName, questionToken: QuestionToken | undefined, typeParameters: readonly TypeParameterDeclaration[] | undefined, parameters: readonly ParameterDeclaration[], type: TypeNode | undefined, body: Block | undefined): MethodDeclaration;
-    };
+    export const createMethod: typeof factory.createMethodDeclaration;
     /** @deprecated Use `factory.updateMethodDeclaration` or the factory supplied by your transformation context instead. */
-    const updateMethod: {
-        (node: MethodDeclaration, modifiers: readonly ModifierLike[] | undefined, asteriskToken: AsteriskToken | undefined, name: PropertyName, questionToken: QuestionToken | undefined, typeParameters: readonly TypeParameterDeclaration[] | undefined, parameters: readonly ParameterDeclaration[], type: TypeNode | undefined, body: Block | undefined): MethodDeclaration;
-        (node: MethodDeclaration, decorators: readonly Decorator[] | undefined, modifiers: readonly Modifier[] | undefined, asteriskToken: AsteriskToken | undefined, name: PropertyName, questionToken: QuestionToken | undefined, typeParameters: readonly TypeParameterDeclaration[] | undefined, parameters: readonly ParameterDeclaration[], type: TypeNode | undefined, body: Block | undefined): MethodDeclaration;
-    };
+    export const updateMethod: typeof factory.updateMethodDeclaration;
     /** @deprecated Use `factory.createConstructorDeclaration` or the factory supplied by your transformation context instead. */
-    const createConstructor: {
-        (modifiers: readonly Modifier[] | undefined, parameters: readonly ParameterDeclaration[], body: Block | undefined): ConstructorDeclaration;
-        (decorators: readonly Decorator[] | undefined, modifiers: readonly Modifier[] | undefined, parameters: readonly ParameterDeclaration[], body: Block | undefined): ConstructorDeclaration;
-    };
+    export const createConstructor: typeof factory.createConstructorDeclaration;
     /** @deprecated Use `factory.updateConstructorDeclaration` or the factory supplied by your transformation context instead. */
-    const updateConstructor: {
-        (node: ConstructorDeclaration, modifiers: readonly Modifier[] | undefined, parameters: readonly ParameterDeclaration[], body: Block | undefined): ConstructorDeclaration;
-        (node: ConstructorDeclaration, decorators: readonly Decorator[] | undefined, modifiers: readonly Modifier[] | undefined, parameters: readonly ParameterDeclaration[], body: Block | undefined): ConstructorDeclaration;
-    };
+    export const updateConstructor: typeof factory.updateConstructorDeclaration;
     /** @deprecated Use `factory.createGetAccessorDeclaration` or the factory supplied by your transformation context instead. */
-    const createGetAccessor: {
-        (modifiers: readonly ModifierLike[] | undefined, name: string | PropertyName, parameters: readonly ParameterDeclaration[], type: TypeNode | undefined, body: Block | undefined): GetAccessorDeclaration;
-        (decorators: readonly Decorator[] | undefined, modifiers: readonly Modifier[] | undefined, name: string | PropertyName, parameters: readonly ParameterDeclaration[], type: TypeNode | undefined, body: Block | undefined): GetAccessorDeclaration;
-    };
+    export const createGetAccessor: typeof factory.createGetAccessorDeclaration;
     /** @deprecated Use `factory.updateGetAccessorDeclaration` or the factory supplied by your transformation context instead. */
-    const updateGetAccessor: {
-        (node: GetAccessorDeclaration, modifiers: readonly ModifierLike[] | undefined, name: PropertyName, parameters: readonly ParameterDeclaration[], type: TypeNode | undefined, body: Block | undefined): GetAccessorDeclaration;
-        (node: GetAccessorDeclaration, decorators: readonly Decorator[] | undefined, modifiers: readonly Modifier[] | undefined, name: PropertyName, parameters: readonly ParameterDeclaration[], type: TypeNode | undefined, body: Block | undefined): GetAccessorDeclaration;
-    };
+    export const updateGetAccessor: typeof factory.updateGetAccessorDeclaration;
     /** @deprecated Use `factory.createSetAccessorDeclaration` or the factory supplied by your transformation context instead. */
-    const createSetAccessor: {
-        (modifiers: readonly ModifierLike[] | undefined, name: string | PropertyName, parameters: readonly ParameterDeclaration[], body: Block | undefined): SetAccessorDeclaration;
-        (decorators: readonly Decorator[] | undefined, modifiers: readonly Modifier[] | undefined, name: string | PropertyName, parameters: readonly ParameterDeclaration[], body: Block | undefined): SetAccessorDeclaration;
-    };
+    export const createSetAccessor: typeof factory.createSetAccessorDeclaration;
     /** @deprecated Use `factory.updateSetAccessorDeclaration` or the factory supplied by your transformation context instead. */
-    const updateSetAccessor: {
-        (node: SetAccessorDeclaration, modifiers: readonly ModifierLike[] | undefined, name: PropertyName, parameters: readonly ParameterDeclaration[], body: Block | undefined): SetAccessorDeclaration;
-        (node: SetAccessorDeclaration, decorators: readonly Decorator[] | undefined, modifiers: readonly Modifier[] | undefined, name: PropertyName, parameters: readonly ParameterDeclaration[], body: Block | undefined): SetAccessorDeclaration;
-    };
+    export const updateSetAccessor: typeof factory.updateSetAccessorDeclaration;
     /** @deprecated Use `factory.createCallSignature` or the factory supplied by your transformation context instead. */
-    const createCallSignature: (typeParameters: readonly TypeParameterDeclaration[] | undefined, parameters: readonly ParameterDeclaration[], type: TypeNode | undefined) => CallSignatureDeclaration;
+    export const createCallSignature: typeof factory.createCallSignature;
     /** @deprecated Use `factory.updateCallSignature` or the factory supplied by your transformation context instead. */
-    const updateCallSignature: (node: CallSignatureDeclaration, typeParameters: NodeArray<TypeParameterDeclaration> | undefined, parameters: NodeArray<ParameterDeclaration>, type: TypeNode | undefined) => CallSignatureDeclaration;
+    export const updateCallSignature: typeof factory.updateCallSignature;
     /** @deprecated Use `factory.createConstructSignature` or the factory supplied by your transformation context instead. */
-    const createConstructSignature: (typeParameters: readonly TypeParameterDeclaration[] | undefined, parameters: readonly ParameterDeclaration[], type: TypeNode | undefined) => ConstructSignatureDeclaration;
+    export const createConstructSignature: typeof factory.createConstructSignature;
     /** @deprecated Use `factory.updateConstructSignature` or the factory supplied by your transformation context instead. */
-    const updateConstructSignature: (node: ConstructSignatureDeclaration, typeParameters: NodeArray<TypeParameterDeclaration> | undefined, parameters: NodeArray<ParameterDeclaration>, type: TypeNode | undefined) => ConstructSignatureDeclaration;
+    export const updateConstructSignature: typeof factory.updateConstructSignature;
     /** @deprecated Use `factory.updateIndexSignature` or the factory supplied by your transformation context instead. */
-    const updateIndexSignature: {
-        (node: IndexSignatureDeclaration, modifiers: readonly Modifier[] | undefined, parameters: readonly ParameterDeclaration[], type: TypeNode): IndexSignatureDeclaration;
-        (node: IndexSignatureDeclaration, decorators: readonly Decorator[] | undefined, modifiers: readonly Modifier[] | undefined, parameters: readonly ParameterDeclaration[], type: TypeNode): IndexSignatureDeclaration;
-    };
+    export const updateIndexSignature: typeof factory.updateIndexSignature;
     /** @deprecated Use `factory.createKeywordTypeNode` or the factory supplied by your transformation context instead. */
-    const createKeywordTypeNode: <TKind extends KeywordTypeSyntaxKind>(kind: TKind) => KeywordTypeNode<TKind>;
+    export const createKeywordTypeNode: typeof factory.createKeywordTypeNode;
     /** @deprecated Use `factory.createTypePredicateNode` or the factory supplied by your transformation context instead. */
-    const createTypePredicateNodeWithModifier: (assertsModifier: AssertsKeyword | undefined, parameterName: string | Identifier | ThisTypeNode, type: TypeNode | undefined) => TypePredicateNode;
+    export const createTypePredicateNodeWithModifier: typeof factory.createTypePredicateNode;
     /** @deprecated Use `factory.updateTypePredicateNode` or the factory supplied by your transformation context instead. */
-    const updateTypePredicateNodeWithModifier: (node: TypePredicateNode, assertsModifier: AssertsKeyword | undefined, parameterName: Identifier | ThisTypeNode, type: TypeNode | undefined) => TypePredicateNode;
+    export const updateTypePredicateNodeWithModifier: typeof factory.updateTypePredicateNode;
     /** @deprecated Use `factory.createTypeReferenceNode` or the factory supplied by your transformation context instead. */
-    const createTypeReferenceNode: (typeName: string | EntityName, typeArguments?: readonly TypeNode[] | undefined) => TypeReferenceNode;
+    export const createTypeReferenceNode: typeof factory.createTypeReferenceNode;
     /** @deprecated Use `factory.updateTypeReferenceNode` or the factory supplied by your transformation context instead. */
-    const updateTypeReferenceNode: (node: TypeReferenceNode, typeName: EntityName, typeArguments: NodeArray<TypeNode> | undefined) => TypeReferenceNode;
+    export const updateTypeReferenceNode: typeof factory.updateTypeReferenceNode;
     /** @deprecated Use `factory.createFunctionTypeNode` or the factory supplied by your transformation context instead. */
-    const createFunctionTypeNode: (typeParameters: readonly TypeParameterDeclaration[] | undefined, parameters: readonly ParameterDeclaration[], type: TypeNode) => FunctionTypeNode;
+    export const createFunctionTypeNode: typeof factory.createFunctionTypeNode;
     /** @deprecated Use `factory.updateFunctionTypeNode` or the factory supplied by your transformation context instead. */
-    const updateFunctionTypeNode: (node: FunctionTypeNode, typeParameters: NodeArray<TypeParameterDeclaration> | undefined, parameters: NodeArray<ParameterDeclaration>, type: TypeNode) => FunctionTypeNode;
+    export const updateFunctionTypeNode: typeof factory.updateFunctionTypeNode;
     /** @deprecated Use `factory.createConstructorTypeNode` or the factory supplied by your transformation context instead. */
-    const createConstructorTypeNode: (typeParameters: readonly TypeParameterDeclaration[] | undefined, parameters: readonly ParameterDeclaration[], type: TypeNode) => ConstructorTypeNode;
+    export const createConstructorTypeNode: (typeParameters: readonly TypeParameterDeclaration[] | undefined, parameters: readonly ParameterDeclaration[], type: TypeNode) => ConstructorTypeNode;
     /** @deprecated Use `factory.updateConstructorTypeNode` or the factory supplied by your transformation context instead. */
-    const updateConstructorTypeNode: (node: ConstructorTypeNode, typeParameters: NodeArray<TypeParameterDeclaration> | undefined, parameters: NodeArray<ParameterDeclaration>, type: TypeNode) => ConstructorTypeNode;
+    export const updateConstructorTypeNode: (node: ConstructorTypeNode, typeParameters: NodeArray<TypeParameterDeclaration> | undefined, parameters: NodeArray<ParameterDeclaration>, type: TypeNode) => ConstructorTypeNode;
     /** @deprecated Use `factory.createTypeQueryNode` or the factory supplied by your transformation context instead. */
-    const createTypeQueryNode: (exprName: EntityName, typeArguments?: readonly TypeNode[] | undefined) => TypeQueryNode;
+    export const createTypeQueryNode: typeof factory.createTypeQueryNode;
     /** @deprecated Use `factory.updateTypeQueryNode` or the factory supplied by your transformation context instead. */
-    const updateTypeQueryNode: (node: TypeQueryNode, exprName: EntityName, typeArguments?: readonly TypeNode[] | undefined) => TypeQueryNode;
+    export const updateTypeQueryNode: typeof factory.updateTypeQueryNode;
     /** @deprecated Use `factory.createTypeLiteralNode` or the factory supplied by your transformation context instead. */
-    const createTypeLiteralNode: (members: readonly TypeElement[] | undefined) => TypeLiteralNode;
+    export const createTypeLiteralNode: typeof factory.createTypeLiteralNode;
     /** @deprecated Use `factory.updateTypeLiteralNode` or the factory supplied by your transformation context instead. */
-    const updateTypeLiteralNode: (node: TypeLiteralNode, members: NodeArray<TypeElement>) => TypeLiteralNode;
+    export const updateTypeLiteralNode: typeof factory.updateTypeLiteralNode;
     /** @deprecated Use `factory.createArrayTypeNode` or the factory supplied by your transformation context instead. */
-    const createArrayTypeNode: (elementType: TypeNode) => ArrayTypeNode;
+    export const createArrayTypeNode: typeof factory.createArrayTypeNode;
     /** @deprecated Use `factory.updateArrayTypeNode` or the factory supplied by your transformation context instead. */
-    const updateArrayTypeNode: (node: ArrayTypeNode, elementType: TypeNode) => ArrayTypeNode;
+    export const updateArrayTypeNode: typeof factory.updateArrayTypeNode;
     /** @deprecated Use `factory.createTupleTypeNode` or the factory supplied by your transformation context instead. */
-    const createTupleTypeNode: (elements: readonly (TypeNode | NamedTupleMember)[]) => TupleTypeNode;
+    export const createTupleTypeNode: typeof factory.createTupleTypeNode;
     /** @deprecated Use `factory.updateTupleTypeNode` or the factory supplied by your transformation context instead. */
-    const updateTupleTypeNode: (node: TupleTypeNode, elements: readonly (TypeNode | NamedTupleMember)[]) => TupleTypeNode;
+    export const updateTupleTypeNode: typeof factory.updateTupleTypeNode;
     /** @deprecated Use `factory.createOptionalTypeNode` or the factory supplied by your transformation context instead. */
-    const createOptionalTypeNode: (type: TypeNode) => OptionalTypeNode;
+    export const createOptionalTypeNode: typeof factory.createOptionalTypeNode;
     /** @deprecated Use `factory.updateOptionalTypeNode` or the factory supplied by your transformation context instead. */
-    const updateOptionalTypeNode: (node: OptionalTypeNode, type: TypeNode) => OptionalTypeNode;
+    export const updateOptionalTypeNode: typeof factory.updateOptionalTypeNode;
     /** @deprecated Use `factory.createRestTypeNode` or the factory supplied by your transformation context instead. */
-    const createRestTypeNode: (type: TypeNode) => RestTypeNode;
+    export const createRestTypeNode: typeof factory.createRestTypeNode;
     /** @deprecated Use `factory.updateRestTypeNode` or the factory supplied by your transformation context instead. */
-    const updateRestTypeNode: (node: RestTypeNode, type: TypeNode) => RestTypeNode;
+    export const updateRestTypeNode: typeof factory.updateRestTypeNode;
     /** @deprecated Use `factory.createUnionTypeNode` or the factory supplied by your transformation context instead. */
-    const createUnionTypeNode: (types: readonly TypeNode[]) => UnionTypeNode;
+    export const createUnionTypeNode: typeof factory.createUnionTypeNode;
     /** @deprecated Use `factory.updateUnionTypeNode` or the factory supplied by your transformation context instead. */
-    const updateUnionTypeNode: (node: UnionTypeNode, types: NodeArray<TypeNode>) => UnionTypeNode;
+    export const updateUnionTypeNode: typeof factory.updateUnionTypeNode;
     /** @deprecated Use `factory.createIntersectionTypeNode` or the factory supplied by your transformation context instead. */
-    const createIntersectionTypeNode: (types: readonly TypeNode[]) => IntersectionTypeNode;
+    export const createIntersectionTypeNode: typeof factory.createIntersectionTypeNode;
     /** @deprecated Use `factory.updateIntersectionTypeNode` or the factory supplied by your transformation context instead. */
-    const updateIntersectionTypeNode: (node: IntersectionTypeNode, types: NodeArray<TypeNode>) => IntersectionTypeNode;
+    export const updateIntersectionTypeNode: typeof factory.updateIntersectionTypeNode;
     /** @deprecated Use `factory.createConditionalTypeNode` or the factory supplied by your transformation context instead. */
-    const createConditionalTypeNode: (checkType: TypeNode, extendsType: TypeNode, trueType: TypeNode, falseType: TypeNode) => ConditionalTypeNode;
+    export const createConditionalTypeNode: typeof factory.createConditionalTypeNode;
     /** @deprecated Use `factory.updateConditionalTypeNode` or the factory supplied by your transformation context instead. */
-    const updateConditionalTypeNode: (node: ConditionalTypeNode, checkType: TypeNode, extendsType: TypeNode, trueType: TypeNode, falseType: TypeNode) => ConditionalTypeNode;
+    export const updateConditionalTypeNode: typeof factory.updateConditionalTypeNode;
     /** @deprecated Use `factory.createInferTypeNode` or the factory supplied by your transformation context instead. */
-    const createInferTypeNode: (typeParameter: TypeParameterDeclaration) => InferTypeNode;
+    export const createInferTypeNode: typeof factory.createInferTypeNode;
     /** @deprecated Use `factory.updateInferTypeNode` or the factory supplied by your transformation context instead. */
-    const updateInferTypeNode: (node: InferTypeNode, typeParameter: TypeParameterDeclaration) => InferTypeNode;
+    export const updateInferTypeNode: typeof factory.updateInferTypeNode;
     /** @deprecated Use `factory.createImportTypeNode` or the factory supplied by your transformation context instead. */
-    const createImportTypeNode: {
-        (argument: TypeNode, assertions?: ImportTypeAssertionContainer | undefined, qualifier?: EntityName | undefined, typeArguments?: readonly TypeNode[] | undefined, isTypeOf?: boolean | undefined): ImportTypeNode;
-        (argument: TypeNode, assertions?: ImportTypeAssertionContainer | undefined, qualifier?: EntityName | undefined, typeArguments?: readonly TypeNode[] | undefined, isTypeOf?: boolean | undefined): ImportTypeNode;
-        (argument: TypeNode, qualifier?: EntityName | undefined, typeArguments?: readonly TypeNode[] | undefined, isTypeOf?: boolean | undefined): ImportTypeNode;
-    };
+    export const createImportTypeNode: typeof factory.createImportTypeNode;
     /** @deprecated Use `factory.updateImportTypeNode` or the factory supplied by your transformation context instead. */
-    const updateImportTypeNode: {
-        (node: ImportTypeNode, argument: TypeNode, assertions: ImportTypeAssertionContainer | undefined, qualifier: EntityName | undefined, typeArguments: readonly TypeNode[] | undefined, isTypeOf?: boolean | undefined): ImportTypeNode;
-        (node: ImportTypeNode, argument: TypeNode, qualifier: EntityName | undefined, typeArguments: readonly TypeNode[] | undefined, isTypeOf?: boolean | undefined): ImportTypeNode;
-    };
+    export const updateImportTypeNode: typeof factory.updateImportTypeNode;
     /** @deprecated Use `factory.createParenthesizedType` or the factory supplied by your transformation context instead. */
-    const createParenthesizedType: (type: TypeNode) => ParenthesizedTypeNode;
+    export const createParenthesizedType: typeof factory.createParenthesizedType;
     /** @deprecated Use `factory.updateParenthesizedType` or the factory supplied by your transformation context instead. */
-    const updateParenthesizedType: (node: ParenthesizedTypeNode, type: TypeNode) => ParenthesizedTypeNode;
+    export const updateParenthesizedType: typeof factory.updateParenthesizedType;
     /** @deprecated Use `factory.createThisTypeNode` or the factory supplied by your transformation context instead. */
-    const createThisTypeNode: () => ThisTypeNode;
+    export const createThisTypeNode: typeof factory.createThisTypeNode;
     /** @deprecated Use `factory.updateTypeOperatorNode` or the factory supplied by your transformation context instead. */
-    const updateTypeOperatorNode: (node: TypeOperatorNode, type: TypeNode) => TypeOperatorNode;
+    export const updateTypeOperatorNode: typeof factory.updateTypeOperatorNode;
     /** @deprecated Use `factory.createIndexedAccessTypeNode` or the factory supplied by your transformation context instead. */
-    const createIndexedAccessTypeNode: (objectType: TypeNode, indexType: TypeNode) => IndexedAccessTypeNode;
+    export const createIndexedAccessTypeNode: typeof factory.createIndexedAccessTypeNode;
     /** @deprecated Use `factory.updateIndexedAccessTypeNode` or the factory supplied by your transformation context instead. */
-    const updateIndexedAccessTypeNode: (node: IndexedAccessTypeNode, objectType: TypeNode, indexType: TypeNode) => IndexedAccessTypeNode;
+    export const updateIndexedAccessTypeNode: typeof factory.updateIndexedAccessTypeNode;
     /** @deprecated Use `factory.createMappedTypeNode` or the factory supplied by your transformation context instead. */
-    const createMappedTypeNode: (readonlyToken: ReadonlyKeyword | PlusToken | MinusToken | undefined, typeParameter: TypeParameterDeclaration, nameType: TypeNode | undefined, questionToken: QuestionToken | PlusToken | MinusToken | undefined, type: TypeNode | undefined, members: NodeArray<TypeElement> | undefined) => MappedTypeNode;
+    export const createMappedTypeNode: typeof factory.createMappedTypeNode;
     /** @deprecated Use `factory.updateMappedTypeNode` or the factory supplied by your transformation context instead. */
-    const updateMappedTypeNode: (node: MappedTypeNode, readonlyToken: ReadonlyKeyword | PlusToken | MinusToken | undefined, typeParameter: TypeParameterDeclaration, nameType: TypeNode | undefined, questionToken: QuestionToken | PlusToken | MinusToken | undefined, type: TypeNode | undefined, members: NodeArray<TypeElement> | undefined) => MappedTypeNode;
+    export const updateMappedTypeNode: typeof factory.updateMappedTypeNode;
     /** @deprecated Use `factory.createLiteralTypeNode` or the factory supplied by your transformation context instead. */
-    const createLiteralTypeNode: (literal: LiteralExpression | BooleanLiteral | PrefixUnaryExpression | NullLiteral) => LiteralTypeNode;
+    export const createLiteralTypeNode: typeof factory.createLiteralTypeNode;
     /** @deprecated Use `factory.updateLiteralTypeNode` or the factory supplied by your transformation context instead. */
-    const updateLiteralTypeNode: (node: LiteralTypeNode, literal: LiteralExpression | BooleanLiteral | PrefixUnaryExpression | NullLiteral) => LiteralTypeNode;
+    export const updateLiteralTypeNode: typeof factory.updateLiteralTypeNode;
     /** @deprecated Use `factory.createObjectBindingPattern` or the factory supplied by your transformation context instead. */
-    const createObjectBindingPattern: (elements: readonly BindingElement[]) => ObjectBindingPattern;
+    export const createObjectBindingPattern: typeof factory.createObjectBindingPattern;
     /** @deprecated Use `factory.updateObjectBindingPattern` or the factory supplied by your transformation context instead. */
-    const updateObjectBindingPattern: (node: ObjectBindingPattern, elements: readonly BindingElement[]) => ObjectBindingPattern;
+    export const updateObjectBindingPattern: typeof factory.updateObjectBindingPattern;
     /** @deprecated Use `factory.createArrayBindingPattern` or the factory supplied by your transformation context instead. */
-    const createArrayBindingPattern: (elements: readonly ArrayBindingElement[]) => ArrayBindingPattern;
+    export const createArrayBindingPattern: typeof factory.createArrayBindingPattern;
     /** @deprecated Use `factory.updateArrayBindingPattern` or the factory supplied by your transformation context instead. */
-    const updateArrayBindingPattern: (node: ArrayBindingPattern, elements: readonly ArrayBindingElement[]) => ArrayBindingPattern;
+    export const updateArrayBindingPattern: typeof factory.updateArrayBindingPattern;
     /** @deprecated Use `factory.createBindingElement` or the factory supplied by your transformation context instead. */
-    const createBindingElement: (dotDotDotToken: DotDotDotToken | undefined, propertyName: string | PropertyName | undefined, name: string | BindingName, initializer?: Expression | undefined) => BindingElement;
+    export const createBindingElement: typeof factory.createBindingElement;
     /** @deprecated Use `factory.updateBindingElement` or the factory supplied by your transformation context instead. */
-    const updateBindingElement: (node: BindingElement, dotDotDotToken: DotDotDotToken | undefined, propertyName: PropertyName | undefined, name: BindingName, initializer: Expression | undefined) => BindingElement;
+    export const updateBindingElement: typeof factory.updateBindingElement;
     /** @deprecated Use `factory.createArrayLiteralExpression` or the factory supplied by your transformation context instead. */
-    const createArrayLiteral: (elements?: readonly Expression[] | undefined, multiLine?: boolean | undefined) => ArrayLiteralExpression;
+    export const createArrayLiteral: typeof factory.createArrayLiteralExpression;
     /** @deprecated Use `factory.updateArrayLiteralExpression` or the factory supplied by your transformation context instead. */
-    const updateArrayLiteral: (node: ArrayLiteralExpression, elements: readonly Expression[]) => ArrayLiteralExpression;
+    export const updateArrayLiteral: typeof factory.updateArrayLiteralExpression;
     /** @deprecated Use `factory.createObjectLiteralExpression` or the factory supplied by your transformation context instead. */
-    const createObjectLiteral: (properties?: readonly ObjectLiteralElementLike[] | undefined, multiLine?: boolean | undefined) => ObjectLiteralExpression;
+    export const createObjectLiteral: typeof factory.createObjectLiteralExpression;
     /** @deprecated Use `factory.updateObjectLiteralExpression` or the factory supplied by your transformation context instead. */
-    const updateObjectLiteral: (node: ObjectLiteralExpression, properties: readonly ObjectLiteralElementLike[]) => ObjectLiteralExpression;
+    export const updateObjectLiteral: typeof factory.updateObjectLiteralExpression;
     /** @deprecated Use `factory.createPropertyAccessExpression` or the factory supplied by your transformation context instead. */
-    const createPropertyAccess: (expression: Expression, name: string | MemberName) => PropertyAccessExpression;
+    export const createPropertyAccess: typeof factory.createPropertyAccessExpression;
     /** @deprecated Use `factory.updatePropertyAccessExpression` or the factory supplied by your transformation context instead. */
-    const updatePropertyAccess: (node: PropertyAccessExpression, expression: Expression, name: MemberName) => PropertyAccessExpression;
+    export const updatePropertyAccess: typeof factory.updatePropertyAccessExpression;
     /** @deprecated Use `factory.createPropertyAccessChain` or the factory supplied by your transformation context instead. */
-    const createPropertyAccessChain: (expression: Expression, questionDotToken: QuestionDotToken | undefined, name: string | MemberName) => PropertyAccessChain;
+    export const createPropertyAccessChain: typeof factory.createPropertyAccessChain;
     /** @deprecated Use `factory.updatePropertyAccessChain` or the factory supplied by your transformation context instead. */
-    const updatePropertyAccessChain: (node: PropertyAccessChain, expression: Expression, questionDotToken: QuestionDotToken | undefined, name: MemberName) => PropertyAccessChain;
+    export const updatePropertyAccessChain: typeof factory.updatePropertyAccessChain;
     /** @deprecated Use `factory.createElementAccessExpression` or the factory supplied by your transformation context instead. */
-    const createElementAccess: (expression: Expression, index: number | Expression) => ElementAccessExpression;
+    export const createElementAccess: typeof factory.createElementAccessExpression;
     /** @deprecated Use `factory.updateElementAccessExpression` or the factory supplied by your transformation context instead. */
-    const updateElementAccess: (node: ElementAccessExpression, expression: Expression, argumentExpression: Expression) => ElementAccessExpression;
+    export const updateElementAccess: typeof factory.updateElementAccessExpression;
     /** @deprecated Use `factory.createElementAccessChain` or the factory supplied by your transformation context instead. */
-    const createElementAccessChain: (expression: Expression, questionDotToken: QuestionDotToken | undefined, index: number | Expression) => ElementAccessChain;
+    export const createElementAccessChain: typeof factory.createElementAccessChain;
     /** @deprecated Use `factory.updateElementAccessChain` or the factory supplied by your transformation context instead. */
-    const updateElementAccessChain: (node: ElementAccessChain, expression: Expression, questionDotToken: QuestionDotToken | undefined, argumentExpression: Expression) => ElementAccessChain;
+    export const updateElementAccessChain: typeof factory.updateElementAccessChain;
     /** @deprecated Use `factory.createCallExpression` or the factory supplied by your transformation context instead. */
-    const createCall: (expression: Expression, typeArguments: readonly TypeNode[] | undefined, argumentsArray: readonly Expression[] | undefined) => CallExpression;
+    export const createCall: typeof factory.createCallExpression;
     /** @deprecated Use `factory.updateCallExpression` or the factory supplied by your transformation context instead. */
-    const updateCall: (node: CallExpression, expression: Expression, typeArguments: readonly TypeNode[] | undefined, argumentsArray: readonly Expression[]) => CallExpression;
+    export const updateCall: typeof factory.updateCallExpression;
     /** @deprecated Use `factory.createCallChain` or the factory supplied by your transformation context instead. */
-    const createCallChain: (expression: Expression, questionDotToken: QuestionDotToken | undefined, typeArguments: readonly TypeNode[] | undefined, argumentsArray: readonly Expression[] | undefined) => CallChain;
+    export const createCallChain: typeof factory.createCallChain;
     /** @deprecated Use `factory.updateCallChain` or the factory supplied by your transformation context instead. */
-    const updateCallChain: (node: CallChain, expression: Expression, questionDotToken: QuestionDotToken | undefined, typeArguments: readonly TypeNode[] | undefined, argumentsArray: readonly Expression[]) => CallChain;
+    export const updateCallChain: typeof factory.updateCallChain;
     /** @deprecated Use `factory.createNewExpression` or the factory supplied by your transformation context instead. */
-    const createNew: (expression: Expression, typeArguments: readonly TypeNode[] | undefined, argumentsArray: readonly Expression[] | undefined) => NewExpression;
+    export const createNew: typeof factory.createNewExpression;
     /** @deprecated Use `factory.updateNewExpression` or the factory supplied by your transformation context instead. */
-    const updateNew: (node: NewExpression, expression: Expression, typeArguments: readonly TypeNode[] | undefined, argumentsArray: readonly Expression[] | undefined) => NewExpression;
+    export const updateNew: typeof factory.updateNewExpression;
     /** @deprecated Use `factory.createTypeAssertion` or the factory supplied by your transformation context instead. */
-    const createTypeAssertion: (type: TypeNode, expression: Expression) => TypeAssertion;
+    export const createTypeAssertion: typeof factory.createTypeAssertion;
     /** @deprecated Use `factory.updateTypeAssertion` or the factory supplied by your transformation context instead. */
-    const updateTypeAssertion: (node: TypeAssertion, type: TypeNode, expression: Expression) => TypeAssertion;
+    export const updateTypeAssertion: typeof factory.updateTypeAssertion;
     /** @deprecated Use `factory.createParenthesizedExpression` or the factory supplied by your transformation context instead. */
-    const createParen: (expression: Expression) => ParenthesizedExpression;
+    export const createParen: typeof factory.createParenthesizedExpression;
     /** @deprecated Use `factory.updateParenthesizedExpression` or the factory supplied by your transformation context instead. */
-    const updateParen: (node: ParenthesizedExpression, expression: Expression) => ParenthesizedExpression;
+    export const updateParen: typeof factory.updateParenthesizedExpression;
     /** @deprecated Use `factory.createFunctionExpression` or the factory supplied by your transformation context instead. */
-    const createFunctionExpression: (modifiers: readonly Modifier[] | undefined, asteriskToken: AsteriskToken | undefined, name: string | Identifier | undefined, typeParameters: readonly TypeParameterDeclaration[] | undefined, parameters: readonly ParameterDeclaration[] | undefined, type: TypeNode | undefined, body: Block) => FunctionExpression;
+    export const createFunctionExpression: typeof factory.createFunctionExpression;
     /** @deprecated Use `factory.updateFunctionExpression` or the factory supplied by your transformation context instead. */
-    const updateFunctionExpression: (node: FunctionExpression, modifiers: readonly Modifier[] | undefined, asteriskToken: AsteriskToken | undefined, name: Identifier | undefined, typeParameters: readonly TypeParameterDeclaration[] | undefined, parameters: readonly ParameterDeclaration[], type: TypeNode | undefined, body: Block) => FunctionExpression;
+    export const updateFunctionExpression: typeof factory.updateFunctionExpression;
     /** @deprecated Use `factory.createDeleteExpression` or the factory supplied by your transformation context instead. */
-    const createDelete: (expression: Expression) => DeleteExpression;
+    export const createDelete: typeof factory.createDeleteExpression;
     /** @deprecated Use `factory.updateDeleteExpression` or the factory supplied by your transformation context instead. */
-    const updateDelete: (node: DeleteExpression, expression: Expression) => DeleteExpression;
+    export const updateDelete: typeof factory.updateDeleteExpression;
     /** @deprecated Use `factory.createTypeOfExpression` or the factory supplied by your transformation context instead. */
-    const createTypeOf: (expression: Expression) => TypeOfExpression;
+    export const createTypeOf: typeof factory.createTypeOfExpression;
     /** @deprecated Use `factory.updateTypeOfExpression` or the factory supplied by your transformation context instead. */
-    const updateTypeOf: (node: TypeOfExpression, expression: Expression) => TypeOfExpression;
+    export const updateTypeOf: typeof factory.updateTypeOfExpression;
     /** @deprecated Use `factory.createVoidExpression` or the factory supplied by your transformation context instead. */
-    const createVoid: (expression: Expression) => VoidExpression;
+    export const createVoid: typeof factory.createVoidExpression;
     /** @deprecated Use `factory.updateVoidExpression` or the factory supplied by your transformation context instead. */
-    const updateVoid: (node: VoidExpression, expression: Expression) => VoidExpression;
+    export const updateVoid: typeof factory.updateVoidExpression;
     /** @deprecated Use `factory.createAwaitExpression` or the factory supplied by your transformation context instead. */
-    const createAwait: (expression: Expression) => AwaitExpression;
+    export const createAwait: typeof factory.createAwaitExpression;
     /** @deprecated Use `factory.updateAwaitExpression` or the factory supplied by your transformation context instead. */
-    const updateAwait: (node: AwaitExpression, expression: Expression) => AwaitExpression;
+    export const updateAwait: typeof factory.updateAwaitExpression;
     /** @deprecated Use `factory.createPrefixExpression` or the factory supplied by your transformation context instead. */
-    const createPrefix: (operator: PrefixUnaryOperator, operand: Expression) => PrefixUnaryExpression;
+    export const createPrefix: typeof factory.createPrefixUnaryExpression;
     /** @deprecated Use `factory.updatePrefixExpression` or the factory supplied by your transformation context instead. */
-    const updatePrefix: (node: PrefixUnaryExpression, operand: Expression) => PrefixUnaryExpression;
+    export const updatePrefix: typeof factory.updatePrefixUnaryExpression;
     /** @deprecated Use `factory.createPostfixUnaryExpression` or the factory supplied by your transformation context instead. */
-    const createPostfix: (operand: Expression, operator: PostfixUnaryOperator) => PostfixUnaryExpression;
+    export const createPostfix: typeof factory.createPostfixUnaryExpression;
     /** @deprecated Use `factory.updatePostfixUnaryExpression` or the factory supplied by your transformation context instead. */
-    const updatePostfix: (node: PostfixUnaryExpression, operand: Expression) => PostfixUnaryExpression;
+    export const updatePostfix: typeof factory.updatePostfixUnaryExpression;
     /** @deprecated Use `factory.createBinaryExpression` or the factory supplied by your transformation context instead. */
-    const createBinary: (left: Expression, operator: BinaryOperator | BinaryOperatorToken, right: Expression) => BinaryExpression;
+    export const createBinary: typeof factory.createBinaryExpression;
     /** @deprecated Use `factory.updateConditionalExpression` or the factory supplied by your transformation context instead. */
-    const updateConditional: (node: ConditionalExpression, condition: Expression, questionToken: QuestionToken, whenTrue: Expression, colonToken: ColonToken, whenFalse: Expression) => ConditionalExpression;
+    export const updateConditional: typeof factory.updateConditionalExpression;
     /** @deprecated Use `factory.createTemplateExpression` or the factory supplied by your transformation context instead. */
-    const createTemplateExpression: (head: TemplateHead, templateSpans: readonly TemplateSpan[]) => TemplateExpression;
+    export const createTemplateExpression: typeof factory.createTemplateExpression;
     /** @deprecated Use `factory.updateTemplateExpression` or the factory supplied by your transformation context instead. */
-    const updateTemplateExpression: (node: TemplateExpression, head: TemplateHead, templateSpans: readonly TemplateSpan[]) => TemplateExpression;
+    export const updateTemplateExpression: typeof factory.updateTemplateExpression;
     /** @deprecated Use `factory.createTemplateHead` or the factory supplied by your transformation context instead. */
-    const createTemplateHead: {
-        (text: string, rawText?: string | undefined, templateFlags?: TokenFlags | undefined): TemplateHead;
-        (text: string | undefined, rawText: string, templateFlags?: TokenFlags | undefined): TemplateHead;
-    };
+    export const createTemplateHead: typeof factory.createTemplateHead;
     /** @deprecated Use `factory.createTemplateMiddle` or the factory supplied by your transformation context instead. */
-    const createTemplateMiddle: {
-        (text: string, rawText?: string | undefined, templateFlags?: TokenFlags | undefined): TemplateMiddle;
-        (text: string | undefined, rawText: string, templateFlags?: TokenFlags | undefined): TemplateMiddle;
-    };
+    export const createTemplateMiddle: typeof factory.createTemplateMiddle;
     /** @deprecated Use `factory.createTemplateTail` or the factory supplied by your transformation context instead. */
-    const createTemplateTail: {
-        (text: string, rawText?: string | undefined, templateFlags?: TokenFlags | undefined): TemplateTail;
-        (text: string | undefined, rawText: string, templateFlags?: TokenFlags | undefined): TemplateTail;
-    };
+    export const createTemplateTail: typeof factory.createTemplateTail;
     /** @deprecated Use `factory.createNoSubstitutionTemplateLiteral` or the factory supplied by your transformation context instead. */
-    const createNoSubstitutionTemplateLiteral: {
-        (text: string, rawText?: string | undefined): NoSubstitutionTemplateLiteral;
-        (text: string | undefined, rawText: string): NoSubstitutionTemplateLiteral;
-    };
+    export const createNoSubstitutionTemplateLiteral: typeof factory.createNoSubstitutionTemplateLiteral;
     /** @deprecated Use `factory.updateYieldExpression` or the factory supplied by your transformation context instead. */
-    const updateYield: (node: YieldExpression, asteriskToken: AsteriskToken | undefined, expression: Expression | undefined) => YieldExpression;
+    export const updateYield: typeof factory.updateYieldExpression;
     /** @deprecated Use `factory.createSpreadExpression` or the factory supplied by your transformation context instead. */
-    const createSpread: (expression: Expression) => SpreadElement;
+    export const createSpread: typeof factory.createSpreadElement;
     /** @deprecated Use `factory.updateSpreadExpression` or the factory supplied by your transformation context instead. */
-    const updateSpread: (node: SpreadElement, expression: Expression) => SpreadElement;
+    export const updateSpread: typeof factory.updateSpreadElement;
     /** @deprecated Use `factory.createOmittedExpression` or the factory supplied by your transformation context instead. */
-    const createOmittedExpression: () => OmittedExpression;
+    export const createOmittedExpression: typeof factory.createOmittedExpression;
     /** @deprecated Use `factory.createAsExpression` or the factory supplied by your transformation context instead. */
-    const createAsExpression: (expression: Expression, type: TypeNode) => AsExpression;
+    export const createAsExpression: typeof factory.createAsExpression;
     /** @deprecated Use `factory.updateAsExpression` or the factory supplied by your transformation context instead. */
-    const updateAsExpression: (node: AsExpression, expression: Expression, type: TypeNode) => AsExpression;
+    export const updateAsExpression: typeof factory.updateAsExpression;
     /** @deprecated Use `factory.createNonNullExpression` or the factory supplied by your transformation context instead. */
-    const createNonNullExpression: (expression: Expression) => NonNullExpression;
+    export const createNonNullExpression: typeof factory.createNonNullExpression;
     /** @deprecated Use `factory.updateNonNullExpression` or the factory supplied by your transformation context instead. */
-    const updateNonNullExpression: (node: NonNullExpression, expression: Expression) => NonNullExpression;
+    export const updateNonNullExpression: typeof factory.updateNonNullExpression;
     /** @deprecated Use `factory.createNonNullChain` or the factory supplied by your transformation context instead. */
-    const createNonNullChain: (expression: Expression) => NonNullChain;
+    export const createNonNullChain: typeof factory.createNonNullChain;
     /** @deprecated Use `factory.updateNonNullChain` or the factory supplied by your transformation context instead. */
-    const updateNonNullChain: (node: NonNullChain, expression: Expression) => NonNullChain;
+    export const updateNonNullChain: typeof factory.updateNonNullChain;
     /** @deprecated Use `factory.createMetaProperty` or the factory supplied by your transformation context instead. */
-    const createMetaProperty: (keywordToken: SyntaxKind.ImportKeyword | SyntaxKind.NewKeyword, name: Identifier) => MetaProperty;
+    export const createMetaProperty: typeof factory.createMetaProperty;
     /** @deprecated Use `factory.updateMetaProperty` or the factory supplied by your transformation context instead. */
-    const updateMetaProperty: (node: MetaProperty, name: Identifier) => MetaProperty;
+    export const updateMetaProperty: typeof factory.updateMetaProperty;
     /** @deprecated Use `factory.createTemplateSpan` or the factory supplied by your transformation context instead. */
-    const createTemplateSpan: (expression: Expression, literal: TemplateMiddle | TemplateTail) => TemplateSpan;
+    export const createTemplateSpan: typeof factory.createTemplateSpan;
     /** @deprecated Use `factory.updateTemplateSpan` or the factory supplied by your transformation context instead. */
-    const updateTemplateSpan: (node: TemplateSpan, expression: Expression, literal: TemplateMiddle | TemplateTail) => TemplateSpan;
+    export const updateTemplateSpan: typeof factory.updateTemplateSpan;
     /** @deprecated Use `factory.createSemicolonClassElement` or the factory supplied by your transformation context instead. */
-    const createSemicolonClassElement: () => SemicolonClassElement;
+    export const createSemicolonClassElement: typeof factory.createSemicolonClassElement;
     /** @deprecated Use `factory.createBlock` or the factory supplied by your transformation context instead. */
-    const createBlock: (statements: readonly Statement[], multiLine?: boolean | undefined) => Block;
+    export const createBlock: typeof factory.createBlock;
     /** @deprecated Use `factory.updateBlock` or the factory supplied by your transformation context instead. */
-    const updateBlock: (node: Block, statements: readonly Statement[]) => Block;
+    export const updateBlock: typeof factory.updateBlock;
     /** @deprecated Use `factory.createVariableStatement` or the factory supplied by your transformation context instead. */
-    const createVariableStatement: (modifiers: readonly Modifier[] | undefined, declarationList: VariableDeclarationList | readonly VariableDeclaration[]) => VariableStatement;
+    export const createVariableStatement: typeof factory.createVariableStatement;
     /** @deprecated Use `factory.updateVariableStatement` or the factory supplied by your transformation context instead. */
-    const updateVariableStatement: (node: VariableStatement, modifiers: readonly Modifier[] | undefined, declarationList: VariableDeclarationList) => VariableStatement;
+    export const updateVariableStatement: typeof factory.updateVariableStatement;
     /** @deprecated Use `factory.createEmptyStatement` or the factory supplied by your transformation context instead. */
-    const createEmptyStatement: () => EmptyStatement;
+    export const createEmptyStatement: typeof factory.createEmptyStatement;
     /** @deprecated Use `factory.createExpressionStatement` or the factory supplied by your transformation context instead. */
-    const createExpressionStatement: (expression: Expression) => ExpressionStatement;
+    export const createExpressionStatement: typeof factory.createExpressionStatement;
     /** @deprecated Use `factory.updateExpressionStatement` or the factory supplied by your transformation context instead. */
-    const updateExpressionStatement: (node: ExpressionStatement, expression: Expression) => ExpressionStatement;
+    export const updateExpressionStatement: typeof factory.updateExpressionStatement;
     /** @deprecated Use `factory.createExpressionStatement` or the factory supplied by your transformation context instead. */
-    const createStatement: (expression: Expression) => ExpressionStatement;
+    export const createStatement: typeof factory.createExpressionStatement;
     /** @deprecated Use `factory.updateExpressionStatement` or the factory supplied by your transformation context instead. */
-    const updateStatement: (node: ExpressionStatement, expression: Expression) => ExpressionStatement;
+    export const updateStatement: typeof factory.updateExpressionStatement;
     /** @deprecated Use `factory.createIfStatement` or the factory supplied by your transformation context instead. */
-    const createIf: (expression: Expression, thenStatement: Statement, elseStatement?: Statement | undefined) => IfStatement;
+    export const createIf: typeof factory.createIfStatement;
     /** @deprecated Use `factory.updateIfStatement` or the factory supplied by your transformation context instead. */
-    const updateIf: (node: IfStatement, expression: Expression, thenStatement: Statement, elseStatement: Statement | undefined) => IfStatement;
+    export const updateIf: typeof factory.updateIfStatement;
     /** @deprecated Use `factory.createDoStatement` or the factory supplied by your transformation context instead. */
-    const createDo: (statement: Statement, expression: Expression) => DoStatement;
+    export const createDo: typeof factory.createDoStatement;
     /** @deprecated Use `factory.updateDoStatement` or the factory supplied by your transformation context instead. */
-    const updateDo: (node: DoStatement, statement: Statement, expression: Expression) => DoStatement;
+    export const updateDo: typeof factory.updateDoStatement;
     /** @deprecated Use `factory.createWhileStatement` or the factory supplied by your transformation context instead. */
-    const createWhile: (expression: Expression, statement: Statement) => WhileStatement;
+    export const createWhile: typeof factory.createWhileStatement;
     /** @deprecated Use `factory.updateWhileStatement` or the factory supplied by your transformation context instead. */
-    const updateWhile: (node: WhileStatement, expression: Expression, statement: Statement) => WhileStatement;
+    export const updateWhile: typeof factory.updateWhileStatement;
     /** @deprecated Use `factory.createForStatement` or the factory supplied by your transformation context instead. */
-    const createFor: (initializer: ForInitializer | undefined, condition: Expression | undefined, incrementor: Expression | undefined, statement: Statement) => ForStatement;
+    export const createFor: typeof factory.createForStatement;
     /** @deprecated Use `factory.updateForStatement` or the factory supplied by your transformation context instead. */
-    const updateFor: (node: ForStatement, initializer: ForInitializer | undefined, condition: Expression | undefined, incrementor: Expression | undefined, statement: Statement) => ForStatement;
+    export const updateFor: typeof factory.updateForStatement;
     /** @deprecated Use `factory.createForInStatement` or the factory supplied by your transformation context instead. */
-    const createForIn: (initializer: ForInitializer, expression: Expression, statement: Statement) => ForInStatement;
+    export const createForIn: typeof factory.createForInStatement;
     /** @deprecated Use `factory.updateForInStatement` or the factory supplied by your transformation context instead. */
-    const updateForIn: (node: ForInStatement, initializer: ForInitializer, expression: Expression, statement: Statement) => ForInStatement;
+    export const updateForIn: typeof factory.updateForInStatement;
     /** @deprecated Use `factory.createForOfStatement` or the factory supplied by your transformation context instead. */
-    const createForOf: (awaitModifier: AwaitKeyword | undefined, initializer: ForInitializer, expression: Expression, statement: Statement) => ForOfStatement;
+    export const createForOf: typeof factory.createForOfStatement;
     /** @deprecated Use `factory.updateForOfStatement` or the factory supplied by your transformation context instead. */
-    const updateForOf: (node: ForOfStatement, awaitModifier: AwaitKeyword | undefined, initializer: ForInitializer, expression: Expression, statement: Statement) => ForOfStatement;
+    export const updateForOf: typeof factory.updateForOfStatement;
     /** @deprecated Use `factory.createContinueStatement` or the factory supplied by your transformation context instead. */
-    const createContinue: (label?: string | Identifier | undefined) => ContinueStatement;
+    export const createContinue: typeof factory.createContinueStatement;
     /** @deprecated Use `factory.updateContinueStatement` or the factory supplied by your transformation context instead. */
-    const updateContinue: (node: ContinueStatement, label: Identifier | undefined) => ContinueStatement;
+    export const updateContinue: typeof factory.updateContinueStatement;
     /** @deprecated Use `factory.createBreakStatement` or the factory supplied by your transformation context instead. */
-    const createBreak: (label?: string | Identifier | undefined) => BreakStatement;
+    export const createBreak: typeof factory.createBreakStatement;
     /** @deprecated Use `factory.updateBreakStatement` or the factory supplied by your transformation context instead. */
-    const updateBreak: (node: BreakStatement, label: Identifier | undefined) => BreakStatement;
+    export const updateBreak: typeof factory.updateBreakStatement;
     /** @deprecated Use `factory.createReturnStatement` or the factory supplied by your transformation context instead. */
-    const createReturn: (expression?: Expression | undefined) => ReturnStatement;
+    export const createReturn: typeof factory.createReturnStatement;
     /** @deprecated Use `factory.updateReturnStatement` or the factory supplied by your transformation context instead. */
-    const updateReturn: (node: ReturnStatement, expression: Expression | undefined) => ReturnStatement;
+    export const updateReturn: typeof factory.updateReturnStatement;
     /** @deprecated Use `factory.createWithStatement` or the factory supplied by your transformation context instead. */
-    const createWith: (expression: Expression, statement: Statement) => WithStatement;
+    export const createWith: typeof factory.createWithStatement;
     /** @deprecated Use `factory.updateWithStatement` or the factory supplied by your transformation context instead. */
-    const updateWith: (node: WithStatement, expression: Expression, statement: Statement) => WithStatement;
+    export const updateWith: typeof factory.updateWithStatement;
     /** @deprecated Use `factory.createSwitchStatement` or the factory supplied by your transformation context instead. */
-    const createSwitch: (expression: Expression, caseBlock: CaseBlock) => SwitchStatement;
+    export const createSwitch: typeof factory.createSwitchStatement;
     /** @deprecated Use `factory.updateSwitchStatement` or the factory supplied by your transformation context instead. */
-    const updateSwitch: (node: SwitchStatement, expression: Expression, caseBlock: CaseBlock) => SwitchStatement;
+    export const updateSwitch: typeof factory.updateSwitchStatement;
     /** @deprecated Use `factory.createLabelStatement` or the factory supplied by your transformation context instead. */
-    const createLabel: (label: string | Identifier, statement: Statement) => LabeledStatement;
+    export const createLabel: typeof factory.createLabeledStatement;
     /** @deprecated Use `factory.updateLabelStatement` or the factory supplied by your transformation context instead. */
-    const updateLabel: (node: LabeledStatement, label: Identifier, statement: Statement) => LabeledStatement;
+    export const updateLabel: typeof factory.updateLabeledStatement;
     /** @deprecated Use `factory.createThrowStatement` or the factory supplied by your transformation context instead. */
-    const createThrow: (expression: Expression) => ThrowStatement;
+    export const createThrow: typeof factory.createThrowStatement;
     /** @deprecated Use `factory.updateThrowStatement` or the factory supplied by your transformation context instead. */
-    const updateThrow: (node: ThrowStatement, expression: Expression) => ThrowStatement;
+    export const updateThrow: typeof factory.updateThrowStatement;
     /** @deprecated Use `factory.createTryStatement` or the factory supplied by your transformation context instead. */
-    const createTry: (tryBlock: Block, catchClause: CatchClause | undefined, finallyBlock: Block | undefined) => TryStatement;
+    export const createTry: typeof factory.createTryStatement;
     /** @deprecated Use `factory.updateTryStatement` or the factory supplied by your transformation context instead. */
-    const updateTry: (node: TryStatement, tryBlock: Block, catchClause: CatchClause | undefined, finallyBlock: Block | undefined) => TryStatement;
+    export const updateTry: typeof factory.updateTryStatement;
     /** @deprecated Use `factory.createDebuggerStatement` or the factory supplied by your transformation context instead. */
-    const createDebuggerStatement: () => DebuggerStatement;
+    export const createDebuggerStatement: typeof factory.createDebuggerStatement;
     /** @deprecated Use `factory.createVariableDeclarationList` or the factory supplied by your transformation context instead. */
-    const createVariableDeclarationList: (declarations: readonly VariableDeclaration[], flags?: NodeFlags | undefined) => VariableDeclarationList;
+    export const createVariableDeclarationList: typeof factory.createVariableDeclarationList;
     /** @deprecated Use `factory.updateVariableDeclarationList` or the factory supplied by your transformation context instead. */
-    const updateVariableDeclarationList: (node: VariableDeclarationList, declarations: readonly VariableDeclaration[]) => VariableDeclarationList;
+    export const updateVariableDeclarationList: typeof factory.updateVariableDeclarationList;
     /** @deprecated Use `factory.createFunctionDeclaration` or the factory supplied by your transformation context instead. */
-    const createFunctionDeclaration: {
-        (modifiers: readonly ModifierLike[] | undefined, asteriskToken: AsteriskToken | undefined, name: string | Identifier | undefined, typeParameters: readonly TypeParameterDeclaration[] | undefined, parameters: readonly ParameterDeclaration[], type: TypeNode | undefined, body: Block | undefined): FunctionDeclaration;
-        (decorators: readonly Decorator[] | undefined, modifiers: readonly Modifier[] | undefined, asteriskToken: AsteriskToken | undefined, name: string | Identifier | undefined, typeParameters: readonly TypeParameterDeclaration[] | undefined, parameters: readonly ParameterDeclaration[], type: TypeNode | undefined, body: Block | undefined): FunctionDeclaration;
-    };
+    export const createFunctionDeclaration: typeof factory.createFunctionDeclaration;
     /** @deprecated Use `factory.updateFunctionDeclaration` or the factory supplied by your transformation context instead. */
-    const updateFunctionDeclaration: {
-        (node: FunctionDeclaration, modifiers: readonly ModifierLike[] | undefined, asteriskToken: AsteriskToken | undefined, name: Identifier | undefined, typeParameters: readonly TypeParameterDeclaration[] | undefined, parameters: readonly ParameterDeclaration[], type: TypeNode | undefined, body: Block | undefined): FunctionDeclaration;
-        (node: FunctionDeclaration, decorators: readonly Decorator[] | undefined, modifiers: readonly Modifier[] | undefined, asteriskToken: AsteriskToken | undefined, name: Identifier | undefined, typeParameters: readonly TypeParameterDeclaration[] | undefined, parameters: readonly ParameterDeclaration[], type: TypeNode | undefined, body: Block | undefined): FunctionDeclaration;
-    };
+    export const updateFunctionDeclaration: typeof factory.updateFunctionDeclaration;
     /** @deprecated Use `factory.createClassDeclaration` or the factory supplied by your transformation context instead. */
-    const createClassDeclaration: {
-        (modifiers: readonly ModifierLike[] | undefined, name: string | Identifier | undefined, typeParameters: readonly TypeParameterDeclaration[] | undefined, heritageClauses: readonly HeritageClause[] | undefined, members: readonly ClassElement[]): ClassDeclaration;
-        (decorators: readonly Decorator[] | undefined, modifiers: readonly Modifier[] | undefined, name: string | Identifier | undefined, typeParameters: readonly TypeParameterDeclaration[] | undefined, heritageClauses: readonly HeritageClause[] | undefined, members: readonly ClassElement[]): ClassDeclaration;
-    };
+    export const createClassDeclaration: typeof factory.createClassDeclaration;
     /** @deprecated Use `factory.updateClassDeclaration` or the factory supplied by your transformation context instead. */
-    const updateClassDeclaration: {
-        (node: ClassDeclaration, modifiers: readonly ModifierLike[] | undefined, name: Identifier | undefined, typeParameters: readonly TypeParameterDeclaration[] | undefined, heritageClauses: readonly HeritageClause[] | undefined, members: readonly ClassElement[]): ClassDeclaration;
-        (node: ClassDeclaration, decorators: readonly Decorator[] | undefined, modifiers: readonly Modifier[] | undefined, name: Identifier | undefined, typeParameters: readonly TypeParameterDeclaration[] | undefined, heritageClauses: readonly HeritageClause[] | undefined, members: readonly ClassElement[]): ClassDeclaration;
-    };
+    export const updateClassDeclaration: typeof factory.updateClassDeclaration;
     /** @deprecated Use `factory.createInterfaceDeclaration` or the factory supplied by your transformation context instead. */
-    const createInterfaceDeclaration: {
-        (modifiers: readonly Modifier[] | undefined, name: string | Identifier, typeParameters: readonly TypeParameterDeclaration[] | undefined, heritageClauses: readonly HeritageClause[] | undefined, members: readonly TypeElement[]): InterfaceDeclaration;
-        (decorators: readonly Decorator[] | undefined, modifiers: readonly Modifier[] | undefined, name: string | Identifier, typeParameters: readonly TypeParameterDeclaration[] | undefined, heritageClauses: readonly HeritageClause[] | undefined, members: readonly TypeElement[]): InterfaceDeclaration;
-    };
+    export const createInterfaceDeclaration: typeof factory.createInterfaceDeclaration;
     /** @deprecated Use `factory.updateInterfaceDeclaration` or the factory supplied by your transformation context instead. */
-    const updateInterfaceDeclaration: {
-        (node: InterfaceDeclaration, modifiers: readonly Modifier[] | undefined, name: Identifier, typeParameters: readonly TypeParameterDeclaration[] | undefined, heritageClauses: readonly HeritageClause[] | undefined, members: readonly TypeElement[]): InterfaceDeclaration;
-        (node: InterfaceDeclaration, decorators: readonly Decorator[] | undefined, modifiers: readonly Modifier[] | undefined, name: Identifier, typeParameters: readonly TypeParameterDeclaration[] | undefined, heritageClauses: readonly HeritageClause[] | undefined, members: readonly TypeElement[]): InterfaceDeclaration;
-    };
+    export const updateInterfaceDeclaration: typeof factory.updateInterfaceDeclaration;
     /** @deprecated Use `factory.createTypeAliasDeclaration` or the factory supplied by your transformation context instead. */
-    const createTypeAliasDeclaration: {
-        (modifiers: readonly Modifier[] | undefined, name: string | Identifier, typeParameters: readonly TypeParameterDeclaration[] | undefined, type: TypeNode): TypeAliasDeclaration;
-        (decorators: readonly Decorator[] | undefined, modifiers: readonly Modifier[] | undefined, name: string | Identifier, typeParameters: readonly TypeParameterDeclaration[] | undefined, type: TypeNode): TypeAliasDeclaration;
-    };
+    export const createTypeAliasDeclaration: typeof factory.createTypeAliasDeclaration;
     /** @deprecated Use `factory.updateTypeAliasDeclaration` or the factory supplied by your transformation context instead. */
-    const updateTypeAliasDeclaration: {
-        (node: TypeAliasDeclaration, modifiers: readonly Modifier[] | undefined, name: Identifier, typeParameters: readonly TypeParameterDeclaration[] | undefined, type: TypeNode): TypeAliasDeclaration;
-        (node: TypeAliasDeclaration, decorators: readonly Decorator[] | undefined, modifiers: readonly Modifier[] | undefined, name: Identifier, typeParameters: readonly TypeParameterDeclaration[] | undefined, type: TypeNode): TypeAliasDeclaration;
-    };
+    export const updateTypeAliasDeclaration: typeof factory.updateTypeAliasDeclaration;
     /** @deprecated Use `factory.createEnumDeclaration` or the factory supplied by your transformation context instead. */
-    const createEnumDeclaration: {
-        (modifiers: readonly Modifier[] | undefined, name: string | Identifier, members: readonly EnumMember[]): EnumDeclaration;
-        (decorators: readonly Decorator[] | undefined, modifiers: readonly Modifier[] | undefined, name: string | Identifier, members: readonly EnumMember[]): EnumDeclaration;
-    };
+    export const createEnumDeclaration: typeof factory.createEnumDeclaration;
     /** @deprecated Use `factory.updateEnumDeclaration` or the factory supplied by your transformation context instead. */
-    const updateEnumDeclaration: {
-        (node: EnumDeclaration, modifiers: readonly Modifier[] | undefined, name: Identifier, members: readonly EnumMember[]): EnumDeclaration;
-        (node: EnumDeclaration, decorators: readonly Decorator[] | undefined, modifiers: readonly Modifier[] | undefined, name: Identifier, members: readonly EnumMember[]): EnumDeclaration;
-    };
+    export const updateEnumDeclaration: typeof factory.updateEnumDeclaration;
     /** @deprecated Use `factory.createModuleDeclaration` or the factory supplied by your transformation context instead. */
-    const createModuleDeclaration: {
-        (modifiers: readonly Modifier[] | undefined, name: ModuleName, body: ModuleBody | undefined, flags?: NodeFlags | undefined): ModuleDeclaration;
-        (decorators: readonly Decorator[] | undefined, modifiers: readonly Modifier[] | undefined, name: ModuleName, body: ModuleBody | undefined, flags?: NodeFlags | undefined): ModuleDeclaration;
-    };
+    export const createModuleDeclaration: typeof factory.createModuleDeclaration;
     /** @deprecated Use `factory.updateModuleDeclaration` or the factory supplied by your transformation context instead. */
-    const updateModuleDeclaration: {
-        (node: ModuleDeclaration, modifiers: readonly Modifier[] | undefined, name: ModuleName, body: ModuleBody | undefined): ModuleDeclaration;
-        (node: ModuleDeclaration, decorators: readonly Decorator[] | undefined, modifiers: readonly Modifier[] | undefined, name: ModuleName, body: ModuleBody | undefined): ModuleDeclaration;
-    };
+    export const updateModuleDeclaration: typeof factory.updateModuleDeclaration;
     /** @deprecated Use `factory.createModuleBlock` or the factory supplied by your transformation context instead. */
-    const createModuleBlock: (statements: readonly Statement[]) => ModuleBlock;
+    export const createModuleBlock: typeof factory.createModuleBlock;
     /** @deprecated Use `factory.updateModuleBlock` or the factory supplied by your transformation context instead. */
-    const updateModuleBlock: (node: ModuleBlock, statements: readonly Statement[]) => ModuleBlock;
+    export const updateModuleBlock: typeof factory.updateModuleBlock;
     /** @deprecated Use `factory.createCaseBlock` or the factory supplied by your transformation context instead. */
-    const createCaseBlock: (clauses: readonly CaseOrDefaultClause[]) => CaseBlock;
+    export const createCaseBlock: typeof factory.createCaseBlock;
     /** @deprecated Use `factory.updateCaseBlock` or the factory supplied by your transformation context instead. */
-    const updateCaseBlock: (node: CaseBlock, clauses: readonly CaseOrDefaultClause[]) => CaseBlock;
+    export const updateCaseBlock: typeof factory.updateCaseBlock;
     /** @deprecated Use `factory.createNamespaceExportDeclaration` or the factory supplied by your transformation context instead. */
-    const createNamespaceExportDeclaration: (name: string | Identifier) => NamespaceExportDeclaration;
+    export const createNamespaceExportDeclaration: typeof factory.createNamespaceExportDeclaration;
     /** @deprecated Use `factory.updateNamespaceExportDeclaration` or the factory supplied by your transformation context instead. */
-    const updateNamespaceExportDeclaration: (node: NamespaceExportDeclaration, name: Identifier) => NamespaceExportDeclaration;
+    export const updateNamespaceExportDeclaration: typeof factory.updateNamespaceExportDeclaration;
     /** @deprecated Use `factory.createImportEqualsDeclaration` or the factory supplied by your transformation context instead. */
-    const createImportEqualsDeclaration: {
-        (modifiers: readonly Modifier[] | undefined, isTypeOnly: boolean, name: string | Identifier, moduleReference: ModuleReference): ImportEqualsDeclaration;
-        (decorators: readonly Decorator[] | undefined, modifiers: readonly Modifier[] | undefined, isTypeOnly: boolean, name: string | Identifier, moduleReference: ModuleReference): ImportEqualsDeclaration;
-    };
+    export const createImportEqualsDeclaration: typeof factory.createImportEqualsDeclaration;
     /** @deprecated Use `factory.updateImportEqualsDeclaration` or the factory supplied by your transformation context instead. */
-    const updateImportEqualsDeclaration: {
-        (node: ImportEqualsDeclaration, modifiers: readonly Modifier[] | undefined, isTypeOnly: boolean, name: Identifier, moduleReference: ModuleReference): ImportEqualsDeclaration;
-        (node: ImportEqualsDeclaration, decorators: readonly Decorator[] | undefined, modifiers: readonly Modifier[] | undefined, isTypeOnly: boolean, name: Identifier, moduleReference: ModuleReference): ImportEqualsDeclaration;
-    };
+    export const updateImportEqualsDeclaration: typeof factory.updateImportEqualsDeclaration;
     /** @deprecated Use `factory.createImportDeclaration` or the factory supplied by your transformation context instead. */
-    const createImportDeclaration: {
-        (modifiers: readonly Modifier[] | undefined, importClause: ImportClause | undefined, moduleSpecifier: Expression, assertClause?: AssertClause | undefined): ImportDeclaration;
-        (decorators: readonly Decorator[] | undefined, modifiers: readonly Modifier[] | undefined, importClause: ImportClause | undefined, moduleSpecifier: Expression, assertClause?: AssertClause | undefined): ImportDeclaration;
-    };
+    export const createImportDeclaration: typeof factory.createImportDeclaration;
     /** @deprecated Use `factory.updateImportDeclaration` or the factory supplied by your transformation context instead. */
-    const updateImportDeclaration: {
-        (node: ImportDeclaration, modifiers: readonly Modifier[] | undefined, importClause: ImportClause | undefined, moduleSpecifier: Expression, assertClause: AssertClause | undefined): ImportDeclaration;
-        (node: ImportDeclaration, decorators: readonly Decorator[] | undefined, modifiers: readonly Modifier[] | undefined, importClause: ImportClause | undefined, moduleSpecifier: Expression, assertClause: AssertClause | undefined): ImportDeclaration;
-    };
+    export const updateImportDeclaration: typeof factory.updateImportDeclaration;
     /** @deprecated Use `factory.createNamespaceImport` or the factory supplied by your transformation context instead. */
-    const createNamespaceImport: (name: Identifier) => NamespaceImport;
+    export const createNamespaceImport: typeof factory.createNamespaceImport;
     /** @deprecated Use `factory.updateNamespaceImport` or the factory supplied by your transformation context instead. */
-    const updateNamespaceImport: (node: NamespaceImport, name: Identifier) => NamespaceImport;
+    export const updateNamespaceImport: typeof factory.updateNamespaceImport;
     /** @deprecated Use `factory.createNamedImports` or the factory supplied by your transformation context instead. */
-    const createNamedImports: (elements: readonly ImportSpecifier[]) => NamedImports;
+    export const createNamedImports: typeof factory.createNamedImports;
     /** @deprecated Use `factory.updateNamedImports` or the factory supplied by your transformation context instead. */
-    const updateNamedImports: (node: NamedImports, elements: readonly ImportSpecifier[]) => NamedImports;
+    export const updateNamedImports: typeof factory.updateNamedImports;
     /** @deprecated Use `factory.createImportSpecifier` or the factory supplied by your transformation context instead. */
-    const createImportSpecifier: (isTypeOnly: boolean, propertyName: Identifier | undefined, name: Identifier) => ImportSpecifier;
+    export const createImportSpecifier: typeof factory.createImportSpecifier;
     /** @deprecated Use `factory.updateImportSpecifier` or the factory supplied by your transformation context instead. */
-    const updateImportSpecifier: (node: ImportSpecifier, isTypeOnly: boolean, propertyName: Identifier | undefined, name: Identifier) => ImportSpecifier;
+    export const updateImportSpecifier: typeof factory.updateImportSpecifier;
     /** @deprecated Use `factory.createExportAssignment` or the factory supplied by your transformation context instead. */
-    const createExportAssignment: {
-        (modifiers: readonly Modifier[] | undefined, isExportEquals: boolean | undefined, expression: Expression): ExportAssignment;
-        (decorators: readonly Decorator[] | undefined, modifiers: readonly Modifier[] | undefined, isExportEquals: boolean | undefined, expression: Expression): ExportAssignment;
-    };
+    export const createExportAssignment: typeof factory.createExportAssignment;
     /** @deprecated Use `factory.updateExportAssignment` or the factory supplied by your transformation context instead. */
-    const updateExportAssignment: {
-        (node: ExportAssignment, modifiers: readonly Modifier[] | undefined, expression: Expression): ExportAssignment;
-        (node: ExportAssignment, decorators: readonly Decorator[] | undefined, modifiers: readonly Modifier[] | undefined, expression: Expression): ExportAssignment;
-    };
+    export const updateExportAssignment: typeof factory.updateExportAssignment;
     /** @deprecated Use `factory.createNamedExports` or the factory supplied by your transformation context instead. */
-    const createNamedExports: (elements: readonly ExportSpecifier[]) => NamedExports;
+    export const createNamedExports: typeof factory.createNamedExports;
     /** @deprecated Use `factory.updateNamedExports` or the factory supplied by your transformation context instead. */
-    const updateNamedExports: (node: NamedExports, elements: readonly ExportSpecifier[]) => NamedExports;
+    export const updateNamedExports: typeof factory.updateNamedExports;
     /** @deprecated Use `factory.createExportSpecifier` or the factory supplied by your transformation context instead. */
-    const createExportSpecifier: (isTypeOnly: boolean, propertyName: string | Identifier | undefined, name: string | Identifier) => ExportSpecifier;
+    export const createExportSpecifier: typeof factory.createExportSpecifier;
     /** @deprecated Use `factory.updateExportSpecifier` or the factory supplied by your transformation context instead. */
-    const updateExportSpecifier: (node: ExportSpecifier, isTypeOnly: boolean, propertyName: Identifier | undefined, name: Identifier) => ExportSpecifier;
+    export const updateExportSpecifier: typeof factory.updateExportSpecifier;
     /** @deprecated Use `factory.createExternalModuleReference` or the factory supplied by your transformation context instead. */
-    const createExternalModuleReference: (expression: Expression) => ExternalModuleReference;
+    export const createExternalModuleReference: typeof factory.createExternalModuleReference;
     /** @deprecated Use `factory.updateExternalModuleReference` or the factory supplied by your transformation context instead. */
-    const updateExternalModuleReference: (node: ExternalModuleReference, expression: Expression) => ExternalModuleReference;
+    export const updateExternalModuleReference: typeof factory.updateExternalModuleReference;
     /** @deprecated Use `factory.createJSDocTypeExpression` or the factory supplied by your transformation context instead. */
-    const createJSDocTypeExpression: (type: TypeNode) => JSDocTypeExpression;
+    export const createJSDocTypeExpression: typeof factory.createJSDocTypeExpression;
     /** @deprecated Use `factory.createJSDocTypeTag` or the factory supplied by your transformation context instead. */
-    const createJSDocTypeTag: (tagName: Identifier | undefined, typeExpression: JSDocTypeExpression, comment?: string | NodeArray<JSDocComment> | undefined) => JSDocTypeTag;
+    export const createJSDocTypeTag: typeof factory.createJSDocTypeTag;
     /** @deprecated Use `factory.createJSDocReturnTag` or the factory supplied by your transformation context instead. */
-    const createJSDocReturnTag: (tagName: Identifier | undefined, typeExpression?: JSDocTypeExpression | undefined, comment?: string | NodeArray<JSDocComment> | undefined) => JSDocReturnTag;
+    export const createJSDocReturnTag: typeof factory.createJSDocReturnTag;
     /** @deprecated Use `factory.createJSDocThisTag` or the factory supplied by your transformation context instead. */
-    const createJSDocThisTag: (tagName: Identifier | undefined, typeExpression: JSDocTypeExpression, comment?: string | NodeArray<JSDocComment> | undefined) => JSDocThisTag;
+    export const createJSDocThisTag: typeof factory.createJSDocThisTag;
     /** @deprecated Use `factory.createJSDocComment` or the factory supplied by your transformation context instead. */
-    const createJSDocComment: (comment?: string | NodeArray<JSDocComment> | undefined, tags?: readonly JSDocTag[] | undefined) => JSDoc;
+    export const createJSDocComment: typeof factory.createJSDocComment;
     /** @deprecated Use `factory.createJSDocParameterTag` or the factory supplied by your transformation context instead. */
-    const createJSDocParameterTag: (tagName: Identifier | undefined, name: EntityName, isBracketed: boolean, typeExpression?: JSDocTypeExpression | undefined, isNameFirst?: boolean | undefined, comment?: string | NodeArray<JSDocComment> | undefined) => JSDocParameterTag;
+    export const createJSDocParameterTag: typeof factory.createJSDocParameterTag;
     /** @deprecated Use `factory.createJSDocClassTag` or the factory supplied by your transformation context instead. */
-    const createJSDocClassTag: (tagName: Identifier | undefined, comment?: string | NodeArray<JSDocComment> | undefined) => JSDocClassTag;
+    export const createJSDocClassTag: typeof factory.createJSDocClassTag;
     /** @deprecated Use `factory.createJSDocAugmentsTag` or the factory supplied by your transformation context instead. */
-    const createJSDocAugmentsTag: (tagName: Identifier | undefined, className: ExpressionWithTypeArguments & {
-        readonly expression: Identifier | PropertyAccessEntityNameExpression;
-    }, comment?: string | NodeArray<JSDocComment> | undefined) => JSDocAugmentsTag;
+    export const createJSDocAugmentsTag: typeof factory.createJSDocAugmentsTag;
     /** @deprecated Use `factory.createJSDocEnumTag` or the factory supplied by your transformation context instead. */
-    const createJSDocEnumTag: (tagName: Identifier | undefined, typeExpression: JSDocTypeExpression, comment?: string | NodeArray<JSDocComment> | undefined) => JSDocEnumTag;
+    export const createJSDocEnumTag: typeof factory.createJSDocEnumTag;
     /** @deprecated Use `factory.createJSDocTemplateTag` or the factory supplied by your transformation context instead. */
-    const createJSDocTemplateTag: (tagName: Identifier | undefined, constraint: JSDocTypeExpression | undefined, typeParameters: readonly TypeParameterDeclaration[], comment?: string | NodeArray<JSDocComment> | undefined) => JSDocTemplateTag;
+    export const createJSDocTemplateTag: typeof factory.createJSDocTemplateTag;
     /** @deprecated Use `factory.createJSDocTypedefTag` or the factory supplied by your transformation context instead. */
-    const createJSDocTypedefTag: (tagName: Identifier | undefined, typeExpression?: JSDocTypeLiteral | JSDocTypeExpression | undefined, fullName?: Identifier | JSDocNamespaceDeclaration | undefined, comment?: string | NodeArray<JSDocComment> | undefined) => JSDocTypedefTag;
+    export const createJSDocTypedefTag: typeof factory.createJSDocTypedefTag;
     /** @deprecated Use `factory.createJSDocCallbackTag` or the factory supplied by your transformation context instead. */
-    const createJSDocCallbackTag: (tagName: Identifier | undefined, typeExpression: JSDocSignature, fullName?: Identifier | JSDocNamespaceDeclaration | undefined, comment?: string | NodeArray<JSDocComment> | undefined) => JSDocCallbackTag;
+    export const createJSDocCallbackTag: typeof factory.createJSDocCallbackTag;
     /** @deprecated Use `factory.createJSDocSignature` or the factory supplied by your transformation context instead. */
-    const createJSDocSignature: (typeParameters: readonly JSDocTemplateTag[] | undefined, parameters: readonly JSDocParameterTag[], type?: JSDocReturnTag | undefined) => JSDocSignature;
+    export const createJSDocSignature: typeof factory.createJSDocSignature;
     /** @deprecated Use `factory.createJSDocPropertyTag` or the factory supplied by your transformation context instead. */
-    const createJSDocPropertyTag: (tagName: Identifier | undefined, name: EntityName, isBracketed: boolean, typeExpression?: JSDocTypeExpression | undefined, isNameFirst?: boolean | undefined, comment?: string | NodeArray<JSDocComment> | undefined) => JSDocPropertyTag;
+    export const createJSDocPropertyTag: typeof factory.createJSDocPropertyTag;
     /** @deprecated Use `factory.createJSDocTypeLiteral` or the factory supplied by your transformation context instead. */
-    const createJSDocTypeLiteral: (jsDocPropertyTags?: readonly JSDocPropertyLikeTag[] | undefined, isArrayType?: boolean | undefined) => JSDocTypeLiteral;
+    export const createJSDocTypeLiteral: typeof factory.createJSDocTypeLiteral;
     /** @deprecated Use `factory.createJSDocImplementsTag` or the factory supplied by your transformation context instead. */
-    const createJSDocImplementsTag: (tagName: Identifier | undefined, className: ExpressionWithTypeArguments & {
-        readonly expression: Identifier | PropertyAccessEntityNameExpression;
-    }, comment?: string | NodeArray<JSDocComment> | undefined) => JSDocImplementsTag;
+    export const createJSDocImplementsTag: typeof factory.createJSDocImplementsTag;
     /** @deprecated Use `factory.createJSDocAuthorTag` or the factory supplied by your transformation context instead. */
-    const createJSDocAuthorTag: (tagName: Identifier | undefined, comment?: string | NodeArray<JSDocComment> | undefined) => JSDocAuthorTag;
+    export const createJSDocAuthorTag: typeof factory.createJSDocAuthorTag;
     /** @deprecated Use `factory.createJSDocPublicTag` or the factory supplied by your transformation context instead. */
-    const createJSDocPublicTag: (tagName: Identifier | undefined, comment?: string | NodeArray<JSDocComment> | undefined) => JSDocPublicTag;
+    export const createJSDocPublicTag: typeof factory.createJSDocPublicTag;
     /** @deprecated Use `factory.createJSDocPrivateTag` or the factory supplied by your transformation context instead. */
-    const createJSDocPrivateTag: (tagName: Identifier | undefined, comment?: string | NodeArray<JSDocComment> | undefined) => JSDocPrivateTag;
+    export const createJSDocPrivateTag: typeof factory.createJSDocPrivateTag;
     /** @deprecated Use `factory.createJSDocProtectedTag` or the factory supplied by your transformation context instead. */
-    const createJSDocProtectedTag: (tagName: Identifier | undefined, comment?: string | NodeArray<JSDocComment> | undefined) => JSDocProtectedTag;
+    export const createJSDocProtectedTag: typeof factory.createJSDocProtectedTag;
     /** @deprecated Use `factory.createJSDocReadonlyTag` or the factory supplied by your transformation context instead. */
-    const createJSDocReadonlyTag: (tagName: Identifier | undefined, comment?: string | NodeArray<JSDocComment> | undefined) => JSDocReadonlyTag;
+    export const createJSDocReadonlyTag: typeof factory.createJSDocReadonlyTag;
     /** @deprecated Use `factory.createJSDocUnknownTag` or the factory supplied by your transformation context instead. */
-    const createJSDocTag: (tagName: Identifier, comment?: string | NodeArray<JSDocComment> | undefined) => JSDocUnknownTag;
+    export const createJSDocTag: typeof factory.createJSDocUnknownTag;
     /** @deprecated Use `factory.createJsxElement` or the factory supplied by your transformation context instead. */
-    const createJsxElement: (openingElement: JsxOpeningElement, children: readonly JsxChild[], closingElement: JsxClosingElement) => JsxElement;
+    export const createJsxElement: typeof factory.createJsxElement;
     /** @deprecated Use `factory.updateJsxElement` or the factory supplied by your transformation context instead. */
-    const updateJsxElement: (node: JsxElement, openingElement: JsxOpeningElement, children: readonly JsxChild[], closingElement: JsxClosingElement) => JsxElement;
+    export const updateJsxElement: typeof factory.updateJsxElement;
     /** @deprecated Use `factory.createJsxSelfClosingElement` or the factory supplied by your transformation context instead. */
-    const createJsxSelfClosingElement: (tagName: JsxTagNameExpression, typeArguments: readonly TypeNode[] | undefined, attributes: JsxAttributes) => JsxSelfClosingElement;
+    export const createJsxSelfClosingElement: typeof factory.createJsxSelfClosingElement;
     /** @deprecated Use `factory.updateJsxSelfClosingElement` or the factory supplied by your transformation context instead. */
-    const updateJsxSelfClosingElement: (node: JsxSelfClosingElement, tagName: JsxTagNameExpression, typeArguments: readonly TypeNode[] | undefined, attributes: JsxAttributes) => JsxSelfClosingElement;
+    export const updateJsxSelfClosingElement: typeof factory.updateJsxSelfClosingElement;
     /** @deprecated Use `factory.createJsxOpeningElement` or the factory supplied by your transformation context instead. */
-    const createJsxOpeningElement: (tagName: JsxTagNameExpression, typeArguments: readonly TypeNode[] | undefined, attributes: JsxAttributes) => JsxOpeningElement;
+    export const createJsxOpeningElement: typeof factory.createJsxOpeningElement;
     /** @deprecated Use `factory.updateJsxOpeningElement` or the factory supplied by your transformation context instead. */
-    const updateJsxOpeningElement: (node: JsxOpeningElement, tagName: JsxTagNameExpression, typeArguments: readonly TypeNode[] | undefined, attributes: JsxAttributes) => JsxOpeningElement;
+    export const updateJsxOpeningElement: typeof factory.updateJsxOpeningElement;
     /** @deprecated Use `factory.createJsxClosingElement` or the factory supplied by your transformation context instead. */
-    const createJsxClosingElement: (tagName: JsxTagNameExpression) => JsxClosingElement;
+    export const createJsxClosingElement: typeof factory.createJsxClosingElement;
     /** @deprecated Use `factory.updateJsxClosingElement` or the factory supplied by your transformation context instead. */
-    const updateJsxClosingElement: (node: JsxClosingElement, tagName: JsxTagNameExpression) => JsxClosingElement;
+    export const updateJsxClosingElement: typeof factory.updateJsxClosingElement;
     /** @deprecated Use `factory.createJsxFragment` or the factory supplied by your transformation context instead. */
-    const createJsxFragment: (openingFragment: JsxOpeningFragment, children: readonly JsxChild[], closingFragment: JsxClosingFragment) => JsxFragment;
+    export const createJsxFragment: typeof factory.createJsxFragment;
     /** @deprecated Use `factory.createJsxText` or the factory supplied by your transformation context instead. */
-    const createJsxText: (text: string, containsOnlyTriviaWhiteSpaces?: boolean | undefined) => JsxText;
+    export const createJsxText: typeof factory.createJsxText;
     /** @deprecated Use `factory.updateJsxText` or the factory supplied by your transformation context instead. */
-    const updateJsxText: (node: JsxText, text: string, containsOnlyTriviaWhiteSpaces?: boolean | undefined) => JsxText;
+    export const updateJsxText: typeof factory.updateJsxText;
     /** @deprecated Use `factory.createJsxOpeningFragment` or the factory supplied by your transformation context instead. */
-    const createJsxOpeningFragment: () => JsxOpeningFragment;
+    export const createJsxOpeningFragment: typeof factory.createJsxOpeningFragment;
     /** @deprecated Use `factory.createJsxJsxClosingFragment` or the factory supplied by your transformation context instead. */
-    const createJsxJsxClosingFragment: () => JsxClosingFragment;
+    export const createJsxJsxClosingFragment: typeof factory.createJsxJsxClosingFragment;
     /** @deprecated Use `factory.updateJsxFragment` or the factory supplied by your transformation context instead. */
-    const updateJsxFragment: (node: JsxFragment, openingFragment: JsxOpeningFragment, children: readonly JsxChild[], closingFragment: JsxClosingFragment) => JsxFragment;
+    export const updateJsxFragment: typeof factory.updateJsxFragment;
     /** @deprecated Use `factory.createJsxAttribute` or the factory supplied by your transformation context instead. */
-    const createJsxAttribute: (name: Identifier, initializer: JsxAttributeValue | undefined) => JsxAttribute;
+    export const createJsxAttribute: typeof factory.createJsxAttribute;
     /** @deprecated Use `factory.updateJsxAttribute` or the factory supplied by your transformation context instead. */
-    const updateJsxAttribute: (node: JsxAttribute, name: Identifier, initializer: JsxAttributeValue | undefined) => JsxAttribute;
+    export const updateJsxAttribute: typeof factory.updateJsxAttribute;
     /** @deprecated Use `factory.createJsxAttributes` or the factory supplied by your transformation context instead. */
-    const createJsxAttributes: (properties: readonly JsxAttributeLike[]) => JsxAttributes;
+    export const createJsxAttributes: typeof factory.createJsxAttributes;
     /** @deprecated Use `factory.updateJsxAttributes` or the factory supplied by your transformation context instead. */
-    const updateJsxAttributes: (node: JsxAttributes, properties: readonly JsxAttributeLike[]) => JsxAttributes;
+    export const updateJsxAttributes: typeof factory.updateJsxAttributes;
     /** @deprecated Use `factory.createJsxSpreadAttribute` or the factory supplied by your transformation context instead. */
-    const createJsxSpreadAttribute: (expression: Expression) => JsxSpreadAttribute;
+    export const createJsxSpreadAttribute: typeof factory.createJsxSpreadAttribute;
     /** @deprecated Use `factory.updateJsxSpreadAttribute` or the factory supplied by your transformation context instead. */
-    const updateJsxSpreadAttribute: (node: JsxSpreadAttribute, expression: Expression) => JsxSpreadAttribute;
+    export const updateJsxSpreadAttribute: typeof factory.updateJsxSpreadAttribute;
     /** @deprecated Use `factory.createJsxExpression` or the factory supplied by your transformation context instead. */
-    const createJsxExpression: (dotDotDotToken: DotDotDotToken | undefined, expression: Expression | undefined) => JsxExpression;
+    export const createJsxExpression: typeof factory.createJsxExpression;
     /** @deprecated Use `factory.updateJsxExpression` or the factory supplied by your transformation context instead. */
-    const updateJsxExpression: (node: JsxExpression, expression: Expression | undefined) => JsxExpression;
+    export const updateJsxExpression: typeof factory.updateJsxExpression;
     /** @deprecated Use `factory.createCaseClause` or the factory supplied by your transformation context instead. */
-    const createCaseClause: (expression: Expression, statements: readonly Statement[]) => CaseClause;
+    export const createCaseClause: typeof factory.createCaseClause;
     /** @deprecated Use `factory.updateCaseClause` or the factory supplied by your transformation context instead. */
-    const updateCaseClause: (node: CaseClause, expression: Expression, statements: readonly Statement[]) => CaseClause;
+    export const updateCaseClause: typeof factory.updateCaseClause;
     /** @deprecated Use `factory.createDefaultClause` or the factory supplied by your transformation context instead. */
-    const createDefaultClause: (statements: readonly Statement[]) => DefaultClause;
+    export const createDefaultClause: typeof factory.createDefaultClause;
     /** @deprecated Use `factory.updateDefaultClause` or the factory supplied by your transformation context instead. */
-    const updateDefaultClause: (node: DefaultClause, statements: readonly Statement[]) => DefaultClause;
+    export const updateDefaultClause: typeof factory.updateDefaultClause;
     /** @deprecated Use `factory.createHeritageClause` or the factory supplied by your transformation context instead. */
-    const createHeritageClause: (token: SyntaxKind.ExtendsKeyword | SyntaxKind.ImplementsKeyword, types: readonly ExpressionWithTypeArguments[]) => HeritageClause;
+    export const createHeritageClause: typeof factory.createHeritageClause;
     /** @deprecated Use `factory.updateHeritageClause` or the factory supplied by your transformation context instead. */
-    const updateHeritageClause: (node: HeritageClause, types: readonly ExpressionWithTypeArguments[]) => HeritageClause;
+    export const updateHeritageClause: typeof factory.updateHeritageClause;
     /** @deprecated Use `factory.createCatchClause` or the factory supplied by your transformation context instead. */
-    const createCatchClause: (variableDeclaration: string | VariableDeclaration | BindingName | undefined, block: Block) => CatchClause;
+    export const createCatchClause: typeof factory.createCatchClause;
     /** @deprecated Use `factory.updateCatchClause` or the factory supplied by your transformation context instead. */
-    const updateCatchClause: (node: CatchClause, variableDeclaration: VariableDeclaration | undefined, block: Block) => CatchClause;
+    export const updateCatchClause: typeof factory.updateCatchClause;
     /** @deprecated Use `factory.createPropertyAssignment` or the factory supplied by your transformation context instead. */
-    const createPropertyAssignment: (name: string | PropertyName, initializer: Expression) => PropertyAssignment;
+    export const createPropertyAssignment: typeof factory.createPropertyAssignment;
     /** @deprecated Use `factory.updatePropertyAssignment` or the factory supplied by your transformation context instead. */
-    const updatePropertyAssignment: (node: PropertyAssignment, name: PropertyName, initializer: Expression) => PropertyAssignment;
+    export const updatePropertyAssignment: typeof factory.updatePropertyAssignment;
     /** @deprecated Use `factory.createShorthandPropertyAssignment` or the factory supplied by your transformation context instead. */
-    const createShorthandPropertyAssignment: (name: string | Identifier, objectAssignmentInitializer?: Expression | undefined) => ShorthandPropertyAssignment;
+    export const createShorthandPropertyAssignment: typeof factory.createShorthandPropertyAssignment;
     /** @deprecated Use `factory.updateShorthandPropertyAssignment` or the factory supplied by your transformation context instead. */
-    const updateShorthandPropertyAssignment: (node: ShorthandPropertyAssignment, name: Identifier, objectAssignmentInitializer: Expression | undefined) => ShorthandPropertyAssignment;
+    export const updateShorthandPropertyAssignment: typeof factory.updateShorthandPropertyAssignment;
     /** @deprecated Use `factory.createSpreadAssignment` or the factory supplied by your transformation context instead. */
-    const createSpreadAssignment: (expression: Expression) => SpreadAssignment;
+    export const createSpreadAssignment: typeof factory.createSpreadAssignment;
     /** @deprecated Use `factory.updateSpreadAssignment` or the factory supplied by your transformation context instead. */
-    const updateSpreadAssignment: (node: SpreadAssignment, expression: Expression) => SpreadAssignment;
+    export const updateSpreadAssignment: typeof factory.updateSpreadAssignment;
     /** @deprecated Use `factory.createEnumMember` or the factory supplied by your transformation context instead. */
-    const createEnumMember: (name: string | PropertyName, initializer?: Expression | undefined) => EnumMember;
+    export const createEnumMember: typeof factory.createEnumMember;
     /** @deprecated Use `factory.updateEnumMember` or the factory supplied by your transformation context instead. */
-    const updateEnumMember: (node: EnumMember, name: PropertyName, initializer: Expression | undefined) => EnumMember;
+    export const updateEnumMember: typeof factory.updateEnumMember;
     /** @deprecated Use `factory.updateSourceFile` or the factory supplied by your transformation context instead. */
-    const updateSourceFileNode: (node: SourceFile, statements: readonly Statement[], isDeclarationFile?: boolean | undefined, referencedFiles?: readonly FileReference[] | undefined, typeReferences?: readonly FileReference[] | undefined, hasNoDefaultLib?: boolean | undefined, libReferences?: readonly FileReference[] | undefined) => SourceFile;
+    export const updateSourceFileNode: typeof factory.updateSourceFile;
     /** @deprecated Use `factory.createNotEmittedStatement` or the factory supplied by your transformation context instead. */
-    const createNotEmittedStatement: (original: Node) => NotEmittedStatement;
+    export const createNotEmittedStatement: typeof factory.createNotEmittedStatement;
     /** @deprecated Use `factory.createPartiallyEmittedExpression` or the factory supplied by your transformation context instead. */
-    const createPartiallyEmittedExpression: (expression: Expression, original?: Node | undefined) => PartiallyEmittedExpression;
+    export const createPartiallyEmittedExpression: typeof factory.createPartiallyEmittedExpression;
     /** @deprecated Use `factory.updatePartiallyEmittedExpression` or the factory supplied by your transformation context instead. */
-    const updatePartiallyEmittedExpression: (node: PartiallyEmittedExpression, expression: Expression) => PartiallyEmittedExpression;
+    export const updatePartiallyEmittedExpression: typeof factory.updatePartiallyEmittedExpression;
     /** @deprecated Use `factory.createCommaListExpression` or the factory supplied by your transformation context instead. */
-    const createCommaList: (elements: readonly Expression[]) => CommaListExpression;
+    export const createCommaList: typeof factory.createCommaListExpression;
     /** @deprecated Use `factory.updateCommaListExpression` or the factory supplied by your transformation context instead. */
-    const updateCommaList: (node: CommaListExpression, elements: readonly Expression[]) => CommaListExpression;
+    export const updateCommaList: typeof factory.updateCommaListExpression;
     /** @deprecated Use `factory.createBundle` or the factory supplied by your transformation context instead. */
-    const createBundle: (sourceFiles: readonly SourceFile[], prepends?: readonly (UnparsedSource | InputFiles)[] | undefined) => Bundle;
+    export const createBundle: typeof factory.createBundle;
     /** @deprecated Use `factory.updateBundle` or the factory supplied by your transformation context instead. */
-    const updateBundle: (node: Bundle, sourceFiles: readonly SourceFile[], prepends?: readonly (UnparsedSource | InputFiles)[] | undefined) => Bundle;
+    export const updateBundle: typeof factory.updateBundle;
     /** @deprecated Use `factory.createImmediatelyInvokedFunctionExpression` or the factory supplied by your transformation context instead. */
-    const createImmediatelyInvokedFunctionExpression: {
-        (statements: readonly Statement[]): CallExpression;
-        (statements: readonly Statement[], param: ParameterDeclaration, paramValue: Expression): CallExpression;
-    };
+    export const createImmediatelyInvokedFunctionExpression: typeof factory.createImmediatelyInvokedFunctionExpression;
     /** @deprecated Use `factory.createImmediatelyInvokedArrowFunction` or the factory supplied by your transformation context instead. */
-    const createImmediatelyInvokedArrowFunction: {
-        (statements: readonly Statement[]): CallExpression;
-        (statements: readonly Statement[], param: ParameterDeclaration, paramValue: Expression): CallExpression;
-    };
+    export const createImmediatelyInvokedArrowFunction: typeof factory.createImmediatelyInvokedArrowFunction;
     /** @deprecated Use `factory.createVoidZero` or the factory supplied by your transformation context instead. */
-    const createVoidZero: () => VoidExpression;
+    export const createVoidZero: typeof factory.createVoidZero;
     /** @deprecated Use `factory.createExportDefault` or the factory supplied by your transformation context instead. */
-    const createExportDefault: (expression: Expression) => ExportAssignment;
+    export const createExportDefault: typeof factory.createExportDefault;
     /** @deprecated Use `factory.createExternalModuleExport` or the factory supplied by your transformation context instead. */
-    const createExternalModuleExport: (exportName: Identifier) => ExportDeclaration;
+    export const createExternalModuleExport: typeof factory.createExternalModuleExport;
     /** @deprecated Use `factory.createNamespaceExport` or the factory supplied by your transformation context instead. */
-    const createNamespaceExport: (name: Identifier) => NamespaceExport;
+    export const createNamespaceExport: typeof factory.createNamespaceExport;
     /** @deprecated Use `factory.updateNamespaceExport` or the factory supplied by your transformation context instead. */
-    const updateNamespaceExport: (node: NamespaceExport, name: Identifier) => NamespaceExport;
+    export const updateNamespaceExport: typeof factory.updateNamespaceExport;
     /** @deprecated Use `factory.createToken` or the factory supplied by your transformation context instead. */
-    const createToken: <TKind extends SyntaxKind>(kind: TKind) => Token<TKind>;
+    export const createToken: <TKind extends SyntaxKind>(kind: TKind) => Token<TKind>;
     /** @deprecated Use `factory.createIdentifier` or the factory supplied by your transformation context instead. */
-    const createIdentifier: (text: string) => Identifier;
+    export const createIdentifier: (text: string) => Identifier;
     /** @deprecated Use `factory.createTempVariable` or the factory supplied by your transformation context instead. */
-    const createTempVariable: (recordTempVariable: ((node: Identifier) => void) | undefined) => Identifier;
+    export const createTempVariable: (recordTempVariable: ((node: Identifier) => void) | undefined) => Identifier;
     /** @deprecated Use `factory.getGeneratedNameForNode` or the factory supplied by your transformation context instead. */
-    const getGeneratedNameForNode: (node: Node | undefined) => Identifier;
+    export const getGeneratedNameForNode: (node: Node | undefined) => Identifier;
     /** @deprecated Use `factory.createUniqueName(text, GeneratedIdentifierFlags.Optimistic)` or the factory supplied by your transformation context instead. */
-    const createOptimisticUniqueName: (text: string) => Identifier;
+    export const createOptimisticUniqueName: (text: string) => Identifier;
     /** @deprecated Use `factory.createUniqueName(text, GeneratedIdentifierFlags.Optimistic | GeneratedIdentifierFlags.FileLevel)` or the factory supplied by your transformation context instead. */
-    const createFileLevelUniqueName: (text: string) => Identifier;
+    export const createFileLevelUniqueName: (text: string) => Identifier;
     /** @deprecated Use `factory.createIndexSignature` or the factory supplied by your transformation context instead. */
-    const createIndexSignature: (decorators: readonly Decorator[] | undefined, modifiers: readonly Modifier[] | undefined, parameters: readonly ParameterDeclaration[], type: TypeNode) => IndexSignatureDeclaration;
+    export const createIndexSignature: (decorators: readonly Decorator[] | undefined, modifiers: readonly Modifier[] | undefined, parameters: readonly ParameterDeclaration[], type: TypeNode) => IndexSignatureDeclaration;
     /** @deprecated Use `factory.createTypePredicateNode` or the factory supplied by your transformation context instead. */
-    const createTypePredicateNode: (parameterName: Identifier | ThisTypeNode | string, type: TypeNode) => TypePredicateNode;
+    export const createTypePredicateNode: (parameterName: Identifier | ThisTypeNode | string, type: TypeNode) => TypePredicateNode;
     /** @deprecated Use `factory.updateTypePredicateNode` or the factory supplied by your transformation context instead. */
-    const updateTypePredicateNode: (node: TypePredicateNode, parameterName: Identifier | ThisTypeNode, type: TypeNode) => TypePredicateNode;
+    export const updateTypePredicateNode: (node: TypePredicateNode, parameterName: Identifier | ThisTypeNode, type: TypeNode) => TypePredicateNode;
     /** @deprecated Use `factory.createStringLiteral`, `factory.createStringLiteralFromNode`, `factory.createNumericLiteral`, `factory.createBigIntLiteral`, `factory.createTrue`, `factory.createFalse`, or the factory supplied by your transformation context instead. */
-    const createLiteral: {
+    export const createLiteral: {
         (value: string | StringLiteral | NoSubstitutionTemplateLiteral | NumericLiteral | Identifier): StringLiteral;
         (value: number | PseudoBigInt): NumericLiteral;
         (value: boolean): BooleanLiteral;
         (value: string | number | PseudoBigInt | boolean): PrimaryExpression;
     };
     /** @deprecated Use `factory.createMethodSignature` or the factory supplied by your transformation context instead. */
-    const createMethodSignature: (typeParameters: readonly TypeParameterDeclaration[] | undefined, parameters: readonly ParameterDeclaration[], type: TypeNode | undefined, name: string | PropertyName, questionToken: QuestionToken | undefined) => MethodSignature;
+    export const createMethodSignature: (typeParameters: readonly TypeParameterDeclaration[] | undefined, parameters: readonly ParameterDeclaration[], type: TypeNode | undefined, name: string | PropertyName, questionToken: QuestionToken | undefined) => MethodSignature;
     /** @deprecated Use `factory.updateMethodSignature` or the factory supplied by your transformation context instead. */
-    const updateMethodSignature: (node: MethodSignature, typeParameters: NodeArray<TypeParameterDeclaration> | undefined, parameters: NodeArray<ParameterDeclaration>, type: TypeNode | undefined, name: PropertyName, questionToken: QuestionToken | undefined) => MethodSignature;
+    export const updateMethodSignature: (node: MethodSignature, typeParameters: NodeArray<TypeParameterDeclaration> | undefined, parameters: NodeArray<ParameterDeclaration>, type: TypeNode | undefined, name: PropertyName, questionToken: QuestionToken | undefined) => MethodSignature;
     /** @deprecated Use `factory.createTypeOperatorNode` or the factory supplied by your transformation context instead. */
-    const createTypeOperatorNode: {
+    export const createTypeOperatorNode: {
         (type: TypeNode): TypeOperatorNode;
         (operator: SyntaxKind.KeyOfKeyword | SyntaxKind.UniqueKeyword | SyntaxKind.ReadonlyKeyword, type: TypeNode): TypeOperatorNode;
     };
     /** @deprecated Use `factory.createTaggedTemplate` or the factory supplied by your transformation context instead. */
-    const createTaggedTemplate: {
+    export const createTaggedTemplate: {
         (tag: Expression, template: TemplateLiteral): TaggedTemplateExpression;
         (tag: Expression, typeArguments: readonly TypeNode[] | undefined, template: TemplateLiteral): TaggedTemplateExpression;
     };
     /** @deprecated Use `factory.updateTaggedTemplate` or the factory supplied by your transformation context instead. */
-    const updateTaggedTemplate: {
+    export const updateTaggedTemplate: {
         (node: TaggedTemplateExpression, tag: Expression, template: TemplateLiteral): TaggedTemplateExpression;
         (node: TaggedTemplateExpression, tag: Expression, typeArguments: readonly TypeNode[] | undefined, template: TemplateLiteral): TaggedTemplateExpression;
     };
     /** @deprecated Use `factory.updateBinary` or the factory supplied by your transformation context instead. */
-    const updateBinary: (node: BinaryExpression, left: Expression, right: Expression, operator?: BinaryOperator | BinaryOperatorToken) => BinaryExpression;
+    export const updateBinary: (node: BinaryExpression, left: Expression, right: Expression, operator?: BinaryOperator | BinaryOperatorToken) => BinaryExpression;
     /** @deprecated Use `factory.createConditional` or the factory supplied by your transformation context instead. */
-    const createConditional: {
+    export const createConditional: {
         (condition: Expression, whenTrue: Expression, whenFalse: Expression): ConditionalExpression;
         (condition: Expression, questionToken: QuestionToken, whenTrue: Expression, colonToken: ColonToken, whenFalse: Expression): ConditionalExpression;
     };
     /** @deprecated Use `factory.createYield` or the factory supplied by your transformation context instead. */
-    const createYield: {
+    export const createYield: {
         (expression?: Expression | undefined): YieldExpression;
         (asteriskToken: AsteriskToken | undefined, expression: Expression): YieldExpression;
     };
     /** @deprecated Use `factory.createClassExpression` or the factory supplied by your transformation context instead. */
-    const createClassExpression: (modifiers: readonly Modifier[] | undefined, name: string | Identifier | undefined, typeParameters: readonly TypeParameterDeclaration[] | undefined, heritageClauses: readonly HeritageClause[] | undefined, members: readonly ClassElement[]) => ClassExpression;
+    export const createClassExpression: (modifiers: readonly Modifier[] | undefined, name: string | Identifier | undefined, typeParameters: readonly TypeParameterDeclaration[] | undefined, heritageClauses: readonly HeritageClause[] | undefined, members: readonly ClassElement[]) => ClassExpression;
     /** @deprecated Use `factory.updateClassExpression` or the factory supplied by your transformation context instead. */
-    const updateClassExpression: (node: ClassExpression, modifiers: readonly Modifier[] | undefined, name: Identifier | undefined, typeParameters: readonly TypeParameterDeclaration[] | undefined, heritageClauses: readonly HeritageClause[] | undefined, members: readonly ClassElement[]) => ClassExpression;
+    export const updateClassExpression: (node: ClassExpression, modifiers: readonly Modifier[] | undefined, name: Identifier | undefined, typeParameters: readonly TypeParameterDeclaration[] | undefined, heritageClauses: readonly HeritageClause[] | undefined, members: readonly ClassElement[]) => ClassExpression;
     /** @deprecated Use `factory.createPropertySignature` or the factory supplied by your transformation context instead. */
-    const createPropertySignature: (modifiers: readonly Modifier[] | undefined, name: PropertyName | string, questionToken: QuestionToken | undefined, type: TypeNode | undefined, initializer?: Expression | undefined) => PropertySignature;
+    export const createPropertySignature: (modifiers: readonly Modifier[] | undefined, name: PropertyName | string, questionToken: QuestionToken | undefined, type: TypeNode | undefined, initializer?: Expression | undefined) => PropertySignature;
     /** @deprecated Use `factory.updatePropertySignature` or the factory supplied by your transformation context instead. */
-    const updatePropertySignature: (node: PropertySignature, modifiers: readonly Modifier[] | undefined, name: PropertyName, questionToken: QuestionToken | undefined, type: TypeNode | undefined, initializer: Expression | undefined) => PropertySignature;
+    export const updatePropertySignature: (node: PropertySignature, modifiers: readonly Modifier[] | undefined, name: PropertyName, questionToken: QuestionToken | undefined, type: TypeNode | undefined, initializer: Expression | undefined) => PropertySignature;
     /** @deprecated Use `factory.createExpressionWithTypeArguments` or the factory supplied by your transformation context instead. */
-    const createExpressionWithTypeArguments: (typeArguments: readonly TypeNode[] | undefined, expression: Expression) => ExpressionWithTypeArguments;
+    export const createExpressionWithTypeArguments: (typeArguments: readonly TypeNode[] | undefined, expression: Expression) => ExpressionWithTypeArguments;
     /** @deprecated Use `factory.updateExpressionWithTypeArguments` or the factory supplied by your transformation context instead. */
-    const updateExpressionWithTypeArguments: (node: ExpressionWithTypeArguments, typeArguments: readonly TypeNode[] | undefined, expression: Expression) => ExpressionWithTypeArguments;
+    export const updateExpressionWithTypeArguments: (node: ExpressionWithTypeArguments, typeArguments: readonly TypeNode[] | undefined, expression: Expression) => ExpressionWithTypeArguments;
     /** @deprecated Use `factory.createArrowFunction` or the factory supplied by your transformation context instead. */
-    const createArrowFunction: {
+    export const createArrowFunction: {
         (modifiers: readonly Modifier[] | undefined, typeParameters: readonly TypeParameterDeclaration[] | undefined, parameters: readonly ParameterDeclaration[], type: TypeNode | undefined, equalsGreaterThanToken: EqualsGreaterThanToken | undefined, body: ConciseBody): ArrowFunction;
         (modifiers: readonly Modifier[] | undefined, typeParameters: readonly TypeParameterDeclaration[] | undefined, parameters: readonly ParameterDeclaration[], type: TypeNode | undefined, body: ConciseBody): ArrowFunction;
     };
     /** @deprecated Use `factory.updateArrowFunction` or the factory supplied by your transformation context instead. */
-    const updateArrowFunction: {
+    export const updateArrowFunction: {
         (node: ArrowFunction, modifiers: readonly Modifier[] | undefined, typeParameters: readonly TypeParameterDeclaration[] | undefined, parameters: readonly ParameterDeclaration[], type: TypeNode | undefined, equalsGreaterThanToken: EqualsGreaterThanToken, body: ConciseBody): ArrowFunction;
         (node: ArrowFunction, modifiers: readonly Modifier[] | undefined, typeParameters: readonly TypeParameterDeclaration[] | undefined, parameters: readonly ParameterDeclaration[], type: TypeNode | undefined, body: ConciseBody): ArrowFunction;
     };
     /** @deprecated Use `factory.createVariableDeclaration` or the factory supplied by your transformation context instead. */
-    const createVariableDeclaration: {
+    export const createVariableDeclaration: {
         (name: string | BindingName, type?: TypeNode | undefined, initializer?: Expression | undefined): VariableDeclaration;
         (name: string | BindingName, exclamationToken: ExclamationToken | undefined, type: TypeNode | undefined, initializer: Expression | undefined): VariableDeclaration;
     };
     /** @deprecated Use `factory.updateVariableDeclaration` or the factory supplied by your transformation context instead. */
-    const updateVariableDeclaration: {
+    export const updateVariableDeclaration: {
         (node: VariableDeclaration, name: BindingName, type: TypeNode | undefined, initializer: Expression | undefined): VariableDeclaration;
         (node: VariableDeclaration, name: BindingName, exclamationToken: ExclamationToken | undefined, type: TypeNode | undefined, initializer: Expression | undefined): VariableDeclaration;
     };
     /** @deprecated Use `factory.createImportClause` or the factory supplied by your transformation context instead. */
-    const createImportClause: (name: Identifier | undefined, namedBindings: NamedImportBindings | undefined, isTypeOnly?: any) => ImportClause;
+    export const createImportClause: (name: Identifier | undefined, namedBindings: NamedImportBindings | undefined, isTypeOnly?: any) => ImportClause;
     /** @deprecated Use `factory.updateImportClause` or the factory supplied by your transformation context instead. */
-    const updateImportClause: (node: ImportClause, name: Identifier | undefined, namedBindings: NamedImportBindings | undefined, isTypeOnly: boolean) => ImportClause;
+    export const updateImportClause: (node: ImportClause, name: Identifier | undefined, namedBindings: NamedImportBindings | undefined, isTypeOnly: boolean) => ImportClause;
     /** @deprecated Use `factory.createExportDeclaration` or the factory supplied by your transformation context instead. */
-    const createExportDeclaration: (decorators: readonly Decorator[] | undefined, modifiers: readonly Modifier[] | undefined, exportClause: NamedExportBindings | undefined, moduleSpecifier?: Expression | undefined, isTypeOnly?: any) => ExportDeclaration;
+    export const createExportDeclaration: (decorators: readonly Decorator[] | undefined, modifiers: readonly Modifier[] | undefined, exportClause: NamedExportBindings | undefined, moduleSpecifier?: Expression | undefined, isTypeOnly?: any) => ExportDeclaration;
     /** @deprecated Use `factory.updateExportDeclaration` or the factory supplied by your transformation context instead. */
-    const updateExportDeclaration: (node: ExportDeclaration, decorators: readonly Decorator[] | undefined, modifiers: readonly Modifier[] | undefined, exportClause: NamedExportBindings | undefined, moduleSpecifier: Expression | undefined, isTypeOnly: boolean) => ExportDeclaration;
+    export const updateExportDeclaration: (node: ExportDeclaration, decorators: readonly Decorator[] | undefined, modifiers: readonly Modifier[] | undefined, exportClause: NamedExportBindings | undefined, moduleSpecifier: Expression | undefined, isTypeOnly: boolean) => ExportDeclaration;
     /** @deprecated Use `factory.createJSDocParameterTag` or the factory supplied by your transformation context instead. */
-    const createJSDocParamTag: (name: EntityName, isBracketed: boolean, typeExpression?: JSDocTypeExpression | undefined, comment?: string | undefined) => JSDocParameterTag;
+    export const createJSDocParamTag: (name: EntityName, isBracketed: boolean, typeExpression?: JSDocTypeExpression | undefined, comment?: string | undefined) => JSDocParameterTag;
     /** @deprecated Use `factory.createComma` or the factory supplied by your transformation context instead. */
-    const createComma: (left: Expression, right: Expression) => Expression;
+    export const createComma: (left: Expression, right: Expression) => Expression;
     /** @deprecated Use `factory.createLessThan` or the factory supplied by your transformation context instead. */
-    const createLessThan: (left: Expression, right: Expression) => Expression;
+    export const createLessThan: (left: Expression, right: Expression) => Expression;
     /** @deprecated Use `factory.createAssignment` or the factory supplied by your transformation context instead. */
-    const createAssignment: (left: Expression, right: Expression) => BinaryExpression;
+    export const createAssignment: (left: Expression, right: Expression) => BinaryExpression;
     /** @deprecated Use `factory.createStrictEquality` or the factory supplied by your transformation context instead. */
-    const createStrictEquality: (left: Expression, right: Expression) => BinaryExpression;
+    export const createStrictEquality: (left: Expression, right: Expression) => BinaryExpression;
     /** @deprecated Use `factory.createStrictInequality` or the factory supplied by your transformation context instead. */
-    const createStrictInequality: (left: Expression, right: Expression) => BinaryExpression;
+    export const createStrictInequality: (left: Expression, right: Expression) => BinaryExpression;
     /** @deprecated Use `factory.createAdd` or the factory supplied by your transformation context instead. */
-    const createAdd: (left: Expression, right: Expression) => BinaryExpression;
+    export const createAdd: (left: Expression, right: Expression) => BinaryExpression;
     /** @deprecated Use `factory.createSubtract` or the factory supplied by your transformation context instead. */
-    const createSubtract: (left: Expression, right: Expression) => BinaryExpression;
+    export const createSubtract: (left: Expression, right: Expression) => BinaryExpression;
     /** @deprecated Use `factory.createLogicalAnd` or the factory supplied by your transformation context instead. */
-    const createLogicalAnd: (left: Expression, right: Expression) => BinaryExpression;
+    export const createLogicalAnd: (left: Expression, right: Expression) => BinaryExpression;
     /** @deprecated Use `factory.createLogicalOr` or the factory supplied by your transformation context instead. */
-    const createLogicalOr: (left: Expression, right: Expression) => BinaryExpression;
+    export const createLogicalOr: (left: Expression, right: Expression) => BinaryExpression;
     /** @deprecated Use `factory.createPostfixIncrement` or the factory supplied by your transformation context instead. */
-    const createPostfixIncrement: (operand: Expression) => PostfixUnaryExpression;
+    export const createPostfixIncrement: (operand: Expression) => PostfixUnaryExpression;
     /** @deprecated Use `factory.createLogicalNot` or the factory supplied by your transformation context instead. */
-    const createLogicalNot: (operand: Expression) => PrefixUnaryExpression;
+    export const createLogicalNot: (operand: Expression) => PrefixUnaryExpression;
     /** @deprecated Use an appropriate `factory` method instead. */
-    const createNode: (kind: SyntaxKind, pos?: any, end?: any) => Node;
+    export const createNode: (kind: SyntaxKind, pos?: any, end?: any) => Node;
     /**
      * Creates a shallow, memberwise clone of a node ~for mutation~ with its `pos`, `end`, and `parent` set.
      *
@@ -7890,256 +7939,12 @@ declare namespace ts {
      *
      * @deprecated Use an appropriate `factory.update...` method instead, use `setCommentRange` or `setSourceMapRange`, and avoid setting `parent`.
      */
-    const getMutableClone: <T extends Node>(node: T) => T;
-}
-declare namespace ts {
+    export const getMutableClone: <T extends Node>(node: T) => T;
     /** @deprecated Use `isTypeAssertionExpression` instead. */
-    const isTypeAssertion: (node: Node) => node is TypeAssertion;
-}
-declare namespace ts {
-    /**
-     * @deprecated Use `ts.ReadonlyESMap<K, V>` instead.
-     */
-    interface ReadonlyMap<T> extends ReadonlyESMap<string, T> {
-    }
-    /**
-     * @deprecated Use `ts.ESMap<K, V>` instead.
-     */
-    interface Map<T> extends ESMap<string, T> {
-    }
-}
-declare namespace ts {
+    export const isTypeAssertion: (node: Node) => node is TypeAssertion;
     /**
      * @deprecated Use `isMemberName` instead.
      */
-    const isIdentifierOrPrivateIdentifier: (node: Node) => node is MemberName;
-}
-declare namespace ts {
-    interface NodeFactory {
-        /** @deprecated Use the overload that accepts 'modifiers' */
-        createConstructorTypeNode(typeParameters: readonly TypeParameterDeclaration[] | undefined, parameters: readonly ParameterDeclaration[], type: TypeNode): ConstructorTypeNode;
-        /** @deprecated Use the overload that accepts 'modifiers' */
-        updateConstructorTypeNode(node: ConstructorTypeNode, typeParameters: NodeArray<TypeParameterDeclaration> | undefined, parameters: NodeArray<ParameterDeclaration>, type: TypeNode): ConstructorTypeNode;
-    }
-}
-declare namespace ts {
-    interface NodeFactory {
-        createImportTypeNode(argument: TypeNode, assertions?: ImportTypeAssertionContainer, qualifier?: EntityName, typeArguments?: readonly TypeNode[], isTypeOf?: boolean): ImportTypeNode;
-        /** @deprecated Use the overload that accepts 'assertions' */
-        createImportTypeNode(argument: TypeNode, qualifier?: EntityName, typeArguments?: readonly TypeNode[], isTypeOf?: boolean): ImportTypeNode;
-        /** @deprecated Use the overload that accepts 'assertions' */
-        updateImportTypeNode(node: ImportTypeNode, argument: TypeNode, qualifier: EntityName | undefined, typeArguments: readonly TypeNode[] | undefined, isTypeOf?: boolean): ImportTypeNode;
-    }
-}
-declare namespace ts {
-    interface NodeFactory {
-        /** @deprecated Use the overload that accepts 'modifiers' */
-        createTypeParameterDeclaration(name: string | Identifier, constraint?: TypeNode, defaultType?: TypeNode): TypeParameterDeclaration;
-        /** @deprecated Use the overload that accepts 'modifiers' */
-        updateTypeParameterDeclaration(node: TypeParameterDeclaration, name: Identifier, constraint: TypeNode | undefined, defaultType: TypeNode | undefined): TypeParameterDeclaration;
-    }
+    export const isIdentifierOrPrivateIdentifier: (node: Node) => node is MemberName;
 }
-declare namespace ts {
-    interface Node {
-        /**
-         * @deprecated `decorators` has been removed from `Node` and merged with `modifiers` on the `Node` subtypes that support them.
-         * Use `ts.canHaveDecorators()` to test whether a `Node` can have decorators.
-         * Use `ts.getDecorators()` to get the decorators of a `Node`.
-         *
-         * For example:
-         * ```ts
-         * const decorators = ts.canHaveDecorators(node) ? ts.getDecorators(node) : undefined;
-         * ```
-         */
-        readonly decorators?: undefined;
-        /**
-         * @deprecated `modifiers` has been removed from `Node` and moved to the `Node` subtypes that support them.
-         * Use `ts.canHaveModifiers()` to test whether a `Node` can have modifiers.
-         * Use `ts.getModifiers()` to get the modifiers of a `Node`.
-         *
-         * For example:
-         * ```ts
-         * const modifiers = ts.canHaveModifiers(node) ? ts.getModifiers(node) : undefined;
-         * ```
-         */
-        readonly modifiers?: NodeArray<ModifierLike> | undefined;
-    }
-    interface PropertySignature {
-        /** @deprecated A property signature cannot have an initializer */
-        readonly initializer?: Expression | undefined;
-    }
-    interface PropertyAssignment {
-        /** @deprecated A property assignment cannot have a question token */
-        readonly questionToken?: QuestionToken | undefined;
-        /** @deprecated A property assignment cannot have an exclamation token */
-        readonly exclamationToken?: ExclamationToken | undefined;
-    }
-    interface ShorthandPropertyAssignment {
-        /** @deprecated A shorthand property assignment cannot have modifiers */
-        readonly modifiers?: NodeArray<Modifier> | undefined;
-        /** @deprecated A shorthand property assignment cannot have a question token */
-        readonly questionToken?: QuestionToken | undefined;
-        /** @deprecated A shorthand property assignment cannot have an exclamation token */
-        readonly exclamationToken?: ExclamationToken | undefined;
-    }
-    interface FunctionTypeNode {
-        /** @deprecated A function type cannot have modifiers */
-        readonly modifiers?: NodeArray<Modifier> | undefined;
-    }
-    interface NodeFactory {
-        /**
-         * @deprecated Decorators have been combined with modifiers. Callers should use an overload that does not accept a `decorators` parameter.
-         */
-        createParameterDeclaration(decorators: readonly Decorator[] | undefined, modifiers: readonly Modifier[] | undefined, dotDotDotToken: DotDotDotToken | undefined, name: string | BindingName, questionToken?: QuestionToken, type?: TypeNode, initializer?: Expression): ParameterDeclaration;
-        /**
-         * @deprecated Decorators have been combined with modifiers. Callers should use an overload that does not accept a `decorators` parameter.
-         */
-        updateParameterDeclaration(node: ParameterDeclaration, decorators: readonly Decorator[] | undefined, modifiers: readonly Modifier[] | undefined, dotDotDotToken: DotDotDotToken | undefined, name: string | BindingName, questionToken: QuestionToken | undefined, type: TypeNode | undefined, initializer: Expression | undefined): ParameterDeclaration;
-        /**
-         * @deprecated Decorators have been combined with modifiers. Callers should use an overload that does not accept a `decorators` parameter.
-         */
-        createPropertyDeclaration(decorators: readonly Decorator[] | undefined, modifiers: readonly Modifier[] | undefined, name: string | PropertyName, questionOrExclamationToken: QuestionToken | ExclamationToken | undefined, type: TypeNode | undefined, initializer: Expression | undefined): PropertyDeclaration;
-        /**
-         * @deprecated Decorators have been combined with modifiers. Callers should use an overload that does not accept a `decorators` parameter.
-         */
-        updatePropertyDeclaration(node: PropertyDeclaration, decorators: readonly Decorator[] | undefined, modifiers: readonly Modifier[] | undefined, name: string | PropertyName, questionOrExclamationToken: QuestionToken | ExclamationToken | undefined, type: TypeNode | undefined, initializer: Expression | undefined): PropertyDeclaration;
-        /**
-         * @deprecated Decorators have been combined with modifiers. Callers should use an overload that does not accept a `decorators` parameter.
-         */
-        createMethodDeclaration(decorators: readonly Decorator[] | undefined, modifiers: readonly Modifier[] | undefined, asteriskToken: AsteriskToken | undefined, name: string | PropertyName, questionToken: QuestionToken | undefined, typeParameters: readonly TypeParameterDeclaration[] | undefined, parameters: readonly ParameterDeclaration[], type: TypeNode | undefined, body: Block | undefined): MethodDeclaration;
-        /**
-         * @deprecated Decorators have been combined with modifiers. Callers should use an overload that does not accept a `decorators` parameter.
-         */
-        updateMethodDeclaration(node: MethodDeclaration, decorators: readonly Decorator[] | undefined, modifiers: readonly Modifier[] | undefined, asteriskToken: AsteriskToken | undefined, name: PropertyName, questionToken: QuestionToken | undefined, typeParameters: readonly TypeParameterDeclaration[] | undefined, parameters: readonly ParameterDeclaration[], type: TypeNode | undefined, body: Block | undefined): MethodDeclaration;
-        /**
-         * @deprecated This node does not support Decorators. Callers should use an overload that does not accept a `decorators` parameter.
-         */
-        createConstructorDeclaration(decorators: readonly Decorator[] | undefined, modifiers: readonly Modifier[] | undefined, parameters: readonly ParameterDeclaration[], body: Block | undefined): ConstructorDeclaration;
-        /**
-         * @deprecated This node does not support Decorators. Callers should use an overload that does not accept a `decorators` parameter.
-         */
-        updateConstructorDeclaration(node: ConstructorDeclaration, decorators: readonly Decorator[] | undefined, modifiers: readonly Modifier[] | undefined, parameters: readonly ParameterDeclaration[], body: Block | undefined): ConstructorDeclaration;
-        /**
-         * @deprecated Decorators have been combined with modifiers. Callers should use an overload that does not accept a `decorators` parameter.
-         */
-        createGetAccessorDeclaration(decorators: readonly Decorator[] | undefined, modifiers: readonly Modifier[] | undefined, name: string | PropertyName, parameters: readonly ParameterDeclaration[], type: TypeNode | undefined, body: Block | undefined): GetAccessorDeclaration;
-        /**
-         * @deprecated Decorators have been combined with modifiers. Callers should use an overload that does not accept a `decorators` parameter.
-         */
-        updateGetAccessorDeclaration(node: GetAccessorDeclaration, decorators: readonly Decorator[] | undefined, modifiers: readonly Modifier[] | undefined, name: PropertyName, parameters: readonly ParameterDeclaration[], type: TypeNode | undefined, body: Block | undefined): GetAccessorDeclaration;
-        /**
-         * @deprecated Decorators have been combined with modifiers. Callers should use an overload that does not accept a `decorators` parameter.
-         */
-        createSetAccessorDeclaration(decorators: readonly Decorator[] | undefined, modifiers: readonly Modifier[] | undefined, name: string | PropertyName, parameters: readonly ParameterDeclaration[], body: Block | undefined): SetAccessorDeclaration;
-        /**
-         * @deprecated Decorators have been combined with modifiers. Callers should use an overload that does not accept a `decorators` parameter.
-         */
-        updateSetAccessorDeclaration(node: SetAccessorDeclaration, decorators: readonly Decorator[] | undefined, modifiers: readonly Modifier[] | undefined, name: PropertyName, parameters: readonly ParameterDeclaration[], body: Block | undefined): SetAccessorDeclaration;
-        /**
-         * @deprecated Decorators are no longer supported for this function. Callers should use an overload that does not accept a `decorators` parameter.
-         */
-        createIndexSignature(decorators: readonly Decorator[] | undefined, modifiers: readonly Modifier[] | undefined, parameters: readonly ParameterDeclaration[], type: TypeNode): IndexSignatureDeclaration;
-        /**
-         * @deprecated Decorators and modifiers are no longer supported for this function. Callers should use an overload that does not accept the `decorators` and `modifiers` parameters.
-         */
-        updateIndexSignature(node: IndexSignatureDeclaration, decorators: readonly Decorator[] | undefined, modifiers: readonly Modifier[] | undefined, parameters: readonly ParameterDeclaration[], type: TypeNode): IndexSignatureDeclaration;
-        /**
-         * @deprecated Decorators and modifiers are no longer supported for this function. Callers should use an overload that does not accept the `decorators` and `modifiers` parameters.
-         */
-        createClassStaticBlockDeclaration(decorators: readonly Decorator[] | undefined, modifiers: readonly Modifier[] | undefined, body: Block): ClassStaticBlockDeclaration;
-        /**
-         * @deprecated Decorators are no longer supported for this function. Callers should use an overload that does not accept a `decorators` parameter.
-         */
-        updateClassStaticBlockDeclaration(node: ClassStaticBlockDeclaration, decorators: readonly Decorator[] | undefined, modifiers: readonly Modifier[] | undefined, body: Block): ClassStaticBlockDeclaration;
-        /**
-         * @deprecated Decorators have been combined with modifiers. Callers should use an overload that does not accept a `decorators` parameter.
-         */
-        createClassExpression(decorators: readonly Decorator[] | undefined, modifiers: readonly Modifier[] | undefined, name: string | Identifier | undefined, typeParameters: readonly TypeParameterDeclaration[] | undefined, heritageClauses: readonly HeritageClause[] | undefined, members: readonly ClassElement[]): ClassExpression;
-        /**
-         * @deprecated Decorators have been combined with modifiers. Callers should use an overload that does not accept a `decorators` parameter.
-         */
-        updateClassExpression(node: ClassExpression, decorators: readonly Decorator[] | undefined, modifiers: readonly Modifier[] | undefined, name: Identifier | undefined, typeParameters: readonly TypeParameterDeclaration[] | undefined, heritageClauses: readonly HeritageClause[] | undefined, members: readonly ClassElement[]): ClassExpression;
-        /**
-         * @deprecated Decorators are no longer supported for this function. Callers should use an overload that does not accept a `decorators` parameter.
-         */
-        createFunctionDeclaration(decorators: readonly Decorator[] | undefined, modifiers: readonly Modifier[] | undefined, asteriskToken: AsteriskToken | undefined, name: string | Identifier | undefined, typeParameters: readonly TypeParameterDeclaration[] | undefined, parameters: readonly ParameterDeclaration[], type: TypeNode | undefined, body: Block | undefined): FunctionDeclaration;
-        /**
-         * @deprecated Decorators are no longer supported for this function. Callers should use an overload that does not accept a `decorators` parameter.
-         */
-        updateFunctionDeclaration(node: FunctionDeclaration, decorators: readonly Decorator[] | undefined, modifiers: readonly Modifier[] | undefined, asteriskToken: AsteriskToken | undefined, name: Identifier | undefined, typeParameters: readonly TypeParameterDeclaration[] | undefined, parameters: readonly ParameterDeclaration[], type: TypeNode | undefined, body: Block | undefined): FunctionDeclaration;
-        /**
-         * @deprecated Decorators have been combined with modifiers. Callers should use an overload that does not accept a `decorators` parameter.
-         */
-        createClassDeclaration(decorators: readonly Decorator[] | undefined, modifiers: readonly Modifier[] | undefined, name: string | Identifier | undefined, typeParameters: readonly TypeParameterDeclaration[] | undefined, heritageClauses: readonly HeritageClause[] | undefined, members: readonly ClassElement[]): ClassDeclaration;
-        /**
-         * @deprecated Decorators have been combined with modifiers. Callers should use an overload that does not accept a `decorators` parameter.
-         */
-        updateClassDeclaration(node: ClassDeclaration, decorators: readonly Decorator[] | undefined, modifiers: readonly Modifier[] | undefined, name: Identifier | undefined, typeParameters: readonly TypeParameterDeclaration[] | undefined, heritageClauses: readonly HeritageClause[] | undefined, members: readonly ClassElement[]): ClassDeclaration;
-        /**
-         * @deprecated Decorators are no longer supported for this function. Callers should use an overload that does not accept a `decorators` parameter.
-         */
-        createInterfaceDeclaration(decorators: readonly Decorator[] | undefined, modifiers: readonly Modifier[] | undefined, name: string | Identifier, typeParameters: readonly TypeParameterDeclaration[] | undefined, heritageClauses: readonly HeritageClause[] | undefined, members: readonly TypeElement[]): InterfaceDeclaration;
-        /**
-         * @deprecated Decorators are no longer supported for this function. Callers should use an overload that does not accept a `decorators` parameter.
-         */
-        updateInterfaceDeclaration(node: InterfaceDeclaration, decorators: readonly Decorator[] | undefined, modifiers: readonly Modifier[] | undefined, name: Identifier, typeParameters: readonly TypeParameterDeclaration[] | undefined, heritageClauses: readonly HeritageClause[] | undefined, members: readonly TypeElement[]): InterfaceDeclaration;
-        /**
-         * @deprecated Decorators are no longer supported for this function. Callers should use an overload that does not accept a `decorators` parameter.
-         */
-        createTypeAliasDeclaration(decorators: readonly Decorator[] | undefined, modifiers: readonly Modifier[] | undefined, name: string | Identifier, typeParameters: readonly TypeParameterDeclaration[] | undefined, type: TypeNode): TypeAliasDeclaration;
-        /**
-         * @deprecated Decorators are no longer supported for this function. Callers should use an overload that does not accept a `decorators` parameter.
-         */
-        updateTypeAliasDeclaration(node: TypeAliasDeclaration, decorators: readonly Decorator[] | undefined, modifiers: readonly Modifier[] | undefined, name: Identifier, typeParameters: readonly TypeParameterDeclaration[] | undefined, type: TypeNode): TypeAliasDeclaration;
-        /**
-         * @deprecated Decorators are no longer supported for this function. Callers should use an overload that does not accept a `decorators` parameter.
-         */
-        createEnumDeclaration(decorators: readonly Decorator[] | undefined, modifiers: readonly Modifier[] | undefined, name: string | Identifier, members: readonly EnumMember[]): EnumDeclaration;
-        /**
-         * @deprecated Decorators are no longer supported for this function. Callers should use an overload that does not accept a `decorators` parameter.
-         */
-        updateEnumDeclaration(node: EnumDeclaration, decorators: readonly Decorator[] | undefined, modifiers: readonly Modifier[] | undefined, name: Identifier, members: readonly EnumMember[]): EnumDeclaration;
-        /**
-         * @deprecated Decorators are no longer supported for this function. Callers should use an overload that does not accept a `decorators` parameter.
-         */
-        createModuleDeclaration(decorators: readonly Decorator[] | undefined, modifiers: readonly Modifier[] | undefined, name: ModuleName, body: ModuleBody | undefined, flags?: NodeFlags): ModuleDeclaration;
-        /**
-         * @deprecated Decorators are no longer supported for this function. Callers should use an overload that does not accept a `decorators` parameter.
-         */
-        updateModuleDeclaration(node: ModuleDeclaration, decorators: readonly Decorator[] | undefined, modifiers: readonly Modifier[] | undefined, name: ModuleName, body: ModuleBody | undefined): ModuleDeclaration;
-        /**
-         * @deprecated Decorators are no longer supported for this function. Callers should use an overload that does not accept a `decorators` parameter.
-         */
-        createImportEqualsDeclaration(decorators: readonly Decorator[] | undefined, modifiers: readonly Modifier[] | undefined, isTypeOnly: boolean, name: string | Identifier, moduleReference: ModuleReference): ImportEqualsDeclaration;
-        /**
-         * @deprecated Decorators are no longer supported for this function. Callers should use an overload that does not accept a `decorators` parameter.
-         */
-        updateImportEqualsDeclaration(node: ImportEqualsDeclaration, decorators: readonly Decorator[] | undefined, modifiers: readonly Modifier[] | undefined, isTypeOnly: boolean, name: Identifier, moduleReference: ModuleReference): ImportEqualsDeclaration;
-        /**
-         * @deprecated Decorators are no longer supported for this function. Callers should use an overload that does not accept a `decorators` parameter.
-         */
-        createImportDeclaration(decorators: readonly Decorator[] | undefined, modifiers: readonly Modifier[] | undefined, importClause: ImportClause | undefined, moduleSpecifier: Expression, assertClause?: AssertClause): ImportDeclaration;
-        /**
-         * @deprecated Decorators are no longer supported for this function. Callers should use an overload that does not accept a `decorators` parameter.
-         */
-        updateImportDeclaration(node: ImportDeclaration, decorators: readonly Decorator[] | undefined, modifiers: readonly Modifier[] | undefined, importClause: ImportClause | undefined, moduleSpecifier: Expression, assertClause: AssertClause | undefined): ImportDeclaration;
-        /**
-         * @deprecated Decorators are no longer supported for this function. Callers should use an overload that does not accept a `decorators` parameter.
-         */
-        createExportAssignment(decorators: readonly Decorator[] | undefined, modifiers: readonly Modifier[] | undefined, isExportEquals: boolean | undefined, expression: Expression): ExportAssignment;
-        /**
-         * @deprecated Decorators are no longer supported for this function. Callers should use an overload that does not accept a `decorators` parameter.
-         */
-        updateExportAssignment(node: ExportAssignment, decorators: readonly Decorator[] | undefined, modifiers: readonly Modifier[] | undefined, expression: Expression): ExportAssignment;
-        /**
-         * @deprecated Decorators are no longer supported for this function. Callers should use an overload that does not accept a `decorators` parameter.
-         */
-        createExportDeclaration(decorators: readonly Decorator[] | undefined, modifiers: readonly Modifier[] | undefined, isTypeOnly: boolean, exportClause: NamedExportBindings | undefined, moduleSpecifier?: Expression, assertClause?: AssertClause): ExportDeclaration;
-        /**
-         * @deprecated Decorators are no longer supported for this function. Callers should use an overload that does not accept a `decorators` parameter.
-         */
-        updateExportDeclaration(node: ExportDeclaration, decorators: readonly Decorator[] | undefined, modifiers: readonly Modifier[] | undefined, isTypeOnly: boolean, exportClause: NamedExportBindings | undefined, moduleSpecifier: Expression | undefined, assertClause: AssertClause | undefined): ExportDeclaration;
-    }
-}
-
 export = ts;
\ No newline at end of file
-- 
2.37.3

