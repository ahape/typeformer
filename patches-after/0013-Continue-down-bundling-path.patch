From 0000000000000000000000000000000000000000 Mon Sep 17 00:00:00 2001
From: Jake Bailey <5341706+jakebailey@users.noreply.github.com>
Date: Thu, 15 Sep 2022 17:22:07 -0700
Subject: [PATCH] Continue down bundling path

---
 Gulpfile.js                                   | 115 ++++++++++--------
 src/cancellationToken/tsconfig.json           |   4 +-
 src/compiler/sys.ts                           |  23 ++--
 src/debug/_namespaces/Debug.ts                |   3 -
 src/debug/dbg.ts                              |   8 --
 src/debug/tsconfig.json                       |   1 -
 .../_namespaces/ts.server.ts                  |   3 -
 src/dynamicImportCompat/_namespaces/ts.ts     |   4 -
 .../dynamicImportCompat.ts                    |   2 +-
 src/dynamicImportCompat/tsconfig.json         |   8 +-
 src/services/_namespaces/ts.ts                |   2 +
 src/services/exportAsModule.ts                |  20 ++-
 src/tsconfig-base.json                        |   2 +-
 src/watchGuard/watchGuard.ts                  |   2 +-
 src/webServer/webServer.ts                    |  17 +--
 15 files changed, 105 insertions(+), 109 deletions(-)
 delete mode 100644 src/debug/_namespaces/Debug.ts
 delete mode 100644 src/dynamicImportCompat/_namespaces/ts.server.ts
 delete mode 100644 src/dynamicImportCompat/_namespaces/ts.ts

diff --git a/Gulpfile.js b/Gulpfile.js
index 259b398420..a770322d4e 100644
--- a/Gulpfile.js
+++ b/Gulpfile.js
@@ -15,11 +15,12 @@ const { exec, readJson, needsUpdate, getDiffTool, getDirSize, rm } = require("./
 const { runConsoleTests, refBaseline, localBaseline, refRwcBaseline, localRwcBaseline } = require("./scripts/build/tests");
 const { buildProject, cleanProject, watchProject } = require("./scripts/build/projects");
 const cmdLineOptions = require("./scripts/build/options");
+const esbuild = require("esbuild");
 
 const copyright = "CopyrightNotice.txt";
 const cleanTasks = [];
 
-const testRunner = "./built/local/testRunner.js";
+const testRunner = "./built/local/run.js";
 
 const buildScripts = () => buildProject("scripts");
 task("scripts", buildScripts);
@@ -94,25 +95,34 @@ const localize = async () => {
  * @param {string} entrypoint
  * @param {string} outfile
  */
-async function esbuild(entrypoint, outfile) {
-    await exec("node_modules/esbuild/bin/esbuild", [
-        entrypoint,
-        "--bundle",
-        `--outfile=${outfile}`,
-        "--platform=node",
-        "--target=node10", // Node 10; oldest benchmarker.
-        "--sourcemap",
-        "--external:./node_modules/*",
-        "--conditions=require",
-        // "--supported:const-and-let=false", // Unfortunately, no: https://github.com/evanw/esbuild/issues/297
-        "--supported:object-rest-spread=false", // See: https://github.com/evanw/esbuild/releases/tag/v0.14.46
-    ]);
+async function runEsbuild(entrypoint, outfile) {
+    await esbuild.build({
+        entryPoints: [entrypoint],
+        bundle: true,
+        outfile,
+        platform: "node",
+        // TODO: also specify minimal browser targets
+        target: "node10", // Node 10 is the oldest benchmarker.
+        // format: "iife", // TODO(jakebailey): figure out how to conditionally use module.exports
+        sourcemap: true,
+        external: ["./node_modules/*"], // TODO(jakebailey): does the test runner import relatively from scripts?
+        conditions: ["require"],
+        supported: {
+            // "const-and-let": false, // Unfortunately, no: https://github.com/evanw/esbuild/issues/297
+            "object-rest-spread": false, // See: https://github.com/evanw/esbuild/releases/tag/v0.14.46
+        }
+    });
 }
 
-const buildSrc = () => buildProject("src");
-
-/** @type {(infile: string, outfile: string) => (done: () => void) => void} */
-const writeHackyCJSShim = (infile, outfile) => {
+/**
+ * Creates a function that writes a CJS module that reexports another CJS file via
+ * `module.exports = require("...")`.
+ *
+ * @param {string} infile Relative path from the repo root to the file to be required.
+ * @param {string} outfile Relative path from the repo root to the output file.
+ * @returns {(done: () => void) => void} A function that can be passed to gulp.
+ */
+function writeCJSReexport(infile, outfile) {
     return (done) => {
         const inRelativeToOut = infile = path.relative(path.dirname(outfile), infile);
         fs.writeFileSync(outfile, `module.exports = require("./${inRelativeToOut}")`);
@@ -120,33 +130,39 @@ const writeHackyCJSShim = (infile, outfile) => {
     };
 };
 
-const preBundleFromSrc = parallel(generateLibs, series(buildScripts, generateDiagnostics, localize));
-const preBuildSrc = preBundleFromSrc;
-const preBundleFromEmit = series(preBundleFromSrc, buildSrc);
-
-const bundleTscFromEmit = () => esbuild("./built/local/tsc/tsc.js", "./built/local/tsc.js");
-const bundleTypescriptFromEmit = () => esbuild("./built/local/typescript/typescript.js", "./built/local/typescript.js");
-const bundleServerFromEmit = () => esbuild("./built/local/tsserver/server.js", "./built/local/tsserver.js");
-const bundleServerLibraryFromEmit = () => esbuild("./built/local/tsserverlibrary/tsserverlibrary.js", "./built/local/tsserverlibrary.js");
-const bundleTestsFromEmit = () => esbuild("./built/local/testRunner/_namespaces/Harness.js", testRunner);
-
-const bundleTscFromSrc = () => esbuild("./src/tsc/tsc.ts", "./built/local/tsc.js");
-const bundleTypescriptFromSrc = () => esbuild("./src/typescript/typescript.ts", "./built/local/typescript.js");
-const bundleServerFromSrc = () => esbuild("./src/tsserver/server.ts", "./built/local/tsserver.js");
-const bundleServerLibraryFromSrc = () => esbuild("./src/tsserverlibrary/tsserverlibrary.ts", "./built/local/tsserverlibrary.js");
-const bundleTestsFromSrc = () => esbuild("./src/testRunner/_namespaces/Harness.ts", testRunner);
-
-const bundleAllFromSrc = series([
-    bundleTscFromSrc,
-    bundleTypescriptFromSrc,
-    bundleServerFromSrc,
-    bundleServerLibraryFromSrc,
-    bundleTestsFromSrc,
+// Build the entire project, but will not emit JS.
+const buildSrc = () => buildProject("src");
+
+const preSrc = parallel(generateLibs, series(buildScripts, generateDiagnostics, localize));
+
+// TODO(jakebailey): fixup all build tasks to use this
+// TODO(jakebailey): add a flag that switches us from bundled to not bundled.
+
+const bundleTsc = () => runEsbuild("./src/tsc/tsc.ts", "./built/local/tsc.js");
+const bundleTypescript = () => runEsbuild("./src/typescript/typescript.ts", "./built/local/typescript.js");
+const bundleServer = () => runEsbuild("./src/tsserver/server.ts", "./built/local/tsserver.js");
+const bundleServerLibrary = () => runEsbuild("./src/tsserverlibrary/tsserverlibrary.ts", "./built/local/tsserverlibrary.js");
+const bundleTests = () => runEsbuild("./src/testRunner/_namespaces/Harness.ts", testRunner);
+const bundleCancellationToken = () => runEsbuild("./src/cancellationToken/cancellationToken.ts", "./built/local/cancellationToken.js");
+const bundleTypingsInstaller = () => runEsbuild("./src/typingsInstaller/nodeTypingsInstaller.ts", "./built/local/typingsInstaller.js");
+const bundleWatchGuard = () => runEsbuild("./src/watchGuard/watchGuard.ts", "./built/local/watchGuard.js");
+const bundleDebug = () => runEsbuild("./src/debug/dbg.ts", "./built/local/compiler-debug.js");
+
+const bundleAll = parallel([
+    bundleTsc,
+    bundleTypescript,
+    bundleServer,
+    bundleServerLibrary,
+    bundleTests,
+    bundleCancellationToken,
+    bundleTypingsInstaller,
+    bundleWatchGuard,
+    bundleDebug,
 ]);
-task("bundle-src", series(preBundleFromSrc, bundleAllFromSrc));
+task("bundle", series(preSrc, bundleAll));
 
 
-task("buildSrc", preBundleFromEmit);
+task("buildSrc", series(preSrc, buildSrc));
 
 const apiExtractor = async () => {
     async function runApiExtractor(configPath) {
@@ -164,7 +180,7 @@ const apiExtractor = async () => {
     await runApiExtractor("./src/tsserverlibrary/api-extractor.json");
 };
 
-task("api-extractor", series(buildSrc, apiExtractor));
+task("api-extractor", series(preSrc, buildSrc, apiExtractor));
 
 const buildDebugTools = () => buildProject("src/debug");
 const cleanDebugTools = () => cleanProject("src/debug");
@@ -175,9 +191,7 @@ const lkgPreBuild = parallel(generateLibs, series(buildScripts, generateDiagnost
 
 const buildTsc = () => buildProject("src/tsc");
 
-// task("tsc", series(preBundleFromSrc, bundleTscFromSrc)); // esbuild on ./src
-// task("tsc", series(preBundleFromEmit, bundleTscFromEmit)); // esbuild on emitted ./built/local
-task("tsc", series(preBuildSrc, buildSrc, writeHackyCJSShim("./built/local/tsc/tsc.js", "./built/local/tsc.js"))); // CJS
+task("tsc", series(preSrc, bundleTsc));
 task("tsc").description = "Builds the command-line compiler";
 
 const cleanTsc = () => cleanProject("src/tsc");
@@ -298,10 +312,7 @@ const buildServerMain = () => buildProject("src/tsserver", cmdLineOptions);
 const buildServer = series(buildDynamicImportCompat, buildServerMain);
 buildServer.displayName = "buildServer";
 
-// task("tsserver", series(preBundleFromSrc, bundleServerFromSrc)); // esbuild on ./src
-// task("tsserver", series(preBundleFromEmit, bundleServerFromEmit)); // esbuild on emitted ./built/local
-
-task("tsserver", series(preBuildSrc, buildSrc, writeHackyCJSShim("./built/local/tsserver/server.js", "./built/local/tsserver.js"))); // CJS
+task("tsserver", series(preSrc, bundleServer));
 task("tsserver").description = "Builds the language server";
 task("tsserver").flags = {
     "   --built": "Compile using the built version of the compiler."
@@ -518,7 +529,7 @@ const preTest = parallel(buildTsc, buildTests, buildServices, buildLssl);
 preTest.displayName = "preTest";
 
 const runTests = () => runConsoleTests(testRunner, "mocha-fivemat-progress-reporter", /*runInParallel*/ false, /*watchMode*/ false);
-task("runtests", series(/*preBuild, preTest,*/ preBundleFromSrc, bundleTestsFromSrc, runTests)); // TODO(jakebailey): fix this for modules
+task("runtests", series(/*preBuild, preTest,*/ preSrc, bundleTests, runTests)); // TODO(jakebailey): fix this for modules
 task("runtests").description = "Runs the tests using the built run.js file.";
 task("runtests").flags = {
     "-t --tests=<regex>": "Pattern for tests to run.",
@@ -537,7 +548,7 @@ task("runtests").flags = {
 };
 
 const runTestsParallel = () => runConsoleTests(testRunner, "min", /*runInParallel*/ cmdLineOptions.workers > 1, /*watchMode*/ false);
-task("runtests-parallel", series(/*preBuild, preTest,*/ preBundleFromSrc, bundleTestsFromSrc, runTestsParallel)); // TODO(jakebailey): fix this for modules
+task("runtests-parallel", series(/*preBuild, preTest,*/ preSrc, bundleTests, runTestsParallel)); // TODO(jakebailey): fix this for modules
 task("runtests-parallel").description = "Runs all the tests in parallel using the built run.js file.";
 task("runtests-parallel").flags = {
     "   --light": "Run tests in light mode (fewer verifications, but tests run faster).",
diff --git a/src/cancellationToken/tsconfig.json b/src/cancellationToken/tsconfig.json
index 76eca8f56c..f12034bee9 100644
--- a/src/cancellationToken/tsconfig.json
+++ b/src/cancellationToken/tsconfig.json
@@ -1,7 +1,9 @@
 {
     "extends": "../tsconfig-base",
     "compilerOptions": {
-        "outDir": "../../built/local/cancellationToken",
+        "outDir": "../../built/local",
+        "tsBuildInfoFile": "../../built/local/cancellationToken.tsbuildinfo",
+        "rootDir": ".",
         "module": "commonjs",
         "types": [
             "node"
diff --git a/src/compiler/sys.ts b/src/compiler/sys.ts
index a7aa67d8c9..97e8a2fee2 100644
--- a/src/compiler/sys.ts
+++ b/src/compiler/sys.ts
@@ -1466,6 +1466,13 @@ export let sys: System = (() => {
         const useCaseSensitiveFileNames = isFileSystemCaseSensitive();
         const fsRealpath = !!_fs.realpathSync.native ? process.platform === "win32" ? fsRealPathHandlingLongPath : _fs.realpathSync.native : _fs.realpathSync;
 
+        // If our filename is "sys.js", then we are executing unbundled on the raw tsc output.
+        // In that case, simulate a faked path in the directory where a bundle would normally
+        // appear (e.g. the directory containing lib.*.d.ts files).
+        //
+        // Note that if we ever emit as files like cjs/mjs, this check will be wrong.
+        const executingFilePath = __filename.endsWith("sys.js") ? _path.join(_path.dirname(__dirname), "__fake__.js") : __filename;
+
         const fsSupportsRecursiveFsWatch = isNode4OrLater && (process.platform === "win32" || process.platform === "darwin");
         const getCurrentDirectory = memoize(() => process.cwd());
         const { watchFile, watchDirectory } = createSystemWatchFunctions({
@@ -1525,21 +1532,7 @@ export let sys: System = (() => {
                 }
             },
             getExecutingFilePath() {
-                // This function previously returned a path like `built/local/tsc.js`.
-                // Now, with a module output, this file is now `built/local/compiler/sys.js`.
-                // We want to return a file that looks like the old one, so that callers
-                // can locate other assets like the lib.d.ts files.
-                //
-                // TODO(jakebailey): replace this function with one that returns the path
-                // to the lib folder (or package path)?.
-                // return _path.join(_path.dirname(__dirname), "fake.js");
-
-                // HACK: detect if we are bundled or not for sake of perf testing. This is not
-                // how I'd do it for real.
-                if (__filename.endsWith("sys.js")) {
-                    return _path.join(_path.dirname(__dirname), "fake.js");
-                }
-                return __filename;
+                return executingFilePath;
             },
             getCurrentDirectory,
             getDirectories,
diff --git a/src/debug/_namespaces/Debug.ts b/src/debug/_namespaces/Debug.ts
deleted file mode 100644
index 449c31bdae..0000000000
--- a/src/debug/_namespaces/Debug.ts
+++ /dev/null
@@ -1,3 +0,0 @@
-/* Generated file to emulate the Debug namespace. */
-
-export * from "../dbg";
diff --git a/src/debug/dbg.ts b/src/debug/dbg.ts
index 3b531914d5..1a870b02d6 100644
--- a/src/debug/dbg.ts
+++ b/src/debug/dbg.ts
@@ -1,5 +1,3 @@
-import * as Debug from "./_namespaces/Debug";
-
 /// <reference lib="es2019" />
 
 interface Node {
@@ -510,9 +508,3 @@ export function formatControlFlowGraph(flowNode: FlowNode) {
         return s;
     }
 }
-
-// Export as a module. NOTE: Can't use module exports as this is built using --outFile
-declare const module: { exports: {} };
-if (typeof module !== "undefined" && module.exports) {
-    module.exports = Debug;
-}
diff --git a/src/debug/tsconfig.json b/src/debug/tsconfig.json
index 4f9a47f5af..2325755298 100644
--- a/src/debug/tsconfig.json
+++ b/src/debug/tsconfig.json
@@ -7,6 +7,5 @@
     },
     "files": [
         "dbg.ts",
-        "_namespaces/Debug.ts"
     ]
 }
diff --git a/src/dynamicImportCompat/_namespaces/ts.server.ts b/src/dynamicImportCompat/_namespaces/ts.server.ts
deleted file mode 100644
index 729da9c24e..0000000000
--- a/src/dynamicImportCompat/_namespaces/ts.server.ts
+++ /dev/null
@@ -1,3 +0,0 @@
-/* Generated file to emulate the ts.server namespace. */
-
-export * from "../dynamicImportCompat";
diff --git a/src/dynamicImportCompat/_namespaces/ts.ts b/src/dynamicImportCompat/_namespaces/ts.ts
deleted file mode 100644
index 91d7693414..0000000000
--- a/src/dynamicImportCompat/_namespaces/ts.ts
+++ /dev/null
@@ -1,4 +0,0 @@
-/* Generated file to emulate the ts namespace. */
-
-import * as server from "./ts.server";
-export { server };
diff --git a/src/dynamicImportCompat/dynamicImportCompat.ts b/src/dynamicImportCompat/dynamicImportCompat.ts
index 5981d8c7e9..d02bfd3dca 100644
--- a/src/dynamicImportCompat/dynamicImportCompat.ts
+++ b/src/dynamicImportCompat/dynamicImportCompat.ts
@@ -1 +1 @@
-export const dynamicImport = (id: string) => import(id);
\ No newline at end of file
+(globalThis as any).dynamicImport = (id: string) => import(id);
diff --git a/src/dynamicImportCompat/tsconfig.json b/src/dynamicImportCompat/tsconfig.json
index 3abacb2133..f6529d3c91 100644
--- a/src/dynamicImportCompat/tsconfig.json
+++ b/src/dynamicImportCompat/tsconfig.json
@@ -1,15 +1,15 @@
 {
     "extends": "../tsconfig-base",
     "compilerOptions": {
-        "outDir": "../../built/local/dynamicImportCompat",
+        "outDir": "../../built/local",
+        "tsBuildInfoFile": "../../built/local/dynamicImportCompat.tsbuildinfo",
         "rootDir": ".",
         "target": "esnext",
         "module": "esnext",
-        "lib": ["esnext"]
+        "lib": ["esnext"],
+        "emitDeclarationOnly": false
     },
     "files": [
         "dynamicImportCompat.ts",
-        "_namespaces/ts.server.ts",
-        "_namespaces/ts.ts"
     ]
 }
diff --git a/src/services/_namespaces/ts.ts b/src/services/_namespaces/ts.ts
index eae114fd2e..fe17bc06d1 100644
--- a/src/services/_namespaces/ts.ts
+++ b/src/services/_namespaces/ts.ts
@@ -17,6 +17,8 @@ export * from "../transpile";
 export * from "../services";
 export * from "../transform";
 export * from "../shims";
+export * from "../globalThisShim";
+export * from "../exportAsModule";
 import * as BreakpointResolver from "./ts.BreakpointResolver";
 export { BreakpointResolver };
 import * as CallHierarchy from "./ts.CallHierarchy";
diff --git a/src/services/exportAsModule.ts b/src/services/exportAsModule.ts
index 757f9f7cd3..eb6e51fa9c 100644
--- a/src/services/exportAsModule.ts
+++ b/src/services/exportAsModule.ts
@@ -3,7 +3,19 @@ import * as ts from "./_namespaces/ts";
 // Here we expose the TypeScript services as an external module
 // so that it may be consumed easily like a node module.
 // @ts-ignore
-/** @internal */ declare const module: { exports: {} };
-if (typeof module !== "undefined" && module.exports) {
-    module.exports = ts;
-}
+// /** @internal */ declare const module: { exports: {} };
+// if (typeof module !== "undefined" && module.exports) {
+//     module.exports = ts;
+// }
+
+// If we are bundled with esbuild via IIFE, this is a hacky way to jump out of
+// its module system and conditionally export to CJS in the bundle.
+//
+// We may want to do something different for this.
+
+// eslint-disable-next-line no-eval
+// eval("(ts) => { if (typeof module !== 'undefined' && module.exports) module.exports = ts }")(ts);
+
+// TODO(jakebailey): remove; this is just here and ignored for now.
+// eslint-disable-next-line @typescript-eslint/no-unused-expressions
+ts;
diff --git a/src/tsconfig-base.json b/src/tsconfig-base.json
index bae7684eed..c07487870f 100644
--- a/src/tsconfig-base.json
+++ b/src/tsconfig-base.json
@@ -10,7 +10,7 @@
         "sourceMap": true,
         "composite": true,
         "noEmitOnError": true,
-        // "emitDeclarationOnly": true,
+        "emitDeclarationOnly": true,
 
         "strictNullChecks": true,
         "noImplicitAny": true,
diff --git a/src/watchGuard/watchGuard.ts b/src/watchGuard/watchGuard.ts
index b66338f42e..c9589e048e 100644
--- a/src/watchGuard/watchGuard.ts
+++ b/src/watchGuard/watchGuard.ts
@@ -1,6 +1,6 @@
 /// <reference types="node" />
 
-import * as fs from "fs";
+import fs = require("fs");
 
 if (process.argv.length < 3) {
     process.exit(1);
diff --git a/src/webServer/webServer.ts b/src/webServer/webServer.ts
index ece05e4db6..24141ee9a8 100644
--- a/src/webServer/webServer.ts
+++ b/src/webServer/webServer.ts
@@ -1,4 +1,3 @@
-import * as server from "./_namespaces/ts.server";
 import {
     indent, Logger, LogLevel, ModuleImportResult, Msg, nowString, nullTypingsInstaller, protocol,
     ServerCancellationToken, ServerHost, Session, SessionOptions,
@@ -126,11 +125,17 @@ export class MainProcessLogger extends BaseLogger {
     }
 }
 
+let dynamicImport = async (_id: string): Promise<any> => {
+    throw new Error("Dynamic import not implemented");
+};
+
 // Attempt to load `dynamicImport`
 if (typeof importScripts === "function") {
     try {
         // NOTE: importScripts is synchronous
         importScripts("dynamicImportCompat.js");
+        dynamicImport = (globalThis as any).dynamicImport;
+        delete (globalThis as any).dynamicImport;
     }
     catch {
         // ignored
@@ -144,16 +149,6 @@ export function createWebSystem(host: WebHost, args: string[], getExecutingFileP
     // Later we could map ^memfs:/ to do something special if we want to enable more functionality like module resolution or something like that
     const getWebPath = (path: string) => startsWith(path, directorySeparator) ? path.replace(directorySeparator, getExecutingDirectoryPath()) : undefined;
 
-    const dynamicImport = async (id: string): Promise<any> => {
-        const serverDynamicImport: ((id: string) => Promise<any>) | undefined = (server as any).dynamicImport;
-        // Use syntactic dynamic import first, if available
-        if (serverDynamicImport) {
-            return serverDynamicImport(id);
-        }
-
-        throw new Error("Dynamic import not implemented");
-    };
-
     return {
         args,
         newLine: "\r\n", // This can be configured by clients
-- 
2.37.1

