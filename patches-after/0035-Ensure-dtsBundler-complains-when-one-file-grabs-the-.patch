From 0000000000000000000000000000000000000000 Mon Sep 17 00:00:00 2001
From: Jake Bailey <5341706+jakebailey@users.noreply.github.com>
Date: Wed, 12 Oct 2022 15:46:10 -0700
Subject: [PATCH] Ensure dtsBundler complains when one file grabs the symbol
 from another's scope accidentally

---
 scripts/dtsBundler.mjs | 154 ++++++++++++++++++++++++++++++++++++++---
 src/compiler/watch.ts  |   7 +-
 2 files changed, 148 insertions(+), 13 deletions(-)

diff --git a/scripts/dtsBundler.mjs b/scripts/dtsBundler.mjs
index 7635f1ee38..2d4fb145d6 100644
--- a/scripts/dtsBundler.mjs
+++ b/scripts/dtsBundler.mjs
@@ -5,7 +5,6 @@
  * bundle as namespaces again, even though the project is modules.
  */
 
-import assert from "assert";
 import fs from "fs";
 import path from "path";
 import minimist from "minimist";
@@ -15,6 +14,20 @@ import ts from "../lib/typescript.js";
 const __filename = url.fileURLToPath(new URL(import.meta.url));
 const __dirname = path.dirname(__filename);
 
+// /** @type {any} */ (ts).Debug.enableDebugInfo();
+
+/** @type {(expression: unknown, message?: string, verboseDebugInfo?: string | (() => string), stackCrawlMark?: any) => asserts expression} */
+function assert(expression, message, verboseDebugInfo, stackCrawlMark) {
+    /** @type {any} */ (ts).Debug.assert(expression, message, verboseDebugInfo, stackCrawlMark ?? assert);
+}
+
+/** @type {(message?: string, stackCrawlMark?: any) => never} */
+function fail(message, stackCrawlMark) {
+    /** @type {any} */ (ts).Debug.fail(message, stackCrawlMark ?? fail);
+    throw new Error("unreachable");
+}
+
+
 
 const dotDts = ".d.ts";
 
@@ -83,9 +96,9 @@ const program = ts.createProgram([entrypoint], { target: ts.ScriptTarget.ES5 });
 const typeChecker = program.getTypeChecker();
 
 const sourceFile = program.getSourceFile(entrypoint);
-assert(sourceFile);
+assert(sourceFile, "Failed to load source file");
 const moduleSymbol = typeChecker.getSymbolAtLocation(sourceFile);
-assert(moduleSymbol);
+assert(moduleSymbol, "Failed to get module's symbol");
 
 const printer = ts.createPrinter({ newLine: newLineKind });
 
@@ -191,12 +204,12 @@ function containsPublicAPI(symbol) {
 }
 
 /**
- * @param {ts.Node} decl
+ * @param {ts.Node} node
  */
-function nodeToLocation(decl) {
-    const sourceFile = decl.getSourceFile();
-    const lc = sourceFile.getLineAndCharacterOfPosition(decl.pos);
-    return `${sourceFile.fileName}:${lc.line}:${lc.character}`;
+function nodeToLocation(node) {
+    const sourceFile = node.getSourceFile();
+    const lc = sourceFile.getLineAndCharacterOfPosition(node.pos);
+    return `${sourceFile.fileName}:${lc.line+1}:${lc.character+1}`;
 }
 
 /**
@@ -213,12 +226,125 @@ function removeDeclareConstExport(node) {
     return node;
 }
 
+/** @type {Map<string, ts.Symbol>[]} */
+const scopeStack = [];
+
+/**
+ * @param {string} name
+ */
+function findInScope(name) {
+    for (let i = scopeStack.length-1; i >= 0; i--) {
+        const scope = scopeStack[i];
+        const symbol = scope.get(name);
+        if (symbol) {
+            return symbol;
+        }
+    }
+    return undefined;
+}
+
+/** @type {(symbol: ts.Symbol | undefined, excludes?: ts.SymbolFlags) => boolean} */
+function isNonLocalAlias(symbol, excludes = ts.SymbolFlags.Value | ts.SymbolFlags.Type | ts.SymbolFlags.Namespace) {
+    if (!symbol) return false;
+    return (symbol.flags & (ts.SymbolFlags.Alias | excludes)) === ts.SymbolFlags.Alias || !!(symbol.flags & ts.SymbolFlags.Alias && symbol.flags & ts.SymbolFlags.Assignment);
+}
+
+/**
+ * @param {ts.Symbol} symbol
+ */
+function resolveAlias(symbol) {
+    return typeChecker.getAliasedSymbol(symbol);
+}
+
+/**
+ * @param {ts.Symbol} symbol
+ * @param {boolean | undefined} [dontResolveAlias]
+ */
+function resolveSymbol(symbol, dontResolveAlias = undefined) {
+    return !dontResolveAlias && isNonLocalAlias(symbol) ? resolveAlias(symbol) : symbol;
+}
+
+/**
+ * @param {ts.Symbol} symbol
+ * @returns {ts.Symbol}
+ */
+function getMergedSymbol(symbol) {
+    return /** @type {any} */ (typeChecker).getMergedSymbol(symbol);
+}
+
+/**
+ * @param {ts.Symbol} s1
+ * @param {ts.Symbol} s2
+ */
+function symbolsConflict(s1, s2) {
+    // See getSymbolIfSameReference in checker.ts
+    s1 = getMergedSymbol(resolveSymbol(getMergedSymbol(s1)));
+    s2 = getMergedSymbol(resolveSymbol(getMergedSymbol(s2)));
+    if (s1 === s2) {
+        return false;
+    }
+
+    const s1Flags = s1.flags & (ts.SymbolFlags.Type | ts.SymbolFlags.Value);
+    const s2Flags = s2.flags & (ts.SymbolFlags.Type | ts.SymbolFlags.Value);
+
+    // If the two symbols differ by type/value space, ignore.
+    if (!(s1Flags & s2Flags)) {
+        return false;
+    }
+
+    return true;
+}
+
+/**
+ * @param {ts.Node} node
+ * @returns {boolean}
+ */
+function isPartOfTypeNode(node) {
+    return /** @type {any} */ (ts).isPartOfTypeNode(node);
+}
+
+/**
+ * @param {ts.Statement} decl
+ */
+function verifyMatchingSymbols(decl) {
+    ts.visitEachChild(decl, /** @type {(node: ts.Node) => ts.Node} */ function visit(node) {
+        if (ts.isIdentifier(node) && isPartOfTypeNode(node)) {
+            if (ts.isQualifiedName(node.parent) && node !== node.parent.left) {
+                return node;
+            }
+            if (ts.isParameter(node.parent) && node === node.parent.name) {
+                return node;
+            }
+            if (ts.isNamedTupleMember(node.parent) && node === node.parent.name) {
+                return node;
+            }
+
+            const symbolOfNode = typeChecker.getSymbolAtLocation(node);
+            assert(symbolOfNode, "No symbol for node", () => nodeToLocation(node));
+            const symbolInScope = findInScope(symbolOfNode.name);
+            if (!symbolInScope) {
+                // We didn't find the symbol in scope at all. Just allow it and we'll fail at test time.
+                return node;
+            }
+
+            if (symbolsConflict(symbolOfNode, symbolInScope)) {
+                fail(`Declaration at ${nodeToLocation(decl)}\n    references ${symbolOfNode.name} at ${symbolOfNode.declarations && nodeToLocation(symbolOfNode.declarations[0])},\n    but containing scope contains a symbol with the same name declared at ${symbolInScope.declarations && nodeToLocation(symbolInScope.declarations[0])}`);
+            }
+        }
+
+        return ts.visitEachChild(node, visit, nullTransformationContext);
+    }, nullTransformationContext);
+}
+
 /**
  * @param {string} name
  * @param {ts.Symbol} moduleSymbol
  */
 function emitAsNamespace(name, moduleSymbol) {
-    assert(moduleSymbol.flags & ts.SymbolFlags.ValueModule);
+    assert(moduleSymbol.flags & ts.SymbolFlags.ValueModule, "moduleSymbol is not a module");
+
+    scopeStack.push(new Map());
+    const currentScope = scopeStack[scopeStack.length-1];
 
     const target = containsPublicAPI(moduleSymbol) ? WriteTarget.Both : WriteTarget.Internal;
 
@@ -233,6 +359,10 @@ function emitAsNamespace(name, moduleSymbol) {
     increaseIndent();
 
     const moduleExports = typeChecker.getExportsOfModule(moduleSymbol);
+    for (const me of moduleExports) {
+        currentScope.set(me.name, me);
+    }
+
     for (const me of moduleExports) {
         assert(me.declarations?.length);
 
@@ -247,9 +377,11 @@ function emitAsNamespace(name, moduleSymbol) {
             const sourceFile = decl.getSourceFile();
 
             if (!statement) {
-                throw new Error(`Unhandled declaration for ${me.name} at ${nodeToLocation(decl)}`);
+                fail(`Unhandled declaration for ${me.name} at ${nodeToLocation(decl)}`);
             }
 
+            verifyMatchingSymbols(statement);
+
             const isInternal = isInternalDeclaration(statement);
             if (!isInternal) {
                 const publicStatement = ts.visitEachChild(statement, (node) => {
@@ -269,6 +401,8 @@ function emitAsNamespace(name, moduleSymbol) {
         }
     }
 
+    scopeStack.pop();
+
     decreaseIndent();
     write(`}`, target);
 }
diff --git a/src/compiler/watch.ts b/src/compiler/watch.ts
index 5048c99522..f92b33fac2 100644
--- a/src/compiler/watch.ts
+++ b/src/compiler/watch.ts
@@ -17,7 +17,7 @@ import {
     packageIdToString, ParseConfigFileHost, pathIsAbsolute, Program, ProgramHost, ProjectReference,
     ReportEmitErrorSummary, ReportFileInError, sortAndDeduplicateDiagnostics, SourceFile, sys, System,
     targetOptionDeclaration, WatchCompilerHost, WatchCompilerHostOfConfigFile,
-    WatchCompilerHostOfFilesAndCompilerOptions, WatchFactoryHost, WatchHost, WatchLogLevel, WatchOptions,
+    WatchCompilerHostOfFilesAndCompilerOptions, WatchFactory, WatchFactoryHost, WatchHost, WatchLogLevel, WatchOptions,
     WatchStatusReporter, WriteFileCallback, writeFileEnsuringDirectories,
 } from "./_namespaces/ts";
 
@@ -632,7 +632,8 @@ export interface WatchTypeRegistry {
     NodeModulesForModuleSpecifierCache: "node_modules for module specifier cache invalidation",
 }
 
-interface WatchFactory<X, Y = undefined> extends ts.WatchFactory<X, Y> {
+/** @internal */
+export interface WatchFactoryWithLog<X, Y = undefined> extends WatchFactory<X, Y> {
     writeLog: (s: string) => void;
 }
 
@@ -640,7 +641,7 @@ interface WatchFactory<X, Y = undefined> extends ts.WatchFactory<X, Y> {
 export function createWatchFactory<Y = undefined>(host: WatchFactoryHost & { trace?(s: string): void; }, options: { extendedDiagnostics?: boolean; diagnostics?: boolean; }) {
     const watchLogLevel = host.trace ? options.extendedDiagnostics ? WatchLogLevel.Verbose : options.diagnostics ? WatchLogLevel.TriggerOnly : WatchLogLevel.None : WatchLogLevel.None;
     const writeLog: (s: string) => void = watchLogLevel !== WatchLogLevel.None ? (s => host.trace!(s)) : noop;
-    const result = getWatchFactory<WatchType, Y>(host, watchLogLevel, writeLog) as WatchFactory<WatchType, Y>;
+    const result = getWatchFactory<WatchType, Y>(host, watchLogLevel, writeLog) as WatchFactoryWithLog<WatchType, Y>;
     result.writeLog = writeLog;
     return result;
 }
-- 
2.38.0

