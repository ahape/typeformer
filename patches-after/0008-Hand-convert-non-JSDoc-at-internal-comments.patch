From 0000000000000000000000000000000000000000 Mon Sep 17 00:00:00 2001
From: Jake Bailey <5341706+jakebailey@users.noreply.github.com>
Date: Wed, 7 Sep 2022 14:04:47 -0700
Subject: [PATCH] Hand convert non-JSDoc at-internal comments

If these are regular comments, then they won't appear in our d.ts files.
But, now we are relying on api-extractor to produce out final merged
d.ts files, so they need to be present in the "input" d.ts files,
meaning they have to be JSDoc comments.

These comments only work today because all of our builds load their TS
files from scratch, so they see the actual source files and their
non-JSDoc comments.
---
 src/compiler/builderPublic.ts                 |   22 +-
 src/compiler/builderStatePublic.ts            |    4 +-
 src/compiler/commandLineParser.ts             |   98 +-
 src/compiler/corePublic.ts                    |   16 +-
 src/compiler/emitter.ts                       |   34 +-
 src/compiler/factory/baseNodeFactory.ts       |    4 +-
 src/compiler/factory/emitHelpers.ts           |    2 +-
 src/compiler/factory/emitNode.ts              |   16 +-
 src/compiler/factory/nodeConverters.ts        |    2 +-
 src/compiler/factory/nodeFactory.ts           |   10 +-
 src/compiler/factory/nodeTests.ts             |   40 +-
 src/compiler/factory/utilities.ts             |    2 +-
 src/compiler/moduleNameResolver.ts            |   74 +-
 src/compiler/parser.ts                        |   24 +-
 src/compiler/performanceCore.ts               |    2 +-
 src/compiler/program.ts                       |   58 +-
 src/compiler/scanner.ts                       |   46 +-
 src/compiler/symbolWalker.ts                  |    2 +-
 src/compiler/sys.ts                           |   92 +-
 src/compiler/transformers/declarations.ts     |    2 +-
 src/compiler/transformers/legacyDecorators.ts |    2 +-
 src/compiler/transformers/typeSerializer.ts   |    2 +-
 src/compiler/tsbuild.ts                       |    2 +-
 src/compiler/tsbuildPublic.ts                 |   58 +-
 src/compiler/types.ts                         | 1560 ++++++++---------
 src/compiler/utilities.ts                     |   34 +-
 src/compiler/utilitiesPublic.ts               |  154 +-
 src/compiler/visitorPublic.ts                 |   10 +-
 src/compiler/watchPublic.ts                   |    8 +-
 src/compiler/watchUtilities.ts                |    2 +-
 src/debug/dbg.ts                              |    2 +-
 src/deprecatedCompat/deprecations.ts          |    2 +-
 src/harness/client.ts                         |    8 +-
 src/jsTyping/shared.ts                        |   22 +-
 src/jsTyping/types.ts                         |    8 +-
 src/server/editorServices.ts                  |  208 +--
 src/server/project.ts                         |  278 +--
 src/server/protocol.ts                        |  110 +-
 src/server/scriptInfo.ts                      |   46 +-
 src/server/session.ts                         |    2 +-
 src/server/types.ts                           |    2 +-
 src/server/typingsCache.ts                    |    2 +-
 src/server/utilitiesPublic.ts                 |    6 +-
 src/services/classifier.ts                    |    8 +-
 src/services/documentHighlights.ts            |    2 +-
 src/services/documentRegistry.ts              |    8 +-
 src/services/exportAsModule.ts                |    4 +-
 src/services/globalThisShim.ts                |    4 +-
 src/services/services.ts                      |   16 +-
 src/services/shims.ts                         |    2 +-
 src/services/transpile.ts                     |    2 +-
 src/services/types.ts                         |   96 +-
 src/services/utilities.ts                     |   10 +-
 .../unittests/tsbuild/amdModulesWithOut.ts    |    4 +-
 src/testRunner/unittests/tsbuild/outFile.ts   |   10 +-
 src/typingsInstallerCore/typingsInstaller.ts  |    8 +-
 src/webServer/webServer.ts                    |    2 +-
 57 files changed, 1627 insertions(+), 1627 deletions(-)

diff --git a/src/compiler/builderPublic.ts b/src/compiler/builderPublic.ts
index 605d82018a..a8763836ab 100644
--- a/src/compiler/builderPublic.ts
+++ b/src/compiler/builderPublic.ts
@@ -24,17 +24,17 @@ export interface BuilderProgramHost {
     /**
      * disable using source file version as signature for testing
      */
-    /*@internal*/
+    /** @internal */
     disableUseFileVersionAsSignature?: boolean;
     /**
      * Store the list of files that update signature during the emit
      */
-    /*@internal*/
+    /** @internal */
     storeFilesChangingSignatureDuringEmit?: boolean;
     /**
      * Gets the current time
      */
-    /*@internal*/
+    /** @internal */
     now?(): Date;
 }
 
@@ -42,13 +42,13 @@ export interface BuilderProgramHost {
  * Builder to manage the program state changes
  */
 export interface BuilderProgram {
-    /*@internal*/
+    /** @internal */
     getState(): ReusableBuilderProgramState;
-    /*@internal*/
+    /** @internal */
     saveEmitState(): SavedBuildProgramEmitState;
-    /*@internal*/
+    /** @internal */
     restoreEmitState(saved: SavedBuildProgramEmitState): void;
-    /*@internal*/
+    /** @internal */
     hasChangedEmitSignature?(): boolean;
     /**
      * Returns current program
@@ -57,12 +57,12 @@ export interface BuilderProgram {
     /**
      * Returns current program that could be undefined if the program was released
      */
-    /*@internal*/
+    /** @internal */
     getProgramOrUndefined(): Program | undefined;
     /**
      * Releases reference to the program, making all the other operations that need program to fail.
      */
-    /*@internal*/
+    /** @internal */
     releaseProgram(): void;
     /**
      * Get compiler options of the program
@@ -122,13 +122,13 @@ export interface BuilderProgram {
      * in that order would be used to write the files
      */
     emit(targetSourceFile?: SourceFile, writeFile?: WriteFileCallback, cancellationToken?: CancellationToken, emitOnlyDtsFiles?: boolean, customTransformers?: CustomTransformers): EmitResult;
-    /*@internal*/
+    /** @internal */
     emitBuildInfo(writeFile?: WriteFileCallback, cancellationToken?: CancellationToken): EmitResult;
     /**
      * Get the current directory of the program
      */
     getCurrentDirectory(): string;
-    /*@internal*/
+    /** @internal */
     close(): void;
 }
 
diff --git a/src/compiler/builderStatePublic.ts b/src/compiler/builderStatePublic.ts
index 5700cd02af..7a6109ce6b 100644
--- a/src/compiler/builderStatePublic.ts
+++ b/src/compiler/builderStatePublic.ts
@@ -3,12 +3,12 @@ import { BuildInfo, Diagnostic } from "./_namespaces/ts";
 export interface EmitOutput {
     outputFiles: OutputFile[];
     emitSkipped: boolean;
-    /* @internal */ diagnostics: readonly Diagnostic[];
+    /** @internal */ diagnostics: readonly Diagnostic[];
 }
 
 export interface OutputFile {
     name: string;
     writeByteOrderMark: boolean;
     text: string;
-    /* @internal */ buildInfo?: BuildInfo
+    /** @internal */ buildInfo?: BuildInfo
 }
diff --git a/src/compiler/commandLineParser.ts b/src/compiler/commandLineParser.ts
index 67c0f37c42..852544eac6 100644
--- a/src/compiler/commandLineParser.ts
+++ b/src/compiler/commandLineParser.ts
@@ -21,7 +21,7 @@ import {
     unescapeLeadingUnderscores, WatchDirectoryFlags, WatchDirectoryKind, WatchFileKind, WatchOptions,
 } from "./_namespaces/ts";
 
-/* @internal */
+/** @internal */
 export const compileOnSaveCommandLineOption: CommandLineOption = {
     name: "compileOnSave",
     type: "boolean",
@@ -36,7 +36,7 @@ const jsxOptionMap = new Map(getEntries({
     "react-jsxdev": JsxEmit.ReactJSXDev,
 }));
 
-/* @internal */
+/** @internal */
 export const inverseJsxOptionMap = new Map(arrayFrom(mapIterator(jsxOptionMap.entries(), ([key, value]: [string, JsxEmit]) => ["" + value, key] as const)));
 
 // NOTE: The order here is important to default lib ordering as entries will have the same
@@ -123,18 +123,18 @@ const libEntries: [string, string][] = [
  * when referenced, as well as for spelling suggestions. This ensures the correct ordering for
  * overload resolution when a type declared in one lib is extended by another.
  */
-/* @internal */
+/** @internal */
 export const libs = libEntries.map(entry => entry[0]);
 
 /**
  * A map of lib names to lib files. This map is used both for parsing the "lib" command line
  * option as well as for resolving lib reference directives.
  */
-/* @internal */
+/** @internal */
 export const libMap = new Map(libEntries);
 
 // Watch related options
-/* @internal */
+/** @internal */
 export const optionsForWatch: CommandLineOption[] = [
     {
         name: "watchFile",
@@ -207,7 +207,7 @@ export const optionsForWatch: CommandLineOption[] = [
     },
 ];
 
-/* @internal */
+/** @internal */
 export const commonOptionsWithBuild: CommandLineOption[] = [
     {
         name: "help",
@@ -339,7 +339,7 @@ export const commonOptionsWithBuild: CommandLineOption[] = [
     },
 ];
 
-/* @internal */
+/** @internal */
 export const targetOptionDeclaration: CommandLineOptionOfCustomType = {
     name: "target",
     shortName: "t",
@@ -368,7 +368,7 @@ export const targetOptionDeclaration: CommandLineOptionOfCustomType = {
     defaultValueDescription: ScriptTarget.ES3,
 };
 
-/*@internal*/
+/** @internal */
 export const moduleOptionDeclaration: CommandLineOptionOfCustomType = {
     name: "module",
     shortName: "m",
@@ -1377,42 +1377,42 @@ const commandOptionsWithoutBuild: CommandLineOption[] = [
     }
 ];
 
-/* @internal */
+/** @internal */
 export const optionDeclarations: CommandLineOption[] = [
     ...commonOptionsWithBuild,
     ...commandOptionsWithoutBuild,
 ];
 
-/* @internal */
+/** @internal */
 export const semanticDiagnosticsOptionDeclarations: readonly CommandLineOption[] =
     optionDeclarations.filter(option => !!option.affectsSemanticDiagnostics);
 
-/* @internal */
+/** @internal */
 export const affectsEmitOptionDeclarations: readonly CommandLineOption[] =
     optionDeclarations.filter(option => !!option.affectsEmit);
 
-/* @internal */
+/** @internal */
 export const affectsDeclarationPathOptionDeclarations: readonly CommandLineOption[] =
     optionDeclarations.filter(option => !!option.affectsDeclarationPath);
 
-/* @internal */
+/** @internal */
 export const moduleResolutionOptionDeclarations: readonly CommandLineOption[] =
     optionDeclarations.filter(option => !!option.affectsModuleResolution);
 
-/* @internal */
+/** @internal */
 export const sourceFileAffectingCompilerOptions: readonly CommandLineOption[] = optionDeclarations.filter(option =>
     !!option.affectsSourceFile || !!option.affectsModuleResolution || !!option.affectsBindDiagnostics);
 
-/* @internal */
+/** @internal */
 export const optionsAffectingProgramStructure: readonly CommandLineOption[] =
     optionDeclarations.filter(option => !!option.affectsProgramStructure);
 
-/* @internal */
+/** @internal */
 export const transpileOptionValueCompilerOptions: readonly CommandLineOption[] = optionDeclarations.filter(option =>
     hasProperty(option, "transpileOptionValue"));
 
 // Build related options
-/* @internal */
+/** @internal */
 export const optionsForBuild: CommandLineOption[] = [
     {
         name: "verbose",
@@ -1447,13 +1447,13 @@ export const optionsForBuild: CommandLineOption[] = [
     }
 ];
 
-/* @internal */
+/** @internal */
 export const buildOpts: CommandLineOption[] = [
     ...commonOptionsWithBuild,
     ...optionsForBuild
 ];
 
-/* @internal */
+/** @internal */
 export const typeAcquisitionDeclarations: CommandLineOption[] = [
     {
         /* @deprecated typingOptions.enableAutoDiscovery
@@ -1491,13 +1491,13 @@ export const typeAcquisitionDeclarations: CommandLineOption[] = [
     },
 ];
 
-/* @internal */
+/** @internal */
 export interface OptionsNameMap {
     optionsNameMap: ESMap<string, CommandLineOption>;
     shortOptionNames: ESMap<string, string>;
 }
 
-/*@internal*/
+/** @internal */
 export function createOptionNameMap(optionDeclarations: readonly CommandLineOption[]): OptionsNameMap {
     const optionsNameMap = new Map<string, CommandLineOption>();
     const shortOptionNames = new Map<string, string>();
@@ -1513,7 +1513,7 @@ export function createOptionNameMap(optionDeclarations: readonly CommandLineOpti
 
 let optionsNameMapCache: OptionsNameMap;
 
-/* @internal */
+/** @internal */
 export function getOptionsNameMap(): OptionsNameMap {
     return optionsNameMapCache ||= createOptionNameMap(optionDeclarations);
 }
@@ -1523,7 +1523,7 @@ const compilerOptionsAlternateMode: AlternateModeDiagnostics = {
     getOptionsNameMap: getBuildOptionsNameMap
 };
 
-/* @internal */
+/** @internal */
 export const defaultInitCompilerOptions: CompilerOptions = {
     module: ModuleKind.CommonJS,
     target: ScriptTarget.ES2016,
@@ -1533,7 +1533,7 @@ export const defaultInitCompilerOptions: CompilerOptions = {
     skipLibCheck: true
 };
 
-/* @internal */
+/** @internal */
 export function convertEnableAutoDiscoveryToEnable(typeAcquisition: TypeAcquisition): TypeAcquisition {
     // Convert deprecated typingOptions.enableAutoDiscovery to typeAcquisition.enable
     if (typeAcquisition && typeAcquisition.enableAutoDiscovery !== undefined && typeAcquisition.enable === undefined) {
@@ -1546,7 +1546,7 @@ export function convertEnableAutoDiscoveryToEnable(typeAcquisition: TypeAcquisit
     return typeAcquisition;
 }
 
-/* @internal */
+/** @internal */
 export function createCompilerDiagnosticForInvalidCustomType(opt: CommandLineOptionOfCustomType): Diagnostic {
     return createDiagnosticForInvalidCustomType(opt, createCompilerDiagnostic);
 }
@@ -1556,12 +1556,12 @@ function createDiagnosticForInvalidCustomType(opt: CommandLineOptionOfCustomType
     return createDiagnostic(Diagnostics.Argument_for_0_option_must_be_Colon_1, `--${opt.name}`, namesOfType);
 }
 
-/* @internal */
+/** @internal */
 export function parseCustomTypeOption(opt: CommandLineOptionOfCustomType, value: string, errors: Push<Diagnostic>) {
     return convertJsonOptionOfCustomType(opt, trimString(value || ""), errors);
 }
 
-/* @internal */
+/** @internal */
 export function parseListTypeOption(opt: CommandLineOptionOfListType, value = "", errors: Push<Diagnostic>): (string | number)[] | undefined {
     value = trimString(value);
     if (startsWith(value, "-")) {
@@ -1581,12 +1581,12 @@ export function parseListTypeOption(opt: CommandLineOptionOfListType, value = ""
     }
 }
 
-/*@internal*/
+/** @internal */
 export interface OptionsBase {
     [option: string]: CompilerOptionsValue | TsConfigSourceFile | undefined;
 }
 
-/*@internal*/
+/** @internal */
 export interface ParseCommandLineWorkerDiagnostics extends DidYouMeanOptionsDiagnostics {
     getOptionsNameMap: () => OptionsNameMap;
     optionTypeMismatchDiagnostic: DiagnosticMessage;
@@ -1612,7 +1612,7 @@ function createUnknownOptionError(
         createDiagnostics(diagnostics.unknownOptionDiagnostic, unknownOptionErrorText || unknownOption);
 }
 
-/*@internal*/
+/** @internal */
 export function parseCommandLineWorker(
     diagnostics: ParseCommandLineWorkerDiagnostics,
     commandLine: readonly string[],
@@ -1769,7 +1769,7 @@ function parseOptionValue(
     return i;
 }
 
-/*@internal*/
+/** @internal */
 export const compilerOptionsDidYouMeanDiagnostics: ParseCommandLineWorkerDiagnostics = {
     alternateMode: compilerOptionsAlternateMode,
     getOptionsNameMap,
@@ -1800,7 +1800,7 @@ function getOptionDeclarationFromName(getOptionNameMap: () => OptionsNameMap, op
     return optionsNameMap.get(optionName);
 }
 
-/*@internal*/
+/** @internal */
 export interface ParsedBuildCommand {
     buildOptions: BuildOptions;
     watchOptions: WatchOptions | undefined;
@@ -1827,7 +1827,7 @@ const buildOptionsDidYouMeanDiagnostics: ParseCommandLineWorkerDiagnostics = {
     optionTypeMismatchDiagnostic: Diagnostics.Build_option_0_requires_a_value_of_type_1
 };
 
-/*@internal*/
+/** @internal */
 export function parseBuildCommand(args: readonly string[]): ParsedBuildCommand {
     const { options, watchOptions, fileNames: projects, errors } = parseCommandLineWorker(
         buildOptionsDidYouMeanDiagnostics,
@@ -1857,7 +1857,7 @@ export function parseBuildCommand(args: readonly string[]): ParsedBuildCommand {
     return { buildOptions, watchOptions, projects, errors };
 }
 
-/* @internal */
+/** @internal */
 export function getDiagnosticText(_message: DiagnosticMessage, ..._args: any[]): string {
     const diagnostic = createCompilerDiagnostic.apply(undefined, arguments);
     return diagnostic.messageText as string;
@@ -1947,7 +1947,7 @@ export function readJsonConfigFile(fileName: string, readFile: (path: string) =>
     return isString(textOrDiagnostic) ? parseJsonText(fileName, textOrDiagnostic) : { fileName, parseDiagnostics: [textOrDiagnostic] } as TsConfigSourceFile;
 }
 
-/*@internal*/
+/** @internal */
 export function tryReadFile(fileName: string, readFile: (path: string) => string | undefined): string | Diagnostic {
     let text: string | undefined;
     try {
@@ -2075,7 +2075,7 @@ function getTsconfigRootOptionsMap() {
     return _tsconfigRootOptions;
 }
 
-/*@internal*/
+/** @internal */
 interface JsonConversionNotifier {
     /**
      * Notifies parent option object is being set with the optionKey and a valid optionValue
@@ -2140,7 +2140,7 @@ export function convertToObject(sourceFile: JsonSourceFile, errors: Push<Diagnos
  * This returns the json value (apart from checking errors) only if returnValue provided is true.
  * Otherwise it just checks the errors and returns undefined
  */
-/*@internal*/
+/** @internal */
 export function convertToObjectWorker(
     sourceFile: JsonSourceFile,
     rootExpression: Expression | undefined,
@@ -2473,7 +2473,7 @@ function getCustomTypeMapOfCommandLineOption(optionDefinition: CommandLineOption
     }
 }
 
-/* @internal */
+/** @internal */
 export function getNameOfCompilerOptionValue(value: CompilerOptionsValue, customTypeMap: ESMap<string, string | number>): string | undefined {
     // There is a typeMap associated with this command-line option so use it to map value back to its name
     return forEachEntry(customTypeMap, (mapValue, key) => {
@@ -2584,7 +2584,7 @@ function getSerializedCompilerOption(options: CompilerOptions): ESMap<string, Co
  * @param options commandlineOptions to be generated into tsconfig.json
  * @param fileNames array of filenames to be generated into tsconfig.json
  */
-/* @internal */
+/** @internal */
 export function generateTSConfig(options: CompilerOptions, fileNames: readonly string[], newLine: string): string {
     const compilerOptionsMap = getSerializedCompilerOption(options);
     return writeConfigurations();
@@ -2664,7 +2664,7 @@ export function generateTSConfig(options: CompilerOptions, fileNames: readonly s
     }
 }
 
-/* @internal */
+/** @internal */
 export function convertToOptionsWithAbsolutePaths(options: CompilerOptions, toAbsolutePath: (path: string) => string) {
     const result: CompilerOptions = {};
     const optionsNameMap = getOptionsNameMap().optionsNameMap;
@@ -2724,7 +2724,7 @@ export function parseJsonSourceFileConfigFileContent(sourceFile: TsConfigSourceF
     return result;
 }
 
-/*@internal*/
+/** @internal */
 export function setConfigFileInOptions(options: CompilerOptions, configFile: TsConfigSourceFile | undefined) {
     if (configFile) {
         Object.defineProperty(options, "configFile", { enumerable: false, writable: false, value: configFile });
@@ -2741,7 +2741,7 @@ function directoryOfCombinedPath(fileName: string, basePath: string) {
     return getDirectoryPath(getNormalizedAbsolutePath(fileName, basePath));
 }
 
-/*@internal*/
+/** @internal */
 export const defaultIncludeSpec = "**/*";
 
 /**
@@ -2941,12 +2941,12 @@ function shouldReportNoInputFiles(fileNames: string[], canJsonReportNoInutFiles:
     return fileNames.length === 0 && canJsonReportNoInutFiles && (!resolutionStack || resolutionStack.length === 0);
 }
 
-/*@internal*/
+/** @internal */
 export function canJsonReportNoInputFiles(raw: any) {
     return !hasProperty(raw, "files") && !hasProperty(raw, "references");
 }
 
-/*@internal*/
+/** @internal */
 export function updateErrorForNoInputFiles(fileNames: string[], configFileName: string, configFileSpecs: ConfigFileSpecs, configParseDiagnostics: Diagnostic[], canJsonReportNoInutFiles: boolean) {
     const existingErrors = configParseDiagnostics.length;
     if (shouldReportNoInputFiles(fileNames, canJsonReportNoInutFiles)) {
@@ -3302,7 +3302,7 @@ function convertOptionsFromJson(optionsNameMap: ESMap<string, CommandLineOption>
     return defaultOptions;
 }
 
-/*@internal*/
+/** @internal */
 export function convertJsonOption(opt: CommandLineOption, value: any, basePath: string, errors: Push<Diagnostic>): CompilerOptionsValue {
     if (isCompilerOptionsValue(opt, value)) {
         const optType = opt.type;
@@ -3405,7 +3405,7 @@ const wildcardDirectoryPattern = /^[^*?]*(?=\/[^/]*[*?])/;
  * @param host The host used to resolve files and directories.
  * @param extraFileExtensions optionaly file extra file extension information from host
  */
-/* @internal */
+/** @internal */
 export function getFileNamesFromConfigSpecs(
     configFileSpecs: ConfigFileSpecs,
     basePath: string,
@@ -3495,7 +3495,7 @@ export function getFileNamesFromConfigSpecs(
     return literalFiles.concat(wildcardFiles, arrayFrom(wildCardJsonFileMap.values()));
 }
 
-/* @internal */
+/** @internal */
 export function isExcludedFile(
     pathToCheck: string,
     spec: ConfigFileSpecs,
@@ -3532,7 +3532,7 @@ function invalidDotDotAfterRecursiveWildcard(s: string) {
     return lastDotIndex > wildcardIndex;
 }
 
-/* @internal */
+/** @internal */
 export function matchesExclude(
     pathToCheck: string,
     excludeSpecs: readonly string[] | undefined,
@@ -3724,7 +3724,7 @@ function removeWildcardFilesWithLowerPriorityExtension(file: string, wildcardFil
  * Produces a cleaned version of compiler options with personally identifying info (aka, paths) removed.
  * Also converts enum values back to strings.
  */
-/* @internal */
+/** @internal */
 export function convertCompilerOptionsForTelemetry(opts: CompilerOptions): CompilerOptions {
     const out: CompilerOptions = {};
     for (const key in opts) {
diff --git a/src/compiler/corePublic.ts b/src/compiler/corePublic.ts
index bb9a8d6dab..9ab3d8c1ce 100644
--- a/src/compiler/corePublic.ts
+++ b/src/compiler/corePublic.ts
@@ -61,7 +61,7 @@ export interface ESMap<K, V> extends ReadonlyESMap<K, V>, Collection<K> {
 export interface Map<T> extends ESMap<string, T> {
 }
 
-/* @internal */
+/** @internal */
 export interface MapConstructor {
     // eslint-disable-next-line @typescript-eslint/prefer-function-type
     new <K, V>(iterable?: readonly (readonly [K, V])[] | ReadonlyESMap<K, V>): ESMap<K, V>;
@@ -81,7 +81,7 @@ export interface Set<T> extends ReadonlySet<T>, Collection<T> {
     delete(value: T): boolean;
 }
 
-/* @internal */
+/** @internal */
 export interface SetConstructor {
     // eslint-disable-next-line @typescript-eslint/prefer-function-type
     new <T>(iterable?: readonly T[] | ReadonlySet<T>): Set<T>;
@@ -98,20 +98,20 @@ export interface Push<T> {
     /* @internal*/ readonly length: number;
 }
 
-/* @internal */
+/** @internal */
 export type EqualityComparer<T> = (a: T, b: T) => boolean;
 
-/* @internal */
+/** @internal */
 export type Comparer<T> = (a: T, b: T) => Comparison;
 
-/* @internal */
+/** @internal */
 export const enum Comparison {
     LessThan    = -1,
     EqualTo     = 0,
     GreaterThan = 1
 }
 
-/* @internal */
+/** @internal */
 namespace NativeCollections {
     declare const self: any;
 
@@ -149,7 +149,7 @@ namespace NativeCollections {
     }
 }
 
-/* @internal */
+/** @internal */
 export const Map = NativeCollections.tryGetNativeMap();
-/* @internal */
+/** @internal */
 export const Set = NativeCollections.tryGetNativeSet();
diff --git a/src/compiler/emitter.ts b/src/compiler/emitter.ts
index 9757d691d7..a03e7bd9e6 100644
--- a/src/compiler/emitter.ts
+++ b/src/compiler/emitter.ts
@@ -80,12 +80,12 @@ import {
 
 const brackets = createBracketsMap();
 
-/*@internal*/
+/** @internal */
 export function isBuildInfoFile(file: string) {
     return fileExtensionIs(file, Extension.TsBuildInfo);
 }
 
-/*@internal*/
+/** @internal */
 /**
  * Iterates over the source files that are expected to have an emit output.
  *
@@ -150,7 +150,7 @@ export function getTsBuildInfoEmitOutputFilePath(options: CompilerOptions) {
     return buildInfoExtensionLess + Extension.TsBuildInfo;
 }
 
-/*@internal*/
+/** @internal */
 export function getOutputPathsForBundle(options: CompilerOptions, forceDtsPaths: boolean): EmitFileNames {
     const outPath = outFile(options)!;
     const jsFilePath = options.emitDeclarationOnly ? undefined : outPath;
@@ -161,7 +161,7 @@ export function getOutputPathsForBundle(options: CompilerOptions, forceDtsPaths:
     return { jsFilePath, sourceMapFilePath, declarationFilePath, declarationMapPath, buildInfoPath };
 }
 
-/*@internal*/
+/** @internal */
 export function getOutputPathsFor(sourceFile: SourceFile | Bundle, host: EmitHost, forceDtsPaths: boolean): EmitFileNames {
     const options = host.getCompilerOptions();
     if (sourceFile.kind === SyntaxKind.Bundle) {
@@ -185,7 +185,7 @@ function getSourceMapFilePath(jsFilePath: string, options: CompilerOptions) {
     return (options.sourceMap && !options.inlineSourceMap) ? jsFilePath + ".map" : undefined;
 }
 
-/* @internal */
+/** @internal */
 export function getOutputExtension(fileName: string, options: CompilerOptions): Extension {
     return fileExtensionIs(fileName, Extension.Json) ? Extension.Json :
     options.jsx === JsxEmit.Preserve && fileExtensionIsOneOf(fileName, [Extension.Jsx, Extension.Tsx]) ? Extension.Jsx :
@@ -203,7 +203,7 @@ function getOutputPathWithoutChangingExt(inputFileName: string, configFile: Pars
         inputFileName;
 }
 
-/* @internal */
+/** @internal */
 export function getOutputDeclarationFileName(inputFileName: string, configFile: ParsedCommandLine, ignoreCase: boolean, getCommonSourceDirectory?: () => string) {
     return changeExtension(
         getOutputPathWithoutChangingExt(inputFileName, configFile, ignoreCase, configFile.options.declarationDir || configFile.options.outDir, getCommonSourceDirectory),
@@ -262,7 +262,7 @@ function getOwnOutputFileNames(configFile: ParsedCommandLine, inputFileName: str
     }
 }
 
-/*@internal*/
+/** @internal */
 export function getCommonSourceDirectory(
     options: CompilerOptions,
     emittedFiles: () => readonly string[],
@@ -294,7 +294,7 @@ export function getCommonSourceDirectory(
     return commonSourceDirectory;
 }
 
-/*@internal*/
+/** @internal */
 export function getCommonSourceDirectoryOfConfig({ options, fileNames }: ParsedCommandLine, ignoreCase: boolean): string {
     return getCommonSourceDirectory(
         options,
@@ -304,7 +304,7 @@ export function getCommonSourceDirectoryOfConfig({ options, fileNames }: ParsedC
     );
 }
 
-/*@internal*/
+/** @internal */
 export function getAllProjectOutputs(configFile: ParsedCommandLine, ignoreCase: boolean): readonly string[] {
     const { addOutput, getOutputs } = createAddOutput();
     if (outFile(configFile.options)) {
@@ -333,7 +333,7 @@ export function getOutputFileNames(commandLine: ParsedCommandLine, inputFileName
     return getOutputs();
 }
 
-/*@internal*/
+/** @internal */
 export function getFirstProjectOutput(configFile: ParsedCommandLine, ignoreCase: boolean): string {
     if (outFile(configFile.options)) {
         const { jsFilePath } = getOutputPathsForBundle(configFile.options, /*forceDtsPaths*/ false);
@@ -355,7 +355,7 @@ export function getFirstProjectOutput(configFile: ParsedCommandLine, ignoreCase:
     return Debug.fail(`project ${configFile.options.configFilePath} expected to have at least one output`);
 }
 
-/*@internal*/
+/** @internal */
 // targetSourceFile is when users only want one file in entire project to be emitted. This is used in compileOnSave feature
 export function emitFiles(resolver: EmitResolver, host: EmitHost, targetSourceFile: SourceFile | undefined, { scriptTransformers, declarationTransformers }: EmitTransformers, emitOnlyDtsFiles?: boolean, onlyBuildInfo?: boolean, forceDtsEmit?: boolean): EmitResult {
     const compilerOptions = host.getCompilerOptions();
@@ -725,17 +725,17 @@ export function emitFiles(resolver: EmitResolver, host: EmitHost, targetSourceFi
     }
 }
 
-/*@internal*/
+/** @internal */
 export function getBuildInfoText(buildInfo: BuildInfo) {
     return JSON.stringify(buildInfo);
 }
 
-/*@internal*/
+/** @internal */
 export function getBuildInfo(buildInfoFile: string, buildInfoText: string) {
     return readJsonOrUndefined(buildInfoFile, buildInfoText) as BuildInfo | undefined;
 }
 
-/*@internal*/
+/** @internal */
 export const notImplementedResolver: EmitResolver = {
     hasGlobalName: notImplemented,
     getReferencedExportContainer: notImplemented,
@@ -780,11 +780,11 @@ export const notImplementedResolver: EmitResolver = {
     isImportRequiredByAugmentation: notImplemented,
 };
 
-/*@internal*/
+/** @internal */
 /** File that isnt present resulting in error or output files */
 export type EmitUsingBuildInfoResult = string | readonly OutputFile[];
 
-/*@internal*/
+/** @internal */
 export interface EmitUsingBuildInfoHost extends ModuleResolutionHost {
     getCurrentDirectory(): string;
     getCanonicalFileName(fileName: string): string;
@@ -821,7 +821,7 @@ function createSourceFilesFromBundleBuildInfo(bundle: BundleBuildInfo, buildInfo
     });
 }
 
-/*@internal*/
+/** @internal */
 export function emitUsingBuildInfo(
     config: ParsedCommandLine,
     host: EmitUsingBuildInfoHost,
diff --git a/src/compiler/factory/baseNodeFactory.ts b/src/compiler/factory/baseNodeFactory.ts
index be1bd56d05..b592b1126d 100644
--- a/src/compiler/factory/baseNodeFactory.ts
+++ b/src/compiler/factory/baseNodeFactory.ts
@@ -4,7 +4,7 @@ import { Node, objectAllocator, SyntaxKind } from "../_namespaces/ts";
  * A `BaseNodeFactory` is an abstraction over an `ObjectAllocator` that handles caching `Node` constructors
  * and allocating `Node` instances based on a set of predefined types.
  */
-/* @internal */
+/** @internal */
 export interface BaseNodeFactory {
     createBaseSourceFileNode(kind: SyntaxKind): Node;
     createBaseIdentifierNode(kind: SyntaxKind): Node;
@@ -53,4 +53,4 @@ export function createBaseNodeFactory(): BaseNodeFactory {
     function createBaseNode(kind: SyntaxKind): Node {
         return new (NodeConstructor || (NodeConstructor = objectAllocator.getNodeConstructor()))(kind, /*pos*/ -1, /*end*/ -1);
     }
-}
\ No newline at end of file
+}
diff --git a/src/compiler/factory/emitHelpers.ts b/src/compiler/factory/emitHelpers.ts
index 34f8e9233a..b4eb142d54 100644
--- a/src/compiler/factory/emitHelpers.ts
+++ b/src/compiler/factory/emitHelpers.ts
@@ -412,7 +412,7 @@ export function createEmitHelperFactory(context: TransformationContext): EmitHel
     }
 }
 
-/* @internal */
+/** @internal */
 export function compareEmitHelpers(x: EmitHelper, y: EmitHelper) {
     if (x === y) return Comparison.EqualTo;
     if (x.priority === y.priority) return Comparison.EqualTo;
diff --git a/src/compiler/factory/emitNode.ts b/src/compiler/factory/emitNode.ts
index 44717059b4..98d587b443 100644
--- a/src/compiler/factory/emitNode.ts
+++ b/src/compiler/factory/emitNode.ts
@@ -73,7 +73,7 @@ export function setEmitFlags<T extends Node>(node: T, emitFlags: EmitFlags) {
 /**
  * Sets flags that control emit behavior of a node.
  */
-/* @internal */
+/** @internal */
 export function addEmitFlags<T extends Node>(node: T, emitFlags: EmitFlags) {
     const emitNode = getOrCreateEmitNode(node);
     emitNode.flags = emitNode.flags | emitFlags;
@@ -115,7 +115,7 @@ export function setTokenSourceMapRange<T extends Node>(node: T, token: SyntaxKin
 /**
  * Gets a custom text range to use when emitting comments.
  */
-/*@internal*/
+/** @internal */
 export function getStartsOnNewLine(node: Node) {
     return node.emitNode?.startsOnNewLine;
 }
@@ -123,7 +123,7 @@ export function getStartsOnNewLine(node: Node) {
 /**
  * Sets a custom text range to use when emitting comments.
  */
-/*@internal*/
+/** @internal */
 export function setStartsOnNewLine<T extends Node>(node: T, newLine: boolean) {
     getOrCreateEmitNode(node).startsOnNewLine = newLine;
     return node;
@@ -264,7 +264,7 @@ export function moveEmitHelpers(source: Node, target: Node, predicate: (helper:
 /**
  * Gets the SnippetElement of a node.
  */
-/* @internal */
+/** @internal */
 export function getSnippetElement(node: Node): SnippetElement | undefined {
     return node.emitNode?.snippetElement;
 }
@@ -272,27 +272,27 @@ export function getSnippetElement(node: Node): SnippetElement | undefined {
 /**
  * Sets the SnippetElement of a node.
  */
-/* @internal */
+/** @internal */
 export function setSnippetElement<T extends Node>(node: T, snippet: SnippetElement): T {
     const emitNode = getOrCreateEmitNode(node);
     emitNode.snippetElement = snippet;
     return node;
 }
 
-/* @internal */
+/** @internal */
 export function ignoreSourceNewlines<T extends Node>(node: T): T {
     getOrCreateEmitNode(node).flags |= EmitFlags.IgnoreSourceNewlines;
     return node;
 }
 
-/* @internal */
+/** @internal */
 export function setTypeNode<T extends Node>(node: T, type: TypeNode): T {
     const emitNode = getOrCreateEmitNode(node);
     emitNode.typeNode = type;
     return node;
 }
 
-/* @internal */
+/** @internal */
 export function getTypeNode<T extends Node>(node: T): TypeNode | undefined {
     return node.emitNode?.typeNode;
 }
diff --git a/src/compiler/factory/nodeConverters.ts b/src/compiler/factory/nodeConverters.ts
index 3efb85e75e..74cddf3152 100644
--- a/src/compiler/factory/nodeConverters.ts
+++ b/src/compiler/factory/nodeConverters.ts
@@ -142,4 +142,4 @@ export const nullNodeConverters: NodeConverters = {
     convertToObjectAssignmentPattern: notImplemented,
     convertToArrayAssignmentPattern: notImplemented,
     convertToAssignmentElementTarget: notImplemented,
-};
\ No newline at end of file
+};
diff --git a/src/compiler/factory/nodeFactory.ts b/src/compiler/factory/nodeFactory.ts
index 8d4d722148..00d2c239ed 100644
--- a/src/compiler/factory/nodeFactory.ts
+++ b/src/compiler/factory/nodeFactory.ts
@@ -81,7 +81,7 @@ import {
 
 let nextAutoGenerateId = 0;
 
-/* @internal */
+/** @internal */
 export const enum NodeFactoryFlags {
     None = 0,
     // Disables the parenthesizer rules for the factory.
@@ -96,7 +96,7 @@ export const enum NodeFactoryFlags {
 
 const nodeFactoryPatchers: ((factory: NodeFactory) => void)[] = [];
 
-/* @internal */
+/** @internal */
 export function addNodeFactoryPatcher(fn: (factory: NodeFactory) => void) {
     nodeFactoryPatchers.push(fn);
 }
@@ -106,7 +106,7 @@ export function addNodeFactoryPatcher(fn: (factory: NodeFactory) => void) {
  * @param flags Flags that control factory behavior.
  * @param baseFactory A `BaseNodeFactory` used to create the base `Node` objects.
  */
-/* @internal */
+/** @internal */
 export function createNodeFactory(flags: NodeFactoryFlags, baseFactory: BaseNodeFactory): NodeFactory {
     const update = flags & NodeFactoryFlags.NoOriginalNode ? updateWithoutOriginal : updateWithOriginal;
 
@@ -6518,7 +6518,7 @@ function aggregateChildrenFlags(children: MutableNodeArray<Node>) {
 /**
  * Gets the transform flags to exclude when unioning the transform flags of a subtree.
  */
-/* @internal */
+/** @internal */
 export function getTransformFlagsSubtreeExclusions(kind: SyntaxKind) {
     if (kind >= SyntaxKind.FirstTypeNode && kind <= SyntaxKind.LastTypeNode) {
         return TransformFlags.TypeExcludes;
@@ -6800,7 +6800,7 @@ export function createInputFiles(
     declarationMapPath: string | undefined,
     declarationMapText: string | undefined
 ): InputFiles;
-/*@internal*/
+/** @internal */
 export function createInputFiles(
     javascriptText: string,
     declarationText: string,
diff --git a/src/compiler/factory/nodeTests.ts b/src/compiler/factory/nodeTests.ts
index b6e4dc3111..991eccb491 100644
--- a/src/compiler/factory/nodeTests.ts
+++ b/src/compiler/factory/nodeTests.ts
@@ -85,7 +85,7 @@ export function isDotDotDotToken(node: Node): node is DotDotDotToken {
     return node.kind === SyntaxKind.DotDotDotToken;
 }
 
-/*@internal*/
+/** @internal */
 export function isCommaToken(node: Node): node is Token<SyntaxKind.CommaToken> {
     return node.kind === SyntaxKind.CommaToken;
 }
@@ -102,27 +102,27 @@ export function isAsteriskToken(node: Node): node is AsteriskToken {
     return node.kind === SyntaxKind.AsteriskToken;
 }
 
-/*@internal*/
+/** @internal */
 export function isExclamationToken(node: Node): node is ExclamationToken {
     return node.kind === SyntaxKind.ExclamationToken;
 }
 
-/*@internal*/
+/** @internal */
 export function isQuestionToken(node: Node): node is QuestionToken {
     return node.kind === SyntaxKind.QuestionToken;
 }
 
-/*@internal*/
+/** @internal */
 export function isColonToken(node: Node): node is ColonToken {
     return node.kind === SyntaxKind.ColonToken;
 }
 
-/*@internal*/
+/** @internal */
 export function isQuestionDotToken(node: Node): node is QuestionDotToken {
     return node.kind === SyntaxKind.QuestionDotToken;
 }
 
-/*@internal*/
+/** @internal */
 export function isEqualsGreaterThanToken(node: Node): node is EqualsGreaterThanToken {
     return node.kind === SyntaxKind.EqualsGreaterThanToken;
 }
@@ -139,52 +139,52 @@ export function isPrivateIdentifier(node: Node): node is PrivateIdentifier {
 
 // Reserved Words
 
-/* @internal */
+/** @internal */
 export function isExportModifier(node: Node): node is ExportKeyword {
     return node.kind === SyntaxKind.ExportKeyword;
 }
 
-/* @internal */
+/** @internal */
 export function isAsyncModifier(node: Node): node is AsyncKeyword {
     return node.kind === SyntaxKind.AsyncKeyword;
 }
 
-/* @internal */
+/** @internal */
 export function isAssertsKeyword(node: Node): node is AssertsKeyword {
     return node.kind === SyntaxKind.AssertsKeyword;
 }
 
-/* @internal */
+/** @internal */
 export function isAwaitKeyword(node: Node): node is AwaitKeyword {
     return node.kind === SyntaxKind.AwaitKeyword;
 }
 
-/* @internal */
+/** @internal */
 export function isReadonlyKeyword(node: Node): node is ReadonlyKeyword {
     return node.kind === SyntaxKind.ReadonlyKeyword;
 }
 
-/* @internal */
+/** @internal */
 export function isStaticModifier(node: Node): node is StaticKeyword {
     return node.kind === SyntaxKind.StaticKeyword;
 }
 
-/* @internal */
+/** @internal */
 export function isAbstractModifier(node: Node): node is AbstractKeyword {
     return node.kind === SyntaxKind.AbstractKeyword;
 }
 
-/* @internal */
+/** @internal */
 export function isOverrideModifier(node: Node): node is OverrideKeyword {
     return node.kind === SyntaxKind.OverrideKeyword;
 }
 
-/*@internal*/
+/** @internal */
 export function isSuperKeyword(node: Node): node is SuperExpression {
     return node.kind === SyntaxKind.SuperKeyword;
 }
 
-/*@internal*/
+/** @internal */
 export function isImportKeyword(node: Node): node is ImportExpression {
     return node.kind === SyntaxKind.ImportKeyword;
 }
@@ -698,17 +698,17 @@ export function isNotEmittedStatement(node: Node): node is NotEmittedStatement {
     return node.kind === SyntaxKind.NotEmittedStatement;
 }
 
-/* @internal */
+/** @internal */
 export function isSyntheticReference(node: Node): node is SyntheticReferenceExpression {
     return node.kind === SyntaxKind.SyntheticReferenceExpression;
 }
 
-/* @internal */
+/** @internal */
 export function isMergeDeclarationMarker(node: Node): node is MergeDeclarationMarker {
     return node.kind === SyntaxKind.MergeDeclarationMarker;
 }
 
-/* @internal */
+/** @internal */
 export function isEndOfDeclarationMarker(node: Node): node is EndOfDeclarationMarker {
     return node.kind === SyntaxKind.EndOfDeclarationMarker;
 }
@@ -988,7 +988,7 @@ export function isJSDocImplementsTag(node: Node): node is JSDocImplementsTag {
 
 // Synthesized list
 
-/* @internal */
+/** @internal */
 export function isSyntaxList(n: Node): n is SyntaxList {
     return n.kind === SyntaxKind.SyntaxList;
 }
diff --git a/src/compiler/factory/utilities.ts b/src/compiler/factory/utilities.ts
index 0521f77579..52aa106765 100644
--- a/src/compiler/factory/utilities.ts
+++ b/src/compiler/factory/utilities.ts
@@ -921,7 +921,7 @@ export function getElementsOfBindingOrAssignmentPattern(name: BindingOrAssignmen
     }
 }
 
-/* @internal */
+/** @internal */
 export function getJSDocTypeAliasName(fullName: JSDocNamespaceBody | undefined) {
     if (fullName) {
         let rightNode = fullName;
diff --git a/src/compiler/moduleNameResolver.ts b/src/compiler/moduleNameResolver.ts
index b096965634..bbebd99b8a 100644
--- a/src/compiler/moduleNameResolver.ts
+++ b/src/compiler/moduleNameResolver.ts
@@ -19,13 +19,13 @@ import {
     tryRemoveExtension, version, Version, versionMajorMinor, VersionRange,
 } from "./_namespaces/ts";
 
-/* @internal */
+/** @internal */
 export function trace(host: ModuleResolutionHost, message: DiagnosticMessage, ...args: any[]): void;
 export function trace(host: ModuleResolutionHost): void {
     host.trace!(formatMessage.apply(undefined, arguments));
 }
 
-/* @internal */
+/** @internal */
 export function isTraceEnabled(compilerOptions: CompilerOptions, host: ModuleResolutionHost): boolean {
     return !!compilerOptions.traceResolution && host.trace !== undefined;
 }
@@ -127,7 +127,7 @@ function createResolvedModuleWithFailedLookupLocations(
     };
 }
 
-/*@internal*/
+/** @internal */
 interface ModuleResolutionState {
     host: ModuleResolutionHost;
     compilerOptions: CompilerOptions;
@@ -143,7 +143,7 @@ interface ModuleResolutionState {
 }
 
 /** Just the fields that we use for module resolution. */
-/*@internal*/
+/** @internal */
 interface PackageJsonPathFields {
     typings?: string;
     types?: string;
@@ -223,7 +223,7 @@ function readPackageJsonTypesVersionsField(jsonContent: PackageJson, state: Modu
     return typesVersions;
 }
 
-/*@internal*/
+/** @internal */
 interface VersionPaths {
     version: string;
     paths: MapLike<string[]>;
@@ -262,7 +262,7 @@ function readPackageJsonTypesVersionPaths(jsonContent: PackageJson, state: Modul
 
 let typeScriptVersion: Version | undefined;
 
-/* @internal */
+/** @internal */
 export function getPackageJsonTypesVersionsPaths(typesVersions: MapLike<MapLike<string[]>>) {
     if (!typeScriptVersion) typeScriptVersion = new Version(version);
 
@@ -565,7 +565,7 @@ export function getAutomaticTypeDirectiveNames(options: CompilerOptions, host: M
 }
 
 export interface TypeReferenceDirectiveResolutionCache extends PerDirectoryResolutionCache<ResolvedTypeReferenceDirectiveWithFailedLookupLocations>, PackageJsonInfoCache {
-    /*@internal*/ clearAllExceptPackageJsonInfoCache(): void;
+    /** @internal */ clearAllExceptPackageJsonInfoCache(): void;
 }
 
 export interface ModeAwareCache<T> {
@@ -593,7 +593,7 @@ export interface PerDirectoryResolutionCache<T> {
 
 export interface ModuleResolutionCache extends PerDirectoryResolutionCache<ResolvedModuleWithFailedLookupLocations>, NonRelativeModuleNameResolutionCache, PackageJsonInfoCache {
     getPackageJsonInfoCache(): PackageJsonInfoCache;
-    /*@internal*/ clearAllExceptPackageJsonInfoCache(): void;
+    /** @internal */ clearAllExceptPackageJsonInfoCache(): void;
 }
 
 /**
@@ -605,10 +605,10 @@ export interface NonRelativeModuleNameResolutionCache extends PackageJsonInfoCac
 }
 
 export interface PackageJsonInfoCache {
-    /*@internal*/ getPackageJsonInfo(packageJsonPath: string): PackageJsonInfo | boolean | undefined;
-    /*@internal*/ setPackageJsonInfo(packageJsonPath: string, info: PackageJsonInfo | boolean): void;
-    /*@internal*/ entries(): [Path, PackageJsonInfo | boolean][];
-    /*@internal*/ getInternalMap(): ESMap<Path, PackageJsonInfo | boolean> | undefined;
+    /** @internal */ getPackageJsonInfo(packageJsonPath: string): PackageJsonInfo | boolean | undefined;
+    /** @internal */ setPackageJsonInfo(packageJsonPath: string, info: PackageJsonInfo | boolean): void;
+    /** @internal */ entries(): [Path, PackageJsonInfo | boolean][];
+    /** @internal */ getInternalMap(): ESMap<Path, PackageJsonInfo | boolean> | undefined;
     clear(): void;
 }
 
@@ -617,7 +617,7 @@ export interface PerModuleNameCache {
     set(directory: string, result: ResolvedModuleWithFailedLookupLocations): void;
 }
 
-/*@internal*/
+/** @internal */
 export interface CacheWithRedirects<T> {
     getOwnMap: () => ESMap<string, T>;
     redirectsMap: ESMap<Path, ESMap<string, T>>;
@@ -627,7 +627,7 @@ export interface CacheWithRedirects<T> {
     setOwnMap(newOwnMap: ESMap<string, T>): void;
 }
 
-/*@internal*/
+/** @internal */
 export function createCacheWithRedirects<T>(options?: CompilerOptions): CacheWithRedirects<T> {
     let ownMap: ESMap<string, T> = new Map();
     const redirectsMap = new Map<Path, ESMap<string, T>>();
@@ -752,7 +752,7 @@ function createPerDirectoryResolutionCache<T>(currentDirectory: string, getCanon
     }
 }
 
-/* @internal */
+/** @internal */
 export function createModeAwareCache<T>(): ModeAwareCache<T> {
     const underlying = new Map<string, T>();
     const memoizedReverseKeys = new Map<string, [specifier: string, mode: ModuleKind.CommonJS | ModuleKind.ESNext | undefined]>();
@@ -791,7 +791,7 @@ export function createModeAwareCache<T>(): ModeAwareCache<T> {
     }
 }
 
-/* @internal */
+/** @internal */
 export function zipToModeAwareCache<V>(file: SourceFile, keys: readonly string[] | readonly FileReference[], values: readonly V[]): ModeAwareCache<V> {
     Debug.assert(keys.length === values.length);
     const map = createModeAwareCache<V>();
@@ -810,7 +810,7 @@ export function createModuleResolutionCache(
     getCanonicalFileName: (s: string) => string,
     options?: CompilerOptions
 ): ModuleResolutionCache;
-/*@internal*/
+/** @internal */
 export function createModuleResolutionCache(
     currentDirectory: string,
     getCanonicalFileName: GetCanonicalFileName,
@@ -937,7 +937,7 @@ export function createTypeReferenceDirectiveResolutionCache(
     options?: CompilerOptions,
     packageJsonInfoCache?: PackageJsonInfoCache,
 ): TypeReferenceDirectiveResolutionCache;
-/*@internal*/
+/** @internal */
 export function createTypeReferenceDirectiveResolutionCache(
     currentDirectory: string,
     getCanonicalFileName: GetCanonicalFileName,
@@ -1268,7 +1268,7 @@ function tryLoadModuleUsingBaseUrl(extensions: Extensions, moduleName: string, l
  * No way to do this with `require()`: https://github.com/nodejs/node/issues/5963
  * Throws an error if the module can't be resolved.
  */
-/* @internal */
+/** @internal */
 export function resolveJSModule(moduleName: string, initialDir: string, host: ModuleResolutionHost): string {
     const { resolvedModule, failedLookupLocations } = tryResolveJSModuleWorker(moduleName, initialDir, host);
     if (!resolvedModule) {
@@ -1277,7 +1277,7 @@ export function resolveJSModule(moduleName: string, initialDir: string, host: Mo
     return resolvedModule.resolvedFileName;
 }
 
-/* @internal */
+/** @internal */
 enum NodeResolutionFeatures {
     None = 0,
     // resolving `#local` names in your own package.json
@@ -1349,7 +1349,7 @@ function tryResolveJSModuleWorker(moduleName: string, initialDir: string, host:
 }
 
 export function nodeModuleNameResolver(moduleName: string, containingFile: string, compilerOptions: CompilerOptions, host: ModuleResolutionHost, cache?: ModuleResolutionCache, redirectedReference?: ResolvedProjectReference): ResolvedModuleWithFailedLookupLocations;
-/* @internal */ export function nodeModuleNameResolver(moduleName: string, containingFile: string, compilerOptions: CompilerOptions, host: ModuleResolutionHost, cache?: ModuleResolutionCache, redirectedReference?: ResolvedProjectReference, lookupConfig?: boolean): ResolvedModuleWithFailedLookupLocations; // eslint-disable-line @typescript-eslint/unified-signatures
+/** @internal */ export function nodeModuleNameResolver(moduleName: string, containingFile: string, compilerOptions: CompilerOptions, host: ModuleResolutionHost, cache?: ModuleResolutionCache, redirectedReference?: ResolvedProjectReference, lookupConfig?: boolean): ResolvedModuleWithFailedLookupLocations; // eslint-disable-line @typescript-eslint/unified-signatures
 export function nodeModuleNameResolver(moduleName: string, containingFile: string, compilerOptions: CompilerOptions, host: ModuleResolutionHost, cache?: ModuleResolutionCache, redirectedReference?: ResolvedProjectReference, lookupConfig?: boolean): ResolvedModuleWithFailedLookupLocations {
     let extensions;
     if (lookupConfig) {
@@ -1511,9 +1511,9 @@ function nodeLoadModuleByRelativeName(extensions: Extensions, candidate: string,
     return undefined;
 }
 
-/*@internal*/
+/** @internal */
 export const nodeModulesPathPart = "/node_modules/";
-/*@internal*/
+/** @internal */
 export function pathContainsNodeModules(path: string): boolean {
     return stringContains(path, nodeModulesPathPart);
 }
@@ -1528,7 +1528,7 @@ export function pathContainsNodeModules(path: string): boolean {
  *   For `/node_modules/@types/foo/bar/index.d.ts` this is packageDirectory: "@types/foo"
  *   For `/node_modules/foo/bar/index.d.ts` this is packageDirectory: "foo"
  */
-/* @internal */
+/** @internal */
 export function parseNodeModuleFromPath(resolved: string): string | undefined {
     const path = normalizePath(resolved);
     const idx = path.lastIndexOf(nodeModulesPathPart);
@@ -1704,7 +1704,7 @@ function loadNodeModuleFromDirectory(extensions: Extensions, candidate: string,
     return withPackageId(packageInfo, loadNodeModuleFromDirectoryWorker(extensions, candidate, onlyRecordFailures, state, packageJsonContent, versionPaths));
 }
 
-/* @internal */
+/** @internal */
 export function getEntrypointsFromPackageJsonInfo(
     packageJsonInfo: PackageJsonInfo,
     options: CompilerOptions,
@@ -1809,7 +1809,7 @@ function loadEntrypointsFromExportMap(
     }
 }
 
-/*@internal*/
+/** @internal */
 export function getTemporaryModuleResolutionState(packageJsonInfoCache: PackageJsonInfoCache | undefined, host: ModuleResolutionHost, options: CompilerOptions): ModuleResolutionState {
     return {
         host,
@@ -1825,7 +1825,7 @@ export function getTemporaryModuleResolutionState(packageJsonInfoCache: PackageJ
     };
 }
 
-/*@internal*/
+/** @internal */
 export interface PackageJsonInfo {
     packageDirectory: string;
     packageJsonContent: PackageJsonPathFields;
@@ -1837,7 +1837,7 @@ export interface PackageJsonInfo {
 /**
  * A function for locating the package.json scope for a given path
  */
-/*@internal*/
+/** @internal */
  export function getPackageScopeForPath(fileName: Path, state: ModuleResolutionState): PackageJsonInfo | undefined {
     const parts = getPathComponents(fileName);
     parts.pop();
@@ -1851,7 +1851,7 @@ export interface PackageJsonInfo {
     return undefined;
 }
 
-/*@internal*/
+/** @internal */
 export function getPackageJsonInfo(packageDirectory: string, onlyRecordFailures: boolean, state: ModuleResolutionState): PackageJsonInfo | undefined {
     const { host, traceEnabled } = state;
     const packageJsonPath = combinePaths(packageDirectory, "package.json");
@@ -1995,7 +1995,7 @@ function extensionIsOk(extensions: Extensions, extension: Extension): boolean {
     }
 }
 
-/* @internal */
+/** @internal */
 export function parsePackageName(moduleName: string): { packageName: string, rest: string } {
     let idx = moduleName.indexOf(directorySeparator);
     if (moduleName[0] === "@") {
@@ -2004,7 +2004,7 @@ export function parsePackageName(moduleName: string): { packageName: string, res
     return idx === -1 ? { packageName: moduleName, rest: "" } : { packageName: moduleName.slice(0, idx), rest: moduleName.slice(idx + 1) };
 }
 
-/* @internal */
+/** @internal */
 export function allKeysStartWithDot(obj: MapLike<unknown>) {
     return every(getOwnKeys(obj), k => startsWith(k, "."));
 }
@@ -2373,7 +2373,7 @@ function getLoadModuleFromTargetImportOrExport(extensions: Extensions, state: Mo
     }
 }
 
-/* @internal */
+/** @internal */
 export function isApplicableVersionedTypesKey(conditions: readonly string[], key: string) {
     if (conditions.indexOf("types") === -1) return false; // only apply versioned types conditions if the types condition is applied
     if (!startsWith(key, "types@")) return false;
@@ -2544,12 +2544,12 @@ function mangleScopedPackageNameWithTrace(packageName: string, state: ModuleReso
     return mangled;
 }
 
-/* @internal */
+/** @internal */
 export function getTypesPackageName(packageName: string): string {
     return `@types/${mangleScopedPackageName(packageName)}`;
 }
 
-/* @internal */
+/** @internal */
 export function mangleScopedPackageName(packageName: string): string {
     if (startsWith(packageName, "@")) {
         const replaceSlash = packageName.replace(directorySeparator, mangledScopedPackageSeparator);
@@ -2560,7 +2560,7 @@ export function mangleScopedPackageName(packageName: string): string {
     return packageName;
 }
 
-/* @internal */
+/** @internal */
 export function getPackageNameFromTypesPackageName(mangledName: string): string {
     const withoutAtTypePrefix = removePrefix(mangledName, "@types/");
     if (withoutAtTypePrefix !== mangledName) {
@@ -2569,7 +2569,7 @@ export function getPackageNameFromTypesPackageName(mangledName: string): string
     return mangledName;
 }
 
-/* @internal */
+/** @internal */
 export function unmangleScopedPackageName(typesPackageName: string): string {
     return stringContains(typesPackageName, mangledScopedPackageSeparator) ?
         "@" + typesPackageName.replace(mangledScopedPackageSeparator, directorySeparator) :
@@ -2652,7 +2652,7 @@ export function classicNameResolver(moduleName: string, containingFile: string,
  * A host may load a module from a global cache of typings.
  * This is the minumum code needed to expose that functionality; the rest is in the host.
  */
-/* @internal */
+/** @internal */
 export function loadModuleFromGlobalCache(moduleName: string, projectName: string | undefined, compilerOptions: CompilerOptions, host: ModuleResolutionHost, globalCache: string, packageJsonInfoCache: PackageJsonInfoCache): ResolvedModuleWithFailedLookupLocations {
     const traceEnabled = isTraceEnabled(compilerOptions, host);
     if (traceEnabled) {
diff --git a/src/compiler/parser.ts b/src/compiler/parser.ts
index ca406fa700..e3d01cdc12 100644
--- a/src/compiler/parser.ts
+++ b/src/compiler/parser.ts
@@ -90,7 +90,7 @@ let SourceFileConstructor: new (kind: SyntaxKind, pos?: number, end?: number) =>
 /**
  * NOTE: You should not use this, it is only exported to support `createNode` in `~/src/deprecatedCompat/deprecations.ts`.
  */
-/* @internal */
+/** @internal */
 export const parseBaseNodeFactory: BaseNodeFactory = {
     createBaseSourceFileNode: kind => new (SourceFileConstructor || (SourceFileConstructor = objectAllocator.getSourceFileConstructor()))(kind, -1, -1),
     createBaseIdentifierNode: kind => new (IdentifierConstructor || (IdentifierConstructor = objectAllocator.getIdentifierConstructor()))(kind, -1, -1),
@@ -99,7 +99,7 @@ export const parseBaseNodeFactory: BaseNodeFactory = {
     createBaseNode: kind => new (NodeConstructor || (NodeConstructor = objectAllocator.getNodeConstructor()))(kind, -1, -1),
 };
 
-/* @internal */
+/** @internal */
 export const parseNodeFactory = createNodeFactory(NodeFactoryFlags.NoParenthesizerRules, parseBaseNodeFactory);
 
 function visitNode<T>(cbNode: (node: Node) => T, node: Node | undefined): T | undefined {
@@ -120,14 +120,14 @@ function visitNodes<T>(cbNode: (node: Node) => T, cbNodes: ((node: NodeArray<Nod
     }
 }
 
-/*@internal*/
+/** @internal */
 export function isJSDocLikeText(text: string, start: number) {
     return text.charCodeAt(start + 1) === CharacterCodes.asterisk &&
         text.charCodeAt(start + 2) === CharacterCodes.asterisk &&
         text.charCodeAt(start + 3) !== CharacterCodes.slash;
 }
 
-/*@internal*/
+/** @internal */
 export function isFileProbablyExternalModule(sourceFile: SourceFile) {
     // Try to use the first top-level import/export when available, then
     // fall back to looking for an 'import.meta' somewhere in the tree if necessary.
@@ -992,8 +992,8 @@ export interface CreateSourceFileOptions {
      * check specified by `isFileProbablyExternalModule` will be used to set the field.
      */
     setExternalModuleIndicator?: (file: SourceFile) => void;
-    /*@internal*/ packageJsonLocations?: readonly string[];
-    /*@internal*/ packageJsonScope?: PackageJsonInfo;
+    /** @internal */ packageJsonLocations?: readonly string[];
+    /** @internal */ packageJsonScope?: PackageJsonInfo;
 }
 
 function setExternalModuleIndicator(sourceFile: SourceFile) {
@@ -1064,7 +1064,7 @@ export function updateSourceFile(sourceFile: SourceFile, newText: string, textCh
     return newSourceFile;
 }
 
-/* @internal */
+/** @internal */
 export function parseIsolatedJSDocComment(content: string, start?: number, length?: number) {
     const result = Parser.JSDocParser.parseIsolatedJSDocComment(content, start, length);
     if (result && result.jsDoc) {
@@ -1076,7 +1076,7 @@ export function parseIsolatedJSDocComment(content: string, start?: number, lengt
     return result;
 }
 
-/* @internal */
+/** @internal */
 // Exposed only for testing.
 export function parseJSDocTypeExpressionForTests(content: string, start?: number, length?: number) {
     return Parser.JSDocParser.parseJSDocTypeExpressionForTests(content, start, length);
@@ -9771,7 +9771,7 @@ export function isDeclarationFileName(fileName: string): boolean {
     return fileExtensionIsOneOf(fileName, supportedDeclarationExtensions);
 }
 
-/*@internal*/
+/** @internal */
 export interface PragmaContext {
     languageVersion: ScriptTarget;
     pragmas?: PragmaMap;
@@ -9798,7 +9798,7 @@ function parseResolutionMode(mode: string | undefined, pos: number, end: number,
     return undefined;
 }
 
-/*@internal*/
+/** @internal */
 export function processCommentPragmas(context: PragmaContext, sourceText: string): void {
     const pragmas: PragmaPseudoMapEntry[] = [];
 
@@ -9823,10 +9823,10 @@ export function processCommentPragmas(context: PragmaContext, sourceText: string
     }
 }
 
-/*@internal*/
+/** @internal */
 type PragmaDiagnosticReporter = (pos: number, length: number, message: DiagnosticMessage) => void;
 
-/*@internal*/
+/** @internal */
 export function processPragmasIntoFields(context: PragmaContext, reportDiagnostic: PragmaDiagnosticReporter): void {
     context.checkJsDirective = undefined;
     context.referencedFiles = [];
diff --git a/src/compiler/performanceCore.ts b/src/compiler/performanceCore.ts
index 15d3c41994..4373319375 100644
--- a/src/compiler/performanceCore.ts
+++ b/src/compiler/performanceCore.ts
@@ -140,4 +140,4 @@ export function tryGetNativePerformanceHooks() {
 export const timestamp =
     nativePerformance ? () => nativePerformance.now() :
     Date.now ? Date.now :
-    () => +(new Date());
\ No newline at end of file
+    () => +(new Date());
diff --git a/src/compiler/program.ts b/src/compiler/program.ts
index f8c1cd3fa5..450976e0bb 100644
--- a/src/compiler/program.ts
+++ b/src/compiler/program.ts
@@ -73,7 +73,7 @@ export function resolveTripleslashReference(moduleName: string, containingFile:
     return normalizePath(referencedFileName);
 }
 
-/* @internal */
+/** @internal */
 export function computeCommonSourceDirectoryOfFilenames(fileNames: readonly string[], currentDirectory: string, getCanonicalFileName: GetCanonicalFileName): string {
     let commonPathComponents: string[] | undefined;
     const failed = forEach(fileNames, sourceFile => {
@@ -123,7 +123,7 @@ export function createCompilerHost(options: CompilerOptions, setParentNodes?: bo
     return createCompilerHostWorker(options, setParentNodes);
 }
 
-/*@internal*/
+/** @internal */
 export function createCompilerHostWorker(options: CompilerOptions, setParentNodes?: boolean, system = sys): CompilerHost {
     const existingDirectories = new Map<string, boolean>();
     const getCanonicalFileName = createGetCanonicalFileName(system.useCaseSensitiveFileNames);
@@ -209,7 +209,7 @@ export function createCompilerHostWorker(options: CompilerOptions, setParentNode
     return compilerHost;
 }
 
-/*@internal*/
+/** @internal */
 interface CompilerHostLikeForCache {
     fileExists(fileName: string): boolean;
     readFile(fileName: string, encoding?: string): string | undefined;
@@ -218,7 +218,7 @@ interface CompilerHostLikeForCache {
     writeFile?: WriteFileCallback;
 }
 
-/*@internal*/
+/** @internal */
 export function changeCompilerHostLikeToUseCache(
     host: CompilerHostLikeForCache,
     toPath: (fileName: string) => Path,
@@ -330,7 +330,7 @@ export function changeCompilerHostLikeToUseCache(
 }
 
 export function getPreEmitDiagnostics(program: Program, sourceFile?: SourceFile, cancellationToken?: CancellationToken): readonly Diagnostic[];
-/*@internal*/ export function getPreEmitDiagnostics(program: BuilderProgram, sourceFile?: SourceFile, cancellationToken?: CancellationToken): readonly Diagnostic[]; // eslint-disable-line @typescript-eslint/unified-signatures
+/** @internal */ export function getPreEmitDiagnostics(program: BuilderProgram, sourceFile?: SourceFile, cancellationToken?: CancellationToken): readonly Diagnostic[]; // eslint-disable-line @typescript-eslint/unified-signatures
 export function getPreEmitDiagnostics(program: Program | BuilderProgram, sourceFile?: SourceFile, cancellationToken?: CancellationToken): readonly Diagnostic[] {
     let diagnostics: Diagnostic[] | undefined;
     diagnostics = addRange(diagnostics, program.getConfigFileParsingDiagnostics());
@@ -456,7 +456,7 @@ function formatCodeSpan(file: SourceFile, start: number, length: number, indent:
     return context;
 }
 
-/* @internal */
+/** @internal */
 export function formatLocation(file: SourceFile, start: number, host: FormatDiagnosticsHost, color = formatColorAndReset) {
     const { line: firstLine, character: firstLineChar } = getLineAndCharacterOfPosition(file, start); // TODO: GH#18217
     const relativeFileName = host ? convertToRelativePath(file.fileName, host.getCurrentDirectory(), fileName => host.getCanonicalFileName(fileName)) : file.fileName;
@@ -529,7 +529,7 @@ export function flattenDiagnosticMessageText(diag: string | DiagnosticMessageCha
     return result;
 }
 
-/* @internal */
+/** @internal */
 export function loadWithTypeDirectiveCache<T>(names: string[] | readonly FileReference[], containingFile: string, redirectedReference: ResolvedProjectReference | undefined, containingFileMode: SourceFile["impliedNodeFormat"], loader: (name: string, containingFile: string, redirectedReference: ResolvedProjectReference | undefined, resolutionMode: SourceFile["impliedNodeFormat"]) => T): T[] {
     if (names.length === 0) {
         return [];
@@ -561,8 +561,8 @@ export function loadWithTypeDirectiveCache<T>(names: string[] | readonly FileRef
  * @internal
  */
 export interface SourceFileImportsList {
-    /* @internal */ imports: SourceFile["imports"];
-    /* @internal */ moduleAugmentations: SourceFile["moduleAugmentations"];
+    /** @internal */ imports: SourceFile["imports"];
+    /** @internal */ moduleAugmentations: SourceFile["moduleAugmentations"];
     impliedNodeFormat?: SourceFile["impliedNodeFormat"];
 };
 
@@ -592,7 +592,7 @@ export function getModeForResolutionAtIndex(file: SourceFileImportsList, index:
     return getModeForUsageLocation(file, getModuleNameStringLiteralAt(file, index));
 }
 
-/* @internal */
+/** @internal */
 export function isExclusivelyTypeOnlyImportOrExport(decl: ImportDeclaration | ExportDeclaration) {
     if (isExportDeclaration(decl)) {
         return decl.isTypeOnly;
@@ -639,7 +639,7 @@ export function getModeForUsageLocation(file: {impliedNodeFormat?: SourceFile["i
     return exprParentParent && isImportEqualsDeclaration(exprParentParent) ? ModuleKind.CommonJS : ModuleKind.ESNext;
 }
 
-/* @internal */
+/** @internal */
 export function getResolutionModeOverrideForClause(clause: AssertClause | undefined, grammarErrorOnNode?: (node: Node, diagnostic: DiagnosticMessage) => void) {
     if (!clause) return undefined;
     if (length(clause.elements) !== 1) {
@@ -660,7 +660,7 @@ export function getResolutionModeOverrideForClause(clause: AssertClause | undefi
     return elem.value.text === "import" ? ModuleKind.ESNext : ModuleKind.CommonJS;
 }
 
-/* @internal */
+/** @internal */
 export function loadWithModeAwareCache<T>(names: string[], containingFile: SourceFile, containingFileName: string, redirectedReference: ResolvedProjectReference | undefined, loader: (name: string, resolverMode: ModuleKind.CommonJS | ModuleKind.ESNext | undefined, containingFileName: string, redirectedReference: ResolvedProjectReference | undefined) => T): T[] {
     if (names.length === 0) {
         return [];
@@ -684,7 +684,7 @@ export function loadWithModeAwareCache<T>(names: string[], containingFile: Sourc
     return resolutions;
 }
 
-/* @internal */
+/** @internal */
 export function forEachResolvedProjectReference<T>(
     resolvedProjectReferences: readonly (ResolvedProjectReference | undefined)[] | undefined,
     cb: (resolvedProjectReference: ResolvedProjectReference, parent: ResolvedProjectReference | undefined) => T | undefined
@@ -729,7 +729,7 @@ function forEachProjectReference<T>(
     }
 }
 
-/* @internal */
+/** @internal */
 export const inferredTypesContainingFile = "__inferred type names__.ts";
 
 interface DiagnosticCache<T extends Diagnostic> {
@@ -737,7 +737,7 @@ interface DiagnosticCache<T extends Diagnostic> {
     allDiagnostics?: readonly T[];
 }
 
-/*@internal*/
+/** @internal */
 export function isReferencedFile(reason: FileIncludeReason | undefined): reason is ReferencedFile {
     switch (reason?.kind) {
         case FileIncludeKind.Import:
@@ -750,7 +750,7 @@ export function isReferencedFile(reason: FileIncludeReason | undefined): reason
     }
 }
 
-/*@internal*/
+/** @internal */
 export interface ReferenceFileLocation {
     file: SourceFile;
     pos: number;
@@ -758,19 +758,19 @@ export interface ReferenceFileLocation {
     packageId: PackageId | undefined;
 }
 
-/*@internal*/
+/** @internal */
 export interface SyntheticReferenceFileLocation {
     file: SourceFile;
     packageId: PackageId | undefined;
     text: string;
 }
 
-/*@internal*/
+/** @internal */
 export function isReferenceFileLocation(location: ReferenceFileLocation | SyntheticReferenceFileLocation): location is ReferenceFileLocation {
     return (location as ReferenceFileLocation).pos !== undefined;
 }
 
-/*@internal*/
+/** @internal */
 export function getReferencedFileLocation(getSourceFileByPath: (path: Path) => SourceFile | undefined, ref: ReferencedFile): ReferenceFileLocation | SyntheticReferenceFileLocation {
     const file = Debug.checkDefined(getSourceFileByPath(ref.file));
     const { kind, index } = ref;
@@ -802,7 +802,7 @@ export function getReferencedFileLocation(getSourceFileByPath: (path: Path) => S
 /**
  * Determines if program structure is upto date or needs to be recreated
  */
-/* @internal */
+/** @internal */
 export function isProgramUptoDate(
     program: Program | undefined,
     rootFileNames: string[],
@@ -908,7 +908,7 @@ export function getImpliedNodeFormatForFile(fileName: Path, packageJsonInfoCache
     return typeof result === "object" ? result.impliedNodeFormat : result;
 }
 
-/*@internal*/
+/** @internal */
 export function getImpliedNodeFormatForFileWorker(
     fileName: Path,
     packageJsonInfoCache: PackageJsonInfoCache | undefined,
@@ -4264,10 +4264,10 @@ function updateHostForUseSourceOfProjectReferenceRedirect(host: HostForUseSource
     }
 }
 
-/*@internal*/
+/** @internal */
 export const emitSkippedWithNoDiagnostics: EmitResult = { diagnostics: emptyArray, sourceMaps: undefined, emittedFiles: undefined, emitSkipped: true };
 
-/*@internal*/
+/** @internal */
 export function handleNoEmitOptions<T extends BuilderProgram>(
     program: Program | T,
     sourceFile: SourceFile | undefined,
@@ -4308,12 +4308,12 @@ export function handleNoEmitOptions<T extends BuilderProgram>(
     return { diagnostics, sourceMaps: undefined, emittedFiles, emitSkipped: true };
 }
 
-/*@internal*/
+/** @internal */
 export function filterSemanticDiagnostics(diagnostic: readonly Diagnostic[], option: CompilerOptions): readonly Diagnostic[] {
     return filter(diagnostic, d => !d.skippedOn || !option[d.skippedOn]);
 }
 
-/*@internal*/
+/** @internal */
 interface CompilerHostLike {
     useCaseSensitiveFileNames(): boolean;
     getCurrentDirectory(): string;
@@ -4324,7 +4324,7 @@ interface CompilerHostLike {
     onUnRecoverableConfigFileDiagnostic?: DiagnosticReporter;
 }
 
-/* @internal */
+/** @internal */
 export function parseConfigHostFromCompilerHostLike(host: CompilerHostLike, directoryStructureHost: DirectoryStructureHost = host): ParseConfigFileHost {
     return {
         fileExists: f => directoryStructureHost.fileExists(f),
@@ -4345,7 +4345,7 @@ export function parseConfigHostFromCompilerHostLike(host: CompilerHostLike, dire
     fileExists(fileName: string): boolean;
 }
 
-/* @internal */
+/** @internal */
 export function createPrependNodes(projectReferences: readonly ProjectReference[] | undefined, getCommandLine: (ref: ProjectReference, index: number) => ParsedCommandLine | undefined, readFile: (path: string) => string | undefined) {
     if (!projectReferences) return emptyArray;
     let nodes: InputFiles[] | undefined;
@@ -4375,7 +4375,7 @@ export function resolveProjectReferencePath(hostOrRef: ResolveProjectReferencePa
     return resolveConfigFileProjectName(passedInRef.path);
 }
 
-/* @internal */
+/** @internal */
 /**
  * Returns a DiagnosticMessage if we won't include a resolved module due to its extension.
  * The DiagnosticMessage's parameters are the imported module name, and the filename it resolved to.
@@ -4419,7 +4419,7 @@ function getModuleNames({ imports, moduleAugmentations }: SourceFile): string[]
     return res;
 }
 
-/* @internal */
+/** @internal */
 export function getModuleNameStringLiteralAt({ imports, moduleAugmentations }: SourceFileImportsList, index: number): StringLiteralLike {
     if (index < imports.length) return imports[index];
     let augIndex = imports.length;
diff --git a/src/compiler/scanner.ts b/src/compiler/scanner.ts
index 41d210dcb7..d65dd69daf 100644
--- a/src/compiler/scanner.ts
+++ b/src/compiler/scanner.ts
@@ -7,12 +7,12 @@ import {
 
 export type ErrorCallback = (message: DiagnosticMessage, length: number) => void;
 
-/* @internal */
+/** @internal */
 export function tokenIsIdentifierOrKeyword(token: SyntaxKind): boolean {
     return token >= SyntaxKind.Identifier;
 }
 
-/* @internal */
+/** @internal */
 export function tokenIsIdentifierOrKeywordOrGreaterThan(token: SyntaxKind): boolean {
     return token === SyntaxKind.GreaterThanToken || tokenIsIdentifierOrKeyword(token);
 }
@@ -27,16 +27,16 @@ export interface Scanner {
     hasUnicodeEscape(): boolean;
     hasExtendedUnicodeEscape(): boolean;
     hasPrecedingLineBreak(): boolean;
-    /* @internal */
+    /** @internal */
     hasPrecedingJSDocComment(): boolean;
     isIdentifier(): boolean;
     isReservedWord(): boolean;
     isUnterminated(): boolean;
-    /* @internal */
+    /** @internal */
     getNumericLiteralFlags(): TokenFlags;
-    /* @internal */
+    /** @internal */
     getCommentDirectives(): CommentDirective[] | undefined;
-    /* @internal */
+    /** @internal */
     getTokenFlags(): TokenFlags;
     reScanGreaterToken(): SyntaxKind;
     reScanSlashToken(): SyntaxKind;
@@ -56,7 +56,7 @@ export interface Scanner {
     scan(): SyntaxKind;
 
     getText(): string;
-    /* @internal */
+    /** @internal */
     clearCommentDirectives(): void;
     // Sets the text for the scanner to scan.  An optional subrange starting point and length
     // can be provided to have the scanner only scan a portion of the text.
@@ -65,7 +65,7 @@ export interface Scanner {
     setScriptTarget(scriptTarget: ScriptTarget): void;
     setLanguageVariant(variant: LanguageVariant): void;
     setTextPos(textPos: number): void;
-    /* @internal */
+    /** @internal */
     setInJSDocType(inType: boolean): void;
     // Invokes the provided callback then unconditionally restores the scanner to the state it
     // was in immediately prior to invoking the callback.  The result of invoking the callback
@@ -332,7 +332,7 @@ function lookupInUnicodeMap(code: number, map: readonly number[]): boolean {
     return false;
 }
 
-/* @internal */ export function isUnicodeIdentifierStart(code: number, languageVersion: ScriptTarget | undefined) {
+/** @internal */ export function isUnicodeIdentifierStart(code: number, languageVersion: ScriptTarget | undefined) {
     return languageVersion! >= ScriptTarget.ES2015 ?
         lookupInUnicodeMap(code, unicodeESNextIdentifierStart) :
         languageVersion === ScriptTarget.ES5 ? lookupInUnicodeMap(code, unicodeES5IdentifierStart) :
@@ -359,12 +359,12 @@ export function tokenToString(t: SyntaxKind): string | undefined {
     return tokenStrings[t];
 }
 
-/* @internal */
+/** @internal */
 export function stringToToken(s: string): SyntaxKind | undefined {
     return textToToken.get(s);
 }
 
-/* @internal */
+/** @internal */
 export function computeLineStarts(text: string): number[] {
     const result: number[] = new Array();
     let pos = 0;
@@ -395,7 +395,7 @@ export function computeLineStarts(text: string): number[] {
 }
 
 export function getPositionOfLineAndCharacter(sourceFile: SourceFileLike, line: number, character: number): number;
-/* @internal */
+/** @internal */
 export function getPositionOfLineAndCharacter(sourceFile: SourceFileLike, line: number, character: number, allowEdits?: true): number; // eslint-disable-line @typescript-eslint/unified-signatures
 export function getPositionOfLineAndCharacter(sourceFile: SourceFileLike, line: number, character: number, allowEdits?: true): number {
     return sourceFile.getPositionOfLineAndCharacter ?
@@ -403,7 +403,7 @@ export function getPositionOfLineAndCharacter(sourceFile: SourceFileLike, line:
         computePositionOfLineAndCharacter(getLineStarts(sourceFile), line, character, sourceFile.text, allowEdits);
 }
 
-/* @internal */
+/** @internal */
 export function computePositionOfLineAndCharacter(lineStarts: readonly number[], line: number, character: number, debugText?: string, allowEdits?: true): number {
     if (line < 0 || line >= lineStarts.length) {
         if (allowEdits) {
@@ -431,12 +431,12 @@ export function computePositionOfLineAndCharacter(lineStarts: readonly number[],
     return res;
 }
 
-/* @internal */
+/** @internal */
 export function getLineStarts(sourceFile: SourceFileLike): readonly number[] {
     return sourceFile.lineMap || (sourceFile.lineMap = computeLineStarts(sourceFile.text));
 }
 
-/* @internal */
+/** @internal */
 export function computeLineAndCharacterOfPosition(lineStarts: readonly number[], position: number): LineAndCharacter {
     const lineNumber = computeLineOfPosition(lineStarts, position);
     return {
@@ -533,7 +533,7 @@ function isCodePoint(code: number): boolean {
     return code <= 0x10FFFF;
 }
 
-/* @internal */
+/** @internal */
 export function isOctalDigit(ch: number): boolean {
     return ch >= CharacterCodes._0 && ch <= CharacterCodes._7;
 }
@@ -565,7 +565,7 @@ export function couldStartTrivia(text: string, pos: number): boolean {
     }
 }
 
-/* @internal */
+/** @internal */
 export function skipTrivia(text: string, pos: number, stopAfterLineBreak?: boolean, stopAtComments?: boolean, inJSDoc?: boolean): number {
     if (positionIsSynthesized(pos)) {
         return pos;
@@ -719,14 +719,14 @@ function scanConflictMarkerTrivia(text: string, pos: number, error?: (diag: Diag
 
 const shebangTriviaRegex = /^#!.*/;
 
-/*@internal*/
+/** @internal */
 export function isShebangTrivia(text: string, pos: number) {
     // Shebangs check must only be done at the start of the file
     Debug.assert(pos === 0);
     return shebangTriviaRegex.test(text);
 }
 
-/*@internal*/
+/** @internal */
 export function scanShebangTrivia(text: string, pos: number) {
     const shebang = shebangTriviaRegex.exec(text)![0];
     pos = pos + shebang.length;
@@ -917,7 +917,7 @@ export function isIdentifierPart(ch: number, languageVersion: ScriptTarget | und
         ch > CharacterCodes.maxAsciiCharacter && isUnicodeIdentifierPart(ch, languageVersion);
 }
 
-/* @internal */
+/** @internal */
 export function isIdentifierText(name: string, languageVersion: ScriptTarget | undefined, identifierVariant?: LanguageVariant): boolean {
     let ch = codePointAt(name, 0);
     if (!isIdentifierStart(ch, languageVersion)) {
@@ -2589,7 +2589,7 @@ export function createScanner(languageVersion: ScriptTarget,
     }
 }
 
-/* @internal */
+/** @internal */
 const codePointAt: (s: string, i: number) => number = (String.prototype as any).codePointAt ? (s, i) => (s as any).codePointAt(i) : function codePointAt(str, i): number {
     // from https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/String/codePointAt
     const size = str.length;
@@ -2610,7 +2610,7 @@ const codePointAt: (s: string, i: number) => number = (String.prototype as any).
     return first;
 };
 
-/* @internal */
+/** @internal */
 function charSize(ch: number) {
     if (ch >= 0x10000) {
         return 2;
@@ -2634,7 +2634,7 @@ function utf16EncodeAsStringFallback(codePoint: number) {
 
 const utf16EncodeAsStringWorker: (codePoint: number) => string = (String as any).fromCodePoint ? codePoint => (String as any).fromCodePoint(codePoint) : utf16EncodeAsStringFallback;
 
-/* @internal */
+/** @internal */
 export function utf16EncodeAsString(codePoint: number) {
     return utf16EncodeAsStringWorker(codePoint);
 }
diff --git a/src/compiler/symbolWalker.ts b/src/compiler/symbolWalker.ts
index 905443939f..9a500caf05 100644
--- a/src/compiler/symbolWalker.ts
+++ b/src/compiler/symbolWalker.ts
@@ -193,4 +193,4 @@ export function createGetSymbolWalker(
             return false;
         }
     }
-}
\ No newline at end of file
+}
diff --git a/src/compiler/sys.ts b/src/compiler/sys.ts
index baf41cb437..771f33162d 100644
--- a/src/compiler/sys.ts
+++ b/src/compiler/sys.ts
@@ -16,7 +16,7 @@ declare function clearTimeout(handle: any): void;
  * djb2 hashing algorithm
  * http://www.cse.yorku.ca/~oz/hash.html
  */
-/* @internal */
+/** @internal */
 export function generateDjb2Hash(data: string): string {
     let acc = 5381;
     for (let i = 0; i < data.length; i++) {
@@ -30,7 +30,7 @@ export function generateDjb2Hash(data: string): string {
  * Called for command-line and server use cases.
  * Not called if TypeScript is used as a library.
  */
-/* @internal */
+/** @internal */
 export function setStackTraceLimit() {
     if ((Error as any).stackTraceLimit < 100) { // Also tests that we won't set the property if it doesn't exist.
         (Error as any).stackTraceLimit = 100;
@@ -45,29 +45,29 @@ export enum FileWatcherEventKind {
 
 export type FileWatcherCallback = (fileName: string, eventKind: FileWatcherEventKind, modifiedTime?: Date) => void;
 export type DirectoryWatcherCallback = (fileName: string) => void;
-/*@internal*/
+/** @internal */
 export interface WatchedFile {
     readonly fileName: string;
     readonly callback: FileWatcherCallback;
     mtime: Date;
 }
 
-/* @internal */
+/** @internal */
 export enum PollingInterval {
     High = 2000,
     Medium = 500,
     Low = 250
 }
 
-/* @internal */
+/** @internal */
 export type HostWatchFile = (fileName: string, callback: FileWatcherCallback, pollingInterval: PollingInterval, options: WatchOptions | undefined) => FileWatcher;
-/* @internal */
+/** @internal */
 export type HostWatchDirectory = (fileName: string, callback: DirectoryWatcherCallback, recursive: boolean, options: WatchOptions | undefined) => FileWatcher;
 
-/* @internal */
+/** @internal */
 export const missingFileModifiedTime = new Date(0); // Any subsequent modification will occur after this time
 
-/* @internal */
+/** @internal */
 export function getModifiedTime(host: { getModifiedTime: NonNullable<System["getModifiedTime"]>; }, fileName: string) {
     return host.getModifiedTime(fileName) || missingFileModifiedTime;
 }
@@ -88,10 +88,10 @@ function createPollingIntervalBasedLevels(levels: Levels) {
 
 const defaultChunkLevels: Levels = { Low: 32, Medium: 64, High: 256 };
 let pollingChunkSize = createPollingIntervalBasedLevels(defaultChunkLevels);
-/* @internal */
+/** @internal */
 export let unchangedPollThresholds = createPollingIntervalBasedLevels(defaultChunkLevels);
 
-/* @internal */
+/** @internal */
 export function setCustomPollingValues(system: System) {
     if (!system.getEnvironmentVariable) {
         return;
@@ -199,7 +199,7 @@ function pollWatchedFileQueue<T extends WatchedFileWithIsClosed>(
     }
 }
 
-/* @internal */
+/** @internal */
 export function createDynamicPriorityPollingWatchFile(host: {
     getModifiedTime: NonNullable<System["getModifiedTime"]>;
     setTimeout: NonNullable<System["setTimeout"]>;
@@ -433,7 +433,7 @@ function createFixedChunkSizePollingWatchFile(host: {
     }
 }
 
-/* @internal */
+/** @internal */
 export function createSingleFileWatcherPerName(
     watchFile: HostWatchFile,
     useCaseSensitiveFileNames: boolean
@@ -484,7 +484,7 @@ export function createSingleFileWatcherPerName(
 /**
  * Returns true if file status changed
  */
-/*@internal*/
+/** @internal */
 export function onWatchedFileStat(watchedFile: WatchedFile, modifiedTime: Date): boolean {
     const oldTime = watchedFile.mtime.getTime();
     const newTime = modifiedTime.getTime();
@@ -498,7 +498,7 @@ export function onWatchedFileStat(watchedFile: WatchedFile, modifiedTime: Date):
     return false;
 }
 
-/*@internal*/
+/** @internal */
 export function getFileWatcherEventKind(oldTime: number, newTime: number) {
     return oldTime === 0
         ? FileWatcherEventKind.Created
@@ -507,22 +507,22 @@ export function getFileWatcherEventKind(oldTime: number, newTime: number) {
             : FileWatcherEventKind.Changed;
 }
 
-/*@internal*/
+/** @internal */
 export const ignoredPaths = ["/node_modules/.", "/.git", "/.#"];
 
 let curSysLog: (s: string) => void = noop; // eslint-disable-line prefer-const
 
-/*@internal*/
+/** @internal */
 export function sysLog(s: string) {
     return curSysLog(s);
 }
 
-/*@internal*/
+/** @internal */
 export function setSysLog(logger: typeof sysLog) {
     curSysLog = logger;
 }
 
-/*@internal*/
+/** @internal */
 export interface RecursiveDirectoryWatcherHost {
     watchDirectory: HostWatchDirectory;
     useCaseSensitiveFileNames: boolean;
@@ -539,7 +539,7 @@ export interface RecursiveDirectoryWatcherHost {
  * that means if this is recursive watcher, watch the children directories as well
  * (eg on OS that dont support recursive watch using fs.watch use fs.watchFile)
  */
-/*@internal*/
+/** @internal */
 export function createDirectoryWatcherSupportingRecursive({
     watchDirectory,
     useCaseSensitiveFileNames,
@@ -786,23 +786,23 @@ export function createDirectoryWatcherSupportingRecursive({
     }
 }
 
-/*@internal*/
+/** @internal */
 export type FsWatchCallback = (eventName: "rename" | "change", relativeFileName: string | undefined, modifiedTime?: Date) => void;
-/*@internal*/
+/** @internal */
 export type FsWatch = (fileOrDirectory: string, entryKind: FileSystemEntryKind, callback: FsWatchCallback, recursive: boolean, fallbackPollingInterval: PollingInterval, fallbackOptions: WatchOptions | undefined) => FileWatcher;
-/*@internal*/
+/** @internal */
 export interface FsWatchWorkerWatcher extends FileWatcher {
     on(eventName: string, listener: () => void): void;
 }
-/*@internal*/
+/** @internal */
 export type FsWatchWorker = (fileOrDirectory: string, recursive: boolean, callback: FsWatchCallback) => FsWatchWorkerWatcher;
-/*@internal*/
+/** @internal */
 export const enum FileSystemEntryKind {
     File,
     Directory,
 }
 
-/*@internal*/
+/** @internal */
 export function createFileWatcherCallback(callback: FsWatchCallback): FileWatcherCallback {
     return (_fileName, eventKind, modifiedTime) => callback(eventKind === FileWatcherEventKind.Changed ? "change" : "rename", "", modifiedTime);
 }
@@ -858,10 +858,10 @@ function createFsWatchCallbackForDirectoryWatcherCallback(
     };
 }
 
-/*@internal*/
+/** @internal */
 export type FileSystemEntryExists = (fileorDirectrory: string, entryKind: FileSystemEntryKind) => boolean;
 
-/*@internal*/
+/** @internal */
 export interface CreateSystemWatchFunctions {
     // Polling watch file
     pollingWatchFile: HostWatchFile;
@@ -886,7 +886,7 @@ export interface CreateSystemWatchFunctions {
     sysLog: (s: string) => void;
 }
 
-/*@internal*/
+/** @internal */
 export function createSystemWatchFunctions({
     pollingWatchFile,
     getModifiedTime,
@@ -1230,7 +1230,7 @@ export function createSystemWatchFunctions({
 /**
  * patch writefile to create folder before writing the file
  */
-/*@internal*/
+/** @internal */
 export function patchWriteFileEnsuringDirectory(sys: System) {
     // patch writefile to create folder before writing the file
     const originalWriteFile = sys.writeFile;
@@ -1244,10 +1244,10 @@ export function patchWriteFileEnsuringDirectory(sys: System) {
             path => sys.directoryExists(path));
 }
 
-/*@internal*/
+/** @internal */
 export type BufferEncoding = "ascii" | "utf8" | "utf-8" | "utf16le" | "ucs2" | "ucs-2" | "base64" | "latin1" | "binary" | "hex";
 
-/*@internal*/
+/** @internal */
 interface NodeBuffer extends Uint8Array {
     constructor: any;
     write(str: string, encoding?: BufferEncoding): number;
@@ -1323,7 +1323,7 @@ interface NodeBuffer extends Uint8Array {
     values(): IterableIterator<number>;
 }
 
-/*@internal*/
+/** @internal */
 interface Buffer extends NodeBuffer { }
 
 // TODO: GH#18217 Methods on System are often used as if they are certainly defined
@@ -1363,27 +1363,27 @@ export interface System {
     createSHA256Hash?(data: string): string;
     getMemoryUsage?(): number;
     exit(exitCode?: number): void;
-    /*@internal*/ enableCPUProfiler?(path: string, continuation: () => void): boolean;
-    /*@internal*/ disableCPUProfiler?(continuation: () => void): boolean;
-    /*@internal*/ cpuProfilingEnabled?(): boolean;
+    /** @internal */ enableCPUProfiler?(path: string, continuation: () => void): boolean;
+    /** @internal */ disableCPUProfiler?(continuation: () => void): boolean;
+    /** @internal */ cpuProfilingEnabled?(): boolean;
     realpath?(path: string): string;
-    /*@internal*/ getEnvironmentVariable(name: string): string;
-    /*@internal*/ tryEnableSourceMapsForHost?(): void;
-    /*@internal*/ debugMode?: boolean;
+    /** @internal */ getEnvironmentVariable(name: string): string;
+    /** @internal */ tryEnableSourceMapsForHost?(): void;
+    /** @internal */ debugMode?: boolean;
     setTimeout?(callback: (...args: any[]) => void, ms: number, ...args: any[]): any;
     clearTimeout?(timeoutId: any): void;
     clearScreen?(): void;
-    /*@internal*/ setBlocking?(): void;
+    /** @internal */ setBlocking?(): void;
     base64decode?(input: string): string;
     base64encode?(input: string): string;
-    /*@internal*/ bufferFrom?(input: string, encoding?: string): Buffer;
-    /*@internal*/ require?(baseDir: string, moduleName: string): RequireResult;
-    /*@internal*/ defaultWatchFileKind?(): WatchFileKind | undefined;
+    /** @internal */ bufferFrom?(input: string, encoding?: string): Buffer;
+    /** @internal */ require?(baseDir: string, moduleName: string): RequireResult;
+    /** @internal */ defaultWatchFileKind?(): WatchFileKind | undefined;
 
     // For testing
-    /*@internal*/ now?(): Date;
-    /*@internal*/ disableUseFileVersionAsSignature?: boolean;
-    /*@internal*/ storeFilesChangingSignatureDuringEmit?: boolean;
+    /** @internal */ now?(): Date;
+    /** @internal */ disableUseFileVersionAsSignature?: boolean;
+    /** @internal */ storeFilesChangingSignatureDuringEmit?: boolean;
 }
 
 export interface FileWatcher {
@@ -1973,7 +1973,7 @@ export let sys: System = (() => {
     return sys!;
 })();
 
-/*@internal*/
+/** @internal */
 export function setSys(s: System) {
     sys = s;
 }
diff --git a/src/compiler/transformers/declarations.ts b/src/compiler/transformers/declarations.ts
index a1f5bf41b1..bcb8114d28 100644
--- a/src/compiler/transformers/declarations.ts
+++ b/src/compiler/transformers/declarations.ts
@@ -62,7 +62,7 @@ export function isInternalDeclaration(node: Node, currentSourceFile: SourceFile)
         const commentRanges = previousSibling
             ? concatenate(
                 // to handle
-                // ... parameters, /* @internal */
+                // ... parameters, /** @internal */
                 // public param: string
                 getTrailingCommentRanges(text, skipTrivia(text, previousSibling.end + 1, /* stopAfterLineBreak */ false, /* stopAtComments */ true)),
                 getLeadingCommentRanges(text, node.pos)
diff --git a/src/compiler/transformers/legacyDecorators.ts b/src/compiler/transformers/legacyDecorators.ts
index 161ba925c9..d84b6ffb21 100644
--- a/src/compiler/transformers/legacyDecorators.ts
+++ b/src/compiler/transformers/legacyDecorators.ts
@@ -719,4 +719,4 @@ export function transformLegacyDecorators(context: TransformationContext) {
 
         return undefined;
     }
-}
\ No newline at end of file
+}
diff --git a/src/compiler/transformers/typeSerializer.ts b/src/compiler/transformers/typeSerializer.ts
index cd06f183cb..7548d159c5 100644
--- a/src/compiler/transformers/typeSerializer.ts
+++ b/src/compiler/transformers/typeSerializer.ts
@@ -586,4 +586,4 @@ export function createRuntimeTypeSerializer(context: TransformationContext): Run
             getGlobalConstructorWithFallback(name) :
             factory.createIdentifier(name);
     }
-}
\ No newline at end of file
+}
diff --git a/src/compiler/tsbuild.ts b/src/compiler/tsbuild.ts
index ad20ff97b4..a927555fbe 100644
--- a/src/compiler/tsbuild.ts
+++ b/src/compiler/tsbuild.ts
@@ -174,4 +174,4 @@ export function resolveConfigFileProjectName(project: string): ResolvedConfigFil
     }
 
     return combinePaths(project, "tsconfig.json") as ResolvedConfigFileName;
-}
\ No newline at end of file
+}
diff --git a/src/compiler/tsbuildPublic.ts b/src/compiler/tsbuildPublic.ts
index a178952c1f..e425f9918d 100644
--- a/src/compiler/tsbuildPublic.ts
+++ b/src/compiler/tsbuildPublic.ts
@@ -37,24 +37,24 @@ export interface BuildOptions {
     force?: boolean;
     verbose?: boolean;
 
-    /*@internal*/ clean?: boolean;
-    /*@internal*/ watch?: boolean;
-    /*@internal*/ help?: boolean;
-
-    /*@internal*/ preserveWatchOutput?: boolean;
-    /*@internal*/ listEmittedFiles?: boolean;
-    /*@internal*/ listFiles?: boolean;
-    /*@internal*/ explainFiles?: boolean;
-    /*@internal*/ pretty?: boolean;
+    /** @internal */ clean?: boolean;
+    /** @internal */ watch?: boolean;
+    /** @internal */ help?: boolean;
+
+    /** @internal */ preserveWatchOutput?: boolean;
+    /** @internal */ listEmittedFiles?: boolean;
+    /** @internal */ listFiles?: boolean;
+    /** @internal */ explainFiles?: boolean;
+    /** @internal */ pretty?: boolean;
     incremental?: boolean;
     assumeChangesOnlyAffectDirectDependencies?: boolean;
 
     traceResolution?: boolean;
-    /* @internal */ diagnostics?: boolean;
-    /* @internal */ extendedDiagnostics?: boolean;
-    /* @internal */ locale?: string;
-    /* @internal */ generateCpuProfile?: string;
-    /* @internal */ generateTrace?: string;
+    /** @internal */ diagnostics?: boolean;
+    /** @internal */ extendedDiagnostics?: boolean;
+    /** @internal */ locale?: string;
+    /** @internal */ generateCpuProfile?: string;
+    /** @internal */ generateTrace?: string;
 
     [option: string]: CompilerOptionsValue | undefined;
 }
@@ -81,7 +81,7 @@ enum BuildResultFlags {
     AnyErrors = ConfigFileErrors | SyntaxErrors | TypeErrors | DeclarationEmitErrors | EmitErrors
 }
 
-/*@internal*/
+/** @internal */
 export type ResolvedConfigFilePath = ResolvedConfigFileName & Path;
 
 function getOrCreateValueFromConfigFileMap<T>(configFileMap: ESMap<ResolvedConfigFilePath, T>, resolved: ResolvedConfigFilePath, createT: () => T): T {
@@ -98,7 +98,7 @@ function getOrCreateValueMapFromConfigFileMap<K extends string, V>(configFileMap
     return getOrCreateValueFromConfigFileMap(configFileMap, resolved, () => new Map());
 }
 
-/*@internal*/
+/** @internal */
 /** Helper to use now method instead of current date for testing purposes to get consistent baselines */
 export function getCurrentTime(host: { now?(): Date; }) {
     return host.now ? host.now() : new Date();
@@ -131,10 +131,10 @@ export interface SolutionBuilderHostBase<T extends BuilderProgram> extends Progr
     // TODO: To do better with watch mode and normal build mode api that creates program and emits files
     // This currently helps enable --diagnostics and --extendedDiagnostics
     afterProgramEmitAndDiagnostics?(program: T): void;
-    /*@internal*/ afterEmitBundle?(config: ParsedCommandLine): void;
+    /** @internal */ afterEmitBundle?(config: ParsedCommandLine): void;
 
     // For testing
-    /*@internal*/ now?(): Date;
+    /** @internal */ now?(): Date;
 }
 
 export interface SolutionBuilderHost<T extends BuilderProgram> extends SolutionBuilderHostBase<T> {
@@ -144,22 +144,22 @@ export interface SolutionBuilderHost<T extends BuilderProgram> extends SolutionB
 export interface SolutionBuilderWithWatchHost<T extends BuilderProgram> extends SolutionBuilderHostBase<T>, WatchHost {
 }
 
-/*@internal*/
+/** @internal */
 export type BuildOrder = readonly ResolvedConfigFileName[];
-/*@internal*/
+/** @internal */
 export interface CircularBuildOrder {
     buildOrder: BuildOrder;
     circularDiagnostics: readonly Diagnostic[];
 }
-/*@internal*/
+/** @internal */
 export type AnyBuildOrder = BuildOrder | CircularBuildOrder;
 
-/*@internal*/
+/** @internal */
 export function isCircularBuildOrder(buildOrder: AnyBuildOrder): buildOrder is CircularBuildOrder {
     return !!buildOrder && !!(buildOrder as CircularBuildOrder).buildOrder;
 }
 
-/*@internal*/
+/** @internal */
 export function getBuildOrderFromAnyBuildOrder(anyBuildOrder: AnyBuildOrder): BuildOrder {
     return isCircularBuildOrder(anyBuildOrder) ? anyBuildOrder.buildOrder : anyBuildOrder;
 }
@@ -172,12 +172,12 @@ export interface SolutionBuilder<T extends BuilderProgram> {
     getNextInvalidatedProject(cancellationToken?: CancellationToken): InvalidatedProject<T> | undefined;
 
     // Currently used for testing but can be made public if needed:
-    /*@internal*/ getBuildOrder(): AnyBuildOrder;
+    /** @internal */ getBuildOrder(): AnyBuildOrder;
 
     // Testing only
-    /*@internal*/ getUpToDateStatusOfProject(project: string): UpToDateStatus;
-    /*@internal*/ invalidateProject(configFilePath: ResolvedConfigFilePath, reloadLevel?: ConfigFileProgramReloadLevel): void;
-    /*@internal*/ close(): void;
+    /** @internal */ getUpToDateStatusOfProject(project: string): UpToDateStatus;
+    /** @internal */ invalidateProject(configFilePath: ResolvedConfigFilePath, reloadLevel?: ConfigFileProgramReloadLevel): void;
+    /** @internal */ close(): void;
 }
 
 /**
@@ -682,8 +682,8 @@ export enum InvalidatedProjectKind {
 export interface InvalidatedProjectBase {
     readonly kind: InvalidatedProjectKind;
     readonly project: ResolvedConfigFileName;
-    /*@internal*/ readonly projectPath: ResolvedConfigFilePath;
-    /*@internal*/ readonly buildOrder: readonly ResolvedConfigFileName[];
+    /** @internal */ readonly projectPath: ResolvedConfigFilePath;
+    /** @internal */ readonly buildOrder: readonly ResolvedConfigFileName[];
     /**
      *  To dispose this project and ensure that all the necessary actions are taken and state is updated accordingly
      */
diff --git a/src/compiler/types.ts b/src/compiler/types.ts
index bacca961cf..e1adae934b 100644
--- a/src/compiler/types.ts
+++ b/src/compiler/types.ts
@@ -8,7 +8,7 @@ import {
 // arbitrary file name can be converted to Path via toPath function
 export type Path = string & { __pathBrand: any };
 
-/* @internal */
+/** @internal */
 export type MatchingKeys<TRecord, TMatch, K extends keyof TRecord = keyof TRecord> = K extends (TRecord[K] extends TMatch ? K : never) ? K : never;
 
 export interface TextRange {
@@ -463,8 +463,8 @@ export const enum SyntaxKind {
     LastJSDocNode = JSDocPropertyTag,
     FirstJSDocTagNode = JSDocTag,
     LastJSDocTagNode = JSDocPropertyTag,
-    /* @internal */ FirstContextualKeyword = AbstractKeyword,
-    /* @internal */ LastContextualKeyword = OfKeyword,
+    /** @internal */ FirstContextualKeyword = AbstractKeyword,
+    /** @internal */ LastContextualKeyword = OfKeyword,
 }
 
 export type TriviaSyntaxKind =
@@ -669,7 +669,7 @@ export type KeywordTypeSyntaxKind =
     | SyntaxKind.VoidKeyword
     ;
 
-/* @internal */
+/** @internal */
 export type TypeNodeSyntaxKind =
     | KeywordTypeSyntaxKind
     | SyntaxKind.TypePredicate
@@ -786,15 +786,15 @@ export const enum NodeFlags {
     // removal, it is likely that users will add the import anyway.
     // The advantage of this approach is its simplicity. For the case of batch compilation,
     // we guarantee that users won't have to pay the price of walking the tree if a dynamic import isn't used.
-    /* @internal */ PossiblyContainsDynamicImport = 1 << 21,
-    /* @internal */ PossiblyContainsImportMeta    = 1 << 22,
+    /** @internal */ PossiblyContainsDynamicImport = 1 << 21,
+    /** @internal */ PossiblyContainsImportMeta    = 1 << 22,
 
     JSDoc                                         = 1 << 23, // If node was parsed inside jsdoc
-    /* @internal */ Ambient                       = 1 << 24, // If node was inside an ambient context -- a declaration file, or inside something with the `declare` modifier.
-    /* @internal */ InWithStatement               = 1 << 25, // If any ancestor of node was the `statement` of a WithStatement (not the `expression`)
+    /** @internal */ Ambient                       = 1 << 24, // If node was inside an ambient context -- a declaration file, or inside something with the `declare` modifier.
+    /** @internal */ InWithStatement               = 1 << 25, // If any ancestor of node was the `statement` of a WithStatement (not the `expression`)
     JsonFile                                      = 1 << 26, // If node was parsed in a Json
-    /* @internal */ TypeCached                    = 1 << 27, // If a type was cached for node at any point
-    /* @internal */ Deprecated                    = 1 << 28, // If has '@deprecated' JSDoc tag
+    /** @internal */ TypeCached                    = 1 << 27, // If a type was cached for node at any point
+    /** @internal */ Deprecated                    = 1 << 28, // If has '@deprecated' JSDoc tag
 
     BlockScoped = Let | Const,
 
@@ -810,7 +810,7 @@ export const enum NodeFlags {
     // Represents all flags that are potentially set once and
     // never cleared on SourceFiles which get re-used in between incremental parses.
     // See the comment above on `PossiblyContainsDynamicImport` and `PossiblyContainsImportMeta`.
-    /* @internal */ PermanentlySetIncrementalFlags = PossiblyContainsDynamicImport | PossiblyContainsImportMeta,
+    /** @internal */ PermanentlySetIncrementalFlags = PossiblyContainsDynamicImport | PossiblyContainsImportMeta,
 }
 
 export const enum ModifierFlags {
@@ -856,7 +856,7 @@ export const enum JsxFlags {
     IntrinsicElement = IntrinsicNamedElement | IntrinsicIndexedElement,
 }
 
-/* @internal */
+/** @internal */
 export const enum RelationComparisonResult {
     Succeeded           = 1 << 0, // Should be truthy
     Failed              = 1 << 1,
@@ -867,30 +867,30 @@ export const enum RelationComparisonResult {
     ReportsMask         = ReportsUnmeasurable | ReportsUnreliable
 }
 
-/* @internal */
+/** @internal */
 export type NodeId = number;
 
 export interface Node extends ReadonlyTextRange {
     readonly kind: SyntaxKind;
     readonly flags: NodeFlags;
-    /* @internal */ modifierFlagsCache: ModifierFlags;
-    /* @internal */ readonly transformFlags: TransformFlags; // Flags for transforms
-    /* @internal */ id?: NodeId;                          // Unique id (used to look up NodeLinks)
+    /** @internal */ modifierFlagsCache: ModifierFlags;
+    /** @internal */ readonly transformFlags: TransformFlags; // Flags for transforms
+    /** @internal */ id?: NodeId;                          // Unique id (used to look up NodeLinks)
     readonly parent: Node;                                // Parent node (initialized by binding)
-    /* @internal */ original?: Node;                      // The original node if this is an updated node.
-    /* @internal */ symbol: Symbol;                       // Symbol declared by node (initialized by binding)
-    /* @internal */ locals?: SymbolTable;                 // Locals associated with node (initialized by binding)
-    /* @internal */ nextContainer?: Node;                 // Next container in declaration order (initialized by binding)
-    /* @internal */ localSymbol?: Symbol;                 // Local symbol declared by node (initialized by binding only for exported nodes)
-    /* @internal */ flowNode?: FlowNode;                  // Associated FlowNode (initialized by binding)
-    /* @internal */ emitNode?: EmitNode;                  // Associated EmitNode (initialized by transforms)
-    /* @internal */ contextualType?: Type;                // Used to temporarily assign a contextual type during overload resolution
-    /* @internal */ inferenceContext?: InferenceContext;  // Inference context for contextual type
+    /** @internal */ original?: Node;                      // The original node if this is an updated node.
+    /** @internal */ symbol: Symbol;                       // Symbol declared by node (initialized by binding)
+    /** @internal */ locals?: SymbolTable;                 // Locals associated with node (initialized by binding)
+    /** @internal */ nextContainer?: Node;                 // Next container in declaration order (initialized by binding)
+    /** @internal */ localSymbol?: Symbol;                 // Local symbol declared by node (initialized by binding only for exported nodes)
+    /** @internal */ flowNode?: FlowNode;                  // Associated FlowNode (initialized by binding)
+    /** @internal */ emitNode?: EmitNode;                  // Associated EmitNode (initialized by transforms)
+    /** @internal */ contextualType?: Type;                // Used to temporarily assign a contextual type during overload resolution
+    /** @internal */ inferenceContext?: InferenceContext;  // Inference context for contextual type
 }
 
 export interface JSDocContainer {
-    /* @internal */ jsDoc?: JSDoc[];                      // JSDoc that directly precedes this node
-    /* @internal */ jsDocCache?: readonly JSDocTag[];     // Cache for getJSDocTags
+    /** @internal */ jsDoc?: JSDoc[];                      // JSDoc that directly precedes this node
+    /** @internal */ jsDocCache?: readonly JSDocTag[];     // Cache for getJSDocTags
 }
 
 // Ideally, `ForEachChildNodes` and `VisitEachChildNodes` would not differ.
@@ -898,7 +898,7 @@ export interface JSDocContainer {
 // On the other hand, `visitEachChild` actually processes `Identifier`s (which really *shouldn't* have children,
 // but are constructed as if they could for faked-up `QualifiedName`s in the language service.)
 
-/* @internal */
+/** @internal */
 export type ForEachChildNodes =
     | HasChildren
     | MissingDeclaration
@@ -938,13 +938,13 @@ export type ForEachChildNodes =
     | JSDocDeprecatedTag
     ;
 
-/* @internal */
+/** @internal */
 export type VisitEachChildNodes =
     | HasChildren
     | Identifier
     ;
 
-/* @internal */
+/** @internal */
 export type HasChildren =
     | QualifiedName
     | ComputedPropertyName
@@ -1162,7 +1162,7 @@ export type HasType =
 
 // NOTE: Changing the following list requires changes to:
 // - `canHaveIllegalType` in factory/utilities.ts
-/* @internal */
+/** @internal */
 export type HasIllegalType =
     | ConstructorDeclaration
     | SetAccessorDeclaration
@@ -1170,7 +1170,7 @@ export type HasIllegalType =
 
 // NOTE: Changing the following list requires changes to:
 // - `canHaveIllegalTypeParameters` in factory/utilities.ts
-/* @internal */
+/** @internal */
 export type HasIllegalTypeParameters =
     | ConstructorDeclaration
     | SetAccessorDeclaration
@@ -1201,7 +1201,7 @@ export type HasExpressionInitializer =
     | EnumMember
     ;
 
-/* @internal */
+/** @internal */
 export type HasIllegalExpressionInitializer =
     | PropertySignature
     ;
@@ -1221,7 +1221,7 @@ export type HasDecorators =
 
 // NOTE: Changing the following list requires changes to:
 // - `canHaveIllegalDecorators` in factory/utilities.ts
-/* @internal */
+/** @internal */
 export type HasIllegalDecorators =
     | PropertyAssignment
     | ShorthandPropertyAssignment
@@ -1275,7 +1275,7 @@ export type HasModifiers =
 
 // NOTE: Changing the following list requires changes to:
 // - `canHaveIllegalModifiers` in factory/utilities.ts
-/* @internal */
+/** @internal */
 export type HasIllegalModifiers =
     | ClassStaticBlockDeclaration
     | PropertyAssignment
@@ -1285,15 +1285,15 @@ export type HasIllegalModifiers =
     | NamespaceExportDeclaration
     ;
 
-/* @internal */
+/** @internal */
 export interface MutableNodeArray<T extends Node> extends Array<T>, TextRange {
     hasTrailingComma: boolean;
-    /* @internal */ transformFlags: TransformFlags;   // Flags for transforms, possibly undefined
+    /** @internal */ transformFlags: TransformFlags;   // Flags for transforms, possibly undefined
 }
 
 export interface NodeArray<T extends Node> extends ReadonlyArray<T>, ReadonlyTextRange {
     readonly hasTrailingComma: boolean;
-    /* @internal */ transformFlags: TransformFlags;   // Flags for transforms, possibly undefined
+    /** @internal */ transformFlags: TransformFlags;   // Flags for transforms, possibly undefined
 }
 
 // TODO(rbuckton): Constraint 'TKind' to 'TokenSyntaxKind'
@@ -1395,11 +1395,11 @@ export type ModifiersArray = NodeArray<Modifier>;
 export const enum GeneratedIdentifierFlags {
     // Kinds
     None = 0,                           // Not automatically generated.
-    /*@internal*/ Auto = 1,             // Automatically generated identifier.
-    /*@internal*/ Loop = 2,             // Automatically generated identifier with a preference for '_i'.
-    /*@internal*/ Unique = 3,           // Unique name based on the 'text' property.
-    /*@internal*/ Node = 4,             // Unique name based on the node in the 'original' property.
-    /*@internal*/ KindMask = 7,         // Mask to extract the kind of identifier from its flags.
+    /** @internal */ Auto = 1,             // Automatically generated identifier.
+    /** @internal */ Loop = 2,             // Automatically generated identifier with a preference for '_i'.
+    /** @internal */ Unique = 3,           // Unique name based on the 'text' property.
+    /** @internal */ Node = 4,             // Unique name based on the node in the 'original' property.
+    /** @internal */ KindMask = 7,         // Mask to extract the kind of identifier from its flags.
 
     // Flags
     ReservedInNestedScopes = 1 << 3,    // Reserve the generated name in nested scopes
@@ -1416,12 +1416,12 @@ export interface Identifier extends PrimaryExpression, Declaration {
      */
     readonly escapedText: __String;
     readonly originalKeywordKind?: SyntaxKind;                // Original syntaxKind which get set so that we can report an error later
-    /*@internal*/ readonly autoGenerateFlags?: GeneratedIdentifierFlags; // Specifies whether to auto-generate the text for an identifier.
-    /*@internal*/ readonly autoGenerateId?: number;           // Ensures unique generated identifiers get unique names, but clones get the same name.
-    /*@internal*/ generatedImportReference?: ImportSpecifier; // Reference to the generated import specifier this identifier refers to
+    /** @internal */ readonly autoGenerateFlags?: GeneratedIdentifierFlags; // Specifies whether to auto-generate the text for an identifier.
+    /** @internal */ readonly autoGenerateId?: number;           // Ensures unique generated identifiers get unique names, but clones get the same name.
+    /** @internal */ generatedImportReference?: ImportSpecifier; // Reference to the generated import specifier this identifier refers to
     isInJSDocNamespace?: boolean;                             // if the node is a member in a JSDoc namespace
-    /*@internal*/ typeArguments?: NodeArray<TypeNode | TypeParameterDeclaration>; // Only defined on synthesized nodes. Though not syntactically valid, used in emitting diagnostics, quickinfo, and signature help.
-    /*@internal*/ jsdocDotPos?: number;                       // Identifier occurs in JSDoc-style generic: Id.<T>
+    /** @internal */ typeArguments?: NodeArray<TypeNode | TypeParameterDeclaration>; // Only defined on synthesized nodes. Though not syntactically valid, used in emitting diagnostics, quickinfo, and signature help.
+    /** @internal */ jsdocDotPos?: number;                       // Identifier occurs in JSDoc-style generic: Id.<T>
 }
 
 // Transient identifier node (marked by id === -1)
@@ -1429,7 +1429,7 @@ export interface TransientIdentifier extends Identifier {
     resolvedSymbol: Symbol;
 }
 
-/*@internal*/
+/** @internal */
 export interface GeneratedIdentifier extends Identifier {
     autoGenerateFlags: GeneratedIdentifierFlags;
 }
@@ -1438,7 +1438,7 @@ export interface QualifiedName extends Node {
     readonly kind: SyntaxKind.QualifiedName;
     readonly left: EntityName;
     readonly right: Identifier;
-    /*@internal*/ jsdocDotPos?: number;                      // QualifiedName occurs in JSDoc-style generic: Id1.Id2.<T>
+    /** @internal */ jsdocDotPos?: number;                      // QualifiedName occurs in JSDoc-style generic: Id1.Id2.<T>
 }
 
 export type EntityName = Identifier | QualifiedName;
@@ -1465,28 +1465,28 @@ export interface NamedDeclaration extends Declaration {
     readonly name?: DeclarationName;
 }
 
-/* @internal */
+/** @internal */
 export interface DynamicNamedDeclaration extends NamedDeclaration {
     readonly name: ComputedPropertyName;
 }
 
-/* @internal */
+/** @internal */
 export interface DynamicNamedBinaryExpression extends BinaryExpression {
     readonly left: ElementAccessExpression;
 }
 
-/* @internal */
+/** @internal */
 // A declaration that supports late-binding (used in checker)
 export interface LateBoundDeclaration extends DynamicNamedDeclaration {
     readonly name: LateBoundName;
 }
 
-/* @internal */
+/** @internal */
 export interface LateBoundBinaryExpressionDeclaration extends DynamicNamedBinaryExpression {
     readonly left: LateBoundElementAccessExpression;
 }
 
-/* @internal */
+/** @internal */
 export interface LateBoundElementAccessExpression extends ElementAccessExpression {
     readonly argumentExpression: EntityNameExpression;
 }
@@ -1510,7 +1510,7 @@ export interface PrivateIdentifier extends PrimaryExpression {
 }
 
 
-/* @internal */
+/** @internal */
 // A name that supports late-binding (used in checker)
 export interface LateBoundName extends ComputedPropertyName {
     readonly expression: EntityNameExpression;
@@ -1541,7 +1541,7 @@ export interface SignatureDeclarationBase extends NamedDeclaration, JSDocContain
     readonly typeParameters?: NodeArray<TypeParameterDeclaration> | undefined;
     readonly parameters: NodeArray<ParameterDeclaration>;
     readonly type?: TypeNode | undefined;
-    /* @internal */ typeArguments?: NodeArray<TypeNode>; // Used for quick info, replaces typeParameters for instantiated signatures
+    /** @internal */ typeArguments?: NodeArray<TypeNode>; // Used for quick info, replaces typeParameters for instantiated signatures
 }
 
 export type SignatureDeclaration =
@@ -1578,7 +1578,7 @@ export interface VariableDeclaration extends NamedDeclaration, JSDocContainer {
     readonly initializer?: Expression;             // Optional initializer
 }
 
-/* @internal */
+/** @internal */
 export type InitializedVariableDeclaration = VariableDeclaration & { readonly initializer: Expression };
 
 export interface VariableDeclarationList extends Node {
@@ -1607,7 +1607,7 @@ export interface BindingElement extends NamedDeclaration {
     readonly initializer?: Expression;           // Optional initializer
 }
 
-/*@internal*/
+/** @internal */
 export type BindingElementGrandparent = BindingElement["parent"]["parent"];
 
 export interface PropertySignature extends TypeElement, JSDocContainer {
@@ -1618,7 +1618,7 @@ export interface PropertySignature extends TypeElement, JSDocContainer {
     readonly type?: TypeNode;                    // Optional type annotation
 
     // The following properties are used only to report grammar errors
-    /* @internal */ readonly initializer?: Expression | undefined; // A property signature cannot have an initializer
+    /** @internal */ readonly initializer?: Expression | undefined; // A property signature cannot have an initializer
 }
 
 export interface PropertyDeclaration extends ClassElement, JSDocContainer {
@@ -1632,32 +1632,32 @@ export interface PropertyDeclaration extends ClassElement, JSDocContainer {
     readonly initializer?: Expression;           // Optional initializer
 }
 
-/*@internal*/
+/** @internal */
 export interface PrivateIdentifierPropertyDeclaration extends PropertyDeclaration {
     name: PrivateIdentifier;
 }
-/*@internal*/
+/** @internal */
 export interface PrivateIdentifierMethodDeclaration extends MethodDeclaration {
     name: PrivateIdentifier;
 }
-/*@internal*/
+/** @internal */
 export interface PrivateIdentifierGetAccessorDeclaration extends GetAccessorDeclaration {
     name: PrivateIdentifier;
 }
-/*@internal*/
+/** @internal */
 export interface PrivateIdentifierSetAccessorDeclaration extends SetAccessorDeclaration {
     name: PrivateIdentifier;
 }
-/*@internal*/
+/** @internal */
 export type PrivateIdentifierAccessorDeclaration = PrivateIdentifierGetAccessorDeclaration | PrivateIdentifierSetAccessorDeclaration;
-/*@internal*/
+/** @internal */
 export type PrivateClassElementDeclaration =
     | PrivateIdentifierPropertyDeclaration
     | PrivateIdentifierMethodDeclaration
     | PrivateIdentifierGetAccessorDeclaration
     | PrivateIdentifierSetAccessorDeclaration;
 
-/* @internal */
+/** @internal */
 export type InitializedPropertyDeclaration = PropertyDeclaration & { readonly initializer: Expression };
 
 export interface ObjectLiteralElement extends NamedDeclaration {
@@ -1681,10 +1681,10 @@ export interface PropertyAssignment extends ObjectLiteralElement, JSDocContainer
     readonly initializer: Expression;
 
     // The following properties are used only to report grammar errors
-    /* @internal */ readonly illegalDecorators?: NodeArray<Decorator> | undefined; // property assignment cannot have decorators
-    /* @internal */ readonly modifiers?: NodeArray<Modifier> | undefined; // property assignment cannot have modifiers
-    /* @internal */ readonly questionToken?: QuestionToken | undefined; // property assignment cannot have a question token
-    /* @internal */ readonly exclamationToken?: ExclamationToken | undefined; // property assignment cannot have an exclamation token
+    /** @internal */ readonly illegalDecorators?: NodeArray<Decorator> | undefined; // property assignment cannot have decorators
+    /** @internal */ readonly modifiers?: NodeArray<Modifier> | undefined; // property assignment cannot have modifiers
+    /** @internal */ readonly questionToken?: QuestionToken | undefined; // property assignment cannot have a question token
+    /** @internal */ readonly exclamationToken?: ExclamationToken | undefined; // property assignment cannot have an exclamation token
 }
 
 export interface ShorthandPropertyAssignment extends ObjectLiteralElement, JSDocContainer {
@@ -1697,10 +1697,10 @@ export interface ShorthandPropertyAssignment extends ObjectLiteralElement, JSDoc
     readonly objectAssignmentInitializer?: Expression;
 
     // The following properties are used only to report grammar errors
-    /* @internal */ readonly illegalDecorators?: NodeArray<Decorator> | undefined; // shorthand property assignment cannot have decorators
-    /* @internal */ readonly modifiers?: NodeArray<Modifier> | undefined; // shorthand property assignment cannot have modifiers
-    /* @internal */ readonly questionToken?: QuestionToken | undefined; // shorthand property assignment cannot have a question token
-    /* @internal */ readonly exclamationToken?: ExclamationToken | undefined; // shorthand property assignment cannot have an exclamation token
+    /** @internal */ readonly illegalDecorators?: NodeArray<Decorator> | undefined; // shorthand property assignment cannot have decorators
+    /** @internal */ readonly modifiers?: NodeArray<Modifier> | undefined; // shorthand property assignment cannot have modifiers
+    /** @internal */ readonly questionToken?: QuestionToken | undefined; // shorthand property assignment cannot have a question token
+    /** @internal */ readonly exclamationToken?: ExclamationToken | undefined; // shorthand property assignment cannot have an exclamation token
 }
 
 export interface SpreadAssignment extends ObjectLiteralElement, JSDocContainer {
@@ -1757,8 +1757,8 @@ export interface FunctionLikeDeclarationBase extends SignatureDeclarationBase {
     readonly questionToken?: QuestionToken | undefined;
     readonly exclamationToken?: ExclamationToken | undefined;
     readonly body?: Block | Expression | undefined;
-    /* @internal */ endFlowNode?: FlowNode;
-    /* @internal */ returnFlowNode?: FlowNode;
+    /** @internal */ endFlowNode?: FlowNode;
+    /** @internal */ returnFlowNode?: FlowNode;
 }
 
 export type FunctionLikeDeclaration =
@@ -1779,7 +1779,7 @@ export interface FunctionDeclaration extends FunctionLikeDeclarationBase, Declar
     readonly body?: FunctionBody;
 
     // The following properties are used only to report grammar errors
-    /* @internal */ readonly illegalDecorators?: NodeArray<Decorator> | undefined; // functions cannot have decorators
+    /** @internal */ readonly illegalDecorators?: NodeArray<Decorator> | undefined; // functions cannot have decorators
 }
 
 export interface MethodSignature extends SignatureDeclarationBase, TypeElement {
@@ -1806,7 +1806,7 @@ export interface MethodDeclaration extends FunctionLikeDeclarationBase, ClassEle
     readonly body?: FunctionBody | undefined;
 
     // The following properties are used only to report grammar errors
-    /* @internal */ readonly exclamationToken?: ExclamationToken | undefined; // A method cannot have an exclamation token
+    /** @internal */ readonly exclamationToken?: ExclamationToken | undefined; // A method cannot have an exclamation token
 }
 
 export interface ConstructorDeclaration extends FunctionLikeDeclarationBase, ClassElement, JSDocContainer {
@@ -1816,9 +1816,9 @@ export interface ConstructorDeclaration extends FunctionLikeDeclarationBase, Cla
     readonly body?: FunctionBody | undefined;
 
     // The following properties are used only to report grammar errors
-    /* @internal */ readonly illegalDecorators?: NodeArray<Decorator> | undefined; // A constructor cannot have decorators
-    /* @internal */ readonly typeParameters?: NodeArray<TypeParameterDeclaration>; // A constructor cannot have type parameters
-    /* @internal */ readonly type?: TypeNode; // A constructor cannot have a return type annotation
+    /** @internal */ readonly illegalDecorators?: NodeArray<Decorator> | undefined; // A constructor cannot have decorators
+    /** @internal */ readonly typeParameters?: NodeArray<TypeParameterDeclaration>; // A constructor cannot have type parameters
+    /** @internal */ readonly type?: TypeNode; // A constructor cannot have a return type annotation
 }
 
 /** For when we encounter a semicolon in a class declaration. ES6 allows these as class elements. */
@@ -1837,7 +1837,7 @@ export interface GetAccessorDeclaration extends FunctionLikeDeclarationBase, Cla
     readonly body?: FunctionBody;
 
     // The following properties are used only to report grammar errors
-    /* @internal */ readonly typeParameters?: NodeArray<TypeParameterDeclaration> | undefined; // A get accessor cannot have type parameters
+    /** @internal */ readonly typeParameters?: NodeArray<TypeParameterDeclaration> | undefined; // A get accessor cannot have type parameters
 }
 
 // See the comment on MethodDeclaration for the intuition behind SetAccessorDeclaration being a
@@ -1850,8 +1850,8 @@ export interface SetAccessorDeclaration extends FunctionLikeDeclarationBase, Cla
     readonly body?: FunctionBody;
 
     // The following properties are used only to report grammar errors
-    /* @internal */ readonly typeParameters?: NodeArray<TypeParameterDeclaration> | undefined; // A set accessor cannot have type parameters
-    /* @internal */ readonly type?: TypeNode | undefined; // A set accessor cannot have a return type
+    /** @internal */ readonly typeParameters?: NodeArray<TypeParameterDeclaration> | undefined; // A set accessor cannot have type parameters
+    /** @internal */ readonly type?: TypeNode | undefined; // A set accessor cannot have a return type
 }
 
 export type AccessorDeclaration = GetAccessorDeclaration | SetAccessorDeclaration;
@@ -1863,7 +1863,7 @@ export interface IndexSignatureDeclaration extends SignatureDeclarationBase, Cla
     readonly type: TypeNode;
 
     // The following properties are used only to report grammar errors
-    /* @internal */ readonly illegalDecorators?: NodeArray<Decorator> | undefined;
+    /** @internal */ readonly illegalDecorators?: NodeArray<Decorator> | undefined;
 }
 
 export interface ClassStaticBlockDeclaration extends ClassElement, JSDocContainer {
@@ -1871,19 +1871,19 @@ export interface ClassStaticBlockDeclaration extends ClassElement, JSDocContaine
     readonly parent: ClassDeclaration | ClassExpression;
     readonly body: Block;
 
-    /* @internal */ endFlowNode?: FlowNode;
-    /* @internal */ returnFlowNode?: FlowNode;
+    /** @internal */ endFlowNode?: FlowNode;
+    /** @internal */ returnFlowNode?: FlowNode;
 
     // The following properties are used only to report grammar errors
-    /* @internal */ readonly illegalDecorators?: NodeArray<Decorator> | undefined;
-    /* @internal */ readonly modifiers?: NodeArray<Modifier> | undefined;
+    /** @internal */ readonly illegalDecorators?: NodeArray<Decorator> | undefined;
+    /** @internal */ readonly modifiers?: NodeArray<Modifier> | undefined;
 }
 
 export interface TypeNode extends Node {
     _typeNodeBrand: any;
 }
 
-/* @internal */
+/** @internal */
 export interface TypeNode extends Node {
     readonly kind: TypeNodeSyntaxKind;
 }
@@ -1907,7 +1907,7 @@ export interface ImportTypeNode extends NodeWithTypeArguments {
     readonly qualifier?: EntityName;
 }
 
-/* @internal */
+/** @internal */
 export type LiteralImportTypeNode = ImportTypeNode & { readonly argument: LiteralTypeNode & { readonly literal: StringLiteral } };
 
 export interface ThisTypeNode extends TypeNode {
@@ -1925,7 +1925,7 @@ export interface FunctionTypeNode extends FunctionOrConstructorTypeNodeBase {
     readonly kind: SyntaxKind.FunctionType;
 
     // The following properties are used only to report grammar errors
-    /* @internal */ readonly modifiers?: NodeArray<Modifier> | undefined;
+    /** @internal */ readonly modifiers?: NodeArray<Modifier> | undefined;
 }
 
 export interface ConstructorTypeNode extends FunctionOrConstructorTypeNodeBase {
@@ -2027,7 +2027,7 @@ export interface TypeOperatorNode extends TypeNode {
     readonly type: TypeNode;
 }
 
-/* @internal */
+/** @internal */
 export interface UniqueTypeOperatorNode extends TypeOperatorNode {
     readonly operator: SyntaxKind.UniqueKeyword;
 }
@@ -2056,9 +2056,9 @@ export interface LiteralTypeNode extends TypeNode {
 
 export interface StringLiteral extends LiteralExpression, Declaration {
     readonly kind: SyntaxKind.StringLiteral;
-    /* @internal */ readonly textSourceNode?: Identifier | StringLiteralLike | NumericLiteral; // Allows a StringLiteral to get its text from another node (used by transforms).
+    /** @internal */ readonly textSourceNode?: Identifier | StringLiteralLike | NumericLiteral; // Allows a StringLiteral to get its text from another node (used by transforms).
     /** Note: this is only set when synthesizing a node, not during parsing. */
-    /* @internal */ readonly singleQuote?: boolean;
+    /** @internal */ readonly singleQuote?: boolean;
 }
 
 export type StringLiteralLike = StringLiteral | NoSubstitutionTemplateLiteral;
@@ -2478,7 +2478,7 @@ export interface LiteralLikeNode extends Node {
 
 export interface TemplateLiteralLikeNode extends LiteralLikeNode {
     rawText?: string;
-    /* @internal */
+    /** @internal */
     templateFlags?: TokenFlags;
 }
 
@@ -2495,42 +2495,42 @@ export interface RegularExpressionLiteral extends LiteralExpression {
 
 export interface NoSubstitutionTemplateLiteral extends LiteralExpression, TemplateLiteralLikeNode, Declaration {
     readonly kind: SyntaxKind.NoSubstitutionTemplateLiteral;
-    /* @internal */
+    /** @internal */
     templateFlags?: TokenFlags;
 }
 
 export const enum TokenFlags {
     None = 0,
-    /* @internal */
+    /** @internal */
     PrecedingLineBreak = 1 << 0,
-    /* @internal */
+    /** @internal */
     PrecedingJSDocComment = 1 << 1,
-    /* @internal */
+    /** @internal */
     Unterminated = 1 << 2,
-    /* @internal */
+    /** @internal */
     ExtendedUnicodeEscape = 1 << 3,
     Scientific = 1 << 4,        // e.g. `10e2`
     Octal = 1 << 5,             // e.g. `0777`
     HexSpecifier = 1 << 6,      // e.g. `0x00000000`
     BinarySpecifier = 1 << 7,   // e.g. `0b0110010000000000`
     OctalSpecifier = 1 << 8,    // e.g. `0o777`
-    /* @internal */
+    /** @internal */
     ContainsSeparator = 1 << 9, // e.g. `0b1100_0101`
-    /* @internal */
+    /** @internal */
     UnicodeEscape = 1 << 10,
-    /* @internal */
+    /** @internal */
     ContainsInvalidEscape = 1 << 11,    // e.g. `\uhello`
-    /* @internal */
+    /** @internal */
     BinaryOrOctalSpecifier = BinarySpecifier | OctalSpecifier,
-    /* @internal */
+    /** @internal */
     NumericLiteralFlags = Scientific | Octal | HexSpecifier | BinaryOrOctalSpecifier | ContainsSeparator,
-    /* @internal */
+    /** @internal */
     TemplateLiteralLikeFlags = ContainsInvalidEscape,
 }
 
 export interface NumericLiteral extends LiteralExpression, Declaration {
     readonly kind: SyntaxKind.NumericLiteral;
-    /* @internal */
+    /** @internal */
     readonly numericLiteralFlags: TokenFlags;
 }
 
@@ -2550,21 +2550,21 @@ export type LiteralToken =
 export interface TemplateHead extends TemplateLiteralLikeNode {
     readonly kind: SyntaxKind.TemplateHead;
     readonly parent: TemplateExpression | TemplateLiteralTypeNode;
-    /* @internal */
+    /** @internal */
     templateFlags?: TokenFlags;
 }
 
 export interface TemplateMiddle extends TemplateLiteralLikeNode {
     readonly kind: SyntaxKind.TemplateMiddle;
     readonly parent: TemplateSpan | TemplateLiteralTypeSpan;
-    /* @internal */
+    /** @internal */
     templateFlags?: TokenFlags;
 }
 
 export interface TemplateTail extends TemplateLiteralLikeNode {
     readonly kind: SyntaxKind.TemplateTail;
     readonly parent: TemplateSpan | TemplateLiteralTypeSpan;
-    /* @internal */
+    /** @internal */
     templateFlags?: TokenFlags;
 }
 
@@ -2604,7 +2604,7 @@ export interface ParenthesizedExpression extends PrimaryExpression, JSDocContain
     readonly expression: Expression;
 }
 
-/* @internal */
+/** @internal */
 export interface JSDocTypeAssertion extends ParenthesizedExpression {
     readonly _jsDocTypeAssertionBrand: never;
 }
@@ -2612,7 +2612,7 @@ export interface JSDocTypeAssertion extends ParenthesizedExpression {
 export interface ArrayLiteralExpression extends PrimaryExpression {
     readonly kind: SyntaxKind.ArrayLiteralExpression;
     readonly elements: NodeArray<Expression>;
-    /* @internal */
+    /** @internal */
     multiLine?: boolean;
 }
 
@@ -2635,7 +2635,7 @@ export interface ObjectLiteralExpressionBase<T extends ObjectLiteralElement> ext
 // An ObjectLiteralExpression is the declaration node for an anonymous symbol.
 export interface ObjectLiteralExpression extends ObjectLiteralExpressionBase<ObjectLiteralElementLike> {
     readonly kind: SyntaxKind.ObjectLiteralExpression;
-    /* @internal */
+    /** @internal */
     multiLine?: boolean;
 }
 
@@ -2650,7 +2650,7 @@ export interface PropertyAccessExpression extends MemberExpression, NamedDeclara
     readonly name: MemberName;
 }
 
-/*@internal*/
+/** @internal */
 export interface PrivateIdentifierPropertyAccessExpression extends PropertyAccessExpression {
     readonly name: PrivateIdentifier;
 }
@@ -2660,7 +2660,7 @@ export interface PropertyAccessChain extends PropertyAccessExpression {
     readonly name: MemberName;
 }
 
-/* @internal */
+/** @internal */
 export interface PropertyAccessChainRoot extends PropertyAccessChain {
     readonly questionDotToken: QuestionDotToken;
 }
@@ -2687,7 +2687,7 @@ export interface ElementAccessChain extends ElementAccessExpression {
     _optionalChainBrand: any;
 }
 
-/* @internal */
+/** @internal */
 export interface ElementAccessChainRoot extends ElementAccessChain {
     readonly questionDotToken: QuestionDotToken;
 }
@@ -2711,7 +2711,7 @@ export interface CallChain extends CallExpression {
     _optionalChainBrand: any;
 }
 
-/* @internal */
+/** @internal */
 export interface CallChainRoot extends CallChain {
     readonly questionDotToken: QuestionDotToken;
 }
@@ -2723,7 +2723,7 @@ export type OptionalChain =
     | NonNullChain
     ;
 
-/* @internal */
+/** @internal */
 export type OptionalChainRoot =
     | PropertyAccessChainRoot
     | ElementAccessChainRoot
@@ -2804,7 +2804,7 @@ export interface TaggedTemplateExpression extends MemberExpression {
     readonly tag: LeftHandSideExpression;
     readonly typeArguments?: NodeArray<TypeNode>;
     readonly template: TemplateLiteral;
-    /*@internal*/ questionDotToken?: QuestionDotToken; // NOTE: Invalid syntax, only used to report a grammar error.
+    /** @internal */ questionDotToken?: QuestionDotToken; // NOTE: Invalid syntax, only used to report a grammar error.
 }
 
 export type CallLikeExpression =
@@ -2855,7 +2855,7 @@ export interface MetaProperty extends PrimaryExpression {
     readonly name: Identifier;
 }
 
-/* @internal */
+/** @internal */
 export interface ImportMetaProperty extends MetaProperty {
     readonly keywordToken: SyntaxKind.ImportKeyword;
     readonly name: Identifier & { readonly escapedText: __String & "meta" };
@@ -2993,7 +2993,7 @@ export interface NotEmittedStatement extends Statement {
 /**
  * Marks the end of transformed declaration to properly emit exports.
  */
-/* @internal */
+/** @internal */
 export interface EndOfDeclarationMarker extends Statement {
     readonly kind: SyntaxKind.EndOfDeclarationMarker;
 }
@@ -3009,12 +3009,12 @@ export interface CommaListExpression extends Expression {
 /**
  * Marks the beginning of a merged transformed declaration.
  */
-/* @internal */
+/** @internal */
 export interface MergeDeclarationMarker extends Statement {
     readonly kind: SyntaxKind.MergeDeclarationMarker;
 }
 
-/* @internal */
+/** @internal */
 export interface SyntheticReferenceExpression extends LeftHandSideExpression {
     readonly kind: SyntaxKind.SyntheticReferenceExpression;
     readonly expression: Expression;
@@ -3034,8 +3034,8 @@ export interface MissingDeclaration extends DeclarationStatement {
     readonly name?: Identifier;
 
     // The following properties are used only to report grammar errors
-    /*@internal*/ illegalDecorators?: NodeArray<Decorator> | undefined;
-    /*@internal*/ modifiers?: NodeArray<Modifier> | undefined;
+    /** @internal */ illegalDecorators?: NodeArray<Decorator> | undefined;
+    /** @internal */ modifiers?: NodeArray<Modifier> | undefined;
 }
 
 export type BlockLike =
@@ -3048,7 +3048,7 @@ export type BlockLike =
 export interface Block extends Statement {
     readonly kind: SyntaxKind.Block;
     readonly statements: NodeArray<Statement>;
-    /*@internal*/ multiLine?: boolean;
+    /** @internal */ multiLine?: boolean;
 }
 
 export interface VariableStatement extends Statement {
@@ -3065,7 +3065,7 @@ export interface ExpressionStatement extends Statement {
     readonly expression: Expression;
 }
 
-/* @internal */
+/** @internal */
 export interface PrologueDirective extends ExpressionStatement {
     readonly expression: StringLiteral;
 }
@@ -3165,14 +3165,14 @@ export interface CaseClause extends Node, JSDocContainer {
     readonly parent: CaseBlock;
     readonly expression: Expression;
     readonly statements: NodeArray<Statement>;
-    /* @internal */ fallthroughFlowNode?: FlowNode;
+    /** @internal */ fallthroughFlowNode?: FlowNode;
 }
 
 export interface DefaultClause extends Node {
     readonly kind: SyntaxKind.DefaultClause;
     readonly parent: CaseBlock;
     readonly statements: NodeArray<Statement>;
-    /* @internal */ fallthroughFlowNode?: FlowNode;
+    /** @internal */ fallthroughFlowNode?: FlowNode;
 }
 
 export type CaseOrDefaultClause =
@@ -3271,7 +3271,7 @@ export interface InterfaceDeclaration extends DeclarationStatement, JSDocContain
     readonly members: NodeArray<TypeElement>;
 
     // The following properties are used only to report grammar errors
-    /* @internal */ readonly illegalDecorators?: NodeArray<Decorator> | undefined;
+    /** @internal */ readonly illegalDecorators?: NodeArray<Decorator> | undefined;
 }
 
 export interface HeritageClause extends Node {
@@ -3289,7 +3289,7 @@ export interface TypeAliasDeclaration extends DeclarationStatement, JSDocContain
     readonly type: TypeNode;
 
     // The following properties are used only to report grammar errors
-    /* @internal */ readonly illegalDecorators?: NodeArray<Decorator> | undefined;
+    /** @internal */ readonly illegalDecorators?: NodeArray<Decorator> | undefined;
 }
 
 export interface EnumMember extends NamedDeclaration, JSDocContainer {
@@ -3308,7 +3308,7 @@ export interface EnumDeclaration extends DeclarationStatement, JSDocContainer {
     readonly members: NodeArray<EnumMember>;
 
     // The following properties are used only to report grammar errors
-    /* @internal */ readonly illegalDecorators?: NodeArray<Decorator> | undefined;
+    /** @internal */ readonly illegalDecorators?: NodeArray<Decorator> | undefined;
 }
 
 export type ModuleName =
@@ -3321,7 +3321,7 @@ export type ModuleBody =
     | JSDocNamespaceBody
     ;
 
-/* @internal */
+/** @internal */
 export interface AmbientModuleDeclaration extends ModuleDeclaration {
     readonly body?: ModuleBlock;
 }
@@ -3334,7 +3334,7 @@ export interface ModuleDeclaration extends DeclarationStatement, JSDocContainer
     readonly body?: ModuleBody | JSDocNamespaceDeclaration;
 
     // The following properties are used only to report grammar errors
-    /* @internal */ readonly illegalDecorators?: NodeArray<Decorator> | undefined;
+    /** @internal */ readonly illegalDecorators?: NodeArray<Decorator> | undefined;
 }
 
 export type NamespaceBody =
@@ -3385,7 +3385,7 @@ export interface ImportEqualsDeclaration extends DeclarationStatement, JSDocCont
     readonly moduleReference: ModuleReference;
 
     // The following properties are used only to report grammar errors
-    /* @internal */ readonly illegalDecorators?: NodeArray<Decorator> | undefined;
+    /** @internal */ readonly illegalDecorators?: NodeArray<Decorator> | undefined;
 }
 
 export interface ExternalModuleReference extends Node {
@@ -3408,7 +3408,7 @@ export interface ImportDeclaration extends Statement {
     readonly assertClause?: AssertClause;
 
     // The following properties are used only to report grammar errors
-    /* @internal */ readonly illegalDecorators?: NodeArray<Decorator> | undefined;
+    /** @internal */ readonly illegalDecorators?: NodeArray<Decorator> | undefined;
 }
 
 export type NamedImportBindings =
@@ -3468,8 +3468,8 @@ export interface NamespaceExportDeclaration extends DeclarationStatement, JSDocC
     readonly name: Identifier;
 
     // The following properties are used only to report grammar errors
-    /* @internal */ readonly illegalDecorators?: NodeArray<Decorator> | undefined;
-    /* @internal */ readonly modifiers?: NodeArray<Modifier> | undefined;
+    /** @internal */ readonly illegalDecorators?: NodeArray<Decorator> | undefined;
+    /** @internal */ readonly modifiers?: NodeArray<Modifier> | undefined;
 }
 
 export interface ExportDeclaration extends DeclarationStatement, JSDocContainer {
@@ -3484,7 +3484,7 @@ export interface ExportDeclaration extends DeclarationStatement, JSDocContainer
     readonly assertClause?: AssertClause;
 
     // The following properties are used only to report grammar errors
-    /* @internal */ readonly illegalDecorators?: NodeArray<Decorator> | undefined;
+    /** @internal */ readonly illegalDecorators?: NodeArray<Decorator> | undefined;
 }
 
 export interface NamedImports extends Node {
@@ -3549,7 +3549,7 @@ export interface ExportAssignment extends DeclarationStatement, JSDocContainer {
     readonly expression: Expression;
 
     // The following properties are used only to report grammar errors
-    /* @internal */ readonly illegalDecorators?: NodeArray<Decorator> | undefined;
+    /** @internal */ readonly illegalDecorators?: NodeArray<Decorator> | undefined;
 }
 
 export interface FileReference extends TextRange {
@@ -3916,14 +3916,14 @@ export interface AmdDependency {
  */
 export interface SourceFileLike {
     readonly text: string;
-    /* @internal */
+    /** @internal */
     lineMap?: readonly number[];
-    /* @internal */
+    /** @internal */
     getPositionOfLineAndCharacter?(line: number, character: number, allowEdits?: true): number;
 }
 
 
-/* @internal */
+/** @internal */
 export interface RedirectInfo {
     /** Source file this redirects to. */
     readonly redirectTarget: SourceFile;
@@ -3941,27 +3941,27 @@ export interface SourceFile extends Declaration {
     readonly endOfFileToken: Token<SyntaxKind.EndOfFileToken>;
 
     fileName: string;
-    /* @internal */ path: Path;
+    /** @internal */ path: Path;
     text: string;
     /** Resolved path can be different from path property,
      * when file is included through project reference is mapped to its output instead of source
      * in that case resolvedPath = path to output file
      * path = input file's path
      */
-    /* @internal */ resolvedPath: Path;
+    /** @internal */ resolvedPath: Path;
     /** Original file name that can be different from fileName,
      * when file is included through project reference is mapped to its output instead of source
      * in that case originalFileName = name of input file
      * fileName = output file's name
      */
-    /* @internal */ originalFileName: string;
+    /** @internal */ originalFileName: string;
 
     /**
      * If two source files are for the same version of the same package, one will redirect to the other.
      * (See `createRedirectSourceFile` in program.ts.)
      * The redirect will have this set. The redirected-to source file will be in `redirectTargetsMap`.
      */
-    /* @internal */ redirectInfo?: RedirectInfo;
+    /** @internal */ redirectInfo?: RedirectInfo;
 
     amdDependencies: readonly AmdDependency[];
     moduleName?: string;
@@ -3972,7 +3972,7 @@ export interface SourceFile extends Declaration {
     isDeclarationFile: boolean;
 
     // this map is used by transpiler to supply alternative names for dependencies (i.e. in case of bundling)
-    /* @internal */
+    /** @internal */
     renamedDependencies?: ReadonlyESMap<string, string>;
 
     /**
@@ -4005,98 +4005,98 @@ export interface SourceFile extends Declaration {
      * CommonJS-output-format by the node module transformer and type checker, regardless of extension or context.
      */
     impliedNodeFormat?: ModuleKind.ESNext | ModuleKind.CommonJS;
-    /*@internal*/ packageJsonLocations?: readonly string[];
-    /*@internal*/ packageJsonScope?: PackageJsonInfo;
+    /** @internal */ packageJsonLocations?: readonly string[];
+    /** @internal */ packageJsonScope?: PackageJsonInfo;
 
-    /* @internal */ scriptKind: ScriptKind;
+    /** @internal */ scriptKind: ScriptKind;
 
     /**
      * The first "most obvious" node that makes a file an external module.
      * This is intended to be the first top-level import/export,
      * but could be arbitrarily nested (e.g. `import.meta`).
      */
-    /* @internal */ externalModuleIndicator?: Node | true;
+    /** @internal */ externalModuleIndicator?: Node | true;
     /**
      * The callback used to set the external module indicator - this is saved to
      * be later reused during incremental reparsing, which otherwise lacks the information
      * to set this field
      */
-    /* @internal */ setExternalModuleIndicator?: (file: SourceFile) => void;
+    /** @internal */ setExternalModuleIndicator?: (file: SourceFile) => void;
     // The first node that causes this file to be a CommonJS module
-    /* @internal */ commonJsModuleIndicator?: Node;
+    /** @internal */ commonJsModuleIndicator?: Node;
     // JS identifier-declarations that are intended to merge with globals
-    /* @internal */ jsGlobalAugmentations?: SymbolTable;
+    /** @internal */ jsGlobalAugmentations?: SymbolTable;
 
-    /* @internal */ identifiers: ESMap<string, string>; // Map from a string to an interned string
-    /* @internal */ nodeCount: number;
-    /* @internal */ identifierCount: number;
-    /* @internal */ symbolCount: number;
+    /** @internal */ identifiers: ESMap<string, string>; // Map from a string to an interned string
+    /** @internal */ nodeCount: number;
+    /** @internal */ identifierCount: number;
+    /** @internal */ symbolCount: number;
 
     // File-level diagnostics reported by the parser (includes diagnostics about /// references
     // as well as code diagnostics).
-    /* @internal */ parseDiagnostics: DiagnosticWithLocation[];
+    /** @internal */ parseDiagnostics: DiagnosticWithLocation[];
 
     // File-level diagnostics reported by the binder.
-    /* @internal */ bindDiagnostics: DiagnosticWithLocation[];
-    /* @internal */ bindSuggestionDiagnostics?: DiagnosticWithLocation[];
+    /** @internal */ bindDiagnostics: DiagnosticWithLocation[];
+    /** @internal */ bindSuggestionDiagnostics?: DiagnosticWithLocation[];
 
     // File-level JSDoc diagnostics reported by the JSDoc parser
-    /* @internal */ jsDocDiagnostics?: DiagnosticWithLocation[];
+    /** @internal */ jsDocDiagnostics?: DiagnosticWithLocation[];
 
     // Stores additional file-level diagnostics reported by the program
-    /* @internal */ additionalSyntacticDiagnostics?: readonly DiagnosticWithLocation[];
+    /** @internal */ additionalSyntacticDiagnostics?: readonly DiagnosticWithLocation[];
 
     // Stores a line map for the file.
     // This field should never be used directly to obtain line map, use getLineMap function instead.
-    /* @internal */ lineMap: readonly number[];
-    /* @internal */ classifiableNames?: ReadonlySet<__String>;
+    /** @internal */ lineMap: readonly number[];
+    /** @internal */ classifiableNames?: ReadonlySet<__String>;
     // Comments containing @ts-* directives, in order.
-    /* @internal */ commentDirectives?: CommentDirective[];
+    /** @internal */ commentDirectives?: CommentDirective[];
     // Stores a mapping 'external module reference text' -> 'resolved file name' | undefined
     // It is used to resolve module names in the checker.
     // Content of this field should never be used directly - use getResolvedModuleFileName/setResolvedModuleFileName functions instead
-    /* @internal */ resolvedModules?: ModeAwareCache<ResolvedModuleFull | undefined>;
-    /* @internal */ resolvedTypeReferenceDirectiveNames: ModeAwareCache<ResolvedTypeReferenceDirective | undefined>;
-    /* @internal */ imports: readonly StringLiteralLike[];
+    /** @internal */ resolvedModules?: ModeAwareCache<ResolvedModuleFull | undefined>;
+    /** @internal */ resolvedTypeReferenceDirectiveNames: ModeAwareCache<ResolvedTypeReferenceDirective | undefined>;
+    /** @internal */ imports: readonly StringLiteralLike[];
     // Identifier only if `declare global`
-    /* @internal */ moduleAugmentations: readonly (StringLiteral | Identifier)[];
-    /* @internal */ patternAmbientModules?: PatternAmbientModule[];
-    /* @internal */ ambientModuleNames: readonly string[];
-    /* @internal */ checkJsDirective?: CheckJsDirective;
-    /* @internal */ version: string;
-    /* @internal */ pragmas: ReadonlyPragmaMap;
-    /* @internal */ localJsxNamespace?: __String;
-    /* @internal */ localJsxFragmentNamespace?: __String;
-    /* @internal */ localJsxFactory?: EntityName;
-    /* @internal */ localJsxFragmentFactory?: EntityName;
-
-    /* @internal */ exportedModulesFromDeclarationEmit?: ExportedModulesFromDeclarationEmit;
-    /* @internal */ endFlowNode?: FlowNode;
-}
-
-/* @internal */
+    /** @internal */ moduleAugmentations: readonly (StringLiteral | Identifier)[];
+    /** @internal */ patternAmbientModules?: PatternAmbientModule[];
+    /** @internal */ ambientModuleNames: readonly string[];
+    /** @internal */ checkJsDirective?: CheckJsDirective;
+    /** @internal */ version: string;
+    /** @internal */ pragmas: ReadonlyPragmaMap;
+    /** @internal */ localJsxNamespace?: __String;
+    /** @internal */ localJsxFragmentNamespace?: __String;
+    /** @internal */ localJsxFactory?: EntityName;
+    /** @internal */ localJsxFragmentFactory?: EntityName;
+
+    /** @internal */ exportedModulesFromDeclarationEmit?: ExportedModulesFromDeclarationEmit;
+    /** @internal */ endFlowNode?: FlowNode;
+}
+
+/** @internal */
 export interface CommentDirective {
     range: TextRange;
     type: CommentDirectiveType,
 }
 
-/* @internal */
+/** @internal */
 export const enum CommentDirectiveType {
     ExpectError,
     Ignore,
 }
 
-/*@internal*/
+/** @internal */
 export type ExportedModulesFromDeclarationEmit = readonly Symbol[];
 
 export interface Bundle extends Node {
     readonly kind: SyntaxKind.Bundle;
     readonly prepends: readonly (InputFiles | UnparsedSource)[];
     readonly sourceFiles: readonly SourceFile[];
-    /* @internal */ syntheticFileReferences?: readonly FileReference[];
-    /* @internal */ syntheticTypeReferences?: readonly FileReference[];
-    /* @internal */ syntheticLibReferences?: readonly FileReference[];
-    /* @internal */ hasNoDefaultLib?: boolean;
+    /** @internal */ syntheticFileReferences?: readonly FileReference[];
+    /** @internal */ syntheticTypeReferences?: readonly FileReference[];
+    /** @internal */ syntheticLibReferences?: readonly FileReference[];
+    /** @internal */ hasNoDefaultLib?: boolean;
 }
 
 export interface InputFiles extends Node {
@@ -4109,9 +4109,9 @@ export interface InputFiles extends Node {
     declarationText: string;
     declarationMapPath?: string;
     declarationMapText?: string;
-    /*@internal*/ buildInfoPath?: string;
-    /*@internal*/ buildInfo?: BuildInfo;
-    /*@internal*/ oldFileOfCurrentEmit?: boolean;
+    /** @internal */ buildInfoPath?: string;
+    /** @internal */ buildInfo?: BuildInfo;
+    /** @internal */ oldFileOfCurrentEmit?: boolean;
 }
 
 export interface UnparsedSource extends Node {
@@ -4131,10 +4131,10 @@ export interface UnparsedSource extends Node {
     sourceMapText?: string;
     readonly syntheticReferences?: readonly UnparsedSyntheticReference[];
     readonly texts: readonly UnparsedSourceText[];
-    /*@internal*/ oldFileOfCurrentEmit?: boolean;
-    /*@internal*/ parsedSourceMap?: RawSourceMap | false | undefined;
+    /** @internal */ oldFileOfCurrentEmit?: boolean;
+    /** @internal */ parsedSourceMap?: RawSourceMap | false | undefined;
     // Adding this to satisfy services, fix later
-    /*@internal*/
+    /** @internal */
     getLineAndCharacterOfPosition(pos: number): LineAndCharacter;
 }
 
@@ -4176,7 +4176,7 @@ export interface UnparsedTextLike extends UnparsedSection {
 export interface UnparsedSyntheticReference extends UnparsedSection {
     readonly kind: SyntaxKind.UnparsedSyntheticReference;
     readonly parent: UnparsedSource;
-    /*@internal*/ readonly section: BundleFileHasNoDefaultLib | BundleFileReference;
+    /** @internal */ readonly section: BundleFileHasNoDefaultLib | BundleFileReference;
 }
 
 export interface JsonSourceFile extends SourceFile {
@@ -4185,7 +4185,7 @@ export interface JsonSourceFile extends SourceFile {
 
 export interface TsConfigSourceFile extends JsonSourceFile {
     extendedSourceFiles?: string[];
-    /*@internal*/ configFileSpecs?: ConfigFileSpecs;
+    /** @internal */ configFileSpecs?: ConfigFileSpecs;
 }
 
 export interface JsonMinusNumericLiteral extends PrefixUnaryExpression {
@@ -4238,9 +4238,9 @@ export interface ParseConfigHost {
 export type ResolvedConfigFileName = string & { _isResolvedConfigFileName: never };
 
 export interface WriteFileCallbackData {
-    /*@internal*/ sourceMapUrlPos?: number;
-    /*@internal*/ buildInfo?: BuildInfo;
-    /*@internal*/ diagnostics?: readonly DiagnosticWithLocation[];
+    /** @internal */ sourceMapUrlPos?: number;
+    /** @internal */ buildInfo?: BuildInfo;
+    /** @internal */ diagnostics?: readonly DiagnosticWithLocation[];
 }
 export type WriteFileCallback = (
     fileName: string,
@@ -4260,7 +4260,7 @@ export interface CancellationToken {
     throwIfCancellationRequested(): void;
 }
 
-/*@internal*/
+/** @internal */
 export enum FileIncludeKind {
     RootFile,
     SourceFromProjectReference,
@@ -4273,49 +4273,49 @@ export enum FileIncludeKind {
     AutomaticTypeDirectiveFile
 }
 
-/*@internal*/
+/** @internal */
 export interface RootFile {
     kind: FileIncludeKind.RootFile,
     index: number;
 }
 
-/*@internal*/
+/** @internal */
 export interface LibFile {
     kind: FileIncludeKind.LibFile;
     index?: number;
 }
 
-/*@internal*/
+/** @internal */
 export type ProjectReferenceFileKind = FileIncludeKind.SourceFromProjectReference |
     FileIncludeKind.OutputFromProjectReference;
 
-/*@internal*/
+/** @internal */
 export interface ProjectReferenceFile {
     kind: ProjectReferenceFileKind;
     index: number;
 }
 
-/*@internal*/
+/** @internal */
 export type ReferencedFileKind = FileIncludeKind.Import |
     FileIncludeKind.ReferenceFile |
     FileIncludeKind.TypeReferenceDirective |
     FileIncludeKind.LibReferenceDirective;
 
-/*@internal*/
+/** @internal */
 export interface ReferencedFile {
     kind: ReferencedFileKind;
     file: Path;
     index: number;
 }
 
-/*@internal*/
+/** @internal */
 export interface AutomaticTypeDirectiveFile {
     kind: FileIncludeKind.AutomaticTypeDirectiveFile;
     typeReference: string;
     packageId: PackageId | undefined;
 }
 
-/*@internal*/
+/** @internal */
 export type FileIncludeReason =
     RootFile |
     LibFile |
@@ -4323,13 +4323,13 @@ export type FileIncludeReason =
     ReferencedFile |
     AutomaticTypeDirectiveFile;
 
-/*@internal*/
+/** @internal */
 export const enum FilePreprocessingDiagnosticsKind {
     FilePreprocessingReferencedDiagnostic,
     FilePreprocessingFileExplainingDiagnostic
 }
 
-/*@internal*/
+/** @internal */
 export interface FilePreprocessingReferencedDiagnostic {
     kind: FilePreprocessingDiagnosticsKind.FilePreprocessingReferencedDiagnostic;
     reason: ReferencedFile;
@@ -4337,7 +4337,7 @@ export interface FilePreprocessingReferencedDiagnostic {
     args?: (string | number | undefined)[];
 }
 
-/*@internal*/
+/** @internal */
 export interface FilePreprocessingFileExplainingDiagnostic {
     kind: FilePreprocessingDiagnosticsKind.FilePreprocessingFileExplainingDiagnostic;
     file?: Path;
@@ -4346,7 +4346,7 @@ export interface FilePreprocessingFileExplainingDiagnostic {
     args?: (string | number | undefined)[];
 }
 
-/*@internal*/
+/** @internal */
 export type FilePreprocessingDiagnostics = FilePreprocessingReferencedDiagnostic | FilePreprocessingFileExplainingDiagnostic;
 
 export interface Program extends ScriptReferenceHost {
@@ -4365,11 +4365,11 @@ export interface Program extends ScriptReferenceHost {
      * Get a list of file names that were passed to 'createProgram' or referenced in a
      * program source file but could not be located.
      */
-    /* @internal */
+    /** @internal */
     getMissingFilePaths(): readonly Path[];
-    /* @internal */
+    /** @internal */
     getModuleResolutionCache(): ModuleResolutionCache | undefined;
-    /* @internal */
+    /** @internal */
     getFilesByNameMap(): ESMap<string, SourceFile | false | undefined>;
 
     /**
@@ -4383,7 +4383,7 @@ export interface Program extends ScriptReferenceHost {
      * will be invoked when writing the JavaScript and declaration files.
      */
     emit(targetSourceFile?: SourceFile, writeFile?: WriteFileCallback, cancellationToken?: CancellationToken, emitOnlyDtsFiles?: boolean, customTransformers?: CustomTransformers): EmitResult;
-    /*@internal*/
+    /** @internal */
     emit(targetSourceFile?: SourceFile, writeFile?: WriteFileCallback, cancellationToken?: CancellationToken, emitOnlyDtsFiles?: boolean, customTransformers?: CustomTransformers, forceDtsEmit?: boolean): EmitResult; // eslint-disable-line @typescript-eslint/unified-signatures
 
     getOptionsDiagnostics(cancellationToken?: CancellationToken): readonly Diagnostic[];
@@ -4393,21 +4393,21 @@ export interface Program extends ScriptReferenceHost {
     getSemanticDiagnostics(sourceFile?: SourceFile, cancellationToken?: CancellationToken): readonly Diagnostic[];
     getDeclarationDiagnostics(sourceFile?: SourceFile, cancellationToken?: CancellationToken): readonly DiagnosticWithLocation[];
     getConfigFileParsingDiagnostics(): readonly Diagnostic[];
-    /* @internal */ getSuggestionDiagnostics(sourceFile: SourceFile, cancellationToken?: CancellationToken): readonly DiagnosticWithLocation[];
+    /** @internal */ getSuggestionDiagnostics(sourceFile: SourceFile, cancellationToken?: CancellationToken): readonly DiagnosticWithLocation[];
 
-    /* @internal */ getBindAndCheckDiagnostics(sourceFile: SourceFile, cancellationToken?: CancellationToken): readonly Diagnostic[];
-    /* @internal */ getProgramDiagnostics(sourceFile: SourceFile, cancellationToken?: CancellationToken): readonly Diagnostic[];
+    /** @internal */ getBindAndCheckDiagnostics(sourceFile: SourceFile, cancellationToken?: CancellationToken): readonly Diagnostic[];
+    /** @internal */ getProgramDiagnostics(sourceFile: SourceFile, cancellationToken?: CancellationToken): readonly Diagnostic[];
 
     /**
      * Gets a type checker that can be used to semantically analyze source files in the program.
      */
     getTypeChecker(): TypeChecker;
 
-    /* @internal */ getCommonSourceDirectory(): string;
+    /** @internal */ getCommonSourceDirectory(): string;
 
-    /* @internal */ getCachedSemanticDiagnostics(sourceFile?: SourceFile): readonly Diagnostic[] | undefined;
+    /** @internal */ getCachedSemanticDiagnostics(sourceFile?: SourceFile): readonly Diagnostic[] | undefined;
 
-    /* @internal */ getClassifiableNames(): Set<__String>;
+    /** @internal */ getClassifiableNames(): Set<__String>;
 
     getNodeCount(): number;
     getIdentifierCount(): number;
@@ -4416,53 +4416,53 @@ export interface Program extends ScriptReferenceHost {
     getInstantiationCount(): number;
     getRelationCacheSizes(): { assignable: number, identity: number, subtype: number, strictSubtype: number };
 
-    /* @internal */ getFileProcessingDiagnostics(): FilePreprocessingDiagnostics[] | undefined;
-    /* @internal */ getResolvedTypeReferenceDirectives(): ModeAwareCache<ResolvedTypeReferenceDirective | undefined>;
+    /** @internal */ getFileProcessingDiagnostics(): FilePreprocessingDiagnostics[] | undefined;
+    /** @internal */ getResolvedTypeReferenceDirectives(): ModeAwareCache<ResolvedTypeReferenceDirective | undefined>;
     isSourceFileFromExternalLibrary(file: SourceFile): boolean;
     isSourceFileDefaultLibrary(file: SourceFile): boolean;
 
     // For testing purposes only.
     // This is set on created program to let us know how the program was created using old program
-    /* @internal */ readonly structureIsReused: StructureIsReused;
+    /** @internal */ readonly structureIsReused: StructureIsReused;
 
-    /* @internal */ getSourceFileFromReference(referencingFile: SourceFile | UnparsedSource, ref: FileReference): SourceFile | undefined;
-    /* @internal */ getLibFileFromReference(ref: FileReference): SourceFile | undefined;
+    /** @internal */ getSourceFileFromReference(referencingFile: SourceFile | UnparsedSource, ref: FileReference): SourceFile | undefined;
+    /** @internal */ getLibFileFromReference(ref: FileReference): SourceFile | undefined;
 
     /** Given a source file, get the name of the package it was imported from. */
-    /* @internal */ sourceFileToPackageName: ESMap<Path, string>;
+    /** @internal */ sourceFileToPackageName: ESMap<Path, string>;
     /** Set of all source files that some other source file redirects to. */
-    /* @internal */ redirectTargetsMap: MultiMap<Path, string>;
+    /** @internal */ redirectTargetsMap: MultiMap<Path, string>;
     /** Whether any (non-external, non-declaration) source files use `node:`-prefixed module specifiers. */
-    /* @internal */ readonly usesUriStyleNodeCoreModules: boolean;
+    /** @internal */ readonly usesUriStyleNodeCoreModules: boolean;
     /** Is the file emitted file */
-    /* @internal */ isEmittedFile(file: string): boolean;
-    /* @internal */ getFileIncludeReasons(): MultiMap<Path, FileIncludeReason>;
-    /* @internal */ useCaseSensitiveFileNames(): boolean;
+    /** @internal */ isEmittedFile(file: string): boolean;
+    /** @internal */ getFileIncludeReasons(): MultiMap<Path, FileIncludeReason>;
+    /** @internal */ useCaseSensitiveFileNames(): boolean;
 
-    /* @internal */ getResolvedModuleWithFailedLookupLocationsFromCache(moduleName: string, containingFile: string, mode?: ModuleKind.CommonJS | ModuleKind.ESNext): ResolvedModuleWithFailedLookupLocations | undefined;
+    /** @internal */ getResolvedModuleWithFailedLookupLocationsFromCache(moduleName: string, containingFile: string, mode?: ModuleKind.CommonJS | ModuleKind.ESNext): ResolvedModuleWithFailedLookupLocations | undefined;
 
     getProjectReferences(): readonly ProjectReference[] | undefined;
     getResolvedProjectReferences(): readonly (ResolvedProjectReference | undefined)[] | undefined;
-    /*@internal*/ getProjectReferenceRedirect(fileName: string): string | undefined;
-    /*@internal*/ getResolvedProjectReferenceToRedirect(fileName: string): ResolvedProjectReference | undefined;
-    /*@internal*/ forEachResolvedProjectReference<T>(cb: (resolvedProjectReference: ResolvedProjectReference) => T | undefined): T | undefined;
-    /*@internal*/ getResolvedProjectReferenceByPath(projectReferencePath: Path): ResolvedProjectReference | undefined;
-    /*@internal*/ isSourceOfProjectReferenceRedirect(fileName: string): boolean;
-    /*@internal*/ getProgramBuildInfo?(): ProgramBuildInfo | undefined;
-    /*@internal*/ emitBuildInfo(writeFile?: WriteFileCallback, cancellationToken?: CancellationToken): EmitResult;
+    /** @internal */ getProjectReferenceRedirect(fileName: string): string | undefined;
+    /** @internal */ getResolvedProjectReferenceToRedirect(fileName: string): ResolvedProjectReference | undefined;
+    /** @internal */ forEachResolvedProjectReference<T>(cb: (resolvedProjectReference: ResolvedProjectReference) => T | undefined): T | undefined;
+    /** @internal */ getResolvedProjectReferenceByPath(projectReferencePath: Path): ResolvedProjectReference | undefined;
+    /** @internal */ isSourceOfProjectReferenceRedirect(fileName: string): boolean;
+    /** @internal */ getProgramBuildInfo?(): ProgramBuildInfo | undefined;
+    /** @internal */ emitBuildInfo(writeFile?: WriteFileCallback, cancellationToken?: CancellationToken): EmitResult;
     /**
      * This implementation handles file exists to be true if file is source of project reference redirect when program is created using useSourceOfProjectReferenceRedirect
      */
-    /*@internal*/ fileExists(fileName: string): boolean;
+    /** @internal */ fileExists(fileName: string): boolean;
     /** Call compilerHost.writeFile on host program was created with */
-    /*@internal*/ writeFile: WriteFileCallback;
+    /** @internal */ writeFile: WriteFileCallback;
 }
 
-/*@internal*/
+/** @internal */
 export interface Program extends TypeCheckerHost, ModuleSpecifierResolutionHost {
 }
 
-/* @internal */
+/** @internal */
 export type RedirectTargetsMap = ReadonlyESMap<Path, readonly string[]>;
 
 export interface ResolvedProjectReference {
@@ -4471,7 +4471,7 @@ export interface ResolvedProjectReference {
     references?: readonly (ResolvedProjectReference | undefined)[];
 }
 
-/* @internal */
+/** @internal */
 export const enum StructureIsReused {
     Not,
     SafeModules,
@@ -4494,7 +4494,7 @@ export interface CustomTransformers {
     afterDeclarations?: (TransformerFactory<Bundle | SourceFile> | CustomTransformerFactory)[];
 }
 
-/*@internal*/
+/** @internal */
 export interface EmitTransformers {
     scriptTransformers: readonly TransformerFactory<SourceFile | Bundle>[];
     declarationTransformers: readonly TransformerFactory<SourceFile | Bundle>[];
@@ -4515,7 +4515,7 @@ export interface SourceMapSpan {
     sourceIndex: number;
 }
 
-/* @internal */
+/** @internal */
 export interface SourceMapEmitResult {
     inputSourceFileNames: readonly string[];      // Input source file (which one can use on program to get the file), 1:1 mapping with the sourceMap.sources list
     sourceMap: RawSourceMap;
@@ -4549,10 +4549,10 @@ export interface EmitResult {
     /** Contains declaration emit diagnostics */
     diagnostics: readonly Diagnostic[];
     emittedFiles?: string[]; // Array of files the compiler wrote to disk
-    /* @internal */ sourceMaps?: SourceMapEmitResult[];  // Array of sourceMapData if compiler emitted sourcemaps
+    /** @internal */ sourceMaps?: SourceMapEmitResult[];  // Array of sourceMapData if compiler emitted sourcemaps
 }
 
-/* @internal */
+/** @internal */
 export interface TypeCheckerHost extends ModuleSpecifierResolutionHost {
     getCompilerOptions(): CompilerOptions;
 
@@ -4567,54 +4567,54 @@ export interface TypeCheckerHost extends ModuleSpecifierResolutionHost {
 
 export interface TypeChecker {
     getTypeOfSymbolAtLocation(symbol: Symbol, node: Node): Type;
-    /* @internal */ getTypeOfSymbol(symbol: Symbol): Type;
+    /** @internal */ getTypeOfSymbol(symbol: Symbol): Type;
     getDeclaredTypeOfSymbol(symbol: Symbol): Type;
     getPropertiesOfType(type: Type): Symbol[];
     getPropertyOfType(type: Type, propertyName: string): Symbol | undefined;
     getPrivateIdentifierPropertyOfType(leftType: Type, name: string, location: Node): Symbol | undefined;
-    /* @internal */ getTypeOfPropertyOfType(type: Type, propertyName: string): Type | undefined;
+    /** @internal */ getTypeOfPropertyOfType(type: Type, propertyName: string): Type | undefined;
     getIndexInfoOfType(type: Type, kind: IndexKind): IndexInfo | undefined;
     getIndexInfosOfType(type: Type): readonly IndexInfo[];
     getIndexInfosOfIndexSymbol: (indexSymbol: Symbol) => IndexInfo[];
     getSignaturesOfType(type: Type, kind: SignatureKind): readonly Signature[];
     getIndexTypeOfType(type: Type, kind: IndexKind): Type | undefined;
-    /* @internal */ getIndexType(type: Type): Type;
+    /** @internal */ getIndexType(type: Type): Type;
     getBaseTypes(type: InterfaceType): BaseType[];
     getBaseTypeOfLiteralType(type: Type): Type;
     getWidenedType(type: Type): Type;
-    /* @internal */
+    /** @internal */
     getPromisedTypeOfPromise(promise: Type, errorNode?: Node): Type | undefined;
-    /* @internal */
+    /** @internal */
     getAwaitedType(type: Type): Type | undefined;
     getReturnTypeOfSignature(signature: Signature): Type;
     /**
      * Gets the type of a parameter at a given position in a signature.
      * Returns `any` if the index is not valid.
      */
-    /* @internal */ getParameterType(signature: Signature, parameterIndex: number): Type;
-    /* @internal */ getParameterIdentifierNameAtPosition(signature: Signature, parameterIndex: number): [parameterName: __String, isRestParameter: boolean] | undefined;
+    /** @internal */ getParameterType(signature: Signature, parameterIndex: number): Type;
+    /** @internal */ getParameterIdentifierNameAtPosition(signature: Signature, parameterIndex: number): [parameterName: __String, isRestParameter: boolean] | undefined;
     getNullableType(type: Type, flags: TypeFlags): Type;
     getNonNullableType(type: Type): Type;
-    /* @internal */ getNonOptionalType(type: Type): Type;
-    /* @internal */ isNullableType(type: Type): boolean;
+    /** @internal */ getNonOptionalType(type: Type): Type;
+    /** @internal */ isNullableType(type: Type): boolean;
     getTypeArguments(type: TypeReference): readonly Type[];
 
     // TODO: GH#18217 `xToDeclaration` calls are frequently asserted as defined.
     /** Note that the resulting nodes cannot be checked. */
     typeToTypeNode(type: Type, enclosingDeclaration: Node | undefined, flags: NodeBuilderFlags | undefined): TypeNode | undefined;
-    /* @internal */ typeToTypeNode(type: Type, enclosingDeclaration: Node | undefined, flags: NodeBuilderFlags | undefined, tracker?: SymbolTracker): TypeNode | undefined; // eslint-disable-line @typescript-eslint/unified-signatures
+    /** @internal */ typeToTypeNode(type: Type, enclosingDeclaration: Node | undefined, flags: NodeBuilderFlags | undefined, tracker?: SymbolTracker): TypeNode | undefined; // eslint-disable-line @typescript-eslint/unified-signatures
     /** Note that the resulting nodes cannot be checked. */
     signatureToSignatureDeclaration(signature: Signature, kind: SyntaxKind, enclosingDeclaration: Node | undefined, flags: NodeBuilderFlags | undefined): SignatureDeclaration & {typeArguments?: NodeArray<TypeNode>} | undefined;
-    /* @internal */ signatureToSignatureDeclaration(signature: Signature, kind: SyntaxKind, enclosingDeclaration: Node | undefined, flags: NodeBuilderFlags | undefined, tracker?: SymbolTracker): SignatureDeclaration & {typeArguments?: NodeArray<TypeNode>} | undefined; // eslint-disable-line @typescript-eslint/unified-signatures
+    /** @internal */ signatureToSignatureDeclaration(signature: Signature, kind: SyntaxKind, enclosingDeclaration: Node | undefined, flags: NodeBuilderFlags | undefined, tracker?: SymbolTracker): SignatureDeclaration & {typeArguments?: NodeArray<TypeNode>} | undefined; // eslint-disable-line @typescript-eslint/unified-signatures
     /** Note that the resulting nodes cannot be checked. */
     indexInfoToIndexSignatureDeclaration(indexInfo: IndexInfo, enclosingDeclaration: Node | undefined, flags: NodeBuilderFlags | undefined): IndexSignatureDeclaration | undefined;
-    /* @internal */ indexInfoToIndexSignatureDeclaration(indexInfo: IndexInfo, enclosingDeclaration: Node | undefined, flags: NodeBuilderFlags | undefined, tracker?: SymbolTracker): IndexSignatureDeclaration | undefined; // eslint-disable-line @typescript-eslint/unified-signatures
+    /** @internal */ indexInfoToIndexSignatureDeclaration(indexInfo: IndexInfo, enclosingDeclaration: Node | undefined, flags: NodeBuilderFlags | undefined, tracker?: SymbolTracker): IndexSignatureDeclaration | undefined; // eslint-disable-line @typescript-eslint/unified-signatures
     /** Note that the resulting nodes cannot be checked. */
     symbolToEntityName(symbol: Symbol, meaning: SymbolFlags, enclosingDeclaration: Node | undefined, flags: NodeBuilderFlags | undefined): EntityName | undefined;
     /** Note that the resulting nodes cannot be checked. */
     symbolToExpression(symbol: Symbol, meaning: SymbolFlags, enclosingDeclaration: Node | undefined, flags: NodeBuilderFlags | undefined): Expression | undefined;
     /** Note that the resulting nodes cannot be checked. */
-    /* @internal */ symbolToNode(symbol: Symbol, meaning: SymbolFlags, enclosingDeclaration: Node | undefined, flags: NodeBuilderFlags | undefined): Node | undefined;
+    /** @internal */ symbolToNode(symbol: Symbol, meaning: SymbolFlags, enclosingDeclaration: Node | undefined, flags: NodeBuilderFlags | undefined): Node | undefined;
     /** Note that the resulting nodes cannot be checked. */
     symbolToTypeParameterDeclarations(symbol: Symbol, enclosingDeclaration: Node | undefined, flags: NodeBuilderFlags | undefined): NodeArray<TypeParameterDeclaration> | undefined;
     /** Note that the resulting nodes cannot be checked. */
@@ -4624,7 +4624,7 @@ export interface TypeChecker {
 
     getSymbolsInScope(location: Node, meaning: SymbolFlags): Symbol[];
     getSymbolAtLocation(node: Node): Symbol | undefined;
-    /* @internal */ getIndexInfosAtLocation(node: Node): readonly IndexInfo[] | undefined;
+    /** @internal */ getIndexInfosAtLocation(node: Node): readonly IndexInfo[] | undefined;
     getSymbolsOfParameterPropertyDeclaration(parameter: ParameterDeclaration, parameterName: string): Symbol[];
     /**
      * The function returns the value (local variable) symbol of an identifier in the short-hand property assignment.
@@ -4652,10 +4652,10 @@ export interface TypeChecker {
     symbolToString(symbol: Symbol, enclosingDeclaration?: Node, meaning?: SymbolFlags, flags?: SymbolFormatFlags): string;
     typePredicateToString(predicate: TypePredicate, enclosingDeclaration?: Node, flags?: TypeFormatFlags): string;
 
-    /* @internal */ writeSignature(signature: Signature, enclosingDeclaration?: Node, flags?: TypeFormatFlags, kind?: SignatureKind, writer?: EmitTextWriter): string;
-    /* @internal */ writeType(type: Type, enclosingDeclaration?: Node, flags?: TypeFormatFlags, writer?: EmitTextWriter): string;
-    /* @internal */ writeSymbol(symbol: Symbol, enclosingDeclaration?: Node, meaning?: SymbolFlags, flags?: SymbolFormatFlags, writer?: EmitTextWriter): string;
-    /* @internal */ writeTypePredicate(predicate: TypePredicate, enclosingDeclaration?: Node, flags?: TypeFormatFlags, writer?: EmitTextWriter): string;
+    /** @internal */ writeSignature(signature: Signature, enclosingDeclaration?: Node, flags?: TypeFormatFlags, kind?: SignatureKind, writer?: EmitTextWriter): string;
+    /** @internal */ writeType(type: Type, enclosingDeclaration?: Node, flags?: TypeFormatFlags, writer?: EmitTextWriter): string;
+    /** @internal */ writeSymbol(symbol: Symbol, enclosingDeclaration?: Node, meaning?: SymbolFlags, flags?: SymbolFormatFlags, writer?: EmitTextWriter): string;
+    /** @internal */ writeTypePredicate(predicate: TypePredicate, enclosingDeclaration?: Node, flags?: TypeFormatFlags, writer?: EmitTextWriter): string;
 
     getFullyQualifiedName(symbol: Symbol): string;
     getAugmentedPropertiesOfType(type: Type): Symbol[];
@@ -4663,12 +4663,12 @@ export interface TypeChecker {
     getRootSymbols(symbol: Symbol): readonly Symbol[];
     getSymbolOfExpando(node: Node, allowDeclaration: boolean): Symbol | undefined;
     getContextualType(node: Expression): Type | undefined;
-    /* @internal */ getContextualType(node: Expression, contextFlags?: ContextFlags): Type | undefined; // eslint-disable-line @typescript-eslint/unified-signatures
-    /* @internal */ getContextualTypeForObjectLiteralElement(element: ObjectLiteralElementLike): Type | undefined;
-    /* @internal */ getContextualTypeForArgumentAtIndex(call: CallLikeExpression, argIndex: number): Type | undefined;
-    /* @internal */ getContextualTypeForJsxAttribute(attribute: JsxAttribute | JsxSpreadAttribute): Type | undefined;
-    /* @internal */ isContextSensitive(node: Expression | MethodDeclaration | ObjectLiteralElementLike | JsxAttributeLike): boolean;
-    /* @internal */ getTypeOfPropertyOfContextualType(type: Type, name: __String): Type | undefined;
+    /** @internal */ getContextualType(node: Expression, contextFlags?: ContextFlags): Type | undefined; // eslint-disable-line @typescript-eslint/unified-signatures
+    /** @internal */ getContextualTypeForObjectLiteralElement(element: ObjectLiteralElementLike): Type | undefined;
+    /** @internal */ getContextualTypeForArgumentAtIndex(call: CallLikeExpression, argIndex: number): Type | undefined;
+    /** @internal */ getContextualTypeForJsxAttribute(attribute: JsxAttribute | JsxSpreadAttribute): Type | undefined;
+    /** @internal */ isContextSensitive(node: Expression | MethodDeclaration | ObjectLiteralElementLike | JsxAttributeLike): boolean;
+    /** @internal */ getTypeOfPropertyOfContextualType(type: Type, name: __String): Type | undefined;
 
     /**
      * returns unknownSignature in the case of an error.
@@ -4676,31 +4676,31 @@ export interface TypeChecker {
      * @param argumentCount Apparent number of arguments, passed in case of a possibly incomplete call. This should come from an ArgumentListInfo. See `signatureHelp.ts`.
      */
     getResolvedSignature(node: CallLikeExpression, candidatesOutArray?: Signature[], argumentCount?: number): Signature | undefined;
-    /* @internal */ getResolvedSignatureForSignatureHelp(node: CallLikeExpression, candidatesOutArray?: Signature[], argumentCount?: number): Signature | undefined;
-    /* @internal */ getResolvedSignatureForStringLiteralCompletions(call: CallLikeExpression, editingArgument: Node, candidatesOutArray: Signature[]): Signature | undefined;
-    /* @internal */ getExpandedParameters(sig: Signature): readonly (readonly Symbol[])[];
-    /* @internal */ hasEffectiveRestParameter(sig: Signature): boolean;
-    /* @internal */ containsArgumentsReference(declaration: SignatureDeclaration): boolean;
+    /** @internal */ getResolvedSignatureForSignatureHelp(node: CallLikeExpression, candidatesOutArray?: Signature[], argumentCount?: number): Signature | undefined;
+    /** @internal */ getResolvedSignatureForStringLiteralCompletions(call: CallLikeExpression, editingArgument: Node, candidatesOutArray: Signature[]): Signature | undefined;
+    /** @internal */ getExpandedParameters(sig: Signature): readonly (readonly Symbol[])[];
+    /** @internal */ hasEffectiveRestParameter(sig: Signature): boolean;
+    /** @internal */ containsArgumentsReference(declaration: SignatureDeclaration): boolean;
 
     getSignatureFromDeclaration(declaration: SignatureDeclaration): Signature | undefined;
     isImplementationOfOverload(node: SignatureDeclaration): boolean | undefined;
     isUndefinedSymbol(symbol: Symbol): boolean;
     isArgumentsSymbol(symbol: Symbol): boolean;
     isUnknownSymbol(symbol: Symbol): boolean;
-    /* @internal */ getMergedSymbol(symbol: Symbol): Symbol;
+    /** @internal */ getMergedSymbol(symbol: Symbol): Symbol;
 
     getConstantValue(node: EnumMember | PropertyAccessExpression | ElementAccessExpression): string | number | undefined;
     isValidPropertyAccess(node: PropertyAccessExpression | QualifiedName | ImportTypeNode, propertyName: string): boolean;
     /** Exclude accesses to private properties. */
-    /* @internal */ isValidPropertyAccessForCompletions(node: PropertyAccessExpression | ImportTypeNode | QualifiedName, type: Type, property: Symbol): boolean;
+    /** @internal */ isValidPropertyAccessForCompletions(node: PropertyAccessExpression | ImportTypeNode | QualifiedName, type: Type, property: Symbol): boolean;
     /** Follow all aliases to get the original symbol. */
     getAliasedSymbol(symbol: Symbol): Symbol;
     /** Follow a *single* alias to get the immediately aliased symbol. */
     getImmediateAliasedSymbol(symbol: Symbol): Symbol | undefined;
     getExportsOfModule(moduleSymbol: Symbol): Symbol[];
     /** Unlike `getExportsOfModule`, this includes properties of an `export =` value. */
-    /* @internal */ getExportsAndPropertiesOfModule(moduleSymbol: Symbol): Symbol[];
-    /* @internal */ forEachExportAndPropertyOfModule(moduleSymbol: Symbol, cb: (symbol: Symbol, key: __String) => void): void;
+    /** @internal */ getExportsAndPropertiesOfModule(moduleSymbol: Symbol): Symbol[];
+    /** @internal */ forEachExportAndPropertyOfModule(moduleSymbol: Symbol, cb: (symbol: Symbol, key: __String) => void): void;
     getJsxIntrinsicTagNamesAt(location: Node): Symbol[];
     isOptionalParameter(node: ParameterDeclaration): boolean;
     getAmbientModules(): Symbol[];
@@ -4710,41 +4710,41 @@ export interface TypeChecker {
      * Unlike `tryGetMemberInModuleExports`, this includes properties of an `export =` value.
      * Does *not* return properties of primitive types.
      */
-    /* @internal */ tryGetMemberInModuleExportsAndProperties(memberName: string, moduleSymbol: Symbol): Symbol | undefined;
+    /** @internal */ tryGetMemberInModuleExportsAndProperties(memberName: string, moduleSymbol: Symbol): Symbol | undefined;
     getApparentType(type: Type): Type;
-    /* @internal */ getSuggestedSymbolForNonexistentProperty(name: MemberName | string, containingType: Type): Symbol | undefined;
-    /* @internal */ getSuggestedSymbolForNonexistentJSXAttribute(name: Identifier | string, containingType: Type): Symbol | undefined;
-    /* @internal */ getSuggestionForNonexistentProperty(name: MemberName | string, containingType: Type): string | undefined;
-    /* @internal */ getSuggestedSymbolForNonexistentSymbol(location: Node, name: string, meaning: SymbolFlags): Symbol | undefined;
-    /* @internal */ getSuggestionForNonexistentSymbol(location: Node, name: string, meaning: SymbolFlags): string | undefined;
-    /* @internal */ getSuggestedSymbolForNonexistentModule(node: Identifier, target: Symbol): Symbol | undefined;
-    /* @internal */ getSuggestedSymbolForNonexistentClassMember(name: string, baseType: Type): Symbol | undefined;
-    /* @internal */ getSuggestionForNonexistentExport(node: Identifier, target: Symbol): string | undefined;
+    /** @internal */ getSuggestedSymbolForNonexistentProperty(name: MemberName | string, containingType: Type): Symbol | undefined;
+    /** @internal */ getSuggestedSymbolForNonexistentJSXAttribute(name: Identifier | string, containingType: Type): Symbol | undefined;
+    /** @internal */ getSuggestionForNonexistentProperty(name: MemberName | string, containingType: Type): string | undefined;
+    /** @internal */ getSuggestedSymbolForNonexistentSymbol(location: Node, name: string, meaning: SymbolFlags): Symbol | undefined;
+    /** @internal */ getSuggestionForNonexistentSymbol(location: Node, name: string, meaning: SymbolFlags): string | undefined;
+    /** @internal */ getSuggestedSymbolForNonexistentModule(node: Identifier, target: Symbol): Symbol | undefined;
+    /** @internal */ getSuggestedSymbolForNonexistentClassMember(name: string, baseType: Type): Symbol | undefined;
+    /** @internal */ getSuggestionForNonexistentExport(node: Identifier, target: Symbol): string | undefined;
     getBaseConstraintOfType(type: Type): Type | undefined;
     getDefaultFromTypeParameter(type: Type): Type | undefined;
 
-    /* @internal */ getAnyType(): Type;
-    /* @internal */ getStringType(): Type;
-    /* @internal */ getNumberType(): Type;
-    /* @internal */ getBooleanType(): Type;
-    /* @internal */ getFalseType(fresh?: boolean): Type;
-    /* @internal */ getTrueType(fresh?: boolean): Type;
-    /* @internal */ getVoidType(): Type;
-    /* @internal */ getUndefinedType(): Type;
-    /* @internal */ getNullType(): Type;
-    /* @internal */ getESSymbolType(): Type;
-    /* @internal */ getNeverType(): Type;
-    /* @internal */ getOptionalType(): Type;
-    /* @internal */ getUnionType(types: Type[], subtypeReduction?: UnionReduction): Type;
-    /* @internal */ createArrayType(elementType: Type): Type;
-    /* @internal */ getElementTypeOfArrayType(arrayType: Type): Type | undefined;
-    /* @internal */ createPromiseType(type: Type): Type;
-    /* @internal */ getPromiseType(): Type;
-    /* @internal */ getPromiseLikeType(): Type;
-
-    /* @internal */ isTypeAssignableTo(source: Type, target: Type): boolean;
-    /* @internal */ createAnonymousType(symbol: Symbol | undefined, members: SymbolTable, callSignatures: Signature[], constructSignatures: Signature[], indexInfos: IndexInfo[]): Type;
-    /* @internal */ createSignature(
+    /** @internal */ getAnyType(): Type;
+    /** @internal */ getStringType(): Type;
+    /** @internal */ getNumberType(): Type;
+    /** @internal */ getBooleanType(): Type;
+    /** @internal */ getFalseType(fresh?: boolean): Type;
+    /** @internal */ getTrueType(fresh?: boolean): Type;
+    /** @internal */ getVoidType(): Type;
+    /** @internal */ getUndefinedType(): Type;
+    /** @internal */ getNullType(): Type;
+    /** @internal */ getESSymbolType(): Type;
+    /** @internal */ getNeverType(): Type;
+    /** @internal */ getOptionalType(): Type;
+    /** @internal */ getUnionType(types: Type[], subtypeReduction?: UnionReduction): Type;
+    /** @internal */ createArrayType(elementType: Type): Type;
+    /** @internal */ getElementTypeOfArrayType(arrayType: Type): Type | undefined;
+    /** @internal */ createPromiseType(type: Type): Type;
+    /** @internal */ getPromiseType(): Type;
+    /** @internal */ getPromiseLikeType(): Type;
+
+    /** @internal */ isTypeAssignableTo(source: Type, target: Type): boolean;
+    /** @internal */ createAnonymousType(symbol: Symbol | undefined, members: SymbolTable, callSignatures: Signature[], constructSignatures: Signature[], indexInfos: IndexInfo[]): Type;
+    /** @internal */ createSignature(
         declaration: SignatureDeclaration | undefined,
         typeParameters: readonly TypeParameter[] | undefined,
         thisParameter: Symbol | undefined,
@@ -4754,47 +4754,47 @@ export interface TypeChecker {
         minArgumentCount: number,
         flags: SignatureFlags
     ): Signature;
-    /* @internal */ createSymbol(flags: SymbolFlags, name: __String): TransientSymbol;
-    /* @internal */ createIndexInfo(keyType: Type, type: Type, isReadonly: boolean, declaration?: SignatureDeclaration): IndexInfo;
-    /* @internal */ isSymbolAccessible(symbol: Symbol, enclosingDeclaration: Node | undefined, meaning: SymbolFlags, shouldComputeAliasToMarkVisible: boolean): SymbolAccessibilityResult;
-    /* @internal */ tryFindAmbientModule(moduleName: string): Symbol | undefined;
-    /* @internal */ tryFindAmbientModuleWithoutAugmentations(moduleName: string): Symbol | undefined;
+    /** @internal */ createSymbol(flags: SymbolFlags, name: __String): TransientSymbol;
+    /** @internal */ createIndexInfo(keyType: Type, type: Type, isReadonly: boolean, declaration?: SignatureDeclaration): IndexInfo;
+    /** @internal */ isSymbolAccessible(symbol: Symbol, enclosingDeclaration: Node | undefined, meaning: SymbolFlags, shouldComputeAliasToMarkVisible: boolean): SymbolAccessibilityResult;
+    /** @internal */ tryFindAmbientModule(moduleName: string): Symbol | undefined;
+    /** @internal */ tryFindAmbientModuleWithoutAugmentations(moduleName: string): Symbol | undefined;
 
-    /* @internal */ getSymbolWalker(accept?: (symbol: Symbol) => boolean): SymbolWalker;
+    /** @internal */ getSymbolWalker(accept?: (symbol: Symbol) => boolean): SymbolWalker;
 
     // Should not be called directly.  Should only be accessed through the Program instance.
-    /* @internal */ getDiagnostics(sourceFile?: SourceFile, cancellationToken?: CancellationToken): Diagnostic[];
-    /* @internal */ getGlobalDiagnostics(): Diagnostic[];
-    /* @internal */ getEmitResolver(sourceFile?: SourceFile, cancellationToken?: CancellationToken): EmitResolver;
-
-    /* @internal */ getNodeCount(): number;
-    /* @internal */ getIdentifierCount(): number;
-    /* @internal */ getSymbolCount(): number;
-    /* @internal */ getTypeCount(): number;
-    /* @internal */ getInstantiationCount(): number;
-    /* @internal */ getRelationCacheSizes(): { assignable: number, identity: number, subtype: number, strictSubtype: number };
-    /* @internal */ getRecursionIdentity(type: Type): object | undefined;
-    /* @internal */ getUnmatchedProperties(source: Type, target: Type, requireOptionalProperties: boolean, matchDiscriminantProperties: boolean): IterableIterator<Symbol>;
-
-    /* @internal */ isArrayType(type: Type): boolean;
-    /* @internal */ isTupleType(type: Type): boolean;
-    /* @internal */ isArrayLikeType(type: Type): boolean;
+    /** @internal */ getDiagnostics(sourceFile?: SourceFile, cancellationToken?: CancellationToken): Diagnostic[];
+    /** @internal */ getGlobalDiagnostics(): Diagnostic[];
+    /** @internal */ getEmitResolver(sourceFile?: SourceFile, cancellationToken?: CancellationToken): EmitResolver;
+
+    /** @internal */ getNodeCount(): number;
+    /** @internal */ getIdentifierCount(): number;
+    /** @internal */ getSymbolCount(): number;
+    /** @internal */ getTypeCount(): number;
+    /** @internal */ getInstantiationCount(): number;
+    /** @internal */ getRelationCacheSizes(): { assignable: number, identity: number, subtype: number, strictSubtype: number };
+    /** @internal */ getRecursionIdentity(type: Type): object | undefined;
+    /** @internal */ getUnmatchedProperties(source: Type, target: Type, requireOptionalProperties: boolean, matchDiscriminantProperties: boolean): IterableIterator<Symbol>;
+
+    /** @internal */ isArrayType(type: Type): boolean;
+    /** @internal */ isTupleType(type: Type): boolean;
+    /** @internal */ isArrayLikeType(type: Type): boolean;
 
     /**
      * True if `contextualType` should not be considered for completions because
      * e.g. it specifies `kind: "a"` and obj has `kind: "b"`.
      */
-    /* @internal */ isTypeInvalidDueToUnionDiscriminant(contextualType: Type, obj: ObjectLiteralExpression | JsxAttributes): boolean;
-    /* @internal */ getExactOptionalProperties(type: Type): Symbol[];
+    /** @internal */ isTypeInvalidDueToUnionDiscriminant(contextualType: Type, obj: ObjectLiteralExpression | JsxAttributes): boolean;
+    /** @internal */ getExactOptionalProperties(type: Type): Symbol[];
     /**
      * For a union, will include a property if it's defined in *any* of the member types.
      * So for `{ a } | { b }`, this will include both `a` and `b`.
      * Does not include properties of primitive types.
      */
-    /* @internal */ getAllPossiblePropertiesOfTypes(type: readonly Type[]): Symbol[];
-    /* @internal */ resolveName(name: string, location: Node | undefined, meaning: SymbolFlags, excludeGlobals: boolean): Symbol | undefined;
-    /* @internal */ getJsxNamespace(location?: Node): string;
-    /* @internal */ getJsxFragmentFactory(location: Node): string | undefined;
+    /** @internal */ getAllPossiblePropertiesOfTypes(type: readonly Type[]): Symbol[];
+    /** @internal */ resolveName(name: string, location: Node | undefined, meaning: SymbolFlags, excludeGlobals: boolean): Symbol | undefined;
+    /** @internal */ getJsxNamespace(location?: Node): string;
+    /** @internal */ getJsxFragmentFactory(location: Node): string | undefined;
 
     /**
      * Note that this will return undefined in the following case:
@@ -4805,23 +4805,23 @@ export interface TypeChecker {
      * Where `C` is the symbol we're looking for.
      * This should be called in a loop climbing parents of the symbol, so we'll get `N`.
      */
-    /* @internal */ getAccessibleSymbolChain(symbol: Symbol, enclosingDeclaration: Node | undefined, meaning: SymbolFlags, useOnlyExternalAliasing: boolean): Symbol[] | undefined;
+    /** @internal */ getAccessibleSymbolChain(symbol: Symbol, enclosingDeclaration: Node | undefined, meaning: SymbolFlags, useOnlyExternalAliasing: boolean): Symbol[] | undefined;
     getTypePredicateOfSignature(signature: Signature): TypePredicate | undefined;
-    /* @internal */ resolveExternalModuleName(moduleSpecifier: Expression): Symbol | undefined;
+    /** @internal */ resolveExternalModuleName(moduleSpecifier: Expression): Symbol | undefined;
     /**
      * An external module with an 'export =' declaration resolves to the target of the 'export =' declaration,
      * and an external module with no 'export =' declaration resolves to the module itself.
      */
-    /* @internal */ resolveExternalModuleSymbol(symbol: Symbol): Symbol;
+    /** @internal */ resolveExternalModuleSymbol(symbol: Symbol): Symbol;
     /** @param node A location where we might consider accessing `this`. Not necessarily a ThisExpression. */
-    /* @internal */ tryGetThisTypeAt(node: Node, includeGlobalThis?: boolean, container?: Node): Type | undefined;
-    /* @internal */ getTypeArgumentConstraint(node: TypeNode): Type | undefined;
+    /** @internal */ tryGetThisTypeAt(node: Node, includeGlobalThis?: boolean, container?: Node): Type | undefined;
+    /** @internal */ getTypeArgumentConstraint(node: TypeNode): Type | undefined;
 
     /**
      * Does *not* get *all* suggestion diagnostics, just the ones that were convenient to report in the checker.
      * Others are added in computeSuggestionDiagnostics.
      */
-    /* @internal */ getSuggestionDiagnostics(file: SourceFile, cancellationToken?: CancellationToken): readonly DiagnosticWithLocation[];
+    /** @internal */ getSuggestionDiagnostics(file: SourceFile, cancellationToken?: CancellationToken): readonly DiagnosticWithLocation[];
 
     /**
      * Depending on the operation performed, it may be appropriate to throw away the checker
@@ -4830,28 +4830,28 @@ export interface TypeChecker {
      */
     runWithCancellationToken<T>(token: CancellationToken, cb: (checker: TypeChecker) => T): T;
 
-    /* @internal */ getLocalTypeParametersOfClassOrInterfaceOrTypeAlias(symbol: Symbol): readonly TypeParameter[] | undefined;
-    /* @internal */ isDeclarationVisible(node: Declaration | AnyImportSyntax): boolean;
-    /* @internal */ isPropertyAccessible(node: Node, isSuper: boolean, isWrite: boolean, containingType: Type, property: Symbol): boolean;
-    /* @internal */ getTypeOnlyAliasDeclaration(symbol: Symbol): TypeOnlyAliasDeclaration | undefined;
-    /* @internal */ getMemberOverrideModifierStatus(node: ClassLikeDeclaration, member: ClassElement): MemberOverrideStatus;
+    /** @internal */ getLocalTypeParametersOfClassOrInterfaceOrTypeAlias(symbol: Symbol): readonly TypeParameter[] | undefined;
+    /** @internal */ isDeclarationVisible(node: Declaration | AnyImportSyntax): boolean;
+    /** @internal */ isPropertyAccessible(node: Node, isSuper: boolean, isWrite: boolean, containingType: Type, property: Symbol): boolean;
+    /** @internal */ getTypeOnlyAliasDeclaration(symbol: Symbol): TypeOnlyAliasDeclaration | undefined;
+    /** @internal */ getMemberOverrideModifierStatus(node: ClassLikeDeclaration, member: ClassElement): MemberOverrideStatus;
 }
 
-/* @internal */
+/** @internal */
 export const enum MemberOverrideStatus {
     Ok,
     NeedsOverride,
     HasInvalidOverride
 }
 
-/* @internal */
+/** @internal */
 export const enum UnionReduction {
     None = 0,
     Literal,
     Subtype,
 }
 
-/* @internal */
+/** @internal */
 export const enum ContextFlags {
     None           = 0,
     Signature      = 1 << 0, // Obtaining contextual signature
@@ -4893,11 +4893,11 @@ export const enum NodeBuilderFlags {
     AllowEmptyTuple                         = 1 << 19,
     AllowUniqueESSymbolType                 = 1 << 20,
     AllowEmptyIndexInfoType                 = 1 << 21,
-    /* @internal */ WriteComputedProps      = 1 << 30, // { [E.A]: 1 }
+    /** @internal */ WriteComputedProps      = 1 << 30, // { [E.A]: 1 }
 
     // Errors (cont.)
     AllowNodeModulesRelativePaths           = 1 << 26,
-    /* @internal */ DoNotIncludeSymbolChain = 1 << 27,    // Skip looking up and printing an accessible symbol chain
+    /** @internal */ DoNotIncludeSymbolChain = 1 << 27,    // Skip looking up and printing an accessible symbol chain
 
     IgnoreErrors = AllowThisInObjectLiteral | AllowQualifiedNameInPlaceOfIdentifier | AllowAnonymousIdentifier | AllowEmptyUnionOrIntersection | AllowEmptyTuple | AllowEmptyIndexInfoType | AllowNodeModulesRelativePaths,
 
@@ -4972,13 +4972,13 @@ export const enum SymbolFormatFlags {
     UseAliasDefinedOutsideCurrentScope      = 1 << 3,
 
     // { [E.A]: 1 }
-    /* @internal */ WriteComputedProps      = 1 << 4,
+    /** @internal */ WriteComputedProps      = 1 << 4,
 
     // Skip building an accessible symbol chain
-    /* @internal */ DoNotIncludeSymbolChain = 1 << 5,
+    /** @internal */ DoNotIncludeSymbolChain = 1 << 5,
 }
 
-/* @internal */
+/** @internal */
 export interface SymbolWalker {
     /** Note: Return values are not ordered. */
     walkType(root: Type): { visitedTypes: readonly Type[], visitedSymbols: readonly Symbol[] };
@@ -4987,7 +4987,7 @@ export interface SymbolWalker {
 }
 
 // This was previously deprecated in our public API, but is still used internally
-/* @internal */
+/** @internal */
 interface SymbolWriter extends SymbolTracker {
     writeKeyword(text: string): void;
     writeOperator(text: string): void;
@@ -5003,14 +5003,14 @@ interface SymbolWriter extends SymbolTracker {
     clear(): void;
 }
 
-/* @internal */
+/** @internal */
 export const enum SymbolAccessibility {
     Accessible,
     NotAccessible,
     CannotBeNamed
 }
 
-/* @internal */
+/** @internal */
 export const enum SyntheticSymbolKind {
     UnionOrIntersection,
     Spread
@@ -5058,52 +5058,52 @@ export interface AssertsIdentifierTypePredicate extends TypePredicateBase {
 
 export type TypePredicate = ThisTypePredicate | IdentifierTypePredicate | AssertsThisTypePredicate | AssertsIdentifierTypePredicate;
 
-/* @internal */
+/** @internal */
 export type AnyImportSyntax = ImportDeclaration | ImportEqualsDeclaration;
 
-/* @internal */
+/** @internal */
 export type AnyImportOrRequire = AnyImportSyntax | VariableDeclarationInitializedTo<RequireOrImportCall>;
 
-/* @internal */
+/** @internal */
 export type AnyImportOrBareOrAccessedRequire = AnyImportSyntax | VariableDeclarationInitializedTo<RequireOrImportCall | AccessExpression>;
 
-/* @internal */
+/** @internal */
 export type AnyImportOrRequireStatement = AnyImportSyntax | RequireVariableStatement;
 
-/* @internal */
+/** @internal */
 export type AnyImportOrReExport = AnyImportSyntax | ExportDeclaration;
 
-/* @internal */
+/** @internal */
 export interface ValidImportTypeNode extends ImportTypeNode {
     argument: LiteralTypeNode & { literal: StringLiteral };
 }
 
-/* @internal */
+/** @internal */
 export type AnyValidImportOrReExport =
     | (ImportDeclaration | ExportDeclaration) & { moduleSpecifier: StringLiteral }
     | ImportEqualsDeclaration & { moduleReference: ExternalModuleReference & { expression: StringLiteral } }
     | RequireOrImportCall
     | ValidImportTypeNode;
 
-/* @internal */
+/** @internal */
 export type RequireOrImportCall = CallExpression & { expression: Identifier, arguments: [StringLiteralLike] };
 
-/* @internal */
+/** @internal */
 export interface VariableDeclarationInitializedTo<T extends Expression> extends VariableDeclaration {
     readonly initializer: T;
 }
 
-/* @internal */
+/** @internal */
 export interface RequireVariableStatement extends VariableStatement {
     readonly declarationList: RequireVariableDeclarationList;
 }
 
-/* @internal */
+/** @internal */
 export interface RequireVariableDeclarationList extends VariableDeclarationList {
     readonly declarations: NodeArray<VariableDeclarationInitializedTo<RequireOrImportCall>>;
 }
 
-/* @internal */
+/** @internal */
 export type LateVisibilityPaintedStatement =
     | AnyImportSyntax
     | VariableStatement
@@ -5114,7 +5114,7 @@ export type LateVisibilityPaintedStatement =
     | InterfaceDeclaration
     | EnumDeclaration;
 
-/* @internal */
+/** @internal */
 export interface SymbolVisibilityResult {
     accessibility: SymbolAccessibility;
     aliasesToMakeVisible?: LateVisibilityPaintedStatement[]; // aliases that need to have this symbol visible
@@ -5122,12 +5122,12 @@ export interface SymbolVisibilityResult {
     errorNode?: Node; // optional node that results in error
 }
 
-/* @internal */
+/** @internal */
 export interface SymbolAccessibilityResult extends SymbolVisibilityResult {
     errorModuleName?: string; // If the symbol is not visible from module, module's name
 }
 
-/* @internal */
+/** @internal */
 export interface AllAccessorDeclarations {
     firstAccessor: AccessorDeclaration;
     secondAccessor: AccessorDeclaration | undefined;
@@ -5135,7 +5135,7 @@ export interface AllAccessorDeclarations {
     setAccessor: SetAccessorDeclaration | undefined;
 }
 
-/* @internal */
+/** @internal */
 export interface AllDecorators {
     decorators: readonly Decorator[] | undefined;
     parameters?: readonly (readonly Decorator[] | undefined)[];
@@ -5144,7 +5144,7 @@ export interface AllDecorators {
 }
 
 /** Indicates how to serialize the name for a TypeReferenceNode when emitting decorator metadata */
-/* @internal */
+/** @internal */
 export enum TypeReferenceSerializationKind {
     // The TypeReferenceNode could not be resolved.
     // The type name should be emitted using a safe fallback.
@@ -5187,7 +5187,7 @@ export enum TypeReferenceSerializationKind {
     ObjectType,
 }
 
-/* @internal */
+/** @internal */
 export interface EmitResolver {
     hasGlobalName(name: string): boolean;
     getReferencedExportContainer(node: Identifier, prefixLocals?: boolean): SourceFile | ModuleDeclaration | EnumDeclaration | undefined;
@@ -5262,7 +5262,7 @@ export const enum SymbolFlags {
     Transient               = 1 << 25,  // Transient symbol (created during type check)
     Assignment              = 1 << 26,  // Assignment treated as declaration (eg `this.prop = 1`)
     ModuleExports           = 1 << 27,  // Symbol for CommonJS `module` of `module.exports`
-    /* @internal */
+    /** @internal */
     All = FunctionScopedVariable | BlockScopedVariable | Property | EnumMember | Function | Class | Interface | ConstEnum | RegularEnum | ValueModule | NamespaceModule | TypeLiteral
         | ObjectLiteral | Method | Constructor | GetAccessor | SetAccessor | Signature | TypeParameter | TypeAlias | ExportValue | Alias | Prototype | ExportStar | Optional | Transient,
 
@@ -5309,22 +5309,22 @@ export const enum SymbolFlags {
 
     ClassMember = Method | Accessor | Property,
 
-    /* @internal */
+    /** @internal */
     ExportSupportsDefaultModifier = Class | Function | Interface,
 
-    /* @internal */
+    /** @internal */
     ExportDoesNotSupportDefaultModifier = ~ExportSupportsDefaultModifier,
 
-    /* @internal */
+    /** @internal */
     // The set of things we consider semantically classifiable.  Used to speed up the LS during
     // classification.
     Classifiable = Class | Enum | TypeAlias | Interface | TypeParameter | Module | Alias,
 
-    /* @internal */
+    /** @internal */
     LateBindingContainer = Class | Interface | TypeLiteral | ObjectLiteral | Function,
 }
 
-/* @internal */
+/** @internal */
 export type SymbolId = number;
 
 export interface Symbol {
@@ -5335,18 +5335,18 @@ export interface Symbol {
     members?: SymbolTable;                  // Class, interface or object literal instance members
     exports?: SymbolTable;                  // Module exports
     globalExports?: SymbolTable;            // Conditional global UMD exports
-    /* @internal */ id?: SymbolId;          // Unique id (used to look up SymbolLinks)
-    /* @internal */ mergeId?: number;       // Merge id (used to look up merged symbol)
-    /* @internal */ parent?: Symbol;        // Parent symbol
-    /* @internal */ exportSymbol?: Symbol;  // Exported symbol associated with this symbol
-    /* @internal */ constEnumOnlyModule?: boolean; // True if module contains only const enums or other modules with only const enums
-    /* @internal */ isReferenced?: SymbolFlags; // True if the symbol is referenced elsewhere. Keeps track of the meaning of a reference in case a symbol is both a type parameter and parameter.
-    /* @internal */ isReplaceableByMethod?: boolean; // Can this Javascript class property be replaced by a method symbol?
-    /* @internal */ isAssigned?: boolean;   // True if the symbol is a parameter with assignments
-    /* @internal */ assignmentDeclarationMembers?: ESMap<number, Declaration>; // detected late-bound assignment declarations associated with the symbol
-}
-
-/* @internal */
+    /** @internal */ id?: SymbolId;          // Unique id (used to look up SymbolLinks)
+    /** @internal */ mergeId?: number;       // Merge id (used to look up merged symbol)
+    /** @internal */ parent?: Symbol;        // Parent symbol
+    /** @internal */ exportSymbol?: Symbol;  // Exported symbol associated with this symbol
+    /** @internal */ constEnumOnlyModule?: boolean; // True if module contains only const enums or other modules with only const enums
+    /** @internal */ isReferenced?: SymbolFlags; // True if the symbol is referenced elsewhere. Keeps track of the meaning of a reference in case a symbol is both a type parameter and parameter.
+    /** @internal */ isReplaceableByMethod?: boolean; // Can this Javascript class property be replaced by a method symbol?
+    /** @internal */ isAssigned?: boolean;   // True if the symbol is a parameter with assignments
+    /** @internal */ assignmentDeclarationMembers?: ESMap<number, Declaration>; // detected late-bound assignment declarations associated with the symbol
+}
+
+/** @internal */
 export interface SymbolLinks {
     immediateTarget?: Symbol;                   // Immediate target of an alias. May be another alias. Do not access directly, use `checker.getImmediateAliasedSymbol` instead.
     aliasTarget?: Symbol,                       // Resolved (non-alias) target of an alias
@@ -5395,13 +5395,13 @@ export interface SymbolLinks {
     filteredIndexSymbolCache?: ESMap<string, Symbol> //Symbol with applicable declarations
 }
 
-/* @internal */
+/** @internal */
 export const enum EnumKind {
     Numeric,                            // Numeric enum (each member has a TypeFlags.Enum type)
     Literal                             // Literal enum (each member has a TypeFlags.EnumLiteral type)
 }
 
-/* @internal */
+/** @internal */
 export const enum CheckFlags {
     Instantiated      = 1 << 0,         // Instantiated symbol
     SyntheticProperty = 1 << 1,         // Property in union or intersection type
@@ -5429,18 +5429,18 @@ export const enum CheckFlags {
     Partial = ReadPartial | WritePartial
 }
 
-/* @internal */
+/** @internal */
 export interface TransientSymbol extends Symbol, SymbolLinks {
     checkFlags: CheckFlags;
 }
 
-/* @internal */
+/** @internal */
 export interface MappedSymbol extends TransientSymbol {
     mappedType: MappedType;
     keyType: Type;
 }
 
-/* @internal */
+/** @internal */
 export interface ReverseMappedSymbol extends TransientSymbol {
     propertyType: Type;
     mappedType: MappedType;
@@ -5489,13 +5489,13 @@ export interface UnderscoreEscapedMap<T> extends ESMap<__String, T>, ReadonlyUnd
 export type SymbolTable = UnderscoreEscapedMap<Symbol>;
 
 /** Used to track a `declare module "foo*"`-like declaration. */
-/* @internal */
+/** @internal */
 export interface PatternAmbientModule {
     pattern: Pattern;
     symbol: Symbol;
 }
 
-/* @internal */
+/** @internal */
 export const enum NodeCheckFlags {
     TypeChecked                              = 0x00000001,  // Node has been type checked
     LexicalThis                              = 0x00000002,  // Lexical 'this' reference
@@ -5524,7 +5524,7 @@ export const enum NodeCheckFlags {
     InCheckIdentifier                        = 0x10000000,
 }
 
-/* @internal */
+/** @internal */
 export interface NodeLinks {
     flags: NodeCheckFlags;              // Set of flags specific to Node
     resolvedType?: Type;                // Cached type of type node
@@ -5585,21 +5585,21 @@ export const enum TypeFlags {
     TemplateLiteral = 1 << 27,  // Template literal type
     StringMapping   = 1 << 28,  // Uppercase/Lowercase type
 
-    /* @internal */
+    /** @internal */
     AnyOrUnknown = Any | Unknown,
-    /* @internal */
+    /** @internal */
     Nullable = Undefined | Null,
     Literal = StringLiteral | NumberLiteral | BigIntLiteral | BooleanLiteral,
     Unit = Literal | UniqueESSymbol | Nullable,
     StringOrNumberLiteral = StringLiteral | NumberLiteral,
-    /* @internal */
+    /** @internal */
     StringOrNumberLiteralOrUnique = StringLiteral | NumberLiteral | UniqueESSymbol,
-    /* @internal */
+    /** @internal */
     DefinitelyFalsy = StringLiteral | NumberLiteral | BigIntLiteral | BooleanLiteral | Void | Undefined | Null,
     PossiblyFalsy = DefinitelyFalsy | String | Number | BigInt | Boolean,
-    /* @internal */
+    /** @internal */
     Intrinsic = Any | Unknown | String | Number | BigInt | Boolean | BooleanLiteral | ESSymbol | Void | Undefined | Null | Never | NonPrimitive,
-    /* @internal */
+    /** @internal */
     Primitive = String | Number | BigInt | Boolean | Enum | EnumLiteral | ESSymbol | Void | Undefined | Null | Literal | UniqueESSymbol,
     StringLike = String | StringLiteral | TemplateLiteral | StringMapping,
     NumberLike = Number | NumberLiteral | Enum,
@@ -5608,9 +5608,9 @@ export const enum TypeFlags {
     EnumLike = Enum | EnumLiteral,
     ESSymbolLike = ESSymbol | UniqueESSymbol,
     VoidLike = Void | Undefined,
-    /* @internal */
+    /** @internal */
     DefinitelyNonNullable = StringLike | NumberLike | BigIntLike | BooleanLike | EnumLike | ESSymbolLike | Object | NonPrimitive,
-    /* @internal */
+    /** @internal */
     DisjointDomains = NonPrimitive | StringLike | NumberLike | BigIntLike | BooleanLike | ESSymbolLike | VoidLike | Null,
     UnionOrIntersection = Union | Intersection,
     StructuredType = Object | Union | Intersection,
@@ -5619,78 +5619,78 @@ export const enum TypeFlags {
     InstantiablePrimitive = Index | TemplateLiteral | StringMapping,
     Instantiable = InstantiableNonPrimitive | InstantiablePrimitive,
     StructuredOrInstantiable = StructuredType | Instantiable,
-    /* @internal */
+    /** @internal */
     ObjectFlagsType = Any | Nullable | Never | Object | Union | Intersection,
-    /* @internal */
+    /** @internal */
     Simplifiable = IndexedAccess | Conditional,
-    /* @internal */
+    /** @internal */
     Singleton = Any | Unknown | String | Number | Boolean | BigInt | ESSymbol | Void | Undefined | Null | Never | NonPrimitive,
     // 'Narrowable' types are types where narrowing actually narrows.
     // This *should* be every type other than null, undefined, void, and never
     Narrowable = Any | Unknown | StructuredOrInstantiable | StringLike | NumberLike | BigIntLike | BooleanLike | ESSymbol | UniqueESSymbol | NonPrimitive,
     // The following flags are aggregated during union and intersection type construction
-    /* @internal */
+    /** @internal */
     IncludesMask = Any | Unknown | Primitive | Never | Object | Union | Intersection | NonPrimitive | TemplateLiteral,
     // The following flags are used for different purposes during union and intersection type construction
-    /* @internal */
+    /** @internal */
     IncludesMissingType = TypeParameter,
-    /* @internal */
+    /** @internal */
     IncludesNonWideningType = Index,
-    /* @internal */
+    /** @internal */
     IncludesWildcard = IndexedAccess,
-    /* @internal */
+    /** @internal */
     IncludesEmptyObject = Conditional,
-    /* @internal */
+    /** @internal */
     IncludesInstantiable = Substitution,
-    /* @internal */
+    /** @internal */
     NotPrimitiveUnion = Any | Unknown | Enum | Void | Never | Object | Intersection | IncludesInstantiable,
 }
 
 export type DestructuringPattern = BindingPattern | ObjectLiteralExpression | ArrayLiteralExpression;
 
-/* @internal */
+/** @internal */
 export type TypeId = number;
 
 // Properties common to all types
 export interface Type {
     flags: TypeFlags;                // Flags
-    /* @internal */ id: TypeId;      // Unique ID
-    /* @internal */ checker: TypeChecker;
+    /** @internal */ id: TypeId;      // Unique ID
+    /** @internal */ checker: TypeChecker;
     symbol: Symbol;                  // Symbol associated with type (if any)
     pattern?: DestructuringPattern;  // Destructuring pattern represented by type (if any)
     aliasSymbol?: Symbol;            // Alias associated with type
     aliasTypeArguments?: readonly Type[]; // Alias type arguments (if any)
-    /* @internal */
+    /** @internal */
     permissiveInstantiation?: Type;  // Instantiation with type parameters mapped to wildcard type
-    /* @internal */
+    /** @internal */
     restrictiveInstantiation?: Type; // Instantiation with type parameters mapped to unconstrained form
-    /* @internal */
+    /** @internal */
     uniqueLiteralFilledInstantiation?: Type;  // Instantiation with type parameters mapped to never type
-    /* @internal */
+    /** @internal */
     immediateBaseConstraint?: Type;  // Immediate base constraint cache
-    /* @internal */
+    /** @internal */
     widened?: Type; // Cached widened form of the type
 }
 
-/* @internal */
+/** @internal */
 // Intrinsic types (TypeFlags.Intrinsic)
 export interface IntrinsicType extends Type {
     intrinsicName: string;        // Name of intrinsic type
     objectFlags: ObjectFlags;
 }
 
-/* @internal */
+/** @internal */
 export interface NullableType extends IntrinsicType {
     objectFlags: ObjectFlags;
 }
 
-/* @internal */
+/** @internal */
 export interface FreshableIntrinsicType extends IntrinsicType {
     freshType: IntrinsicType;     // Fresh version of type
     regularType: IntrinsicType;   // Regular version of type
 }
 
-/* @internal */
+/** @internal */
 export type FreshableType = LiteralType | FreshableIntrinsicType;
 
 // String literal types (TypeFlags.StringLiteral)
@@ -5743,78 +5743,78 @@ export const enum ObjectFlags {
     JSLiteral        = 1 << 12, // Object type declared in JS - disables errors on read/write of nonexisting members
     FreshLiteral     = 1 << 13, // Fresh object literal
     ArrayLiteral     = 1 << 14, // Originates in an array literal
-    /* @internal */
+    /** @internal */
     PrimitiveUnion   = 1 << 15, // Union of only primitive types
-    /* @internal */
+    /** @internal */
     ContainsWideningType = 1 << 16, // Type is or contains undefined or null widening type
-    /* @internal */
+    /** @internal */
     ContainsObjectOrArrayLiteral = 1 << 17, // Type is or contains object literal type
-    /* @internal */
+    /** @internal */
     NonInferrableType = 1 << 18, // Type is or contains anyFunctionType or silentNeverType
-    /* @internal */
+    /** @internal */
     CouldContainTypeVariablesComputed = 1 << 19, // CouldContainTypeVariables flag has been computed
-    /* @internal */
+    /** @internal */
     CouldContainTypeVariables = 1 << 20, // Type could contain a type variable
 
     ClassOrInterface = Class | Interface,
-    /* @internal */
+    /** @internal */
     RequiresWidening = ContainsWideningType | ContainsObjectOrArrayLiteral,
-    /* @internal */
+    /** @internal */
     PropagatingFlags = ContainsWideningType | ContainsObjectOrArrayLiteral | NonInferrableType,
     // Object flags that uniquely identify the kind of ObjectType
-    /* @internal */
+    /** @internal */
     ObjectTypeKindMask = ClassOrInterface | Reference | Tuple | Anonymous | Mapped | ReverseMapped | EvolvingArray,
 
     // Flags that require TypeFlags.Object
     ContainsSpread   = 1 << 21,  // Object literal contains spread operation
     ObjectRestType   = 1 << 22,  // Originates in object rest declaration
     InstantiationExpressionType = 1 << 23,  // Originates in instantiation expression
-    /* @internal */
+    /** @internal */
     IsClassInstanceClone = 1 << 24, // Type is a clone of a class instance type
     // Flags that require TypeFlags.Object and ObjectFlags.Reference
-    /* @internal */
+    /** @internal */
     IdenticalBaseTypeCalculated = 1 << 25, // has had `getSingleBaseForNonAugmentingSubtype` invoked on it already
-    /* @internal */
+    /** @internal */
     IdenticalBaseTypeExists = 1 << 26, // has a defined cachedEquivalentBaseType member
 
     // Flags that require TypeFlags.UnionOrIntersection or TypeFlags.Substitution
-    /* @internal */
+    /** @internal */
     IsGenericTypeComputed = 1 << 21, // IsGenericObjectType flag has been computed
-    /* @internal */
+    /** @internal */
     IsGenericObjectType = 1 << 22, // Union or intersection contains generic object type
-    /* @internal */
+    /** @internal */
     IsGenericIndexType = 1 << 23, // Union or intersection contains generic index type
-    /* @internal */
+    /** @internal */
     IsGenericType = IsGenericObjectType | IsGenericIndexType,
 
     // Flags that require TypeFlags.Union
-    /* @internal */
+    /** @internal */
     ContainsIntersections = 1 << 24, // Union contains intersections
-    /* @internal */
+    /** @internal */
     IsUnknownLikeUnionComputed = 1 << 25, // IsUnknownLikeUnion flag has been computed
-    /* @internal */
+    /** @internal */
     IsUnknownLikeUnion = 1 << 26, // Union of null, undefined, and empty object type
-    /* @internal */
+    /** @internal */
 
     // Flags that require TypeFlags.Intersection
-    /* @internal */
+    /** @internal */
     IsNeverIntersectionComputed = 1 << 24, // IsNeverLike flag has been computed
-    /* @internal */
+    /** @internal */
     IsNeverIntersection = 1 << 25, // Intersection reduces to never
 }
 
-/* @internal */
+/** @internal */
 export type ObjectFlagsType = NullableType | ObjectType | UnionType | IntersectionType;
 
 // Object types (TypeFlags.ObjectType)
 export interface ObjectType extends Type {
     objectFlags: ObjectFlags;
-    /* @internal */ members?: SymbolTable;             // Properties by name
-    /* @internal */ properties?: Symbol[];             // Properties
-    /* @internal */ callSignatures?: readonly Signature[];      // Call signatures of type
-    /* @internal */ constructSignatures?: readonly Signature[]; // Construct signatures of type
-    /* @internal */ indexInfos?: readonly IndexInfo[];  // Index signatures
-    /* @internal */ objectTypeWithoutAbstractConstructSignatures?: ObjectType;
+    /** @internal */ members?: SymbolTable;             // Properties by name
+    /** @internal */ properties?: Symbol[];             // Properties
+    /** @internal */ callSignatures?: readonly Signature[];      // Call signatures of type
+    /** @internal */ constructSignatures?: readonly Signature[]; // Construct signatures of type
+    /** @internal */ indexInfos?: readonly IndexInfo[];  // Index signatures
+    /** @internal */ objectTypeWithoutAbstractConstructSignatures?: ObjectType;
 }
 
 /** Class and interface types (ObjectFlags.Class and ObjectFlags.Interface). */
@@ -5823,11 +5823,11 @@ export interface InterfaceType extends ObjectType {
     outerTypeParameters: TypeParameter[] | undefined; // Outer type parameters (undefined if none)
     localTypeParameters: TypeParameter[] | undefined; // Local type parameters (undefined if none)
     thisType: TypeParameter | undefined;              // The "this" type (undefined if none)
-    /* @internal */
+    /** @internal */
     resolvedBaseConstructorType?: Type;               // Resolved base constructor type of class
-    /* @internal */
+    /** @internal */
     resolvedBaseTypes: BaseType[];                    // Resolved base types
-    /* @internal */
+    /** @internal */
     baseTypesResolved?: boolean;
 }
 
@@ -5854,26 +5854,26 @@ export interface InterfaceTypeWithDeclaredMembers extends InterfaceType {
 export interface TypeReference extends ObjectType {
     target: GenericType;    // Type reference target
     node?: TypeReferenceNode | ArrayTypeNode | TupleTypeNode;
-    /* @internal */
+    /** @internal */
     mapper?: TypeMapper;
-    /* @internal */
+    /** @internal */
     resolvedTypeArguments?: readonly Type[];  // Resolved type reference type arguments
-    /* @internal */
+    /** @internal */
     literalType?: TypeReference;  // Clone of type with ObjectFlags.ArrayLiteral set
-    /* @internal */
+    /** @internal */
     cachedEquivalentBaseType?: Type; // Only set on references to class or interfaces with a single base type and no augmentations
 }
 
 export interface DeferredTypeReference extends TypeReference {
-    /* @internal */
+    /** @internal */
     node: TypeReferenceNode | ArrayTypeNode | TupleTypeNode;
-    /* @internal */
+    /** @internal */
     mapper?: TypeMapper;
-    /* @internal */
+    /** @internal */
     instantiations?: ESMap<string, Type>; // Instantiations of generic type alias (undefined if non-generic)
 }
 
-/* @internal */
+/** @internal */
 export const enum VarianceFlags {
     Invariant     =      0,  // Neither covariant nor contravariant
     Covariant     = 1 << 0,  // Covariant
@@ -5888,9 +5888,9 @@ export const enum VarianceFlags {
 
 // Generic class and interface types
 export interface GenericType extends InterfaceType, TypeReference {
-    /* @internal */
+    /** @internal */
     instantiations: ESMap<string, TypeReference>;  // Generic instantiation cache
-    /* @internal */
+    /** @internal */
     variances?: VarianceFlags[];  // Variance of each type parameter
 }
 
@@ -5921,43 +5921,43 @@ export interface TupleTypeReference extends TypeReference {
 
 export interface UnionOrIntersectionType extends Type {
     types: Type[];                    // Constituent types
-    /* @internal */
+    /** @internal */
     objectFlags: ObjectFlags;
-    /* @internal */
+    /** @internal */
     propertyCache?: SymbolTable;       // Cache of resolved properties
-    /* @internal */
+    /** @internal */
     propertyCacheWithoutObjectFunctionPropertyAugment?: SymbolTable; // Cache of resolved properties that does not augment function or object type properties
-    /* @internal */
+    /** @internal */
     resolvedProperties: Symbol[];
-    /* @internal */
+    /** @internal */
     resolvedIndexType: IndexType;
-    /* @internal */
+    /** @internal */
     resolvedStringIndexType: IndexType;
-    /* @internal */
+    /** @internal */
     resolvedBaseConstraint: Type;
 }
 
 export interface UnionType extends UnionOrIntersectionType {
-    /* @internal */
+    /** @internal */
     resolvedReducedType?: Type;
-    /* @internal */
+    /** @internal */
     regularType?: UnionType;
-    /* @internal */
+    /** @internal */
     origin?: Type;  // Denormalized union, intersection, or index type in which union originates
-    /* @internal */
+    /** @internal */
     keyPropertyName?: __String;  // Property with unique unit type that exists in every object/intersection in union type
-    /* @internal */
+    /** @internal */
     constituentMap?: ESMap<TypeId, Type>;  // Constituents keyed by unit type discriminants
 }
 
 export interface IntersectionType extends UnionOrIntersectionType {
-    /* @internal */
+    /** @internal */
     resolvedApparentType: Type;
 }
 
 export type StructuredType = ObjectType | UnionType | IntersectionType;
 
-/* @internal */
+/** @internal */
 // An instantiated anonymous type has a target and a mapper
 export interface AnonymousType extends ObjectType {
     target?: AnonymousType;  // Instantiation target
@@ -5965,12 +5965,12 @@ export interface AnonymousType extends ObjectType {
     instantiations?: ESMap<string, Type>; // Instantiations of generic type alias (undefined if non-generic)
 }
 
-/* @internal */
+/** @internal */
 export interface InstantiationExpressionType extends AnonymousType {
     node: ExpressionWithTypeArguments | TypeQueryNode;
 }
 
-/* @internal */
+/** @internal */
 export interface MappedType extends AnonymousType {
     declaration: MappedTypeNode;
     typeParameter?: TypeParameter;
@@ -5987,14 +5987,14 @@ export interface EvolvingArrayType extends ObjectType {
     finalArrayType?: Type;  // Final array type of evolving array type
 }
 
-/* @internal */
+/** @internal */
 export interface ReverseMappedType extends ObjectType {
     source: Type;
     mappedType: MappedType;
     constraintType: IndexType;
 }
 
-/* @internal */
+/** @internal */
 // Resolved object, union, or intersection type
 export interface ResolvedType extends ObjectType, UnionOrIntersectionType {
     members: SymbolTable;             // Properties by name
@@ -6004,7 +6004,7 @@ export interface ResolvedType extends ObjectType, UnionOrIntersectionType {
     indexInfos: readonly IndexInfo[];  // Index signatures
 }
 
-/* @internal */
+/** @internal */
 // Object literals are initially marked fresh. Freshness disappears following an assignment,
 // before a type assertion, or when an object literal's type is widened. The regular
 // version of a fresh type is identical except for the TypeFlags.FreshObjectLiteral flag.
@@ -6012,7 +6012,7 @@ export interface FreshObjectLiteralType extends ResolvedType {
     regularType: ResolvedType;  // Regular version of fresh type
 }
 
-/* @internal */
+/** @internal */
 export interface IterationTypes {
     readonly yieldType: Type;
     readonly returnType: Type;
@@ -6020,7 +6020,7 @@ export interface IterationTypes {
 }
 
 // Just a place to cache element types of iterables and iterators
-/* @internal */
+/** @internal */
 export interface IterableOrIteratorType extends ObjectType, UnionType {
     iterationTypesOfGeneratorReturnType?: IterationTypes;
     iterationTypesOfAsyncGeneratorReturnType?: IterationTypes;
@@ -6031,46 +6031,46 @@ export interface IterableOrIteratorType extends ObjectType, UnionType {
     iterationTypesOfIteratorResult?: IterationTypes;
 }
 
-/* @internal */
+/** @internal */
 export interface PromiseOrAwaitableType extends ObjectType, UnionType {
     promiseTypeOfPromiseConstructor?: Type;
     promisedTypeOfPromise?: Type;
     awaitedTypeOfType?: Type;
 }
 
-/* @internal */
+/** @internal */
 export interface SyntheticDefaultModuleType extends Type {
     syntheticType?: Type;
     defaultOnlyType?: Type;
 }
 
 export interface InstantiableType extends Type {
-    /* @internal */
+    /** @internal */
     resolvedBaseConstraint?: Type;
-    /* @internal */
+    /** @internal */
     resolvedIndexType?: IndexType;
-    /* @internal */
+    /** @internal */
     resolvedStringIndexType?: IndexType;
 }
 
 // Type parameters (TypeFlags.TypeParameter)
 export interface TypeParameter extends InstantiableType {
     /** Retrieve using getConstraintFromTypeParameter */
-    /* @internal */
+    /** @internal */
     constraint?: Type;        // Constraint
-    /* @internal */
+    /** @internal */
     default?: Type;
-    /* @internal */
+    /** @internal */
     target?: TypeParameter;  // Instantiation target
-    /* @internal */
+    /** @internal */
     mapper?: TypeMapper;     // Instantiation mapper
-    /* @internal */
+    /** @internal */
     isThisType?: boolean;
-    /* @internal */
+    /** @internal */
     resolvedDefaultType?: Type;
 }
 
-/* @internal */
+/** @internal */
 export const enum AccessFlags {
     None = 0,
     IncludeUndefined = 1 << 0,
@@ -6090,7 +6090,7 @@ export const enum AccessFlags {
 export interface IndexedAccessType extends InstantiableType {
     objectType: Type;
     indexType: Type;
-    /* @internal */
+    /** @internal */
     accessFlags: AccessFlags;  // Only includes AccessFlags.Persistent
     constraint?: Type;
     simplifiedForReading?: Type;
@@ -6102,7 +6102,7 @@ export type TypeVariable = TypeParameter | IndexedAccessType;
 // keyof T types (TypeFlags.Index)
 export interface IndexType extends InstantiableType {
     type: InstantiableType | UnionOrIntersectionType;
-    /* @internal */
+    /** @internal */
     stringsOnly: boolean;
 }
 
@@ -6125,13 +6125,13 @@ export interface ConditionalType extends InstantiableType {
     extendsType: Type;
     resolvedTrueType?: Type;
     resolvedFalseType?: Type;
-    /* @internal */
+    /** @internal */
     resolvedInferredTrueType?: Type; // The `trueType` instantiated with the `combinedMapper`, if present
-    /* @internal */
+    /** @internal */
     resolvedDefaultConstraint?: Type;
-    /* @internal */
+    /** @internal */
     mapper?: TypeMapper;
-    /* @internal */
+    /** @internal */
     combinedMapper?: TypeMapper;
 }
 
@@ -6157,7 +6157,7 @@ export interface SubstitutionType extends InstantiableType {
     constraint: Type;  // Constraint that target type is known to satisfy
 }
 
-/* @internal */
+/** @internal */
 export const enum JsxReferenceKind {
     Component,
     Function,
@@ -6169,7 +6169,7 @@ export const enum SignatureKind {
     Construct,
 }
 
-/* @internal */
+/** @internal */
 export const enum SignatureFlags {
     None = 0,
 
@@ -6192,44 +6192,44 @@ export const enum SignatureFlags {
 }
 
 export interface Signature {
-    /* @internal */ flags: SignatureFlags;
-    /* @internal */ checker?: TypeChecker;
+    /** @internal */ flags: SignatureFlags;
+    /** @internal */ checker?: TypeChecker;
     declaration?: SignatureDeclaration | JSDocSignature; // Originating declaration
     typeParameters?: readonly TypeParameter[];   // Type parameters (undefined if non-generic)
     parameters: readonly Symbol[];               // Parameters
-    /* @internal */
+    /** @internal */
     thisParameter?: Symbol;             // symbol of this-type parameter
-    /* @internal */
+    /** @internal */
     // See comment in `instantiateSignature` for why these are set lazily.
     resolvedReturnType?: Type;          // Lazily set by `getReturnTypeOfSignature`.
-    /* @internal */
+    /** @internal */
     // Lazily set by `getTypePredicateOfSignature`.
     // `undefined` indicates a type predicate that has not yet been computed.
     // Uses a special `noTypePredicate` sentinel value to indicate that there is no type predicate. This looks like a TypePredicate at runtime to avoid polymorphism.
     resolvedTypePredicate?: TypePredicate;
-    /* @internal */
+    /** @internal */
     minArgumentCount: number;           // Number of non-optional parameters
-    /* @internal */
+    /** @internal */
     resolvedMinArgumentCount?: number;  // Number of non-optional parameters (excluding trailing `void`)
-    /* @internal */
+    /** @internal */
     target?: Signature;                 // Instantiation target
-    /* @internal */
+    /** @internal */
     mapper?: TypeMapper;                // Instantiation mapper
-    /* @internal */
+    /** @internal */
     compositeSignatures?: Signature[];  // Underlying signatures of a union/intersection signature
-    /* @internal */
+    /** @internal */
     compositeKind?: TypeFlags;          // TypeFlags.Union if the underlying signatures are from union members, otherwise TypeFlags.Intersection
-    /* @internal */
+    /** @internal */
     erasedSignatureCache?: Signature;   // Erased version of signature (deferred)
-    /* @internal */
+    /** @internal */
     canonicalSignatureCache?: Signature; // Canonical version of signature (deferred)
-    /* @internal */
+    /** @internal */
     baseSignatureCache?: Signature;      // Base version of signature (deferred)
-    /* @internal */
+    /** @internal */
     optionalCallSignatureCache?: { inner?: Signature, outer?: Signature }; // Optional chained call version of signature (deferred)
-    /* @internal */
+    /** @internal */
     isolatedSignatureType?: ObjectType; // A manufactured type that just contains the signature for purposes of signature comparison
-    /* @internal */
+    /** @internal */
     instantiations?: ESMap<string, Signature>;    // Generic signature instantiation cache
 }
 
@@ -6245,7 +6245,7 @@ export interface IndexInfo {
     declaration?: IndexSignatureDeclaration;
 }
 
-/* @internal */
+/** @internal */
 export const enum TypeMapKind {
     Simple,
     Array,
@@ -6255,7 +6255,7 @@ export const enum TypeMapKind {
     Merged,
 }
 
-/* @internal */
+/** @internal */
 export type TypeMapper =
     | { kind: TypeMapKind.Simple, source: Type, target: Type }
     | { kind: TypeMapKind.Array, sources: readonly Type[], targets: readonly Type[] | undefined }
@@ -6281,7 +6281,7 @@ export const enum InferencePriority {
     Circularity = -1,  // Inference circularity (value less than all other priorities)
 }
 
-/* @internal */
+/** @internal */
 export interface InferenceInfo {
     typeParameter: TypeParameter;            // Type parameter for which inferences are being made
     candidates: Type[] | undefined;          // Candidates in covariant positions (or undefined)
@@ -6293,7 +6293,7 @@ export interface InferenceInfo {
     impliedArity?: number;
 }
 
-/* @internal */
+/** @internal */
 export const enum InferenceFlags {
     None            =      0,  // No special inference behaviors
     NoDefault       = 1 << 0,  // Infer unknownType for no inferences (otherwise anyType or emptyObjectType)
@@ -6309,7 +6309,7 @@ export const enum InferenceFlags {
  * Ternary.Unknown is used as the result of a variance check that depends on itself. We make
  * a distinction because we don't want to cache circular variance check results.
  */
-/* @internal */
+/** @internal */
 export const enum Ternary {
     False = 0,
     Unknown = 1,
@@ -6317,10 +6317,10 @@ export const enum Ternary {
     True = -1
 }
 
-/* @internal */
+/** @internal */
 export type TypeComparer = (s: Type, t: Type, reportErrors?: boolean) => Ternary;
 
-/* @internal */
+/** @internal */
 export interface InferenceContext {
     inferences: InferenceInfo[];                  // Inferences made for each type parameter
     signature?: Signature;                        // Generic signature for which inferences are made (if any)
@@ -6333,13 +6333,13 @@ export interface InferenceContext {
     intraExpressionInferenceSites?: IntraExpressionInferenceSite[];
 }
 
-/* @internal */
+/** @internal */
 export interface IntraExpressionInferenceSite {
     node: Expression | MethodDeclaration;
     type: Type;
 }
 
-/* @internal */
+/** @internal */
 export interface WideningContext {
     parent?: WideningContext;       // Parent context
     propertyName?: __String;        // Name of property in parent
@@ -6347,7 +6347,7 @@ export interface WideningContext {
     resolvedProperties?: Symbol[];  // Properties occurring in sibling object literals
 }
 
-/* @internal */
+/** @internal */
 export const enum AssignmentDeclarationKind {
     None,
     /// exports.name = expr
@@ -6390,7 +6390,7 @@ export interface DiagnosticMessage {
     message: string;
     reportsUnnecessary?: {};
     reportsDeprecated?: {};
-    /* @internal */
+    /** @internal */
     elidedInCompatabilityPyramid?: boolean;
 }
 
@@ -6414,7 +6414,7 @@ export interface Diagnostic extends DiagnosticRelatedInformation {
     reportsDeprecated?: {}
     source?: string;
     relatedInformation?: DiagnosticRelatedInformation[];
-    /* @internal */ skippedOn?: keyof CompilerOptions;
+    /** @internal */ skippedOn?: keyof CompilerOptions;
 }
 
 export interface DiagnosticRelatedInformation {
@@ -6446,7 +6446,7 @@ export enum DiagnosticCategory {
     Suggestion,
     Message
 }
-/* @internal */
+/** @internal */
 export function diagnosticCategoryName(d: { category: DiagnosticCategory }, lowerCase = true): string {
     const name = DiagnosticCategory[d.category];
     return lowerCase ? name.toLowerCase() : name;
@@ -6520,9 +6520,9 @@ export enum PollingWatchKind {
 export type CompilerOptionsValue = string | number | boolean | (string | number)[] | string[] | MapLike<string[]> | PluginImport[] | ProjectReference[] | null | undefined;
 
 export interface CompilerOptions {
-    /*@internal*/ all?: boolean;
+    /** @internal */ all?: boolean;
     allowJs?: boolean;
-    /*@internal*/ allowNonTsExtensions?: boolean;
+    /** @internal */ allowNonTsExtensions?: boolean;
     allowSyntheticDefaultImports?: boolean;
     allowUmdGlobalAccess?: boolean;
     allowUnreachableCode?: boolean;
@@ -6530,19 +6530,19 @@ export interface CompilerOptions {
     alwaysStrict?: boolean;  // Always combine with strict property
     baseUrl?: string;
     /** An error if set - this should only go through the -b pipeline and not actually be observed */
-    /*@internal*/
+    /** @internal */
     build?: boolean;
     charset?: string;
     checkJs?: boolean;
-    /* @internal */ configFilePath?: string;
+    /** @internal */ configFilePath?: string;
     /** configFile is set as non enumerable property so as to avoid checking of json source files */
-    /* @internal */ readonly configFile?: TsConfigSourceFile;
+    /** @internal */ readonly configFile?: TsConfigSourceFile;
     declaration?: boolean;
     declarationMap?: boolean;
     emitDeclarationOnly?: boolean;
     declarationDir?: string;
-    /* @internal */ diagnostics?: boolean;
-    /* @internal */ extendedDiagnostics?: boolean;
+    /** @internal */ diagnostics?: boolean;
+    /** @internal */ extendedDiagnostics?: boolean;
     disableSizeLimit?: boolean;
     disableSourceOfProjectReferenceRedirect?: boolean;
     disableSolutionSearching?: boolean;
@@ -6553,22 +6553,22 @@ export interface CompilerOptions {
     exactOptionalPropertyTypes?: boolean;
     experimentalDecorators?: boolean;
     forceConsistentCasingInFileNames?: boolean;
-    /*@internal*/generateCpuProfile?: string;
-    /*@internal*/generateTrace?: string;
-    /*@internal*/help?: boolean;
+    /** @internal */generateCpuProfile?: string;
+    /** @internal */generateTrace?: string;
+    /** @internal */help?: boolean;
     importHelpers?: boolean;
     importsNotUsedAsValues?: ImportsNotUsedAsValues;
-    /*@internal*/init?: boolean;
+    /** @internal */init?: boolean;
     inlineSourceMap?: boolean;
     inlineSources?: boolean;
     isolatedModules?: boolean;
     jsx?: JsxEmit;
     keyofStringsOnly?: boolean;
     lib?: string[];
-    /*@internal*/listEmittedFiles?: boolean;
-    /*@internal*/listFiles?: boolean;
-    /*@internal*/explainFiles?: boolean;
-    /*@internal*/listFilesOnly?: boolean;
+    /** @internal */listEmittedFiles?: boolean;
+    /** @internal */listFiles?: boolean;
+    /** @internal */explainFiles?: boolean;
+    /** @internal */listFilesOnly?: boolean;
     locale?: string;
     mapRoot?: string;
     maxNodeModuleJsDepth?: number;
@@ -6578,7 +6578,7 @@ export interface CompilerOptions {
     moduleDetection?: ModuleDetectionKind;
     newLine?: NewLineKind;
     noEmit?: boolean;
-    /*@internal*/noEmitForJsFiles?: boolean;
+    /** @internal */noEmitForJsFiles?: boolean;
     noEmitHelpers?: boolean;
     noEmitOnError?: boolean;
     noErrorTruncation?: boolean;
@@ -6594,7 +6594,7 @@ export interface CompilerOptions {
     assumeChangesOnlyAffectDirectDependencies?: boolean;
     noLib?: boolean;
     noResolve?: boolean;
-    /*@internal*/
+    /** @internal */
     noDtsResolution?: boolean;
     noUncheckedIndexedAccess?: boolean;
     out?: string;
@@ -6602,15 +6602,15 @@ export interface CompilerOptions {
     outFile?: string;
     paths?: MapLike<string[]>;
     /** The directory of the config file that specified 'paths'. Used to resolve relative paths when 'baseUrl' is absent. */
-    /*@internal*/ pathsBasePath?: string;
-    /*@internal*/ plugins?: PluginImport[];
+    /** @internal */ pathsBasePath?: string;
+    /** @internal */ plugins?: PluginImport[];
     preserveConstEnums?: boolean;
     noImplicitOverride?: boolean;
     preserveSymlinks?: boolean;
     preserveValueImports?: boolean;
-    /* @internal */ preserveWatchOutput?: boolean;
+    /** @internal */ preserveWatchOutput?: boolean;
     project?: string;
-    /* @internal */ pretty?: boolean;
+    /** @internal */ pretty?: boolean;
     reactNamespace?: string;
     jsxFactory?: string;
     jsxFragmentFactory?: string;
@@ -6633,7 +6633,7 @@ export interface CompilerOptions {
     stripInternal?: boolean;
     suppressExcessPropertyErrors?: boolean;
     suppressImplicitAnyIndexErrors?: boolean;
-    /* @internal */ suppressOutputPathCheck?: boolean;
+    /** @internal */ suppressOutputPathCheck?: boolean;
     target?: ScriptTarget;
     traceResolution?: boolean;
     useUnknownInCatchVariables?: boolean;
@@ -6641,10 +6641,10 @@ export interface CompilerOptions {
     types?: string[];
     /** Paths used to compute primary types search locations */
     typeRoots?: string[];
-    /*@internal*/ version?: boolean;
-    /*@internal*/ watch?: boolean;
+    /** @internal */ version?: boolean;
+    /** @internal */ watch?: boolean;
     esModuleInterop?: boolean;
-    /* @internal */ showConfig?: boolean;
+    /** @internal */ showConfig?: boolean;
     useDefineForClassFields?: boolean;
 
     [option: string]: CompilerOptionsValue | TsConfigSourceFile | undefined;
@@ -6777,7 +6777,7 @@ export const enum WatchDirectoryFlags {
     Recursive = 1 << 0,
 }
 
-/* @internal */
+/** @internal */
 export interface ConfigFileSpecs {
     filesSpecs: readonly string[] | undefined;
     /**
@@ -6795,7 +6795,7 @@ export interface ConfigFileSpecs {
     isDefaultIncludeSpec: boolean;
 }
 
-/* @internal */
+/** @internal */
 export type RequireResult<T = {}> =
     | { module: T, modulePath?: string, error: undefined }
     | { module: undefined, modulePath?: undefined, error: { stack?: string, message?: string } };
@@ -6809,7 +6809,7 @@ export interface CreateProgramOptions {
     configFileParsingDiagnostics?: readonly Diagnostic[];
 }
 
-/* @internal */
+/** @internal */
 export interface CommandLineOptionBase {
     name: string;
     type: "string" | "number" | "boolean" | "object" | "list" | ESMap<string, number | string>;    // a value of a primitive type, or an object literal mapping named values to actual values
@@ -6836,37 +6836,37 @@ export interface CommandLineOptionBase {
     extraValidation?: (value: CompilerOptionsValue) => [DiagnosticMessage, ...string[]] | undefined; // Additional validation to be performed for the value to be valid
 }
 
-/* @internal */
+/** @internal */
 export interface CommandLineOptionOfStringType extends CommandLineOptionBase {
     type: "string";
     defaultValueDescription?: string | undefined | DiagnosticMessage;
 }
 
-/* @internal */
+/** @internal */
 export interface CommandLineOptionOfNumberType extends CommandLineOptionBase {
     type: "number";
     defaultValueDescription: number | undefined | DiagnosticMessage;
 }
 
-/* @internal */
+/** @internal */
 export interface CommandLineOptionOfBooleanType extends CommandLineOptionBase {
     type: "boolean";
     defaultValueDescription: boolean | undefined | DiagnosticMessage;
 }
 
-/* @internal */
+/** @internal */
 export interface CommandLineOptionOfCustomType extends CommandLineOptionBase {
     type: ESMap<string, number | string>;  // an object literal mapping named values to actual values
     defaultValueDescription: number | string | undefined | DiagnosticMessage;
 }
 
-/* @internal */
+/** @internal */
 export interface AlternateModeDiagnostics {
     diagnostic: DiagnosticMessage;
     getOptionsNameMap: () => OptionsNameMap;
 }
 
-/* @internal */
+/** @internal */
 export interface DidYouMeanOptionsDiagnostics {
     alternateMode?: AlternateModeDiagnostics;
     optionDeclarations: CommandLineOption[];
@@ -6874,24 +6874,24 @@ export interface DidYouMeanOptionsDiagnostics {
     unknownDidYouMeanDiagnostic: DiagnosticMessage,
 }
 
-/* @internal */
+/** @internal */
 export interface TsConfigOnlyOption extends CommandLineOptionBase {
     type: "object";
     elementOptions?: ESMap<string, CommandLineOption>;
     extraKeyDiagnostics?: DidYouMeanOptionsDiagnostics;
 }
 
-/* @internal */
+/** @internal */
 export interface CommandLineOptionOfListType extends CommandLineOptionBase {
     type: "list";
     element: CommandLineOptionOfCustomType | CommandLineOptionOfStringType | CommandLineOptionOfNumberType | CommandLineOptionOfBooleanType | TsConfigOnlyOption;
     listPreserveFalsyValues?: boolean;
 }
 
-/* @internal */
+/** @internal */
 export type CommandLineOption = CommandLineOptionOfCustomType | CommandLineOptionOfStringType | CommandLineOptionOfNumberType | CommandLineOptionOfBooleanType | TsConfigOnlyOption | CommandLineOptionOfListType;
 
-/* @internal */
+/** @internal */
 export const enum CharacterCodes {
     nullCharacter = 0,
     maxAsciiCharacter = 0x7F,
@@ -7126,11 +7126,11 @@ export const enum Extension {
 
 export interface ResolvedModuleWithFailedLookupLocations {
     readonly resolvedModule: ResolvedModuleFull | undefined;
-    /* @internal */
+    /** @internal */
     readonly failedLookupLocations: string[];
-    /* @internal */
+    /** @internal */
     readonly affectingLocations: string[];
-    /* @internal */
+    /** @internal */
     readonly resolutionDiagnostics: Diagnostic[]
 }
 
@@ -7153,13 +7153,13 @@ export interface ResolvedTypeReferenceDirective {
 export interface ResolvedTypeReferenceDirectiveWithFailedLookupLocations {
     readonly resolvedTypeReferenceDirective: ResolvedTypeReferenceDirective | undefined;
     readonly failedLookupLocations: string[];
-    /*@internal*/ readonly affectingLocations: string[];
-    /* @internal */ resolutionDiagnostics: Diagnostic[];
+    /** @internal */ readonly affectingLocations: string[];
+    /** @internal */ resolutionDiagnostics: Diagnostic[];
 }
 
-/* @internal */
+/** @internal */
 export type HasInvalidatedResolution = (sourceFile: Path) => boolean;
-/* @internal */
+/** @internal */
 export type HasChangedAutomaticTypeDirectiveNames = () => boolean;
 
 export interface CompilerHost extends ModuleResolutionHost {
@@ -7192,34 +7192,34 @@ export interface CompilerHost extends ModuleResolutionHost {
      */
     resolveTypeReferenceDirectives?(typeReferenceDirectiveNames: string[] | readonly FileReference[], containingFile: string, redirectedReference: ResolvedProjectReference | undefined, options: CompilerOptions, containingFileMode?: SourceFile["impliedNodeFormat"] | undefined): (ResolvedTypeReferenceDirective | undefined)[];
     getEnvironmentVariable?(name: string): string | undefined;
-    /* @internal */ onReleaseOldSourceFile?(oldSourceFile: SourceFile, oldOptions: CompilerOptions, hasSourceFileByPath: boolean): void;
-    /* @internal */ onReleaseParsedCommandLine?(configFileName: string, oldResolvedRef: ResolvedProjectReference | undefined, optionOptions: CompilerOptions): void;
-    /* @internal */ hasInvalidatedResolution?: HasInvalidatedResolution;
-    /* @internal */ hasChangedAutomaticTypeDirectiveNames?: HasChangedAutomaticTypeDirectiveNames;
+    /** @internal */ onReleaseOldSourceFile?(oldSourceFile: SourceFile, oldOptions: CompilerOptions, hasSourceFileByPath: boolean): void;
+    /** @internal */ onReleaseParsedCommandLine?(configFileName: string, oldResolvedRef: ResolvedProjectReference | undefined, optionOptions: CompilerOptions): void;
+    /** @internal */ hasInvalidatedResolution?: HasInvalidatedResolution;
+    /** @internal */ hasChangedAutomaticTypeDirectiveNames?: HasChangedAutomaticTypeDirectiveNames;
     createHash?(data: string): string;
     getParsedCommandLine?(fileName: string): ParsedCommandLine | undefined;
-    /* @internal */ useSourceOfProjectReferenceRedirect?(): boolean;
+    /** @internal */ useSourceOfProjectReferenceRedirect?(): boolean;
 
     // TODO: later handle this in better way in builder host instead once the api for tsbuild finalizes and doesn't use compilerHost as base
-    /*@internal*/createDirectory?(directory: string): void;
-    /*@internal*/getSymlinkCache?(): SymlinkCache;
+    /** @internal */createDirectory?(directory: string): void;
+    /** @internal */getSymlinkCache?(): SymlinkCache;
 
     // For testing:
-    /*@internal*/ disableUseFileVersionAsSignature?: boolean;
-    /*@internal*/ storeFilesChangingSignatureDuringEmit?: boolean;
+    /** @internal */ disableUseFileVersionAsSignature?: boolean;
+    /** @internal */ storeFilesChangingSignatureDuringEmit?: boolean;
 }
 
 /** true if --out otherwise source file name */
-/*@internal*/
+/** @internal */
 export type SourceOfProjectReferenceRedirect = string | true;
 
-/*@internal*/
+/** @internal */
 export interface ResolvedProjectReferenceCallbacks {
     getSourceOfProjectReferenceRedirect(fileName: string): SourceOfProjectReferenceRedirect | undefined;
     forEachResolvedProjectReference<T>(cb: (resolvedProjectReference: ResolvedProjectReference) => T | undefined): T | undefined;
 }
 
-/* @internal */
+/** @internal */
 export const enum TransformFlags {
     None = 0,
 
@@ -7314,11 +7314,11 @@ export interface SourceMapRange extends TextRange {
 export interface SourceMapSource {
     fileName: string;
     text: string;
-    /* @internal */ lineMap: readonly number[];
+    /** @internal */ lineMap: readonly number[];
     skipTrivia?: (pos: number) => number;
 }
 
-/* @internal */
+/** @internal */
 export interface EmitNode {
     annotatedNodes?: Node[];                 // Tracks Parse-tree nodes with EmitNodes for eventual cleanup.
     flags: EmitFlags;                        // Flags that customize emit
@@ -7336,23 +7336,23 @@ export interface EmitNode {
     typeNode?: TypeNode;                         // VariableDeclaration type
 }
 
-/* @internal */
+/** @internal */
 export type SnippetElement = TabStop | Placeholder;
 
-/* @internal */
+/** @internal */
 export interface TabStop {
     kind: SnippetKind.TabStop;
     order: number;
 }
 
-/* @internal */
+/** @internal */
 export interface Placeholder {
     kind: SnippetKind.Placeholder;
     order: number;
 }
 
 // Reference: https://code.visualstudio.com/docs/editor/userdefinedsnippets#_snippet-syntax
-/* @internal */
+/** @internal */
 export const enum SnippetKind {
     TabStop,                                // `$1`, `$2`
     Placeholder,                            // `${1:foo}`
@@ -7390,11 +7390,11 @@ export const enum EmitFlags {
     HasEndOfDeclarationMarker = 1 << 22,    // Declaration has an associated NotEmittedStatement to mark the end of the declaration
     Iterator = 1 << 23,                     // The expression to a `yield*` should be treated as an Iterator when down-leveling, not an Iterable.
     NoAsciiEscaping = 1 << 24,              // When synthesizing nodes that lack an original node or textSourceNode, we want to write the text on the node with ASCII escaping substitutions.
-    /*@internal*/ TypeScriptClassWrapper = 1 << 25, // The node is an IIFE class wrapper created by the ts transform.
-    /*@internal*/ NeverApplyImportHelper = 1 << 26, // Indicates the node should never be wrapped with an import star helper (because, for example, it imports tslib itself)
-    /*@internal*/ IgnoreSourceNewlines = 1 << 27,   // Overrides `printerOptions.preserveSourceNewlines` to print this node (and all descendants) with default whitespace.
-    /*@internal*/ Immutable = 1 << 28,      // Indicates a node is a singleton intended to be reused in multiple locations. Any attempt to make further changes to the node will result in an error.
-    /*@internal*/ IndirectCall = 1 << 29,   // Emit CallExpression as an indirect call: `(0, f)()`
+    /** @internal */ TypeScriptClassWrapper = 1 << 25, // The node is an IIFE class wrapper created by the ts transform.
+    /** @internal */ NeverApplyImportHelper = 1 << 26, // Indicates the node should never be wrapped with an import star helper (because, for example, it imports tslib itself)
+    /** @internal */ IgnoreSourceNewlines = 1 << 27,   // Overrides `printerOptions.preserveSourceNewlines` to print this node (and all descendants) with default whitespace.
+    /** @internal */ Immutable = 1 << 28,      // Indicates a node is a singleton intended to be reused in multiple locations. Any attempt to make further changes to the node will result in an error.
+    /** @internal */ IndirectCall = 1 << 29,   // Emit CallExpression as an indirect call: `(0, f)()`
 }
 
 export interface EmitHelperBase {
@@ -7411,14 +7411,14 @@ export interface ScopedEmitHelper extends EmitHelperBase {
 
 export interface UnscopedEmitHelper extends EmitHelperBase {
     readonly scoped: false;                                         // Indicates whether the helper MUST be emitted in the current scope.
-    /* @internal */
+    /** @internal */
     readonly importName?: string;                                   // The name of the helper to use when importing via `--importHelpers`.
     readonly text: string;                                          // ES3-compatible raw script text, or a function yielding such a string
 }
 
 export type EmitHelper = ScopedEmitHelper | UnscopedEmitHelper;
 
-/* @internal */
+/** @internal */
 export type UniqueNameHandler = (baseName: string, checkFn?: (name: string) => boolean, optimistic?: boolean) => string;
 
 export type EmitHelperUniqueNameCallback = (name: string) => string;
@@ -7427,7 +7427,7 @@ export type EmitHelperUniqueNameCallback = (name: string) => string;
  * Used by the checker, this enum keeps track of external emit helpers that should be type
  * checked.
  */
-/* @internal */
+/** @internal */
 export const enum ExternalEmitHelpers {
     Extends = 1 << 0,               // __extends (used by the ES2015 class transformation)
     Assign = 1 << 1,                // __assign (used by Jsx and ESNext object spread transformations)
@@ -7481,7 +7481,7 @@ export const enum EmitHint {
     JsxAttributeValue,   // Emitting a JSX attribute value
 }
 
-/* @internal */
+/** @internal */
 export interface SourceFileMayBeEmittedHost {
     getCompilerOptions(): CompilerOptions;
     isSourceFileFromExternalLibrary(file: SourceFile): boolean;
@@ -7489,7 +7489,7 @@ export interface SourceFileMayBeEmittedHost {
     isSourceOfProjectReferenceRedirect(fileName: string): boolean;
 }
 
-/* @internal */
+/** @internal */
 export interface EmitHost extends ScriptReferenceHost, ModuleSpecifierResolutionHost, SourceFileMayBeEmittedHost {
     getSourceFiles(): readonly SourceFile[];
     useCaseSensitiveFileNames(): boolean;
@@ -7512,7 +7512,7 @@ export interface EmitHost extends ScriptReferenceHost, ModuleSpecifierResolution
     createHash?(data: string): string;
 }
 
-/* @internal */
+/** @internal */
 export interface PropertyDescriptorAttributes {
     enumerable?: boolean | Expression;
     configurable?: boolean | Expression;
@@ -7534,7 +7534,7 @@ export const enum OuterExpressionKinds {
     ExcludeJSDocTypeAssertion = 1 << 4,
 }
 
-/* @internal */
+/** @internal */
 export type OuterExpression =
     | ParenthesizedExpression
     | TypeAssertion
@@ -7545,13 +7545,13 @@ export type OuterExpression =
 
 export type TypeOfTag = "undefined" | "number" | "bigint" | "boolean" | "string" | "symbol" | "object" | "function";
 
-/* @internal */
+/** @internal */
 export interface CallBinding {
     target: LeftHandSideExpression;
     thisArg: Expression;
 }
 
-/* @internal */
+/** @internal */
 export interface ParenthesizerRules {
     getParenthesizeLeftSideOfBinaryForOperator(binaryOperator: SyntaxKind): (leftSide: Expression) => Expression;
     getParenthesizeRightSideOfBinaryForOperator(binaryOperator: SyntaxKind): (rightSide: Expression) => Expression;
@@ -7586,7 +7586,7 @@ export interface ParenthesizerRules {
     parenthesizeTypeArguments(typeParameters: readonly TypeNode[] | undefined): NodeArray<TypeNode> | undefined;
 }
 
-/* @internal */
+/** @internal */
 export interface NodeConverters {
     convertToFunctionBlock(node: ConciseBody, multiLine?: boolean): Block;
     convertToFunctionExpression(node: FunctionDeclaration): FunctionExpression;
@@ -7599,10 +7599,10 @@ export interface NodeConverters {
 }
 
 export interface NodeFactory {
-    /* @internal */ readonly parenthesizer: ParenthesizerRules;
-    /* @internal */ readonly converters: NodeConverters;
-    /* @internal */ readonly baseFactory: BaseNodeFactory;
-    /* @internal */ readonly flags: NodeFactoryFlags;
+    /** @internal */ readonly parenthesizer: ParenthesizerRules;
+    /** @internal */ readonly converters: NodeConverters;
+    /** @internal */ readonly baseFactory: BaseNodeFactory;
+    /** @internal */ readonly flags: NodeFactoryFlags;
     createNodeArray<T extends Node>(elements?: readonly T[], hasTrailingComma?: boolean): NodeArray<T>;
 
     //
@@ -7621,8 +7621,8 @@ export interface NodeFactory {
     //
 
     createIdentifier(text: string): Identifier;
-    /* @internal */ createIdentifier(text: string, typeArguments?: readonly (TypeNode | TypeParameterDeclaration)[], originalKeywordKind?: SyntaxKind): Identifier; // eslint-disable-line @typescript-eslint/unified-signatures
-    /* @internal */ updateIdentifier(node: Identifier, typeArguments: NodeArray<TypeNode | TypeParameterDeclaration> | undefined): Identifier;
+    /** @internal */ createIdentifier(text: string, typeArguments?: readonly (TypeNode | TypeParameterDeclaration)[], originalKeywordKind?: SyntaxKind): Identifier; // eslint-disable-line @typescript-eslint/unified-signatures
+    /** @internal */ updateIdentifier(node: Identifier, typeArguments: NodeArray<TypeNode | TypeParameterDeclaration> | undefined): Identifier;
 
     /**
      * Create a unique temporary variable.
@@ -7665,7 +7665,7 @@ export interface NodeFactory {
     createToken<TKind extends ModifierSyntaxKind>(token: TKind): ModifierToken<TKind>;
     createToken<TKind extends KeywordSyntaxKind>(token: TKind): KeywordToken<TKind>;
     createToken<TKind extends SyntaxKind.Unknown | SyntaxKind.EndOfFileToken>(token: TKind): Token<TKind>;
-    /*@internal*/ createToken<TKind extends SyntaxKind>(token: TKind): Token<TKind>;
+    /** @internal */ createToken<TKind extends SyntaxKind>(token: TKind): Token<TKind>;
 
     //
     // Reserved words
@@ -7727,7 +7727,7 @@ export interface NodeFactory {
     createConstructSignature(typeParameters: readonly TypeParameterDeclaration[] | undefined, parameters: readonly ParameterDeclaration[], type: TypeNode | undefined): ConstructSignatureDeclaration;
     updateConstructSignature(node: ConstructSignatureDeclaration, typeParameters: NodeArray<TypeParameterDeclaration> | undefined, parameters: NodeArray<ParameterDeclaration>, type: TypeNode | undefined): ConstructSignatureDeclaration;
     createIndexSignature(modifiers: readonly Modifier[] | undefined, parameters: readonly ParameterDeclaration[], type: TypeNode): IndexSignatureDeclaration;
-    /* @internal */ createIndexSignature(modifiers: readonly Modifier[] | undefined, parameters: readonly ParameterDeclaration[], type: TypeNode | undefined): IndexSignatureDeclaration; // eslint-disable-line @typescript-eslint/unified-signatures
+    /** @internal */ createIndexSignature(modifiers: readonly Modifier[] | undefined, parameters: readonly ParameterDeclaration[], type: TypeNode | undefined): IndexSignatureDeclaration; // eslint-disable-line @typescript-eslint/unified-signatures
     updateIndexSignature(node: IndexSignatureDeclaration, modifiers: readonly Modifier[] | undefined, parameters: readonly ParameterDeclaration[], type: TypeNode): IndexSignatureDeclaration;
     createTemplateLiteralTypeSpan(type: TypeNode, literal: TemplateMiddle | TemplateTail): TemplateLiteralTypeSpan;
     updateTemplateLiteralTypeSpan(node: TemplateLiteralTypeSpan, type: TypeNode, literal: TemplateMiddle | TemplateTail): TemplateLiteralTypeSpan;
@@ -7854,11 +7854,11 @@ export interface NodeFactory {
     createTemplateTail(text: string | undefined, rawText: string, templateFlags?: TokenFlags): TemplateTail;
     createNoSubstitutionTemplateLiteral(text: string, rawText?: string): NoSubstitutionTemplateLiteral;
     createNoSubstitutionTemplateLiteral(text: string | undefined, rawText: string): NoSubstitutionTemplateLiteral;
-    /* @internal */ createLiteralLikeNode(kind: LiteralToken["kind"] | SyntaxKind.JsxTextAllWhiteSpaces, text: string): LiteralToken;
-    /* @internal */ createTemplateLiteralLikeNode(kind: TemplateLiteralToken["kind"], text: string, rawText: string, templateFlags: TokenFlags | undefined): TemplateLiteralLikeNode;
+    /** @internal */ createLiteralLikeNode(kind: LiteralToken["kind"] | SyntaxKind.JsxTextAllWhiteSpaces, text: string): LiteralToken;
+    /** @internal */ createTemplateLiteralLikeNode(kind: TemplateLiteralToken["kind"], text: string, rawText: string, templateFlags: TokenFlags | undefined): TemplateLiteralLikeNode;
     createYieldExpression(asteriskToken: AsteriskToken, expression: Expression): YieldExpression;
     createYieldExpression(asteriskToken: undefined, expression: Expression | undefined): YieldExpression;
-    /* @internal */ createYieldExpression(asteriskToken: AsteriskToken | undefined, expression: Expression | undefined): YieldExpression; // eslint-disable-line @typescript-eslint/unified-signatures
+    /** @internal */ createYieldExpression(asteriskToken: AsteriskToken | undefined, expression: Expression | undefined): YieldExpression; // eslint-disable-line @typescript-eslint/unified-signatures
     updateYieldExpression(node: YieldExpression, asteriskToken: AsteriskToken | undefined, expression: Expression | undefined): YieldExpression;
     createSpreadElement(expression: Expression): SpreadElement;
     updateSpreadElement(node: SpreadElement, expression: Expression): SpreadElement;
@@ -8131,30 +8131,30 @@ export interface NodeFactory {
     createSourceFile(statements: readonly Statement[], endOfFileToken: EndOfFileToken, flags: NodeFlags): SourceFile;
     updateSourceFile(node: SourceFile, statements: readonly Statement[], isDeclarationFile?: boolean, referencedFiles?: readonly FileReference[], typeReferences?: readonly FileReference[], hasNoDefaultLib?: boolean, libReferences?: readonly FileReference[]): SourceFile;
 
-    /* @internal */ createUnparsedSource(prologues: readonly UnparsedPrologue[], syntheticReferences: readonly UnparsedSyntheticReference[] | undefined, texts: readonly UnparsedSourceText[]): UnparsedSource;
-    /* @internal */ createUnparsedPrologue(data?: string): UnparsedPrologue;
-    /* @internal */ createUnparsedPrepend(data: string | undefined, texts: readonly UnparsedSourceText[]): UnparsedPrepend;
-    /* @internal */ createUnparsedTextLike(data: string | undefined, internal: boolean): UnparsedTextLike;
-    /* @internal */ createUnparsedSyntheticReference(section: BundleFileHasNoDefaultLib | BundleFileReference): UnparsedSyntheticReference;
-    /* @internal */ createInputFiles(): InputFiles;
+    /** @internal */ createUnparsedSource(prologues: readonly UnparsedPrologue[], syntheticReferences: readonly UnparsedSyntheticReference[] | undefined, texts: readonly UnparsedSourceText[]): UnparsedSource;
+    /** @internal */ createUnparsedPrologue(data?: string): UnparsedPrologue;
+    /** @internal */ createUnparsedPrepend(data: string | undefined, texts: readonly UnparsedSourceText[]): UnparsedPrepend;
+    /** @internal */ createUnparsedTextLike(data: string | undefined, internal: boolean): UnparsedTextLike;
+    /** @internal */ createUnparsedSyntheticReference(section: BundleFileHasNoDefaultLib | BundleFileReference): UnparsedSyntheticReference;
+    /** @internal */ createInputFiles(): InputFiles;
 
     //
     // Synthetic Nodes
     //
-    /* @internal */ createSyntheticExpression(type: Type, isSpread?: boolean, tupleNameSource?: ParameterDeclaration | NamedTupleMember): SyntheticExpression;
-    /* @internal */ createSyntaxList(children: Node[]): SyntaxList;
+    /** @internal */ createSyntheticExpression(type: Type, isSpread?: boolean, tupleNameSource?: ParameterDeclaration | NamedTupleMember): SyntheticExpression;
+    /** @internal */ createSyntaxList(children: Node[]): SyntaxList;
 
     //
     // Transformation nodes
     //
 
     createNotEmittedStatement(original: Node): NotEmittedStatement;
-    /* @internal */ createEndOfDeclarationMarker(original: Node): EndOfDeclarationMarker;
-    /* @internal */ createMergeDeclarationMarker(original: Node): MergeDeclarationMarker;
+    /** @internal */ createEndOfDeclarationMarker(original: Node): EndOfDeclarationMarker;
+    /** @internal */ createMergeDeclarationMarker(original: Node): MergeDeclarationMarker;
     createPartiallyEmittedExpression(expression: Expression, original?: Node): PartiallyEmittedExpression;
     updatePartiallyEmittedExpression(node: PartiallyEmittedExpression, expression: Expression): PartiallyEmittedExpression;
-    /* @internal */ createSyntheticReferenceExpression(expression: Expression, thisArg: Expression): SyntheticReferenceExpression;
-    /* @internal */ updateSyntheticReferenceExpression(node: SyntheticReferenceExpression, expression: Expression, thisArg: Expression): SyntheticReferenceExpression;
+    /** @internal */ createSyntheticReferenceExpression(expression: Expression, thisArg: Expression): SyntheticReferenceExpression;
+    /** @internal */ updateSyntheticReferenceExpression(node: SyntheticReferenceExpression, expression: Expression, thisArg: Expression): SyntheticReferenceExpression;
     createCommaListExpression(elements: readonly Expression[]): CommaListExpression;
     updateCommaListExpression(node: CommaListExpression, elements: readonly Expression[]): CommaListExpression;
     createBundle(sourceFiles: readonly SourceFile[], prepends?: readonly (UnparsedSource | InputFiles)[]): Bundle;
@@ -8212,19 +8212,19 @@ export interface NodeFactory {
     createExportDefault(expression: Expression): ExportAssignment;
     createExternalModuleExport(exportName: Identifier): ExportDeclaration;
 
-    /* @internal */ createTypeCheck(value: Expression, tag: TypeOfTag): Expression;
-    /* @internal */ createMethodCall(object: Expression, methodName: string | Identifier, argumentsList: readonly Expression[]): CallExpression;
-    /* @internal */ createGlobalMethodCall(globalObjectName: string, globalMethodName: string, argumentsList: readonly Expression[]): CallExpression;
-    /* @internal */ createFunctionBindCall(target: Expression, thisArg: Expression, argumentsList: readonly Expression[]): CallExpression;
-    /* @internal */ createFunctionCallCall(target: Expression, thisArg: Expression, argumentsList: readonly Expression[]): CallExpression;
-    /* @internal */ createFunctionApplyCall(target: Expression, thisArg: Expression, argumentsExpression: Expression): CallExpression;
-    /* @internal */ createObjectDefinePropertyCall(target: Expression, propertyName: string | Expression, attributes: Expression): CallExpression;
-    /* @internal */ createReflectGetCall(target: Expression, propertyKey: Expression, receiver?: Expression): CallExpression;
-    /* @internal */ createReflectSetCall(target: Expression, propertyKey: Expression, value: Expression, receiver?: Expression): CallExpression;
-    /* @internal */ createPropertyDescriptor(attributes: PropertyDescriptorAttributes, singleLine?: boolean): ObjectLiteralExpression;
-    /* @internal */ createArraySliceCall(array: Expression, start?: number | Expression): CallExpression;
-    /* @internal */ createArrayConcatCall(array: Expression, values: readonly Expression[]): CallExpression;
-    /* @internal */ createCallBinding(expression: Expression, recordTempVariable: (temp: Identifier) => void, languageVersion?: ScriptTarget, cacheIdentifiers?: boolean): CallBinding;
+    /** @internal */ createTypeCheck(value: Expression, tag: TypeOfTag): Expression;
+    /** @internal */ createMethodCall(object: Expression, methodName: string | Identifier, argumentsList: readonly Expression[]): CallExpression;
+    /** @internal */ createGlobalMethodCall(globalObjectName: string, globalMethodName: string, argumentsList: readonly Expression[]): CallExpression;
+    /** @internal */ createFunctionBindCall(target: Expression, thisArg: Expression, argumentsList: readonly Expression[]): CallExpression;
+    /** @internal */ createFunctionCallCall(target: Expression, thisArg: Expression, argumentsList: readonly Expression[]): CallExpression;
+    /** @internal */ createFunctionApplyCall(target: Expression, thisArg: Expression, argumentsExpression: Expression): CallExpression;
+    /** @internal */ createObjectDefinePropertyCall(target: Expression, propertyName: string | Expression, attributes: Expression): CallExpression;
+    /** @internal */ createReflectGetCall(target: Expression, propertyKey: Expression, receiver?: Expression): CallExpression;
+    /** @internal */ createReflectSetCall(target: Expression, propertyKey: Expression, value: Expression, receiver?: Expression): CallExpression;
+    /** @internal */ createPropertyDescriptor(attributes: PropertyDescriptorAttributes, singleLine?: boolean): ObjectLiteralExpression;
+    /** @internal */ createArraySliceCall(array: Expression, start?: number | Expression): CallExpression;
+    /** @internal */ createArrayConcatCall(array: Expression, values: readonly Expression[]): CallExpression;
+    /** @internal */ createCallBinding(expression: Expression, recordTempVariable: (temp: Identifier) => void, languageVersion?: ScriptTarget, cacheIdentifiers?: boolean): CallBinding;
     /**
      * Wraps an expression that cannot be an assignment target in an expression that can be.
      *
@@ -8240,8 +8240,8 @@ export interface NodeFactory {
      * @param paramName
      * @param expression
      */
-    /* @internal */ createAssignmentTargetWrapper(paramName: Identifier, expression: Expression): LeftHandSideExpression;
-    /* @internal */ inlineExpressions(expressions: readonly Expression[]): Expression;
+    /** @internal */ createAssignmentTargetWrapper(paramName: Identifier, expression: Expression): LeftHandSideExpression;
+    /** @internal */ inlineExpressions(expressions: readonly Expression[]): Expression;
     /**
      * Gets the internal name of a declaration. This is primarily used for declarations that can be
      * referred to by name in the body of an ES5 class function body. An internal name will *never*
@@ -8253,7 +8253,7 @@ export interface NodeFactory {
      * @param allowComments A value indicating whether comments may be emitted for the name.
      * @param allowSourceMaps A value indicating whether source maps may be emitted for the name.
      */
-    /* @internal */ getInternalName(node: Declaration, allowComments?: boolean, allowSourceMaps?: boolean): Identifier;
+    /** @internal */ getInternalName(node: Declaration, allowComments?: boolean, allowSourceMaps?: boolean): Identifier;
     /**
      * Gets the local name of a declaration. This is primarily used for declarations that can be
      * referred to by name in the declaration's immediate scope (classes, enums, namespaces). A
@@ -8264,7 +8264,7 @@ export interface NodeFactory {
      * @param allowComments A value indicating whether comments may be emitted for the name.
      * @param allowSourceMaps A value indicating whether source maps may be emitted for the name.
      */
-    /* @internal */ getLocalName(node: Declaration, allowComments?: boolean, allowSourceMaps?: boolean): Identifier;
+    /** @internal */ getLocalName(node: Declaration, allowComments?: boolean, allowSourceMaps?: boolean): Identifier;
     /**
      * Gets the export name of a declaration. This is primarily used for declarations that can be
      * referred to by name in the declaration's immediate scope (classes, enums, namespaces). An
@@ -8275,7 +8275,7 @@ export interface NodeFactory {
      * @param allowComments A value indicating whether comments may be emitted for the name.
      * @param allowSourceMaps A value indicating whether source maps may be emitted for the name.
      */
-    /* @internal */ getExportName(node: Declaration, allowComments?: boolean, allowSourceMaps?: boolean): Identifier;
+    /** @internal */ getExportName(node: Declaration, allowComments?: boolean, allowSourceMaps?: boolean): Identifier;
     /**
      * Gets the name of a declaration for use in declarations.
      *
@@ -8283,7 +8283,7 @@ export interface NodeFactory {
      * @param allowComments A value indicating whether comments may be emitted for the name.
      * @param allowSourceMaps A value indicating whether source maps may be emitted for the name.
      */
-    /* @internal */ getDeclarationName(node: Declaration | undefined, allowComments?: boolean, allowSourceMaps?: boolean): Identifier;
+    /** @internal */ getDeclarationName(node: Declaration | undefined, allowComments?: boolean, allowSourceMaps?: boolean): Identifier;
     /**
      * Gets a namespace-qualified name for use in expressions.
      *
@@ -8292,7 +8292,7 @@ export interface NodeFactory {
      * @param allowComments A value indicating whether comments may be emitted for the name.
      * @param allowSourceMaps A value indicating whether source maps may be emitted for the name.
      */
-    /* @internal */ getNamespaceMemberName(ns: Identifier, name: Identifier, allowComments?: boolean, allowSourceMaps?: boolean): PropertyAccessExpression;
+    /** @internal */ getNamespaceMemberName(ns: Identifier, name: Identifier, allowComments?: boolean, allowSourceMaps?: boolean): PropertyAccessExpression;
     /**
      * Gets the exported name of a declaration for use in expressions.
      *
@@ -8304,15 +8304,15 @@ export interface NodeFactory {
      * @param allowComments A value indicating whether comments may be emitted for the name.
      * @param allowSourceMaps A value indicating whether source maps may be emitted for the name.
      */
-    /* @internal */ getExternalModuleOrNamespaceExportName(ns: Identifier | undefined, node: Declaration, allowComments?: boolean, allowSourceMaps?: boolean): Identifier | PropertyAccessExpression;
+    /** @internal */ getExternalModuleOrNamespaceExportName(ns: Identifier | undefined, node: Declaration, allowComments?: boolean, allowSourceMaps?: boolean): Identifier | PropertyAccessExpression;
 
     //
     // Utilities
     //
 
     restoreOuterExpressions(outerExpression: Expression | undefined, innerExpression: Expression, kinds?: OuterExpressionKinds): Expression;
-    /* @internal */ restoreEnclosingLabel(node: Statement, outermostLabeledStatement: LabeledStatement | undefined, afterRestoreLabelCallback?: (node: LabeledStatement) => void): Statement;
-    /* @internal */ createUseStrictPrologue(): PrologueDirective;
+    /** @internal */ restoreEnclosingLabel(node: Statement, outermostLabeledStatement: LabeledStatement | undefined, afterRestoreLabelCallback?: (node: LabeledStatement) => void): Statement;
+    /** @internal */ createUseStrictPrologue(): PrologueDirective;
     /**
      * Copies any necessary standard and custom prologue-directives into target array.
      * @param source origin statements array
@@ -8320,7 +8320,7 @@ export interface NodeFactory {
      * @param ensureUseStrict boolean determining whether the function need to add prologue-directives
      * @param visitor Optional callback used to visit any custom prologue directives.
      */
-    /* @internal */ copyPrologue(source: readonly Statement[], target: Push<Statement>, ensureUseStrict?: boolean, visitor?: (node: Node) => VisitResult<Node>): number;
+    /** @internal */ copyPrologue(source: readonly Statement[], target: Push<Statement>, ensureUseStrict?: boolean, visitor?: (node: Node) => VisitResult<Node>): number;
     /**
      * Copies only the standard (string-expression) prologue-directives into the target statement-array.
      * @param source origin statements array
@@ -8328,7 +8328,7 @@ export interface NodeFactory {
      * @param statementOffset The offset at which to begin the copy.
      * @param ensureUseStrict boolean determining whether the function need to add prologue-directives
      */
-    /* @internal */ copyStandardPrologue(source: readonly Statement[], target: Push<Statement>, statementOffset: number | undefined, ensureUseStrict?: boolean): number;
+    /** @internal */ copyStandardPrologue(source: readonly Statement[], target: Push<Statement>, statementOffset: number | undefined, ensureUseStrict?: boolean): number;
     /**
      * Copies only the custom prologue-directives into target statement-array.
      * @param source origin statements array
@@ -8336,29 +8336,29 @@ export interface NodeFactory {
      * @param statementOffset The offset at which to begin the copy.
      * @param visitor Optional callback used to visit any custom prologue directives.
      */
-    /* @internal */ copyCustomPrologue(source: readonly Statement[], target: Push<Statement>, statementOffset: number, visitor?: (node: Node) => VisitResult<Node>, filter?: (node: Node) => boolean): number;
-    /* @internal */ copyCustomPrologue(source: readonly Statement[], target: Push<Statement>, statementOffset: number | undefined, visitor?: (node: Node) => VisitResult<Node>, filter?: (node: Node) => boolean): number | undefined;
-    /* @internal */ ensureUseStrict(statements: NodeArray<Statement>): NodeArray<Statement>;
-    /* @internal */ liftToBlock(nodes: readonly Node[]): Statement;
+    /** @internal */ copyCustomPrologue(source: readonly Statement[], target: Push<Statement>, statementOffset: number, visitor?: (node: Node) => VisitResult<Node>, filter?: (node: Node) => boolean): number;
+    /** @internal */ copyCustomPrologue(source: readonly Statement[], target: Push<Statement>, statementOffset: number | undefined, visitor?: (node: Node) => VisitResult<Node>, filter?: (node: Node) => boolean): number | undefined;
+    /** @internal */ ensureUseStrict(statements: NodeArray<Statement>): NodeArray<Statement>;
+    /** @internal */ liftToBlock(nodes: readonly Node[]): Statement;
     /**
      * Merges generated lexical declarations into a new statement list.
      */
-    /* @internal */ mergeLexicalEnvironment(statements: NodeArray<Statement>, declarations: readonly Statement[] | undefined): NodeArray<Statement>;
+    /** @internal */ mergeLexicalEnvironment(statements: NodeArray<Statement>, declarations: readonly Statement[] | undefined): NodeArray<Statement>;
     /**
      * Appends generated lexical declarations to an array of statements.
      */
-    /* @internal */ mergeLexicalEnvironment(statements: Statement[], declarations: readonly Statement[] | undefined): Statement[];
+    /** @internal */ mergeLexicalEnvironment(statements: Statement[], declarations: readonly Statement[] | undefined): Statement[];
     /**
      * Creates a shallow, memberwise clone of a node.
      * - The result will have its `original` pointer set to `node`.
      * - The result will have its `pos` and `end` set to `-1`.
      * - *DO NOT USE THIS* if a more appropriate function is available.
      */
-    /* @internal */ cloneNode<T extends Node | undefined>(node: T): T;
-    /* @internal */ updateModifiers<T extends HasModifiers>(node: T, modifiers: readonly Modifier[] | ModifierFlags | undefined): T;
+    /** @internal */ cloneNode<T extends Node | undefined>(node: T): T;
+    /** @internal */ updateModifiers<T extends HasModifiers>(node: T, modifiers: readonly Modifier[] | ModifierFlags | undefined): T;
 }
 
-/* @internal */
+/** @internal */
 export const enum LexicalEnvironmentFlags {
     None = 0,
     InParameters = 1 << 0, // currently visiting a parameter list
@@ -8374,8 +8374,8 @@ export interface CoreTransformationContext {
     /** Starts a new lexical environment. */
     startLexicalEnvironment(): void;
 
-    /* @internal */ setLexicalEnvironmentFlags(flags: LexicalEnvironmentFlags, value: boolean): void;
-    /* @internal */ getLexicalEnvironmentFlags(): LexicalEnvironmentFlags;
+    /** @internal */ setLexicalEnvironmentFlags(flags: LexicalEnvironmentFlags, value: boolean): void;
+    /** @internal */ getLexicalEnvironmentFlags(): LexicalEnvironmentFlags;
 
     /** Suspends the current lexical environment, usually after visiting a parameter list. */
     suspendLexicalEnvironment(): void;
@@ -8392,21 +8392,21 @@ export interface CoreTransformationContext {
     /** Hoists a variable declaration to the containing scope. */
     hoistVariableDeclaration(node: Identifier): void;
 
-    /*@internal*/ startBlockScope(): void;
+    /** @internal */ startBlockScope(): void;
 
-    /*@internal*/ endBlockScope(): Statement[] | undefined;
+    /** @internal */ endBlockScope(): Statement[] | undefined;
 
-    /*@internal*/ addBlockScopedVariable(node: Identifier): void;
+    /** @internal */ addBlockScopedVariable(node: Identifier): void;
 
     /** Adds an initialization statement to the top of the lexical environment. */
-    /* @internal */
+    /** @internal */
     addInitializationStatement(node: Statement): void;
 }
 
 export interface TransformationContext extends CoreTransformationContext {
-    /*@internal*/ getEmitResolver(): EmitResolver;
-    /*@internal*/ getEmitHost(): EmitHost;
-    /*@internal*/ getEmitHelperFactory(): EmitHelperFactory;
+    /** @internal */ getEmitResolver(): EmitResolver;
+    /** @internal */ getEmitHost(): EmitHost;
+    /** @internal */ getEmitHelperFactory(): EmitHelperFactory;
 
     /** Records a request for a non-scoped emit helper in the current context. */
     requestEmitHelper(helper: EmitHelper): void;
@@ -8450,7 +8450,7 @@ export interface TransformationContext extends CoreTransformationContext {
      */
     onEmitNode: (hint: EmitHint, node: Node, emitCallback: (hint: EmitHint, node: Node) => void) => void;
 
-    /* @internal */ addDiagnostic(diag: DiagnosticWithLocation): void;
+    /** @internal */ addDiagnostic(diag: DiagnosticWithLocation): void;
 }
 
 export interface TransformationResult<T extends Node> {
@@ -8545,14 +8545,14 @@ export interface Printer {
      * Prints a bundle of source files as-is, without any emit transformations.
      */
     printBundle(bundle: Bundle): string;
-    /*@internal*/ writeNode(hint: EmitHint, node: Node, sourceFile: SourceFile | undefined, writer: EmitTextWriter): void;
-    /*@internal*/ writeList<T extends Node>(format: ListFormat, list: NodeArray<T> | undefined, sourceFile: SourceFile | undefined, writer: EmitTextWriter): void;
-    /*@internal*/ writeFile(sourceFile: SourceFile, writer: EmitTextWriter, sourceMapGenerator: SourceMapGenerator | undefined): void;
-    /*@internal*/ writeBundle(bundle: Bundle, writer: EmitTextWriter, sourceMapGenerator: SourceMapGenerator | undefined): void;
-    /*@internal*/ bundleFileInfo?: BundleFileInfo;
+    /** @internal */ writeNode(hint: EmitHint, node: Node, sourceFile: SourceFile | undefined, writer: EmitTextWriter): void;
+    /** @internal */ writeList<T extends Node>(format: ListFormat, list: NodeArray<T> | undefined, sourceFile: SourceFile | undefined, writer: EmitTextWriter): void;
+    /** @internal */ writeFile(sourceFile: SourceFile, writer: EmitTextWriter, sourceMapGenerator: SourceMapGenerator | undefined): void;
+    /** @internal */ writeBundle(bundle: Bundle, writer: EmitTextWriter, sourceMapGenerator: SourceMapGenerator | undefined): void;
+    /** @internal */ bundleFileInfo?: BundleFileInfo;
 }
 
-/*@internal*/
+/** @internal */
 export const enum BundleFileSectionKind {
     Prologue = "prologue",
     EmitHelpers = "emitHelpers",
@@ -8568,51 +8568,51 @@ export const enum BundleFileSectionKind {
     // comments?
 }
 
-/*@internal*/
+/** @internal */
 export interface BundleFileSectionBase extends TextRange {
     kind: BundleFileSectionKind;
     data?: string;
 }
 
-/*@internal*/
+/** @internal */
 export interface BundleFilePrologue extends BundleFileSectionBase {
     kind: BundleFileSectionKind.Prologue;
     data: string;
 }
 
-/*@internal*/
+/** @internal */
 export interface BundleFileEmitHelpers extends BundleFileSectionBase {
     kind: BundleFileSectionKind.EmitHelpers;
     data: string;
 }
 
-/*@internal*/
+/** @internal */
 export interface BundleFileHasNoDefaultLib extends BundleFileSectionBase {
     kind: BundleFileSectionKind.NoDefaultLib;
 }
 
-/*@internal*/
+/** @internal */
 export interface BundleFileReference extends BundleFileSectionBase {
     kind: BundleFileSectionKind.Reference | BundleFileSectionKind.Type | BundleFileSectionKind.Lib | BundleFileSectionKind.TypeResolutionModeImport | BundleFileSectionKind.TypeResolutionModeRequire;
     data: string;
 }
 
-/*@internal*/
+/** @internal */
 export interface BundleFilePrepend extends BundleFileSectionBase {
     kind: BundleFileSectionKind.Prepend;
     data: string;
     texts: BundleFileTextLike[];
 }
 
-/*@internal*/
+/** @internal */
 export type BundleFileTextLikeKind = BundleFileSectionKind.Text | BundleFileSectionKind.Internal;
 
-/*@internal*/
+/** @internal */
 export interface BundleFileTextLike extends BundleFileSectionBase {
     kind: BundleFileTextLikeKind;
 }
 
-/*@internal*/
+/** @internal */
 export type BundleFileSection =
     BundleFilePrologue
     | BundleFileEmitHelpers
@@ -8621,31 +8621,31 @@ export type BundleFileSection =
     | BundleFilePrepend
     | BundleFileTextLike;
 
-/*@internal*/
+/** @internal */
 export interface SourceFilePrologueDirectiveExpression extends TextRange {
     text: string;
 }
 
-/*@internal*/
+/** @internal */
 export interface SourceFilePrologueDirective extends TextRange {
     expression: SourceFilePrologueDirectiveExpression;
 }
 
-/*@internal*/
+/** @internal */
 export interface SourceFilePrologueInfo {
     file: number;
     text: string;
     directives: SourceFilePrologueDirective[];
 }
 
-/*@internal*/
+/** @internal */
 export interface SourceFileInfo {
     // List of helpers in own source files emitted if no prepend is present
     helpers?: string[];
     prologues?: SourceFilePrologueInfo[];
 }
 
-/*@internal*/
+/** @internal */
 export interface BundleFileInfo {
     sections: BundleFileSection[];
     hash?: string;
@@ -8653,7 +8653,7 @@ export interface BundleFileInfo {
     sources?: SourceFileInfo;
 }
 
-/*@internal*/
+/** @internal */
 export interface BundleBuildInfo {
     js?: BundleFileInfo;
     dts?: BundleFileInfo;
@@ -8661,7 +8661,7 @@ export interface BundleBuildInfo {
     sourceFiles: readonly string[];
 }
 
-/* @internal */
+/** @internal */
 export interface BuildInfo {
     bundle?: BundleBuildInfo;
     program?: ProgramBuildInfo;
@@ -8716,16 +8716,16 @@ export interface PrintHandlers {
      * ```
      */
     substituteNode?(hint: EmitHint, node: Node): Node;
-    /*@internal*/ onEmitSourceMapOfNode?: (hint: EmitHint, node: Node, emitCallback: (hint: EmitHint, node: Node) => void) => void;
-    /*@internal*/ onEmitSourceMapOfToken?: (node: Node | undefined, token: SyntaxKind, writer: (s: string) => void, pos: number, emitCallback: (token: SyntaxKind, writer: (s: string) => void, pos: number) => number) => number;
-    /*@internal*/ onEmitSourceMapOfPosition?: (pos: number) => void;
-    /*@internal*/ onSetSourceFile?: (node: SourceFile) => void;
-    /*@internal*/ onBeforeEmitNode?: (node: Node | undefined) => void;
-    /*@internal*/ onAfterEmitNode?: (node: Node | undefined) => void;
-    /*@internal*/ onBeforeEmitNodeArray?: (nodes: NodeArray<any> | undefined) => void;
-    /*@internal*/ onAfterEmitNodeArray?: (nodes: NodeArray<any> | undefined) => void;
-    /*@internal*/ onBeforeEmitToken?: (node: Node) => void;
-    /*@internal*/ onAfterEmitToken?: (node: Node) => void;
+    /** @internal */ onEmitSourceMapOfNode?: (hint: EmitHint, node: Node, emitCallback: (hint: EmitHint, node: Node) => void) => void;
+    /** @internal */ onEmitSourceMapOfToken?: (node: Node | undefined, token: SyntaxKind, writer: (s: string) => void, pos: number, emitCallback: (token: SyntaxKind, writer: (s: string) => void, pos: number) => number) => number;
+    /** @internal */ onEmitSourceMapOfPosition?: (pos: number) => void;
+    /** @internal */ onSetSourceFile?: (node: SourceFile) => void;
+    /** @internal */ onBeforeEmitNode?: (node: Node | undefined) => void;
+    /** @internal */ onAfterEmitNode?: (node: Node | undefined) => void;
+    /** @internal */ onBeforeEmitNodeArray?: (nodes: NodeArray<any> | undefined) => void;
+    /** @internal */ onAfterEmitNodeArray?: (nodes: NodeArray<any> | undefined) => void;
+    /** @internal */ onBeforeEmitToken?: (node: Node) => void;
+    /** @internal */ onAfterEmitToken?: (node: Node) => void;
 }
 
 export interface PrinterOptions {
@@ -8733,23 +8733,23 @@ export interface PrinterOptions {
     newLine?: NewLineKind;
     omitTrailingSemicolon?: boolean;
     noEmitHelpers?: boolean;
-    /*@internal*/ module?: CompilerOptions["module"];
-    /*@internal*/ target?: CompilerOptions["target"];
-    /*@internal*/ sourceMap?: boolean;
-    /*@internal*/ inlineSourceMap?: boolean;
-    /*@internal*/ inlineSources?: boolean;
-    /*@internal*/ extendedDiagnostics?: boolean;
-    /*@internal*/ onlyPrintJsDocStyle?: boolean;
-    /*@internal*/ neverAsciiEscape?: boolean;
-    /*@internal*/ writeBundleFileInfo?: boolean;
-    /*@internal*/ recordInternalSection?: boolean;
-    /*@internal*/ stripInternal?: boolean;
-    /*@internal*/ preserveSourceNewlines?: boolean;
-    /*@internal*/ terminateUnterminatedLiterals?: boolean;
-    /*@internal*/ relativeToBuildInfo?: (path: string) => string;
-}
-
-/* @internal */
+    /** @internal */ module?: CompilerOptions["module"];
+    /** @internal */ target?: CompilerOptions["target"];
+    /** @internal */ sourceMap?: boolean;
+    /** @internal */ inlineSourceMap?: boolean;
+    /** @internal */ inlineSources?: boolean;
+    /** @internal */ extendedDiagnostics?: boolean;
+    /** @internal */ onlyPrintJsDocStyle?: boolean;
+    /** @internal */ neverAsciiEscape?: boolean;
+    /** @internal */ writeBundleFileInfo?: boolean;
+    /** @internal */ recordInternalSection?: boolean;
+    /** @internal */ stripInternal?: boolean;
+    /** @internal */ preserveSourceNewlines?: boolean;
+    /** @internal */ terminateUnterminatedLiterals?: boolean;
+    /** @internal */ relativeToBuildInfo?: (path: string) => string;
+}
+
+/** @internal */
 export interface RawSourceMap {
     version: 3;
     file: string;
@@ -8763,7 +8763,7 @@ export interface RawSourceMap {
 /**
  * Generates a source map.
  */
-/* @internal */
+/** @internal */
 export interface SourceMapGenerator {
     getSources(): readonly string[];
     /**
@@ -8800,7 +8800,7 @@ export interface SourceMapGenerator {
     toString(): string;
 }
 
-/* @internal */
+/** @internal */
 export interface DocumentPositionMapperHost {
     getSourceFileLike(fileName: string): SourceFileLike | undefined;
     getCanonicalFileName(path: string): string;
@@ -8810,19 +8810,19 @@ export interface DocumentPositionMapperHost {
 /**
  * Maps positions between source and generated files.
  */
-/* @internal */
+/** @internal */
 export interface DocumentPositionMapper {
     getSourcePosition(input: DocumentPosition): DocumentPosition;
     getGeneratedPosition(input: DocumentPosition): DocumentPosition;
 }
 
-/* @internal */
+/** @internal */
 export interface DocumentPosition {
     fileName: string;
     pos: number;
 }
 
-/* @internal */
+/** @internal */
 export interface EmitTextWriter extends SymbolWriter {
     write(s: string): void;
     writeTrailingSemicolon(text: string): void;
@@ -8846,12 +8846,12 @@ export interface GetEffectiveTypeRootsHost {
     getCurrentDirectory?(): string;
 }
 
-/* @internal */
+/** @internal */
 export interface HasCurrentDirectory {
     getCurrentDirectory(): string;
 }
 
-/*@internal*/
+/** @internal */
 export interface ModuleSpecifierResolutionHost {
     useCaseSensitiveFileNames?(): boolean;
     fileExists(path: string): boolean;
@@ -8871,26 +8871,26 @@ export interface ModuleSpecifierResolutionHost {
     getFileIncludeReasons(): MultiMap<Path, FileIncludeReason>;
 }
 
-/* @internal */
+/** @internal */
 export interface ModulePath {
     path: string;
     isInNodeModules: boolean;
     isRedirect: boolean;
 }
 
-/*@internal*/
+/** @internal */
 export interface ResolvedModuleSpecifierInfo {
     modulePaths: readonly ModulePath[] | undefined;
     moduleSpecifiers: readonly string[] | undefined;
     isBlockedByPackageJsonDependencies: boolean | undefined;
 }
 
-/* @internal */
+/** @internal */
 export interface ModuleSpecifierOptions {
     overrideImportMode?: SourceFile["impliedNodeFormat"];
 }
 
-/* @internal */
+/** @internal */
 export interface ModuleSpecifierCache {
     get(fromFileName: Path, toFileName: Path, preferences: UserPreferences, options: ModuleSpecifierOptions): Readonly<ResolvedModuleSpecifierInfo> | undefined;
     set(fromFileName: Path, toFileName: Path, preferences: UserPreferences, options: ModuleSpecifierOptions, modulePaths: readonly ModulePath[], moduleSpecifiers: readonly string[]): void;
@@ -8901,7 +8901,7 @@ export interface ModuleSpecifierCache {
 }
 
 // Note: this used to be deprecated in our public API, but is still used internally
-/* @internal */
+/** @internal */
 export interface SymbolTracker {
     // Called when the symbol writer encounters a symbol to write.  Currently only used by the
     // declaration emitter to help determine if it should patch up the final declaration file
@@ -8931,7 +8931,7 @@ export interface TextChangeRange {
     newLength: number;
 }
 
-/* @internal */
+/** @internal */
 export interface DiagnosticCollection {
     // Adds a diagnostic to this diagnostic collection.
     add(diagnostic: Diagnostic): void;
@@ -9040,7 +9040,7 @@ export const enum ListFormat {
     JSDocComment = MultiLine | AsteriskDelimited,
 }
 
-/* @internal */
+/** @internal */
 export const enum PragmaKindFlags {
     None            =      0,
     /**
@@ -9064,14 +9064,14 @@ export const enum PragmaKindFlags {
     Default = All,
 }
 
-/* @internal */
+/** @internal */
 interface PragmaArgumentSpecification<TName extends string> {
     name: TName; // Determines the name of the key in the resulting parsed type, type parameter to cause literal type inference
     optional?: boolean;
     captureSpan?: boolean;
 }
 
-/* @internal */
+/** @internal */
 export interface PragmaDefinition<T1 extends string = string, T2 extends string = string, T3 extends string = string, T4 extends string = string> {
     args?:
         | readonly [PragmaArgumentSpecification<T1>]
@@ -9084,7 +9084,7 @@ export interface PragmaDefinition<T1 extends string = string, T2 extends string
 
 // While not strictly a type, this is here because `PragmaMap` needs to be here to be used with `SourceFile`, and we don't
 //  fancy effectively defining it twice, once in value-space and once in type-space
-/* @internal */
+/** @internal */
 export const commentPragmas = {
     "reference": {
         args: [
@@ -9128,20 +9128,20 @@ export const commentPragmas = {
     },
 } as const;
 
-/* @internal */
+/** @internal */
 type PragmaArgTypeMaybeCapture<TDesc> = TDesc extends {captureSpan: true} ? {value: string, pos: number, end: number} : string;
 
-/* @internal */
+/** @internal */
 type PragmaArgTypeOptional<TDesc, TName extends string> =
     TDesc extends {optional: true}
         ? {[K in TName]?: PragmaArgTypeMaybeCapture<TDesc>}
         : {[K in TName]: PragmaArgTypeMaybeCapture<TDesc>};
 
-/* @internal */
+/** @internal */
 type UnionToIntersection<U> =
         (U extends any ? (k: U) => void : never) extends ((k: infer I) => void) ? I : never;
 
-/* @internal */
+/** @internal */
 type ArgumentDefinitionToFieldUnion<T extends readonly PragmaArgumentSpecification<any>[]> = {
     [K in keyof T]: PragmaArgTypeOptional<T[K], T[K] extends {name: infer TName} ? TName extends string ? TName : never : never>
 }[Extract<keyof T, number>]; // The mapped type maps over only the tuple members, but this reindex gets _all_ members - by extracting only `number` keys, we get only the tuple members
@@ -9149,22 +9149,22 @@ type ArgumentDefinitionToFieldUnion<T extends readonly PragmaArgumentSpecificati
 /**
  * Maps a pragma definition into the desired shape for its arguments object
  */
-/* @internal */
+/** @internal */
 type PragmaArgumentType<KPrag extends keyof ConcretePragmaSpecs> =
     ConcretePragmaSpecs[KPrag] extends { args: readonly PragmaArgumentSpecification<any>[] }
         ? UnionToIntersection<ArgumentDefinitionToFieldUnion<ConcretePragmaSpecs[KPrag]["args"]>>
         : never;
 
-/* @internal */
+/** @internal */
 type ConcretePragmaSpecs = typeof commentPragmas;
 
-/* @internal */
+/** @internal */
 export type PragmaPseudoMap = {[K in keyof ConcretePragmaSpecs]: {arguments: PragmaArgumentType<K>, range: CommentRange}};
 
-/* @internal */
+/** @internal */
 export type PragmaPseudoMapEntry = {[K in keyof PragmaPseudoMap]: {name: K, args: PragmaPseudoMap[K]}}[keyof PragmaPseudoMap];
 
-/* @internal */
+/** @internal */
 export interface ReadonlyPragmaMap extends ReadonlyESMap<string, PragmaPseudoMap[keyof PragmaPseudoMap] | PragmaPseudoMap[keyof PragmaPseudoMap][]> {
     get<TKey extends keyof PragmaPseudoMap>(key: TKey): PragmaPseudoMap[TKey] | PragmaPseudoMap[TKey][];
     forEach(action: <TKey extends keyof PragmaPseudoMap>(value: PragmaPseudoMap[TKey] | PragmaPseudoMap[TKey][], key: TKey) => void): void;
@@ -9175,14 +9175,14 @@ export interface ReadonlyPragmaMap extends ReadonlyESMap<string, PragmaPseudoMap
  * value (if only one was found), or an array of multiple argument values if the pragma is present
  * in multiple places
  */
-/* @internal */
+/** @internal */
 export interface PragmaMap extends ESMap<string, PragmaPseudoMap[keyof PragmaPseudoMap] | PragmaPseudoMap[keyof PragmaPseudoMap][]>, ReadonlyPragmaMap {
     set<TKey extends keyof PragmaPseudoMap>(key: TKey, value: PragmaPseudoMap[TKey] | PragmaPseudoMap[TKey][]): this;
     get<TKey extends keyof PragmaPseudoMap>(key: TKey): PragmaPseudoMap[TKey] | PragmaPseudoMap[TKey][];
     forEach(action: <TKey extends keyof PragmaPseudoMap>(value: PragmaPseudoMap[TKey] | PragmaPseudoMap[TKey][], key: TKey) => void): void;
 }
 
-/* @internal */
+/** @internal */
 export interface CommentDirectivesMap {
     getUnusedExpectations(): CommentDirective[];
     markUsed(matchedLine: number): boolean;
@@ -9226,7 +9226,7 @@ export interface PseudoBigInt {
     base10Value: string;
 }
 
-/* @internal */
+/** @internal */
 export interface Queue<T> {
     enqueue(...items: T[]): void;
     dequeue(): T;
diff --git a/src/compiler/utilities.ts b/src/compiler/utilities.ts
index 47acbf220e..53db12a227 100644
--- a/src/compiler/utilities.ts
+++ b/src/compiler/utilities.ts
@@ -2779,7 +2779,7 @@ function isVoidZero(node: Node) {
  * Does not handle signed numeric names like `a[+0]` - handling those would require handling prefix unary expressions
  * throughout late binding handling as well, which is awkward (but ultimately probably doable if there is demand)
  */
-/* @internal */
+/** @internal */
 export function getElementOrPropertyAccessArgumentExpressionOrName(node: AccessExpression): Identifier | PrivateIdentifier | StringLiteralLike | NumericLiteral | ElementAccessExpression | undefined {
     if (isPropertyAccessExpression(node)) {
         return node.name;
@@ -2791,7 +2791,7 @@ export function getElementOrPropertyAccessArgumentExpressionOrName(node: AccessE
     return node;
 }
 
-/* @internal */
+/** @internal */
 export function getElementOrPropertyAccessName(node: LiteralLikeElementAccessExpression | PropertyAccessExpression): __String;
 /** @internal */
 export function getElementOrPropertyAccessName(node: AccessExpression): __String | undefined;
@@ -6626,12 +6626,12 @@ export function formatStringFromArgs(text: string, args: ArrayLike<string | numb
 
 let localizedDiagnosticMessages: MapLike<string> | undefined;
 
-/* @internal */
+/** @internal */
 export function setLocalizedDiagnosticMessages(messages: typeof localizedDiagnosticMessages) {
     localizedDiagnosticMessages = messages;
 }
 
-/* @internal */
+/** @internal */
 // If the localized messages json is unset, and if given function use it to set the json
 
 export function maybeSetLocalizedDiagnosticMessages(getMessages: undefined | (() => typeof localizedDiagnosticMessages)) {
@@ -8055,7 +8055,7 @@ export function arrayIsHomogeneous<T>(array: readonly T[], comparer: EqualityCom
 /**
  * Bypasses immutability and directly sets the `pos` property of a `TextRange` or `Node`.
  */
-/* @internal */
+/** @internal */
 export function setTextRangePos<T extends ReadonlyTextRange>(range: T, pos: number) {
     (range as TextRange).pos = pos;
     return range;
@@ -8064,7 +8064,7 @@ export function setTextRangePos<T extends ReadonlyTextRange>(range: T, pos: numb
 /**
  * Bypasses immutability and directly sets the `end` property of a `TextRange` or `Node`.
  */
-/* @internal */
+/** @internal */
 export function setTextRangeEnd<T extends ReadonlyTextRange>(range: T, end: number) {
     (range as TextRange).end = end;
     return range;
@@ -8073,7 +8073,7 @@ export function setTextRangeEnd<T extends ReadonlyTextRange>(range: T, end: numb
 /**
  * Bypasses immutability and directly sets the `pos` and `end` properties of a `TextRange` or `Node`.
  */
-/* @internal */
+/** @internal */
 export function setTextRangePosEnd<T extends ReadonlyTextRange>(range: T, pos: number, end: number) {
     return setTextRangeEnd(setTextRangePos(range, pos), end);
 }
@@ -8082,7 +8082,7 @@ export function setTextRangePosEnd<T extends ReadonlyTextRange>(range: T, pos: n
  * Bypasses immutability and directly sets the `pos` and `end` properties of a `TextRange` or `Node` from the
  * provided position and width.
  */
-/* @internal */
+/** @internal */
 export function setTextRangePosWidth<T extends ReadonlyTextRange>(range: T, pos: number, width: number) {
     return setTextRangePosEnd(range, pos, pos + width);
 }
@@ -8090,9 +8090,9 @@ export function setTextRangePosWidth<T extends ReadonlyTextRange>(range: T, pos:
 /**
  * Bypasses immutability and directly sets the `flags` property of a `Node`.
  */
-/* @internal */
+/** @internal */
 export function setNodeFlags<T extends Node>(node: T, newFlags: NodeFlags): T;
-/* @internal */
+/** @internal */
 export function setNodeFlags<T extends Node>(node: T | undefined, newFlags: NodeFlags): T | undefined;
 /** @internal */
 export function setNodeFlags<T extends Node>(node: T | undefined, newFlags: NodeFlags): T | undefined {
@@ -8105,9 +8105,9 @@ export function setNodeFlags<T extends Node>(node: T | undefined, newFlags: Node
 /**
  * Bypasses immutability and directly sets the `parent` property of a `Node`.
  */
-/* @internal */
+/** @internal */
 export function setParent<T extends Node>(child: T, parent: T["parent"] | undefined): T;
-/* @internal */
+/** @internal */
 export function setParent<T extends Node>(child: T | undefined, parent: T["parent"] | undefined): T | undefined;
 /** @internal */
 export function setParent<T extends Node>(child: T | undefined, parent: T["parent"] | undefined): T | undefined {
@@ -8120,9 +8120,9 @@ export function setParent<T extends Node>(child: T | undefined, parent: T["paren
 /**
  * Bypasses immutability and directly sets the `parent` property of each `Node` in an array of nodes, if is not already set.
  */
-/* @internal */
+/** @internal */
 export function setEachParent<T extends readonly Node[]>(children: T, parent: T[number]["parent"]): T;
-/* @internal */
+/** @internal */
 export function setEachParent<T extends readonly Node[]>(children: T | undefined, parent: T[number]["parent"]): T | undefined;
 /** @internal */
 export function setEachParent<T extends readonly Node[]>(children: T | undefined, parent: T[number]["parent"]): T | undefined {
@@ -8140,9 +8140,9 @@ export function setEachParent<T extends readonly Node[]>(children: T | undefined
  * @param incremental When `true`, only recursively descends through nodes whose `parent` pointers are incorrect.
  * This allows us to quickly bail out of setting `parent` for subtrees during incremental parsing.
  */
-/* @internal */
+/** @internal */
 export function setParentRecursive<T extends Node>(rootNode: T, incremental: boolean): T;
-/* @internal */
+/** @internal */
 export function setParentRecursive<T extends Node>(rootNode: T | undefined, incremental: boolean): T | undefined;
 /** @internal */
 export function setParentRecursive<T extends Node>(rootNode: T | undefined, incremental: boolean): T | undefined {
@@ -8319,7 +8319,7 @@ export function hasContextSensitiveParameters(node: FunctionLikeDeclaration) {
     return false;
 }
 
-/* @internal */
+/** @internal */
 export function isInfinityOrNaNString(name: string | __String): boolean {
     return name === "Infinity" || name === "-Infinity" || name === "NaN";
 }
diff --git a/src/compiler/utilitiesPublic.ts b/src/compiler/utilitiesPublic.ts
index d31ae70159..4a81783914 100644
--- a/src/compiler/utilitiesPublic.ts
+++ b/src/compiler/utilitiesPublic.ts
@@ -95,7 +95,7 @@ export function textSpanContainsPosition(span: TextSpan, position: number) {
     return position >= span.start && position < textSpanEnd(span);
 }
 
-/* @internal */
+/** @internal */
 export function textRangeContainsPositionInclusive(span: TextRange, position: number): boolean {
     return position >= span.pos && position <= span.end;
 }
@@ -354,7 +354,7 @@ export function getCombinedModifierFlags(node: Declaration): ModifierFlags {
     return getCombinedFlags(node, getEffectiveModifierFlags);
 }
 
-/* @internal */
+/** @internal */
 export function getCombinedNodeFlagsAlwaysIncludeJSDoc(node: Declaration): ModifierFlags {
     return getCombinedFlags(node, getEffectiveModifierFlagsAlwaysIncludeJSDoc);
 }
@@ -370,7 +370,7 @@ export function getCombinedNodeFlags(node: Node): NodeFlags {
     return getCombinedFlags(node, n => n.flags);
 }
 
-/* @internal */
+/** @internal */
 export const supportedLocaleDirectories = ["cs", "de", "es", "fr", "it", "ja", "ko", "pl", "pt-br", "ru", "tr", "zh-cn", "zh-tw"];
 
 /**
@@ -672,7 +672,7 @@ export function getNameOfDeclaration(declaration: Declaration | Expression | und
         (isFunctionExpression(declaration) || isArrowFunction(declaration) || isClassExpression(declaration) ? getAssignedName(declaration) : undefined);
 }
 
-/*@internal*/
+/** @internal */
 export function getAssignedName(node: Node): DeclarationName | undefined {
     if (!node.parent) {
         return undefined;
@@ -740,7 +740,7 @@ export function getJSDocParameterTags(param: ParameterDeclaration): readonly JSD
     return getJSDocParameterTagsWorker(param, /*noCache*/ false);
 }
 
-/* @internal */
+/** @internal */
 export function getJSDocParameterTagsNoCache(param: ParameterDeclaration): readonly JSDocParameterTag[] {
     return getJSDocParameterTagsWorker(param, /*noCache*/ true);
 }
@@ -765,7 +765,7 @@ export function getJSDocTypeParameterTags(param: TypeParameterDeclaration): read
     return getJSDocTypeParameterTagsWorker(param, /*noCache*/ false);
 }
 
-/* @internal */
+/** @internal */
 export function getJSDocTypeParameterTagsNoCache(param: TypeParameterDeclaration): readonly JSDocTemplateTag[] {
     return getJSDocTypeParameterTagsWorker(param, /*noCache*/ true);
 }
@@ -800,7 +800,7 @@ export function getJSDocPublicTag(node: Node): JSDocPublicTag | undefined {
     return getFirstJSDocTag(node, isJSDocPublicTag);
 }
 
-/*@internal*/
+/** @internal */
 export function getJSDocPublicTagNoCache(node: Node): JSDocPublicTag | undefined {
     return getFirstJSDocTag(node, isJSDocPublicTag, /*noCache*/ true);
 }
@@ -810,7 +810,7 @@ export function getJSDocPrivateTag(node: Node): JSDocPrivateTag | undefined {
     return getFirstJSDocTag(node, isJSDocPrivateTag);
 }
 
-/*@internal*/
+/** @internal */
 export function getJSDocPrivateTagNoCache(node: Node): JSDocPrivateTag | undefined {
     return getFirstJSDocTag(node, isJSDocPrivateTag, /*noCache*/ true);
 }
@@ -820,7 +820,7 @@ export function getJSDocProtectedTag(node: Node): JSDocProtectedTag | undefined
     return getFirstJSDocTag(node, isJSDocProtectedTag);
 }
 
-/*@internal*/
+/** @internal */
 export function getJSDocProtectedTagNoCache(node: Node): JSDocProtectedTag | undefined {
     return getFirstJSDocTag(node, isJSDocProtectedTag, /*noCache*/ true);
 }
@@ -830,7 +830,7 @@ export function getJSDocReadonlyTag(node: Node): JSDocReadonlyTag | undefined {
     return getFirstJSDocTag(node, isJSDocReadonlyTag);
 }
 
-/*@internal*/
+/** @internal */
 export function getJSDocReadonlyTagNoCache(node: Node): JSDocReadonlyTag | undefined {
     return getFirstJSDocTag(node, isJSDocReadonlyTag, /*noCache*/ true);
 }
@@ -844,7 +844,7 @@ export function getJSDocDeprecatedTag(node: Node): JSDocDeprecatedTag | undefine
     return getFirstJSDocTag(node, isJSDocDeprecatedTag);
 }
 
-/*@internal */
+/** @internal */
 export function getJSDocDeprecatedTagNoCache(node: Node): JSDocDeprecatedTag | undefined {
     return getFirstJSDocTag(node, isJSDocDeprecatedTag, /*noCache*/ true);
 }
@@ -942,7 +942,7 @@ export function getJSDocTags(node: Node): readonly JSDocTag[] {
     return getJSDocTagsWorker(node, /*noCache*/ false);
 }
 
-/* @internal */
+/** @internal */
 export function getJSDocTagsNoCache(node: Node): readonly JSDocTag[] {
     return getJSDocTagsWorker(node, /*noCache*/ true);
 }
@@ -1026,7 +1026,7 @@ export function isMemberName(node: Node): node is MemberName {
     return node.kind === SyntaxKind.Identifier || node.kind === SyntaxKind.PrivateIdentifier;
 }
 
-/* @internal */
+/** @internal */
 export function isGetOrSetAccessorDeclaration(node: Node): node is AccessorDeclaration {
     return node.kind === SyntaxKind.SetAccessor || node.kind === SyntaxKind.GetAccessor;
 }
@@ -1052,7 +1052,7 @@ export function isOptionalChain(node: Node): node is PropertyAccessChain | Eleme
             || kind === SyntaxKind.NonNullExpression);
 }
 
-/* @internal */
+/** @internal */
 export function isOptionalChainRoot(node: Node): node is OptionalChainRoot {
     return isOptionalChain(node) && !isNonNullExpression(node) && !!node.questionDotToken;
 }
@@ -1060,7 +1060,7 @@ export function isOptionalChainRoot(node: Node): node is OptionalChainRoot {
 /**
  * Determines whether a node is the expression preceding an optional chain (i.e. `a` in `a?.b`).
  */
-/* @internal */
+/** @internal */
 export function isExpressionOfOptionalChainRoot(node: Node): node is Expression & { parent: OptionalChainRoot } {
     return isOptionalChainRoot(node.parent) && node.parent.expression === node;
 }
@@ -1076,7 +1076,7 @@ export function isExpressionOfOptionalChainRoot(node: Node): node is Expression
  * 5. For `a?.(b?.c).d`, both `b?.c` and `a?.(b?.c)d` are outermost (`c` is the end of the chain starting at `b`, and `d` is
  *   the end of the chain starting at `a?.`)
  */
-/* @internal */
+/** @internal */
 export function isOutermostOptionalChain(node: OptionalChain) {
     return !isOptionalChain(node.parent) // cases 1, 2, and 3
         || isOptionalChainRoot(node.parent) // case 4
@@ -1137,12 +1137,12 @@ export function isJSDocPropertyLikeTag(node: Node): node is JSDocPropertyLikeTag
 //
 // All node tests in the following list should *not* reference parent pointers so that
 // they may be used with transformations.
-/* @internal */
+/** @internal */
 export function isNode(node: Node) {
     return isNodeKind(node.kind);
 }
 
-/* @internal */
+/** @internal */
 export function isNodeKind(kind: SyntaxKind) {
     return kind >= SyntaxKind.FirstNode;
 }
@@ -1167,14 +1167,14 @@ export function isToken(n: Node): boolean {
 
 // Node Arrays
 
-/* @internal */
+/** @internal */
 export function isNodeArray<T extends Node>(array: readonly T[]): array is NodeArray<T> {
     return array.hasOwnProperty("pos") && array.hasOwnProperty("end");
 }
 
 // Literals
 
-/* @internal */
+/** @internal */
 export function isLiteralKind(kind: SyntaxKind): kind is LiteralToken["kind"] {
     return SyntaxKind.FirstLiteralToken <= kind && kind <= SyntaxKind.LastLiteralToken;
 }
@@ -1198,7 +1198,7 @@ export function isLiteralExpressionOfObject(node: Node) {
 
 // Pseudo-literals
 
-/* @internal */
+/** @internal */
 export function isTemplateLiteralKind(kind: SyntaxKind): kind is TemplateLiteralToken["kind"] {
     return SyntaxKind.FirstTemplateToken <= kind && kind <= SyntaxKind.LastTemplateToken;
 }
@@ -1242,25 +1242,25 @@ export function isStringTextContainingNode(node: Node): node is StringLiteral |
 
 // Identifiers
 
-/* @internal */
+/** @internal */
 export function isGeneratedIdentifier(node: Node): node is GeneratedIdentifier {
     return isIdentifier(node) && (node.autoGenerateFlags! & GeneratedIdentifierFlags.KindMask) > GeneratedIdentifierFlags.None;
 }
 
 // Private Identifiers
-/*@internal*/
+/** @internal */
 export function isPrivateIdentifierClassElementDeclaration(node: Node): node is PrivateClassElementDeclaration {
     return (isPropertyDeclaration(node) || isMethodOrAccessor(node)) && isPrivateIdentifier(node.name);
 }
 
-/*@internal*/
+/** @internal */
 export function isPrivateIdentifierPropertyAccessExpression(node: Node): node is PrivateIdentifierPropertyAccessExpression {
     return isPropertyAccessExpression(node) && isPrivateIdentifier(node.name);
 }
 
 // Keywords
 
-/* @internal */
+/** @internal */
 export function isModifierKind(token: SyntaxKind): token is Modifier["kind"] {
     switch (token) {
         case SyntaxKind.AbstractKeyword:
@@ -1282,12 +1282,12 @@ export function isModifierKind(token: SyntaxKind): token is Modifier["kind"] {
     return false;
 }
 
-/* @internal */
+/** @internal */
 export function isParameterPropertyModifier(kind: SyntaxKind): boolean {
     return !!(modifierToFlag(kind) & ModifierFlags.ParameterPropertyModifier);
 }
 
-/* @internal */
+/** @internal */
 export function isClassMemberModifier(idToken: SyntaxKind): boolean {
     return isParameterPropertyModifier(idToken) || idToken === SyntaxKind.StaticKeyword || idToken === SyntaxKind.OverrideKeyword;
 }
@@ -1324,17 +1324,17 @@ export function isFunctionLike(node: Node | undefined): node is SignatureDeclara
     return !!node && isFunctionLikeKind(node.kind);
 }
 
-/* @internal */
+/** @internal */
 export function isFunctionLikeOrClassStaticBlockDeclaration(node: Node | undefined): node is SignatureDeclaration | ClassStaticBlockDeclaration {
     return !!node && (isFunctionLikeKind(node.kind) || isClassStaticBlockDeclaration(node));
 }
 
-/* @internal */
+/** @internal */
 export function isFunctionLikeDeclaration(node: Node): node is FunctionLikeDeclaration {
     return node && isFunctionLikeDeclarationKind(node.kind);
 }
 
-/* @internal */
+/** @internal */
 export function isBooleanLiteral(node: Node): node is BooleanLiteral {
     return node.kind === SyntaxKind.TrueKeyword || node.kind === SyntaxKind.FalseKeyword;
 }
@@ -1354,7 +1354,7 @@ function isFunctionLikeDeclarationKind(kind: SyntaxKind): boolean {
     }
 }
 
-/* @internal */
+/** @internal */
 export function isFunctionLikeKind(kind: SyntaxKind): boolean {
     switch (kind) {
         case SyntaxKind.MethodSignature:
@@ -1371,7 +1371,7 @@ export function isFunctionLikeKind(kind: SyntaxKind): boolean {
     }
 }
 
-/* @internal */
+/** @internal */
 export function isFunctionOrModuleBlock(node: Node): boolean {
     return isSourceFile(node) || isModuleBlock(node) || isBlock(node) && isFunctionLike(node.parent);
 }
@@ -1397,7 +1397,7 @@ export function isAccessor(node: Node): node is AccessorDeclaration {
     return node && (node.kind === SyntaxKind.GetAccessor || node.kind === SyntaxKind.SetAccessor);
 }
 
-/* @internal */
+/** @internal */
 export function isMethodOrAccessor(node: Node): node is MethodDeclaration | AccessorDeclaration {
     switch (node.kind) {
         case SyntaxKind.MethodDeclaration:
@@ -1463,7 +1463,7 @@ export function isFunctionOrConstructorTypeNode(node: Node): node is FunctionTyp
 
 // Binding patterns
 
-/* @internal */
+/** @internal */
 export function isBindingPattern(node: Node | undefined): node is BindingPattern {
     if (node) {
         const kind = node.kind;
@@ -1474,7 +1474,7 @@ export function isBindingPattern(node: Node | undefined): node is BindingPattern
     return false;
 }
 
-/* @internal */
+/** @internal */
 export function isAssignmentPattern(node: Node): node is AssignmentPattern {
     const kind = node.kind;
     return kind === SyntaxKind.ArrayLiteralExpression
@@ -1482,7 +1482,7 @@ export function isAssignmentPattern(node: Node): node is AssignmentPattern {
 }
 
 
-/* @internal */
+/** @internal */
 export function isArrayBindingElement(node: Node): node is ArrayBindingElement {
     const kind = node.kind;
     return kind === SyntaxKind.BindingElement
@@ -1493,7 +1493,7 @@ export function isArrayBindingElement(node: Node): node is ArrayBindingElement {
 /**
  * Determines whether the BindingOrAssignmentElement is a BindingElement-like declaration
  */
-/* @internal */
+/** @internal */
 export function isDeclarationBindingElement(bindingElement: BindingOrAssignmentElement): bindingElement is VariableDeclaration | ParameterDeclaration | BindingElement {
     switch (bindingElement.kind) {
         case SyntaxKind.VariableDeclaration:
@@ -1508,7 +1508,7 @@ export function isDeclarationBindingElement(bindingElement: BindingOrAssignmentE
 /**
  * Determines whether a node is a BindingOrAssignmentPattern
  */
-/* @internal */
+/** @internal */
 export function isBindingOrAssignmentPattern(node: BindingOrAssignmentElementTarget): node is BindingOrAssignmentPattern {
     return isObjectBindingOrAssignmentPattern(node)
         || isArrayBindingOrAssignmentPattern(node);
@@ -1517,7 +1517,7 @@ export function isBindingOrAssignmentPattern(node: BindingOrAssignmentElementTar
 /**
  * Determines whether a node is an ObjectBindingOrAssignmentPattern
  */
-/* @internal */
+/** @internal */
 export function isObjectBindingOrAssignmentPattern(node: BindingOrAssignmentElementTarget): node is ObjectBindingOrAssignmentPattern {
     switch (node.kind) {
         case SyntaxKind.ObjectBindingPattern:
@@ -1528,7 +1528,7 @@ export function isObjectBindingOrAssignmentPattern(node: BindingOrAssignmentElem
     return false;
 }
 
-/* @internal */
+/** @internal */
 export function isObjectBindingOrAssignmentElement(node: Node): node is ObjectBindingOrAssignmentElement {
     switch (node.kind) {
         case SyntaxKind.BindingElement:
@@ -1543,7 +1543,7 @@ export function isObjectBindingOrAssignmentElement(node: Node): node is ObjectBi
 /**
  * Determines whether a node is an ArrayBindingOrAssignmentPattern
  */
-/* @internal */
+/** @internal */
 export function isArrayBindingOrAssignmentPattern(node: BindingOrAssignmentElementTarget): node is ArrayBindingOrAssignmentPattern {
     switch (node.kind) {
         case SyntaxKind.ArrayBindingPattern:
@@ -1554,7 +1554,7 @@ export function isArrayBindingOrAssignmentPattern(node: BindingOrAssignmentEleme
     return false;
 }
 
-/* @internal */
+/** @internal */
 export function isPropertyAccessOrQualifiedNameOrImportTypeNode(node: Node): node is PropertyAccessExpression | QualifiedName | ImportTypeNode {
     const kind = node.kind;
     return kind === SyntaxKind.PropertyAccessExpression
@@ -1594,7 +1594,7 @@ export function isTemplateLiteral(node: Node): node is TemplateLiteral {
         || kind === SyntaxKind.NoSubstitutionTemplateLiteral;
 }
 
-/* @internal */
+/** @internal */
 export function isLeftHandSideExpression(node: Node): node is LeftHandSideExpression {
     return isLeftHandSideExpressionKind(skipPartiallyEmittedExpressions(node).kind);
 }
@@ -1637,7 +1637,7 @@ function isLeftHandSideExpressionKind(kind: SyntaxKind): boolean {
     }
 }
 
-/* @internal */
+/** @internal */
 export function isUnaryExpression(node: Node): node is UnaryExpression {
     return isUnaryExpressionKind(skipPartiallyEmittedExpressions(node).kind);
 }
@@ -1657,7 +1657,7 @@ function isUnaryExpressionKind(kind: SyntaxKind): boolean {
     }
 }
 
-/* @internal */
+/** @internal */
 export function isUnaryExpressionWithWrite(expr: Node): expr is PrefixUnaryExpression | PostfixUnaryExpression {
     switch (expr.kind) {
         case SyntaxKind.PostfixUnaryExpression:
@@ -1670,7 +1670,7 @@ export function isUnaryExpressionWithWrite(expr: Node): expr is PrefixUnaryExpre
     }
 }
 
-/* @internal */
+/** @internal */
 /**
  * Determines whether a node is an expression based only on its kind.
  * Use `isExpressionNode` if not in transforms.
@@ -1703,7 +1703,7 @@ export function isAssertionExpression(node: Node): node is AssertionExpression {
         || kind === SyntaxKind.AsExpression;
 }
 
-/* @internal */
+/** @internal */
 export function isNotEmittedOrPartiallyEmittedNode(node: Node): node is NotEmittedStatement | PartiallyEmittedExpression {
     return isNotEmittedStatement(node)
         || isPartiallyEmittedExpression(node);
@@ -1728,52 +1728,52 @@ export function isIterationStatement(node: Node, lookInLabeledStatements: boolea
     return false;
 }
 
-/* @internal */
+/** @internal */
 export function isScopeMarker(node: Node) {
     return isExportAssignment(node) || isExportDeclaration(node);
 }
 
-/* @internal */
+/** @internal */
 export function hasScopeMarker(statements: readonly Statement[]) {
     return some(statements, isScopeMarker);
 }
 
-/* @internal */
+/** @internal */
 export function needsScopeMarker(result: Statement) {
     return !isAnyImportOrReExport(result) && !isExportAssignment(result) && !hasSyntacticModifier(result, ModifierFlags.Export) && !isAmbientModule(result);
 }
 
-/* @internal */
+/** @internal */
 export function isExternalModuleIndicator(result: Statement) {
     // Exported top-level member indicates moduleness
     return isAnyImportOrReExport(result) || isExportAssignment(result) || hasSyntacticModifier(result, ModifierFlags.Export);
 }
 
-/* @internal */
+/** @internal */
 export function isForInOrOfStatement(node: Node): node is ForInOrOfStatement {
     return node.kind === SyntaxKind.ForInStatement || node.kind === SyntaxKind.ForOfStatement;
 }
 
 // Element
 
-/* @internal */
+/** @internal */
 export function isConciseBody(node: Node): node is ConciseBody {
     return isBlock(node)
         || isExpression(node);
 }
 
-/* @internal */
+/** @internal */
 export function isFunctionBody(node: Node): node is FunctionBody {
     return isBlock(node);
 }
 
-/* @internal */
+/** @internal */
 export function isForInitializer(node: Node): node is ForInitializer {
     return isVariableDeclarationList(node)
         || isExpression(node);
 }
 
-/* @internal */
+/** @internal */
 export function isModuleBody(node: Node): node is ModuleBody {
     const kind = node.kind;
     return kind === SyntaxKind.ModuleBlock
@@ -1781,28 +1781,28 @@ export function isModuleBody(node: Node): node is ModuleBody {
         || kind === SyntaxKind.Identifier;
 }
 
-/* @internal */
+/** @internal */
 export function isNamespaceBody(node: Node): node is NamespaceBody {
     const kind = node.kind;
     return kind === SyntaxKind.ModuleBlock
         || kind === SyntaxKind.ModuleDeclaration;
 }
 
-/* @internal */
+/** @internal */
 export function isJSDocNamespaceBody(node: Node): node is JSDocNamespaceBody {
     const kind = node.kind;
     return kind === SyntaxKind.Identifier
         || kind === SyntaxKind.ModuleDeclaration;
 }
 
-/* @internal */
+/** @internal */
 export function isNamedImportBindings(node: Node): node is NamedImportBindings {
     const kind = node.kind;
     return kind === SyntaxKind.NamedImports
         || kind === SyntaxKind.NamespaceImport;
 }
 
-/* @internal */
+/** @internal */
 export function isModuleOrEnumDeclaration(node: Node): node is ModuleDeclaration | EnumDeclaration {
     return node.kind === SyntaxKind.ModuleDeclaration || node.kind === SyntaxKind.EnumDeclaration;
 }
@@ -1884,7 +1884,7 @@ function isStatementKindButNotDeclarationKind(kind: SyntaxKind) {
         || kind === SyntaxKind.MergeDeclarationMarker;
 }
 
-/* @internal */
+/** @internal */
 export function isDeclaration(node: Node): node is NamedDeclaration {
     if (node.kind === SyntaxKind.TypeParameter) {
         return (node.parent && node.parent.kind !== SyntaxKind.JSDocTemplateTag) || isInJSFile(node);
@@ -1893,7 +1893,7 @@ export function isDeclaration(node: Node): node is NamedDeclaration {
     return isDeclarationKind(node.kind);
 }
 
-/* @internal */
+/** @internal */
 export function isDeclarationStatement(node: Node): node is DeclarationStatement {
     return isDeclarationStatementKind(node.kind);
 }
@@ -1901,12 +1901,12 @@ export function isDeclarationStatement(node: Node): node is DeclarationStatement
 /**
  * Determines whether the node is a statement that is not also a declaration
  */
-/* @internal */
+/** @internal */
 export function isStatementButNotDeclaration(node: Node): node is Statement {
     return isStatementKindButNotDeclarationKind(node.kind);
 }
 
-/* @internal */
+/** @internal */
 export function isStatement(node: Node): node is Statement {
     const kind = node.kind;
     return isStatementKindButNotDeclarationKind(kind)
@@ -1927,7 +1927,7 @@ function isBlockStatement(node: Node): node is Block {
 /**
  * NOTE: This is similar to `isStatement` but does not access parent pointers.
  */
-/* @internal */
+/** @internal */
 export function isStatementOrBlock(node: Node): node is Statement | Block {
     const kind = node.kind;
     return isStatementKindButNotDeclarationKind(kind)
@@ -1937,7 +1937,7 @@ export function isStatementOrBlock(node: Node): node is Statement | Block {
 
 // Module references
 
-/* @internal */
+/** @internal */
 export function isModuleReference(node: Node): node is ModuleReference {
     const kind = node.kind;
     return kind === SyntaxKind.ExternalModuleReference
@@ -1947,7 +1947,7 @@ export function isModuleReference(node: Node): node is ModuleReference {
 
 // JSX
 
-/* @internal */
+/** @internal */
 export function isJsxTagNameExpression(node: Node): node is JsxTagNameExpression {
     const kind = node.kind;
     return kind === SyntaxKind.ThisKeyword
@@ -1955,7 +1955,7 @@ export function isJsxTagNameExpression(node: Node): node is JsxTagNameExpression
         || kind === SyntaxKind.PropertyAccessExpression;
 }
 
-/* @internal */
+/** @internal */
 export function isJsxChild(node: Node): node is JsxChild {
     const kind = node.kind;
     return kind === SyntaxKind.JsxElement
@@ -1965,14 +1965,14 @@ export function isJsxChild(node: Node): node is JsxChild {
         || kind === SyntaxKind.JsxFragment;
 }
 
-/* @internal */
+/** @internal */
 export function isJsxAttributeLike(node: Node): node is JsxAttributeLike {
     const kind = node.kind;
     return kind === SyntaxKind.JsxAttribute
         || kind === SyntaxKind.JsxSpreadAttribute;
 }
 
-/* @internal */
+/** @internal */
 export function isStringLiteralOrJsxExpression(node: Node): node is StringLiteral | JsxExpression {
     const kind = node.kind;
     return kind === SyntaxKind.StringLiteral
@@ -1996,7 +1996,7 @@ export function isCaseOrDefaultClause(node: Node): node is CaseOrDefaultClause {
 // JSDoc
 
 /** True if node is of some JSDoc syntax kind. */
-/* @internal */
+/** @internal */
 export function isJSDocNode(node: Node): boolean {
     return node.kind >= SyntaxKind.FirstJSDocNode && node.kind <= SyntaxKind.LastJSDocNode;
 }
@@ -2013,7 +2013,7 @@ export function isJSDocCommentContainingNode(node: Node): boolean {
 }
 
 // TODO: determine what this does before making it public.
-/* @internal */
+/** @internal */
 export function isJSDocTag(node: Node): node is JSDocTag {
     return node.kind >= SyntaxKind.FirstJSDocTagNode && node.kind <= SyntaxKind.LastJSDocTagNode;
 }
@@ -2027,7 +2027,7 @@ export function isGetAccessor(node: Node): node is GetAccessorDeclaration {
 }
 
 /** True if has jsdoc nodes attached to it. */
-/* @internal */
+/** @internal */
 // TODO: GH#19856 Would like to return `node is Node & { jsDoc: JSDoc[] }` but it causes long compile times
 export function hasJSDocNodes(node: Node): node is HasJSDoc {
     const { jsDoc } = node as JSDocContainer;
@@ -2035,13 +2035,13 @@ export function hasJSDocNodes(node: Node): node is HasJSDoc {
 }
 
 /** True if has type node attached to it. */
-/* @internal */
+/** @internal */
 export function hasType(node: Node): node is HasType {
     return !!(node as HasType).type;
 }
 
 /** True if has initializer node attached to it. */
-/* @internal */
+/** @internal */
 export function hasInitializer(node: Node): node is HasInitializer {
     return !!(node as HasInitializer).initializer;
 }
@@ -2065,13 +2065,13 @@ export function isObjectLiteralElement(node: Node): node is ObjectLiteralElement
     return node.kind === SyntaxKind.JsxAttribute || node.kind === SyntaxKind.JsxSpreadAttribute || isObjectLiteralElementLike(node);
 }
 
-/* @internal */
+/** @internal */
 export function isTypeReferenceType(node: Node): node is TypeReferenceType {
     return node.kind === SyntaxKind.TypeReference || node.kind === SyntaxKind.ExpressionWithTypeArguments;
 }
 
 const MAX_SMI_X86 = 0x3fff_ffff;
-/* @internal */
+/** @internal */
 export function guessIndentation(lines: string[]) {
     let indentation = MAX_SMI_X86;
     for (const line of lines) {
diff --git a/src/compiler/visitorPublic.ts b/src/compiler/visitorPublic.ts
index 2173a18ab1..2dc1c01bbc 100644
--- a/src/compiler/visitorPublic.ts
+++ b/src/compiler/visitorPublic.ts
@@ -135,7 +135,7 @@ export function visitNodes<T extends Node>(nodes: NodeArray<T> | undefined, visi
     return nodes;
 }
 
-/* @internal */
+/** @internal */
 export function visitArray<T extends Node, U extends T>(nodes: readonly T[] | undefined, visitor: Visitor, test: (node: Node) => node is U, start?: number, count?: number): readonly U[] | undefined {
     if (nodes === undefined) {
         return nodes;
@@ -154,7 +154,7 @@ export function visitArray<T extends Node, U extends T>(nodes: readonly T[] | un
     return visitArrayWorker(nodes, visitor, test, start, count) as readonly U[];
 }
 
-/* @internal */
+/** @internal */
 function visitArrayWorker<T extends Node>(nodes: readonly T[], visitor: Visitor, test: ((node: Node) => boolean) | undefined, start: number, count: number): readonly T[] | undefined {
     let updated: T[] | undefined;
 
@@ -364,7 +364,7 @@ export function visitFunctionBody(node: ConciseBody | undefined, visitor: Visito
  * Visits an iteration body, adding any block-scoped variables required by the transformation.
  */
 export function visitIterationBody(body: Statement, visitor: Visitor, context: TransformationContext): Statement;
-/* @internal */
+/** @internal */
 export function visitIterationBody(body: Statement, visitor: Visitor, context: TransformationContext, nodeVisitor?: NodeVisitor): Statement; // eslint-disable-line @typescript-eslint/unified-signatures
 export function visitIterationBody(body: Statement, visitor: Visitor, context: TransformationContext, nodeVisitor: NodeVisitor = visitNode): Statement {
     context.startBlockScope();
@@ -389,7 +389,7 @@ export function visitIterationBody(body: Statement, visitor: Visitor, context: T
  * @param context A lexical environment context for the visitor.
  */
 export function visitEachChild<T extends Node>(node: T, visitor: Visitor, context: TransformationContext): T;
-/* @internal */
+/** @internal */
 export function visitEachChild<T extends Node>(node: T, visitor: Visitor, context: TransformationContext, nodesVisitor?: NodesVisitor, tokenVisitor?: Visitor, nodeVisitor?: NodeVisitor): T; // eslint-disable-line @typescript-eslint/unified-signatures
 /**
  * Visits each child of a Node using the supplied visitor, possibly returning a new Node of the same kind in its place.
@@ -399,7 +399,7 @@ export function visitEachChild<T extends Node>(node: T, visitor: Visitor, contex
  * @param context A lexical environment context for the visitor.
  */
 export function visitEachChild<T extends Node>(node: T | undefined, visitor: Visitor, context: TransformationContext, nodesVisitor?: typeof visitNodes, tokenVisitor?: Visitor): T | undefined;
-/* @internal */
+/** @internal */
 export function visitEachChild<T extends Node>(node: T | undefined, visitor: Visitor, context: TransformationContext, nodesVisitor?: NodesVisitor, tokenVisitor?: Visitor, nodeVisitor?: NodeVisitor): T | undefined; // eslint-disable-line @typescript-eslint/unified-signatures
 export function visitEachChild<T extends Node>(node: T | undefined, visitor: Visitor, context: TransformationContext, nodesVisitor = visitNodes, tokenVisitor?: Visitor, nodeVisitor: NodeVisitor = visitNode): T | undefined {
     if (node === undefined) {
diff --git a/src/compiler/watchPublic.ts b/src/compiler/watchPublic.ts
index ca5186aa17..016df40d23 100644
--- a/src/compiler/watchPublic.ts
+++ b/src/compiler/watchPublic.ts
@@ -25,7 +25,7 @@ export interface ReadBuildProgramHost {
     useCaseSensitiveFileNames(): boolean;
     getCurrentDirectory(): string;
     readFile(fileName: string): string | undefined;
-    /*@internal*/
+    /** @internal */
     getBuildInfo?(fileName: string, configFilePath: string | undefined): BuildInfo | undefined;
 }
 export function readBuilderProgram(compilerOptions: CompilerOptions, host: ReadBuildProgramHost) {
@@ -141,7 +141,7 @@ export interface ProgramHost<T extends BuilderProgram> {
 }
 /** Internal interface used to wire emit through same host */
 
-/*@internal*/
+/** @internal */
 export interface ProgramHost<T extends BuilderProgram> {
     // TODO: GH#18217 Optional methods are frequently asserted
     createDirectory?(path: string): void;
@@ -203,7 +203,7 @@ export interface WatchCompilerHostOfConfigFile<T extends BuilderProgram> extends
 /**
  * Host to create watch with config file that is already parsed (from tsc)
  */
-/*@internal*/
+/** @internal */
 export interface WatchCompilerHostOfConfigFile<T extends BuilderProgram> extends WatchCompilerHost<T> {
     configFileParsingResult?: ParsedCommandLine;
     extendedConfigCache?: Map<ExtendedConfigCacheEntry>;
@@ -213,7 +213,7 @@ export interface Watch<T> {
     /** Synchronize with host and get updated program */
     getProgram(): T;
     /** Gets the existing program without synchronizing with changes on host */
-    /*@internal*/
+    /** @internal */
     getCurrentProgram(): T;
     /** Closes the watch */
     close(): void;
diff --git a/src/compiler/watchUtilities.ts b/src/compiler/watchUtilities.ts
index b5dc7f19de..f126713313 100644
--- a/src/compiler/watchUtilities.ts
+++ b/src/compiler/watchUtilities.ts
@@ -513,7 +513,7 @@ export interface IsIgnoredFileFromWildCardWatchingInput {
     writeLog: (s: string) => void;
     toPath: (fileName: string) => Path;
 }
-/* @internal */
+/** @internal */
 export function isIgnoredFileFromWildCardWatching({
     watchedDirPath, fileOrDirectory, fileOrDirectoryPath,
     configFileName, options, program, extraFileExtensions,
diff --git a/src/debug/dbg.ts b/src/debug/dbg.ts
index 066e952bd0..3b531914d5 100644
--- a/src/debug/dbg.ts
+++ b/src/debug/dbg.ts
@@ -515,4 +515,4 @@ export function formatControlFlowGraph(flowNode: FlowNode) {
 declare const module: { exports: {} };
 if (typeof module !== "undefined" && module.exports) {
     module.exports = Debug;
-}
\ No newline at end of file
+}
diff --git a/src/deprecatedCompat/deprecations.ts b/src/deprecatedCompat/deprecations.ts
index 8c80005d2f..d85748d14d 100644
--- a/src/deprecatedCompat/deprecations.ts
+++ b/src/deprecatedCompat/deprecations.ts
@@ -106,4 +106,4 @@ export function buildOverload(name: string): OverloadBuilder {
             })
         })
     };
-}
\ No newline at end of file
+}
diff --git a/src/harness/client.ts b/src/harness/client.ts
index 2ff546d622..7808709963 100644
--- a/src/harness/client.ts
+++ b/src/harness/client.ts
@@ -29,7 +29,7 @@ interface RenameEntry {
     readonly locations: RenameLocation[];
 }
 
-/* @internal */
+/** @internal */
 export function extractMessage(message: string): string {
     // Read the content length
     const contentLengthPrefix = "Content-Length: ";
@@ -138,7 +138,7 @@ export class SessionClient implements LanguageService {
         return response;
     }
 
-    /*@internal*/
+    /** @internal */
     configure(preferences: UserPreferences) {
         this.preferences = preferences;
         const args: protocol.ConfigureRequestArguments = { preferences };
@@ -146,14 +146,14 @@ export class SessionClient implements LanguageService {
         this.processResponse(request, /*expectEmptyBody*/ true);
     }
 
-    /*@internal*/
+    /** @internal */
     setFormattingOptions(formatOptions: FormatCodeSettings) {
         const args: protocol.ConfigureRequestArguments = { formatOptions };
         const request = this.processRequest(CommandNames.Configure, args);
         this.processResponse(request, /*expectEmptyBody*/ true);
     }
 
-    /*@internal*/
+    /** @internal */
     setCompilerOptionsForInferredProjects(options: protocol.CompilerOptions) {
         const args: protocol.SetCompilerOptionsForInferredProjectsArgs = { options };
         const request = this.processRequest(CommandNames.CompilerOptionsForInferredProjects, args);
diff --git a/src/jsTyping/shared.ts b/src/jsTyping/shared.ts
index 2b6282d25f..f004b0257a 100644
--- a/src/jsTyping/shared.ts
+++ b/src/jsTyping/shared.ts
@@ -7,22 +7,22 @@ export type EventTypesRegistry = "event::typesRegistry";
 export type EventBeginInstallTypes = "event::beginInstallTypes";
 export type EventEndInstallTypes = "event::endInstallTypes";
 export type EventInitializationFailed = "event::initializationFailed";
-/* @internal */
+/** @internal */
 export const ActionSet: ActionSet = "action::set";
-/* @internal */
+/** @internal */
 export const ActionInvalidate: ActionInvalidate = "action::invalidate";
-/* @internal */
+/** @internal */
 export const ActionPackageInstalled: ActionPackageInstalled = "action::packageInstalled";
-/* @internal */
+/** @internal */
 export const EventTypesRegistry: EventTypesRegistry = "event::typesRegistry";
-/* @internal */
+/** @internal */
 export const EventBeginInstallTypes: EventBeginInstallTypes = "event::beginInstallTypes";
-/* @internal */
+/** @internal */
 export const EventEndInstallTypes: EventEndInstallTypes = "event::endInstallTypes";
-/* @internal */
+/** @internal */
 export const EventInitializationFailed: EventInitializationFailed = "event::initializationFailed";
 
-/* @internal */
+/** @internal */
 export namespace Arguments {
     export const GlobalCacheLocation = "--globalTypingsCacheLocation";
     export const LogFile = "--logFile";
@@ -41,12 +41,12 @@ export namespace Arguments {
     export const ValidateDefaultNpmLocation = "--validateDefaultNpmLocation";
 }
 
-/* @internal */
+/** @internal */
 export function hasArgument(argumentName: string) {
     return sys.args.indexOf(argumentName) >= 0;
 }
 
-/* @internal */
+/** @internal */
 export function findArgument(argumentName: string): string | undefined {
     const index = sys.args.indexOf(argumentName);
     return index >= 0 && index < sys.args.length - 1
@@ -54,7 +54,7 @@ export function findArgument(argumentName: string): string | undefined {
         : undefined;
 }
 
-/* @internal */
+/** @internal */
 export function nowString() {
     // E.g. "12:34:56.789"
     const d = new Date();
diff --git a/src/jsTyping/types.ts b/src/jsTyping/types.ts
index 4d948b5b75..013e32553c 100644
--- a/src/jsTyping/types.ts
+++ b/src/jsTyping/types.ts
@@ -15,7 +15,7 @@ export interface TypingInstallerRequestWithProjectName {
     readonly projectName: string;
 }
 
-/* @internal */
+/** @internal */
 export type TypingInstallerRequestUnion = DiscoverTypings | CloseProject | TypesRegistryRequest | InstallPackageRequest;
 
 export interface DiscoverTypings extends TypingInstallerRequestWithProjectName {
@@ -44,7 +44,7 @@ export interface InstallPackageRequest extends TypingInstallerRequestWithProject
     readonly projectRootPath: Path;
 }
 
-/* @internal */
+/** @internal */
 export interface TypesRegistryResponse extends TypingInstallerResponse {
     readonly kind: EventTypesRegistry;
     readonly typesRegistry: MapLike<MapLike<string>>;
@@ -86,7 +86,7 @@ export interface EndInstallTypes extends InstallTypes {
     readonly installSuccess: boolean;
 }
 
-/* @internal */
+/** @internal */
 export interface InstallTypingHost extends JsTyping.TypingResolutionHost {
     useCaseSensitiveFileNames: boolean;
     writeFile(path: string, content: string): void;
@@ -104,5 +104,5 @@ export interface SetTypings extends ProjectResponse {
     readonly kind: ActionSet;
 }
 
-/* @internal */
+/** @internal */
 export type TypingInstallerResponseUnion = SetTypings | InvalidateCachedTypings | TypesRegistryResponse | PackageInstalledResponse | InstallTypes | InitializationFailedResponse;
diff --git a/src/server/editorServices.ts b/src/server/editorServices.ts
index 899759fce3..0824a76b82 100644
--- a/src/server/editorServices.ts
+++ b/src/server/editorServices.ts
@@ -35,7 +35,7 @@ import {
 } from "./_namespaces/ts";
 
 export const maxProgramSizeForNonTsFiles = 20 * 1024 * 1024;
-/*@internal*/
+/** @internal */
 export const maxFileSize = 4 * 1024 * 1024;
 
 export const ProjectsUpdatedInBackgroundEvent = "projectsUpdatedInBackground";
@@ -185,7 +185,7 @@ export type ProjectServiceEvent =
 
 export type ProjectServiceEventHandler = (event: ProjectServiceEvent) => void;
 
-/*@internal*/
+/** @internal */
 export type PerformanceEventHandler = (event: PerformanceEvent) => void;
 
 export interface SafeList {
@@ -329,7 +329,7 @@ export function convertScriptKindName(scriptKindName: protocol.ScriptKindName) {
     }
 }
 
-/*@internal*/
+/** @internal */
 export function convertUserPreferences(preferences: protocol.UserPreferences): UserPreferences {
     const { lazyConfiguredProjectsFromExternalProject, ...userPreferences } = preferences;
     return userPreferences;
@@ -395,7 +395,7 @@ function findProjectByName<T extends Project>(projectName: string, projects: T[]
 
 const noopConfigFileWatcher: FileWatcher = { close: noop };
 
-/*@internal*/
+/** @internal */
 interface ConfigFileExistenceInfo {
     /**
      * Cached value of existence of config file
@@ -467,7 +467,7 @@ function isAncestorConfigFileInfo(infoOrFileNameOrConfig: OpenScriptInfoOrClosed
     return !!(infoOrFileNameOrConfig as AncestorConfigFileInfo).configFileInfo;
 }
 
-/*@internal*/
+/** @internal */
 /** Kind of operation to perform to get project reference project */
 export enum ProjectReferenceProjectLoadKind {
     /** Find existing project for project reference */
@@ -478,14 +478,14 @@ export enum ProjectReferenceProjectLoadKind {
     FindCreateLoad
 }
 
-/*@internal*/
+/** @internal */
 export function forEachResolvedProjectReferenceProject<T>(
     project: ConfiguredProject,
     fileName: string | undefined,
     cb: (child: ConfiguredProject) => T | undefined,
     projectReferenceProjectLoadKind: ProjectReferenceProjectLoadKind.Find | ProjectReferenceProjectLoadKind.FindCreate,
 ): T | undefined;
-/*@internal*/
+/** @internal */
 export function forEachResolvedProjectReferenceProject<T>(
     project: ConfiguredProject,
     fileName: string | undefined,
@@ -639,14 +639,14 @@ function isScriptInfoWatchedFromNodeModules(info: ScriptInfo) {
     return !info.isScriptOpen() && info.mTime !== undefined;
 }
 
-/*@internal*/
+/** @internal */
 /** true if script info is part of project and is not in project because it is referenced from project reference source */
 export function projectContainsInfoDirectly(project: Project, info: ScriptInfo) {
     return project.containsScriptInfo(info) &&
         !project.isSourceOfProjectReferenceRedirect(info.path);
 }
 
-/*@internal*/
+/** @internal */
 export function updateProjectIfDirty(project: Project) {
     project.invalidateResolutionsOfFailedLookupLocations();
     return project.dirty && project.updateGraph();
@@ -658,7 +658,7 @@ function setProjectOptionsUsed(project: ConfiguredProject | ExternalProject) {
     }
 }
 
-/*@internal*/
+/** @internal */
 export interface OpenFileArguments {
     fileName: string;
     content?: string;
@@ -667,7 +667,7 @@ export interface OpenFileArguments {
     projectRootPath?: string;
 }
 
-/*@internal*/
+/** @internal */
 export interface ChangeFileArguments {
     fileName: string;
     changes: Iterator<TextChange>;
@@ -678,7 +678,7 @@ export interface WatchOptionsAndErrors {
     errors: Diagnostic[] | undefined;
 }
 
-/*@internal*/
+/** @internal */
 export interface ParsedConfig{
     cachedDirectoryStructureHost: CachedDirectoryStructureHost;
     /**
@@ -703,16 +703,16 @@ function createProjectNameFactoryWithCounter(nameFactory: (counter: number) => s
 
 export class ProjectService {
 
-    /*@internal*/
+    /** @internal */
     readonly typingsCache: TypingsCache;
 
-    /*@internal*/
+    /** @internal */
     readonly documentRegistry: DocumentRegistry;
 
     /**
      * Container of all known scripts
      */
-    /*@internal*/
+    /** @internal */
     readonly filenameToScriptInfo = new Map<string, ScriptInfo>();
     private readonly nodeModulesWatchers = new Map<string, NodeModulesWatcher>();
     /**
@@ -727,7 +727,7 @@ export class ProjectService {
     /**
      * Map to the real path of the infos
      */
-    /* @internal */
+    /** @internal */
     readonly realpathToScriptInfos: MultiMap<Path, ScriptInfo> | undefined;
     /**
      * maps external project file name to list of config files that were the part of this project
@@ -746,17 +746,17 @@ export class ProjectService {
      * projects specified by a tsconfig.json file
      */
     readonly configuredProjects: Map<ConfiguredProject> = new Map<string, ConfiguredProject>();
-    /*@internal*/
+    /** @internal */
     readonly newInferredProjectName = createProjectNameFactoryWithCounter(makeInferredProjectName);
-    /*@internal*/
+    /** @internal */
     readonly newAutoImportProviderProjectName = createProjectNameFactoryWithCounter(makeAutoImportProviderProjectName);
-    /*@internal*/
+    /** @internal */
     readonly newAuxiliaryProjectName = createProjectNameFactoryWithCounter(makeAuxiliaryProjectName);
     /**
      * Open files: with value being project root path, and key being Path of the file that is open
      */
     readonly openFiles: Map<NormalizedPath | undefined> = new Map<Path, NormalizedPath | undefined>();
-    /* @internal */
+    /** @internal */
     readonly configFileForOpenFiles: ESMap<Path, NormalizedPath | false> = new Map();
     /**
      * Map of open files that are opened without complete path but have projectRoot as current directory
@@ -780,15 +780,15 @@ export class ProjectService {
      * - Or it is present if we have configured project open with config file at that location
      *   In this case the exists property is always true
      */
-    /*@internal*/ readonly configFileExistenceInfoCache = new Map<NormalizedPath, ConfigFileExistenceInfo>();
-    /*@internal*/ readonly throttledOperations: ThrottledOperations;
+    /** @internal */ readonly configFileExistenceInfoCache = new Map<NormalizedPath, ConfigFileExistenceInfo>();
+    /** @internal */ readonly throttledOperations: ThrottledOperations;
 
     private readonly hostConfiguration: HostConfiguration;
     private safelist: SafeList = defaultTypeSafeList;
     private readonly legacySafelist = new Map<string, string>();
 
     private pendingProjectUpdates = new Map<string, Project>();
-    /* @internal */
+    /** @internal */
     pendingEnsureProjectForOpenFiles = false;
 
     readonly currentDirectory: NormalizedPath;
@@ -819,21 +819,21 @@ export class ProjectService {
     /** Tracks projects that we have already sent telemetry for. */
     private readonly seenProjects = new Map<string, true>();
 
-    /*@internal*/
+    /** @internal */
     readonly watchFactory: WatchFactory<WatchType, Project | NormalizedPath>;
 
-    /*@internal*/
+    /** @internal */
     private readonly sharedExtendedConfigFileWatchers = new Map<Path, SharedExtendedConfigFileWatcher<NormalizedPath>>();
-    /*@internal*/
+    /** @internal */
     private readonly extendedConfigCache = new Map<string, ExtendedConfigCacheEntry>();
 
-    /*@internal*/
+    /** @internal */
     readonly packageJsonCache: PackageJsonCache;
-    /*@internal*/
+    /** @internal */
     private packageJsonFilesMap: ESMap<Path, FileWatcher> | undefined;
-    /*@internal*/
+    /** @internal */
     private incompleteCompletionsCache: IncompleteCompletionsCache | undefined;
-    /*@internal*/
+    /** @internal */
     readonly session: Session<unknown> | undefined;
 
 
@@ -916,39 +916,39 @@ export class ProjectService {
         return toPath(fileName, this.currentDirectory, this.toCanonicalFileName);
     }
 
-    /*@internal*/
+    /** @internal */
     getExecutingFilePath() {
         return this.getNormalizedAbsolutePath(this.host.getExecutingFilePath());
     }
 
-    /*@internal*/
+    /** @internal */
     getNormalizedAbsolutePath(fileName: string) {
         return getNormalizedAbsolutePath(fileName, this.host.getCurrentDirectory());
     }
 
-    /*@internal*/
+    /** @internal */
     setDocument(key: DocumentRegistryBucketKeyWithMode, path: Path, sourceFile: SourceFile) {
         const info = Debug.checkDefined(this.getScriptInfoForPath(path));
         info.cacheSourceFile = { key, sourceFile };
     }
 
-    /*@internal*/
+    /** @internal */
     getDocument(key: DocumentRegistryBucketKeyWithMode, path: Path): SourceFile | undefined {
         const info = this.getScriptInfoForPath(path);
         return info && info.cacheSourceFile && info.cacheSourceFile.key === key ? info.cacheSourceFile.sourceFile : undefined;
     }
 
-    /* @internal */
+    /** @internal */
     ensureInferredProjectsUpToDate_TestOnly() {
         this.ensureProjectStructuresUptoDate();
     }
 
-    /* @internal */
+    /** @internal */
     getCompilerOptionsForInferredProjects() {
         return this.compilerOptionsForInferredProjects;
     }
 
-    /* @internal */
+    /** @internal */
     onUpdateLanguageServiceStateForProject(project: Project, languageServiceEnabled: boolean) {
         if (!this.eventHandler) {
             return;
@@ -1007,7 +1007,7 @@ export class ProjectService {
         }
     }
 
-    /*@internal*/
+    /** @internal */
     delayEnsureProjectForOpenFiles() {
         if (!this.openFiles.size) return;
         this.pendingEnsureProjectForOpenFiles = true;
@@ -1040,12 +1040,12 @@ export class ProjectService {
         }
     }
 
-    /*@internal*/
+    /** @internal */
     hasPendingProjectUpdate(project: Project) {
         return this.pendingProjectUpdates.has(project.getProjectName());
     }
 
-    /* @internal */
+    /** @internal */
     sendProjectsUpdatedInBackgroundEvent() {
         if (!this.eventHandler) {
             return;
@@ -1060,7 +1060,7 @@ export class ProjectService {
         this.eventHandler(event);
     }
 
-    /* @internal */
+    /** @internal */
     sendLargeFileReferencedEvent(file: string, fileSize: number) {
         if (!this.eventHandler) {
             return;
@@ -1073,7 +1073,7 @@ export class ProjectService {
         this.eventHandler(event);
     }
 
-    /* @internal */
+    /** @internal */
     sendProjectLoadingStartEvent(project: ConfiguredProject, reason: string) {
         if (!this.eventHandler) {
             return;
@@ -1086,7 +1086,7 @@ export class ProjectService {
         this.eventHandler(event);
     }
 
-    /* @internal */
+    /** @internal */
     sendProjectLoadingFinishEvent(project: ConfiguredProject) {
         if (!this.eventHandler || !project.sendLoadingProjectFinish) {
             return;
@@ -1100,14 +1100,14 @@ export class ProjectService {
         this.eventHandler(event);
     }
 
-    /* @internal */
+    /** @internal */
     sendPerformanceEvent(kind: PerformanceEvent["kind"], durationMs: number) {
         if (this.performanceEventHandler) {
             this.performanceEventHandler({ kind, durationMs });
         }
     }
 
-    /* @internal */
+    /** @internal */
     delayUpdateProjectGraphAndEnsureProjectStructureForOpenFiles(project: Project) {
         this.delayUpdateProjectGraph(project);
         this.delayEnsureProjectForOpenFiles();
@@ -1181,14 +1181,14 @@ export class ProjectService {
         return this.findExternalProjectByProjectName(projectName) || this.findConfiguredProjectByProjectName(toNormalizedPath(projectName));
     }
 
-    /* @internal */
+    /** @internal */
     private forEachProject(cb: (project: Project) => void) {
         this.externalProjects.forEach(cb);
         this.configuredProjects.forEach(cb);
         this.inferredProjects.forEach(cb);
     }
 
-    /* @internal */
+    /** @internal */
     forEachEnabledProject(cb: (project: Project) => void) {
         this.forEachProject(project => {
             if (!project.isOrphan() && project.languageServiceEnabled) {
@@ -1201,13 +1201,13 @@ export class ProjectService {
         return ensureProject ? this.ensureDefaultProjectForFile(fileName) : this.tryGetDefaultProjectForFile(fileName);
     }
 
-    /* @internal */
+    /** @internal */
     tryGetDefaultProjectForFile(fileName: NormalizedPath): Project | undefined {
         const scriptInfo = this.getScriptInfoForNormalizedPath(fileName);
         return scriptInfo && !scriptInfo.isOrphan() ? scriptInfo.getDefaultProject() : undefined;
     }
 
-    /* @internal */
+    /** @internal */
     ensureDefaultProjectForFile(fileName: NormalizedPath): Project {
         return this.tryGetDefaultProjectForFile(fileName) || this.doEnsureDefaultProjectForFile(fileName);
     }
@@ -1336,7 +1336,7 @@ export class ProjectService {
     /**
      * This is to watch whenever files are added or removed to the wildcard directories
      */
-    /*@internal*/
+    /** @internal */
     private watchWildcardDirectory(directory: Path, flags: WatchDirectoryFlags, configFileName: NormalizedPath, config: ParsedConfig) {
         return this.watchFactory.watchDirectory(
             directory,
@@ -1402,7 +1402,7 @@ export class ProjectService {
         );
     }
 
-    /*@internal*/
+    /** @internal */
     private delayUpdateProjectsFromParsedConfigOnConfigFileChange(canonicalConfigFilePath: NormalizedPath, reloadReason: string) {
         const configFileExistenceInfo = this.configFileExistenceInfoCache.get(canonicalConfigFilePath);
         if (!configFileExistenceInfo?.config) return false;
@@ -1431,7 +1431,7 @@ export class ProjectService {
         return scheduledAnyProjectUpdate;
     }
 
-    /*@internal*/
+    /** @internal */
     private onConfigFileChanged(canonicalConfigFilePath: NormalizedPath, eventKind: FileWatcherEventKind) {
         const configFileExistenceInfo = this.configFileExistenceInfoCache.get(canonicalConfigFilePath)!;
         if (eventKind === FileWatcherEventKind.Deleted) {
@@ -1515,7 +1515,7 @@ export class ProjectService {
         }
     }
 
-    /*@internal*/
+    /** @internal */
     assignOrphanScriptInfoToInferredProject(info: ScriptInfo, projectRootPath: NormalizedPath | undefined) {
         Debug.assert(info.isOrphan());
 
@@ -1701,7 +1701,7 @@ export class ProjectService {
         return exists;
     }
 
-    /*@internal*/
+    /** @internal */
     private createConfigFileWatcherForParsedConfig(configFileName: NormalizedPath, canonicalConfigFilePath: NormalizedPath, forProject: ConfiguredProject) {
         const configFileExistenceInfo = this.configFileExistenceInfoCache.get(canonicalConfigFilePath)!;
         // When watching config file for parsed config, remove the noopFileWatcher that can be created for open files impacted by config file and watch for real
@@ -1728,7 +1728,7 @@ export class ProjectService {
             forEachEntry(configFileExistenceInfo.openFilesImpactedByConfigFile, identity);
     }
 
-    /* @internal */
+    /** @internal */
     releaseParsedConfig(canonicalConfigFilePath: NormalizedPath, forProject: ConfiguredProject) {
         const configFileExistenceInfo = this.configFileExistenceInfoCache.get(canonicalConfigFilePath)!;
         if (!configFileExistenceInfo.config?.projects.delete(forProject.canonicalConfigFilePath)) return;
@@ -1766,7 +1766,7 @@ export class ProjectService {
      * Close the config file watcher in the cached ConfigFileExistenceInfo
      *   if there arent any open files that are root of inferred project and there is no parsed config held by any project
      */
-    /*@internal*/
+    /** @internal */
     private closeConfigFileWatcherOnReleaseOfOpenFile(configFileExistenceInfo: ConfigFileExistenceInfo) {
         // Close the config file watcher if there are no more open files that are root of inferred project
         // or if there are no projects that need to watch this config file existence info
@@ -1814,7 +1814,7 @@ export class ProjectService {
     /**
      * This is called by inferred project whenever script info is added as a root
      */
-    /* @internal */
+    /** @internal */
     startWatchingConfigFilesForInferredProjectRoot(info: ScriptInfo) {
         Debug.assert(info.isScriptOpen());
         this.forEachConfigFileLocation(info, (canonicalConfigFilePath, configFileName) => {
@@ -1844,7 +1844,7 @@ export class ProjectService {
     /**
      * This is called by inferred project whenever root script info is removed from it
      */
-    /* @internal */
+    /** @internal */
     stopWatchingConfigFilesForInferredProjectRoot(info: ScriptInfo) {
         this.forEachConfigFileLocation(info, canonicalConfigFilePath => {
             const configFileExistenceInfo = this.configFileExistenceInfoCache.get(canonicalConfigFilePath);
@@ -1913,7 +1913,7 @@ export class ProjectService {
         return undefined;
     }
 
-    /*@internal*/
+    /** @internal */
     findDefaultConfiguredProject(info: ScriptInfo) {
         if (!info.isScriptOpen()) return undefined;
         const configFileName = this.getConfigFileNameForFile(info);
@@ -1977,7 +1977,7 @@ export class ProjectService {
         this.logger.endGroup();
     }
 
-    /*@internal*/
+    /** @internal */
     findConfiguredProjectByProjectName(configFileName: NormalizedPath): ConfiguredProject | undefined {
         // make sure that casing of config file name is consistent
         const canonicalConfigFilePath = asNormalizedPath(this.toCanonicalFileName(configFileName));
@@ -2048,7 +2048,7 @@ export class ProjectService {
         return project;
     }
 
-    /*@internal*/
+    /** @internal */
     sendProjectTelemetry(project: ExternalProject | ConfiguredProject): void {
         if (this.seenProjects.has(project.projectName)) {
             setProjectOptionsUsed(project);
@@ -2102,7 +2102,7 @@ export class ProjectService {
         project.setTypeAcquisition(typeAcquisition);
     }
 
-    /* @internal */
+    /** @internal */
     createConfiguredProject(configFileName: NormalizedPath) {
         tracing?.instant(tracing.Phase.Session, "createConfiguredProject", { configFilePath: configFileName });
         this.logger.info(`Creating configuration project ${configFileName}`);
@@ -2135,7 +2135,7 @@ export class ProjectService {
         return project;
     }
 
-    /* @internal */
+    /** @internal */
     private createConfiguredProjectWithDelayLoad(configFileName: NormalizedPath, reason: string) {
         const project = this.createConfiguredProject(configFileName);
         project.pendingReload = ConfigFileProgramReloadLevel.Full;
@@ -2143,14 +2143,14 @@ export class ProjectService {
         return project;
     }
 
-    /* @internal */
+    /** @internal */
     createAndLoadConfiguredProject(configFileName: NormalizedPath, reason: string) {
         const project = this.createConfiguredProject(configFileName);
         this.loadConfiguredProject(project, reason);
         return project;
     }
 
-    /* @internal */
+    /** @internal */
     private createLoadAndUpdateConfiguredProject(configFileName: NormalizedPath, reason: string) {
         const project = this.createAndLoadConfiguredProject(configFileName, reason);
         project.updateGraph();
@@ -2160,7 +2160,7 @@ export class ProjectService {
     /**
      * Read the config file of the project, and update the project root file names.
      */
-    /* @internal */
+    /** @internal */
     private loadConfiguredProject(project: ConfiguredProject, reason: string) {
         tracing?.push(tracing.Phase.Session, "loadConfiguredProject", { configFilePath: project.canonicalConfigFilePath });
         this.sendProjectLoadingStartEvent(project, reason);
@@ -2207,7 +2207,7 @@ export class ProjectService {
         tracing?.pop();
     }
 
-    /*@internal*/
+    /** @internal */
     ensureParsedConfigUptoDate(configFilename: NormalizedPath, canonicalConfigFilePath: NormalizedPath, configFileExistenceInfo: ConfigFileExistenceInfo, forProject: ConfiguredProject): ConfigFileExistenceInfo {
         if (configFileExistenceInfo.config) {
             if (!configFileExistenceInfo.config.reloadLevel) return configFileExistenceInfo;
@@ -2299,7 +2299,7 @@ export class ProjectService {
         return configFileExistenceInfo;
     }
 
-    /*@internal*/
+    /** @internal */
     watchWildcards(configFileName: NormalizedPath, { exists, config }: ConfigFileExistenceInfo, forProject: ConfiguredProject) {
         config!.projects.set(forProject.canonicalConfigFilePath, true);
         if (exists) {
@@ -2320,7 +2320,7 @@ export class ProjectService {
         }
     }
 
-    /*@internal*/
+    /** @internal */
     stopWatchingWildCards(canonicalConfigFilePath: NormalizedPath, forProject: ConfiguredProject) {
         const configFileExistenceInfo = this.configFileExistenceInfoCache.get(canonicalConfigFilePath)!;
         if (!configFileExistenceInfo.config ||
@@ -2426,7 +2426,7 @@ export class ProjectService {
     /**
      * Reload the file names from config file specs and update the project graph
      */
-    /*@internal*/
+    /** @internal */
     reloadFileNamesOfConfiguredProject(project: ConfiguredProject) {
         const fileNames = this.reloadFileNamesOfParsedConfig(project.getConfigFilePath(), this.configFileExistenceInfoCache.get(project.canonicalConfigFilePath)!.config!);
         project.updateErrorOnNoInputFiles(fileNames);
@@ -2434,7 +2434,7 @@ export class ProjectService {
         return project.updateGraph();
     }
 
-    /*@internal*/
+    /** @internal */
     private reloadFileNamesOfParsedConfig(configFileName: NormalizedPath, config: ParsedConfig) {
         if (config.reloadLevel === undefined) return config.parsedCommandLine!.fileNames;
         Debug.assert(config.reloadLevel === ConfigFileProgramReloadLevel.Partial);
@@ -2450,7 +2450,7 @@ export class ProjectService {
         return fileNames;
     }
 
-    /*@internal*/
+    /** @internal */
     setFileNamesOfAutoImportProviderProject(project: AutoImportProviderProject, fileNames: string[]) {
         this.updateNonInferredProjectFiles(project, fileNames, fileNamePropertyReader);
     }
@@ -2458,7 +2458,7 @@ export class ProjectService {
     /**
      * Read the config file of the project again by clearing the cache and update the project graph
      */
-    /* @internal */
+    /** @internal */
     reloadConfiguredProject(project: ConfiguredProject, reason: string, isInitialLoad: boolean, clearSemanticCache: boolean) {
         // At this point, there is no reason to not have configFile in the host
         const host = project.getCachedDirectoryStructureHost();
@@ -2476,7 +2476,7 @@ export class ProjectService {
         this.sendConfigFileDiagEvent(project, configFileName);
     }
 
-    /* @internal */
+    /** @internal */
     private clearSemanticCache(project: Project) {
         project.resolutionCache.clear();
         project.getLanguageService(/*ensureSynchronized*/ false).cleanupSemanticCache();
@@ -2593,7 +2593,7 @@ export class ProjectService {
         return project;
     }
 
-    /*@internal*/
+    /** @internal */
     getOrCreateScriptInfoNotOpenedByClient(uncheckedFileName: string, currentDirectory: string, hostToQueryFileExistsOn: DirectoryStructureHost) {
         return this.getOrCreateScriptInfoNotOpenedByClientForNormalizedPath(
             toNormalizedPath(uncheckedFileName), currentDirectory, /*scriptKind*/ undefined,
@@ -2605,7 +2605,7 @@ export class ProjectService {
         return this.getScriptInfoForNormalizedPath(toNormalizedPath(uncheckedFileName));
     }
 
-    /* @internal */
+    /** @internal */
     getScriptInfoOrConfig(uncheckedFileName: string): ScriptInfoOrConfig | undefined {
         const path = toNormalizedPath(uncheckedFileName);
         const info = this.getScriptInfoForNormalizedPath(path);
@@ -2614,7 +2614,7 @@ export class ProjectService {
         return configProject && configProject.getCompilerOptions().configFile;
     }
 
-    /* @internal */
+    /** @internal */
     logErrorForScriptInfoNotFound(fileName: string): void {
         const names = arrayFrom(this.filenameToScriptInfo.entries()).map(([path, scriptInfo]) => ({ path, fileName: scriptInfo.fileName }));
         this.logger.msg(`Could not find file ${JSON.stringify(fileName)}.\nAll files are: ${JSON.stringify(names)}`, Msg.Err);
@@ -2624,7 +2624,7 @@ export class ProjectService {
      * Returns the projects that contain script info through SymLink
      * Note that this does not return projects in info.containingProjects
      */
-    /*@internal*/
+    /** @internal */
     getSymlinkedProjects(info: ScriptInfo): MultiMap<Path, Project> | undefined {
         let projects: MultiMap<Path, Project> | undefined;
         if (this.realpathToScriptInfos) {
@@ -2737,7 +2737,7 @@ export class ProjectService {
         return result;
     }
 
-    /*@internal*/
+    /** @internal */
     watchPackageJsonsInNodeModules(dir: Path, project: Project): FileWatcher {
         const watcher = this.nodeModulesWatchers.get(dir) || this.createNodeModulesWatcher(dir);
         (watcher.affectedModuleSpecifierCacheProjects ||= new Set()).add(project.getProjectName());
@@ -2865,7 +2865,7 @@ export class ProjectService {
         return this.filenameToScriptInfo.get(fileName);
     }
 
-    /*@internal*/
+    /** @internal */
     getDocumentPositionMapper(project: Project, generatedFileName: string, sourceFileName?: string): DocumentPositionMapper | undefined {
         // Since declaration info and map file watches arent updating project's directory structure host (which can cache file structure) use host
         const declarationInfo = this.getOrCreateScriptInfoNotOpenedByClient(generatedFileName, project.currentDirectory, this.host);
@@ -2974,7 +2974,7 @@ export class ProjectService {
         return fileWatcher;
     }
 
-    /*@internal*/
+    /** @internal */
     getSourceFileLike(fileName: string, projectNameOrProject: string | Project, declarationInfo?: ScriptInfo) {
         const project = (projectNameOrProject as Project).projectName ? projectNameOrProject as Project : this.findProject(projectNameOrProject as string);
         if (project) {
@@ -3015,7 +3015,7 @@ export class ProjectService {
         return info.sourceFileLike;
     }
 
-    /*@internal*/
+    /** @internal */
     setPerformanceEventHandler(performanceEventHandler: PerformanceEventHandler) {
         this.performanceEventHandler = performanceEventHandler;
     }
@@ -3073,12 +3073,12 @@ export class ProjectService {
         }
     }
 
-    /*@internal*/
+    /** @internal */
     getWatchOptions(project: Project) {
         return this.getWatchOptionsFromProjectWatchOptions(project.getWatchOptions());
     }
 
-    /*@internal*/
+    /** @internal */
     private getWatchOptionsFromProjectWatchOptions(projectOptions: WatchOptions | undefined) {
         return projectOptions && this.hostConfiguration.watchOptions ?
             { ...this.hostConfiguration.watchOptions, ...projectOptions } :
@@ -3268,7 +3268,7 @@ export class ProjectService {
         return this.openClientFileWithNormalizedPath(toNormalizedPath(fileName), fileContent, scriptKind, /*hasMixedContent*/ false, projectRootPath ? toNormalizedPath(projectRootPath) : undefined);
     }
 
-    /*@internal*/
+    /** @internal */
     getOriginalLocationEnsuringConfiguredProject(project: Project, location: DocumentPosition): DocumentPosition | undefined {
         const isSourceOfProjectReferenceRedirect = project.isSourceOfProjectReferenceRedirect(location.fileName);
         const originalLocation = isSourceOfProjectReferenceRedirect ?
@@ -3499,7 +3499,7 @@ export class ProjectService {
         }
     }
 
-    /*@internal*/
+    /** @internal */
     loadAncestorProjectTree(forProjects?: ReadonlyCollection<string>) {
         forProjects = forProjects || mapDefinedEntries(
             this.configuredProjects,
@@ -3698,7 +3698,7 @@ export class ProjectService {
      * @param filename is absolute pathname
      */
     closeClientFile(uncheckedFileName: string): void;
-    /*@internal*/
+    /** @internal */
     closeClientFile(uncheckedFileName: string, skipAssignOrphanScriptInfosToInferredProject: true): boolean;
     closeClientFile(uncheckedFileName: string, skipAssignOrphanScriptInfosToInferredProject?: true) {
         const info = this.getScriptInfoForNormalizedPath(toNormalizedPath(uncheckedFileName));
@@ -3721,7 +3721,7 @@ export class ProjectService {
         }
     }
 
-    /* @internal */
+    /** @internal */
     synchronizeProjectList(knownProjects: protocol.ProjectVersionInfo[], includeProjectReferenceRedirectInfo?: boolean): ProjectFilesWithTSDiagnostics[] {
         const files: ProjectFilesWithTSDiagnostics[] = [];
         this.collectChanges(knownProjects, this.externalProjects, includeProjectReferenceRedirectInfo, files);
@@ -3730,7 +3730,7 @@ export class ProjectService {
         return files;
     }
 
-    /* @internal */
+    /** @internal */
     applyChangesInOpenFiles(openFiles: Iterator<OpenFileArguments> | undefined, changedFiles?: Iterator<ChangeFileArguments>, closedFiles?: string[]): void {
         let openScriptInfos: ScriptInfo[] | undefined;
         let assignOrphanScriptInfosToInferredProject = false;
@@ -3793,7 +3793,7 @@ export class ProjectService {
         }
     }
 
-    /* @internal */
+    /** @internal */
     applyChangesToFile(scriptInfo: ScriptInfo, changes: Iterator<TextChange>) {
         while (true) {
             const iterResult = changes.next();
@@ -4101,7 +4101,7 @@ export class ProjectService {
         return false;
     }
 
-    /*@internal*/
+    /** @internal */
     requestEnablePlugin(project: Project, pluginConfigEntry: PluginImport, searchPaths: string[], pluginConfigOverrides: Map<any> | undefined) {
         if (!this.host.importPlugin && !this.host.require) {
             this.logger.info("Plugins were requested but not running in environment that supports 'require'. Nothing will be loaded");
@@ -4128,12 +4128,12 @@ export class ProjectService {
         project.endEnablePlugin(project.beginEnablePluginSync(pluginConfigEntry, searchPaths, pluginConfigOverrides));
     }
 
-    /* @internal */
+    /** @internal */
     hasNewPluginEnablementRequests() {
         return !!this.pendingPluginEnablements;
     }
 
-    /* @internal */
+    /** @internal */
     hasPendingPluginEnablements() {
         return !!this.currentPluginEnablementPromise;
     }
@@ -4141,7 +4141,7 @@ export class ProjectService {
     /**
      * Waits for any ongoing plugin enablement requests to complete.
      */
-    /* @internal */
+    /** @internal */
     async waitForPendingPlugins() {
         while (this.currentPluginEnablementPromise) {
             await this.currentPluginEnablementPromise;
@@ -4151,7 +4151,7 @@ export class ProjectService {
     /**
      * Starts enabling any requested plugins without waiting for the result.
      */
-    /* @internal */
+    /** @internal */
     enableRequestedPlugins() {
         if (this.pendingPluginEnablements) {
             void this.enableRequestedPluginsAsync();
@@ -4219,7 +4219,7 @@ export class ProjectService {
         this.currentPluginConfigOverrides.set(args.pluginName, args.configuration);
     }
 
-    /*@internal*/
+    /** @internal */
     getPackageJsonsVisibleToFile(fileName: string, rootDir?: string): readonly ProjectPackageJsonInfo[] {
         const packageJsonCache = this.packageJsonCache;
         const rootPath = rootDir && this.toPath(rootDir);
@@ -4247,7 +4247,7 @@ export class ProjectService {
         return result;
     }
 
-    /*@internal*/
+    /** @internal */
     getNearestAncestorDirectoryWithPackageJson(fileName: string): string | undefined {
         return forEachAncestorDirectory(fileName, directory => {
             switch (this.packageJsonCache.directoryHasPackageJson(this.toPath(directory))) {
@@ -4261,7 +4261,7 @@ export class ProjectService {
         });
     }
 
-    /*@internal*/
+    /** @internal */
     private watchPackageJsonFile(path: Path) {
         const watchers = this.packageJsonFilesMap || (this.packageJsonFilesMap = new Map());
         if (!watchers.has(path)) {
@@ -4291,13 +4291,13 @@ export class ProjectService {
         }
     }
 
-    /*@internal*/
+    /** @internal */
     private onAddPackageJson(path: Path) {
         this.packageJsonCache.addOrUpdate(path);
         this.watchPackageJsonFile(path);
     }
 
-    /*@internal*/
+    /** @internal */
     includePackageJsonAutoImports(): PackageJsonAutoImportPreference {
         switch (this.hostConfiguration.preferences.includePackageJsonAutoImports) {
             case "on": return PackageJsonAutoImportPreference.On;
@@ -4306,7 +4306,7 @@ export class ProjectService {
         }
     }
 
-    /*@internal*/
+    /** @internal */
     private invalidateProjectPackageJson(packageJsonPath: Path | undefined) {
         this.configuredProjects.forEach(invalidate);
         this.inferredProjects.forEach(invalidate);
@@ -4321,7 +4321,7 @@ export class ProjectService {
         }
     }
 
-    /*@internal*/
+    /** @internal */
     getIncompleteCompletionsCache() {
         return this.incompleteCompletionsCache ||= createIncompleteCompletionsCache();
     }
@@ -4342,9 +4342,9 @@ function createIncompleteCompletionsCache(): IncompleteCompletionsCache {
     };
 }
 
-/* @internal */
+/** @internal */
 export type ScriptInfoOrConfig = ScriptInfo | TsConfigSourceFile;
-/* @internal */
+/** @internal */
 export function isConfigFile(config: ScriptInfoOrConfig): config is TsConfigSourceFile {
     return (config as TsConfigSourceFile).kind !== undefined;
 }
diff --git a/src/server/project.ts b/src/server/project.ts
index 11f84dae88..40e2f09422 100644
--- a/src/server/project.ts
+++ b/src/server/project.ts
@@ -39,10 +39,10 @@ export enum ProjectKind {
     Auxiliary,
 }
 
-/* @internal */
+/** @internal */
 export type Mutable<T> = { -readonly [K in keyof T]: T[K]; };
 
-/* @internal */
+/** @internal */
 export function countEachFileTypes(infos: ScriptInfo[], includeSizes = false): FileStats {
     const result: Mutable<FileStats> = {
         js: 0, jsSize: 0,
@@ -101,12 +101,12 @@ export function allFilesAreJsOrDts(project: Project): boolean {
     return counts.ts === 0 && counts.tsx === 0;
 }
 
-/* @internal */
+/** @internal */
 export function hasNoTypeScriptSource(fileNames: string[]): boolean {
     return !fileNames.some(fileName => (fileExtensionIs(fileName, Extension.Ts) && !isDeclarationFileName(fileName)) || fileExtensionIs(fileName, Extension.Tsx));
 }
 
-/* @internal */
+/** @internal */
 export interface ProjectFilesWithTSDiagnostics extends protocol.ProjectFiles {
     projectErrors: readonly Diagnostic[];
 }
@@ -133,7 +133,7 @@ export interface PluginModuleWithName {
 
 export type PluginModuleFactory = (mod: { typescript: typeof ts }) => PluginModule;
 
-/* @internal */
+/** @internal */
 export interface BeginEnablePluginResult {
     pluginConfigEntry: PluginImport;
     pluginConfigOverrides: Map<any> | undefined;
@@ -145,7 +145,7 @@ export interface BeginEnablePluginResult {
  * The project root can be script info - if root is present,
  * or it could be just normalized path if root wasn't present on the host(only for non inferred project)
  */
-/* @internal */
+/** @internal */
 export interface ProjectRootFile {
     fileName: NormalizedPath;
     info?: ScriptInfo;
@@ -160,7 +160,7 @@ function isGeneratedFileWatcher(watch: GeneratedFileWatcherMap): watch is Genera
     return (watch as GeneratedFileWatcher).generatedFilePath !== undefined;
 }
 
-/*@internal*/
+/** @internal */
 export interface EmitResult {
     emitSkipped: boolean;
     diagnostics: readonly Diagnostic[];
@@ -176,7 +176,7 @@ export abstract class Project implements LanguageServiceHost, ModuleResolutionHo
 
     private plugins: PluginModuleWithName[] = [];
 
-    /*@internal*/
+    /** @internal */
     /**
      * This is map from files to unresolved imports in it
      * Maop does not contain entries for files that do not have unresolved imports
@@ -184,14 +184,14 @@ export abstract class Project implements LanguageServiceHost, ModuleResolutionHo
      */
     cachedUnresolvedImportsPerFile = new Map<Path, readonly string[]>();
 
-    /*@internal*/
+    /** @internal */
     lastCachedUnresolvedImportsList: SortedReadonlyArray<string> | undefined;
-    /*@internal*/
+    /** @internal */
     private hasAddedorRemovedFiles = false;
-    /*@internal*/
+    /** @internal */
     private hasAddedOrRemovedSymlinks = false;
 
-    /*@internal*/
+    /** @internal */
     lastFileExceededProgramSize: string | undefined;
 
     // wrapper over the real language service that will suppress all semantic operations
@@ -202,10 +202,10 @@ export abstract class Project implements LanguageServiceHost, ModuleResolutionHo
     readonly trace?: (s: string) => void;
     readonly realpath?: (path: string) => string;
 
-    /*@internal*/
+    /** @internal */
     hasInvalidatedResolution: HasInvalidatedResolution | undefined;
 
-    /*@internal*/
+    /** @internal */
     resolutionCache: ResolutionCache;
 
     private builderState: BuilderState | undefined;
@@ -238,28 +238,28 @@ export abstract class Project implements LanguageServiceHost, ModuleResolutionHo
 
     protected isInitialLoadPending: () => boolean = returnFalse;
 
-    /*@internal*/
+    /** @internal */
     dirty = false;
 
-    /*@internal*/
+    /** @internal */
     typingFiles: SortedReadonlyArray<string> = emptyArray;
 
-    /*@internal*/
+    /** @internal */
     originalConfiguredProjects: Set<NormalizedPath> | undefined;
 
-    /*@internal*/
+    /** @internal */
     private packageJsonsForAutoImport: Set<string> | undefined;
 
-    /*@internal*/
+    /** @internal */
     private noDtsResolutionProject?: AuxiliaryProject | undefined;
 
-    /*@internal*/
+    /** @internal */
     getResolvedProjectReferenceToRedirect(_fileName: string): ResolvedProjectReference | undefined {
         return undefined;
     }
 
-    /* @internal */ useSourceOfProjectReferenceRedirect?(): boolean;
-    /* @internal */ getParsedCommandLine?(fileName: string): ParsedCommandLine | undefined;
+    /** @internal */ useSourceOfProjectReferenceRedirect?(): boolean;
+    /** @internal */ getParsedCommandLine?(fileName: string): ParsedCommandLine | undefined;
 
     private readonly cancellationToken: ThrottledCancellationToken;
 
@@ -285,7 +285,7 @@ export abstract class Project implements LanguageServiceHost, ModuleResolutionHo
         return result.module;
     }
 
-    /*@internal*/
+    /** @internal */
     public static async importServicePluginAsync(moduleName: string, initialDir: string, host: ServerHost, log: (message: string) => void, logErrors?: (message: string) => void): Promise<{} | undefined> {
         Debug.assertIsDefined(host.importPlugin);
         const resolvedPath = combinePaths(initialDir, "node_modules");
@@ -305,31 +305,31 @@ export abstract class Project implements LanguageServiceHost, ModuleResolutionHo
         return result.module;
     }
 
-    /*@internal*/
+    /** @internal */
     readonly currentDirectory: string;
 
-    /*@internal*/
+    /** @internal */
     public directoryStructureHost: DirectoryStructureHost;
 
-    /*@internal*/
+    /** @internal */
     public readonly getCanonicalFileName: GetCanonicalFileName;
 
-    /*@internal*/
+    /** @internal */
     private exportMapCache: ExportInfoMap | undefined;
-    /*@internal*/
+    /** @internal */
     private changedFilesForExportMapCache: Set<Path> | undefined;
-    /*@internal*/
+    /** @internal */
     private moduleSpecifierCache = createModuleSpecifierCache(this);
-    /*@internal*/
+    /** @internal */
     private symlinks: SymlinkCache | undefined;
-    /*@internal*/
+    /** @internal */
     autoImportProviderHost: AutoImportProviderProject | false | undefined;
-    /*@internal*/
+    /** @internal */
     protected typeAcquisition: TypeAcquisition | undefined;
 
-    /*@internal*/
+    /** @internal */
     constructor(
-        /*@internal*/ readonly projectName: string,
+        /** @internal */ readonly projectName: string,
         readonly projectKind: ProjectKind,
         readonly projectService: ProjectService,
         private documentRegistry: DocumentRegistry,
@@ -407,7 +407,7 @@ export abstract class Project implements LanguageServiceHost, ModuleResolutionHo
         return this.typingsCache.installPackage({ ...options, projectName: this.projectName, projectRootPath: this.toPath(this.currentDirectory) });
     }
 
-    /*@internal*/
+    /** @internal */
     getGlobalTypingsCacheLocation() {
         return this.getGlobalCache();
     }
@@ -416,7 +416,7 @@ export abstract class Project implements LanguageServiceHost, ModuleResolutionHo
         return this.projectService.typingsCache;
     }
 
-    /*@internal*/
+    /** @internal */
     getSymlinkCache(): SymlinkCache {
         if (!this.symlinks) {
             this.symlinks = createSymlinkCache(this.getCurrentDirectory(), this.getCanonicalFileName);
@@ -560,17 +560,17 @@ export abstract class Project implements LanguageServiceHost, ModuleResolutionHo
         return this.directoryStructureHost.getDirectories!(path); // TODO: GH#18217
     }
 
-    /*@internal*/
+    /** @internal */
     getCachedDirectoryStructureHost(): CachedDirectoryStructureHost {
         return undefined!; // TODO: GH#18217
     }
 
-    /*@internal*/
+    /** @internal */
     toPath(fileName: string) {
         return toPath(fileName, this.currentDirectory, this.projectService.toCanonicalFileName);
     }
 
-    /*@internal*/
+    /** @internal */
     watchDirectoryOfFailedLookupLocation(directory: string, cb: DirectoryWatcherCallback, flags: WatchDirectoryFlags) {
         return this.projectService.watchFactory.watchDirectory(
             directory,
@@ -582,7 +582,7 @@ export abstract class Project implements LanguageServiceHost, ModuleResolutionHo
         );
     }
 
-    /*@internal*/
+    /** @internal */
     watchAffectingFileLocation(file: string, cb: FileWatcherCallback) {
         return this.projectService.watchFactory.watchFile(
             file,
@@ -594,12 +594,12 @@ export abstract class Project implements LanguageServiceHost, ModuleResolutionHo
         );
     }
 
-    /*@internal*/
+    /** @internal */
     clearInvalidateResolutionOfFailedLookupTimer() {
         return this.projectService.throttledOperations.cancel(`${this.getProjectName()}FailedLookupInvalidation`);
     }
 
-    /*@internal*/
+    /** @internal */
     scheduleInvalidateResolutionsOfFailedLookupLocations() {
         this.projectService.throttledOperations.schedule(`${this.getProjectName()}FailedLookupInvalidation`, /*delay*/ 1000, () => {
             if (this.resolutionCache.invalidateResolutionsOfFailedLookupLocations()) {
@@ -608,7 +608,7 @@ export abstract class Project implements LanguageServiceHost, ModuleResolutionHo
         });
     }
 
-    /*@internal*/
+    /** @internal */
     invalidateResolutionsOfFailedLookupLocations() {
         if (this.clearInvalidateResolutionOfFailedLookupTimer() &&
             this.resolutionCache.invalidateResolutionsOfFailedLookupLocations()) {
@@ -617,12 +617,12 @@ export abstract class Project implements LanguageServiceHost, ModuleResolutionHo
         }
     }
 
-    /*@internal*/
+    /** @internal */
     onInvalidatedResolution() {
         this.projectService.delayUpdateProjectGraphAndEnsureProjectStructureForOpenFiles(this);
     }
 
-    /*@internal*/
+    /** @internal */
     watchTypeRootsDirectory(directory: string, cb: DirectoryWatcherCallback, flags: WatchDirectoryFlags) {
         return this.projectService.watchFactory.watchDirectory(
             directory,
@@ -634,30 +634,30 @@ export abstract class Project implements LanguageServiceHost, ModuleResolutionHo
         );
     }
 
-    /*@internal*/
+    /** @internal */
     hasChangedAutomaticTypeDirectiveNames() {
         return this.resolutionCache.hasChangedAutomaticTypeDirectiveNames();
     }
 
-    /*@internal*/
+    /** @internal */
     onChangedAutomaticTypeDirectiveNames() {
         this.projectService.delayUpdateProjectGraphAndEnsureProjectStructureForOpenFiles(this);
     }
 
-    /*@internal*/
+    /** @internal */
     getGlobalCache() {
         return this.getTypeAcquisition().enable ? this.projectService.typingsInstaller.globalTypingsCacheLocation : undefined;
     }
 
-    /*@internal*/
+    /** @internal */
     globalCacheResolutionModuleName = JsTyping.nonRelativeModuleNameForTypingCache;
 
-    /*@internal*/
+    /** @internal */
     fileIsOpen(filePath: Path) {
         return this.projectService.openFiles.has(filePath);
     }
 
-    /*@internal*/
+    /** @internal */
     writeLog(s: string) {
         this.projectService.logger.info(s);
     }
@@ -711,17 +711,17 @@ export abstract class Project implements LanguageServiceHost, ModuleResolutionHo
         this.languageService.clearSourceMapperCache();
     }
 
-    /*@internal*/
+    /** @internal */
     getDocumentPositionMapper(generatedFileName: string, sourceFileName?: string): DocumentPositionMapper | undefined {
         return this.projectService.getDocumentPositionMapper(this, generatedFileName, sourceFileName);
     }
 
-    /*@internal*/
+    /** @internal */
     getSourceFileLike(fileName: string) {
         return this.projectService.getSourceFileLike(fileName, this);
     }
 
-    /*@internal*/
+    /** @internal */
     shouldEmitFile(scriptInfo: ScriptInfo | undefined) {
         return scriptInfo &&
             !scriptInfo.isDynamicOrHasMixedContent() &&
@@ -838,7 +838,7 @@ export abstract class Project implements LanguageServiceHost, ModuleResolutionHo
         return this.program.getSourceFileByPath(path);
     }
 
-    /* @internal */
+    /** @internal */
     getSourceFileOrConfigFile(path: Path): SourceFile | undefined {
         const options = this.program!.getCompilerOptions();
         return path === options.configFilePath ? options.configFile : this.getSourceFile(path);
@@ -915,7 +915,7 @@ export abstract class Project implements LanguageServiceHost, ModuleResolutionHo
         return this.rootFiles && this.rootFiles.length > 0;
     }
 
-    /*@internal*/
+    /** @internal */
     isOrphan() {
         return false;
     }
@@ -924,7 +924,7 @@ export abstract class Project implements LanguageServiceHost, ModuleResolutionHo
         return this.rootFiles && this.rootFiles.map(info => info.fileName);
     }
 
-    /*@internal*/
+    /** @internal */
     getRootFilesMap() {
         return this.rootFilesMap;
     }
@@ -986,7 +986,7 @@ export abstract class Project implements LanguageServiceHost, ModuleResolutionHo
         return result;
     }
 
-    /* @internal */
+    /** @internal */
     getFileNamesWithRedirectInfo(includeProjectReferenceRedirectInfo: boolean) {
         return this.getFileNames().map((fileName): protocol.FileWithProjectReferenceRedirectInfo => ({
             fileName,
@@ -1073,7 +1073,7 @@ export abstract class Project implements LanguageServiceHost, ModuleResolutionHo
         (this.updatedFileNames || (this.updatedFileNames = new Set<string>())).add(fileName);
     }
 
-    /*@internal*/
+    /** @internal */
     markFileAsDirty(changedFile: Path) {
         this.markAsDirty();
         if (this.exportMapCache && !this.exportMapCache.isEmpty()) {
@@ -1088,7 +1088,7 @@ export abstract class Project implements LanguageServiceHost, ModuleResolutionHo
         }
     }
 
-    /*@internal*/
+    /** @internal */
     onAutoImportProviderSettingsChanged() {
         if (this.autoImportProviderHost === false) {
             this.autoImportProviderHost = undefined;
@@ -1098,7 +1098,7 @@ export abstract class Project implements LanguageServiceHost, ModuleResolutionHo
         }
     }
 
-    /*@internal*/
+    /** @internal */
     onPackageJsonChange(packageJsonPath: Path) {
         if (this.packageJsonsForAutoImport?.has(packageJsonPath)) {
             this.moduleSpecifierCache.clear();
@@ -1108,7 +1108,7 @@ export abstract class Project implements LanguageServiceHost, ModuleResolutionHo
         }
     }
 
-    /* @internal */
+    /** @internal */
     onFileAddedOrRemoved(isSymlink: boolean | undefined) {
         this.hasAddedorRemovedFiles = true;
         if (isSymlink) {
@@ -1116,7 +1116,7 @@ export abstract class Project implements LanguageServiceHost, ModuleResolutionHo
         }
     }
 
-    /* @internal */
+    /** @internal */
     onDiscoveredSymlink() {
         this.hasAddedOrRemovedSymlinks = true;
     }
@@ -1178,7 +1178,7 @@ export abstract class Project implements LanguageServiceHost, ModuleResolutionHo
         return !hasNewProgram;
     }
 
-    /*@internal*/
+    /** @internal */
     updateTypingFiles(typingFiles: SortedReadonlyArray<string>) {
         if (enumerateInsertsAndDeletes<string, string>(typingFiles, this.typingFiles, getStringComparer(!this.useCaseSensitiveFileNames()),
             /*inserted*/ noop,
@@ -1192,7 +1192,7 @@ export abstract class Project implements LanguageServiceHost, ModuleResolutionHo
         }
     }
 
-    /* @internal */
+    /** @internal */
     getCurrentProgram(): Program | undefined {
         return this.program;
     }
@@ -1338,7 +1338,7 @@ export abstract class Project implements LanguageServiceHost, ModuleResolutionHo
         return hasNewProgram;
     }
 
-    /* @internal */
+    /** @internal */
     sendPerformanceEvent(kind: PerformanceEvent["kind"], durationMs: number) {
         this.projectService.sendPerformanceEvent(kind, durationMs);
     }
@@ -1386,7 +1386,7 @@ export abstract class Project implements LanguageServiceHost, ModuleResolutionHo
         return !!this.missingFilesMap && this.missingFilesMap.has(path);
     }
 
-    /* @internal */
+    /** @internal */
     addGeneratedFileWatch(generatedFile: string, sourceFile: string) {
         if (outFile(this.compilerOptions)) {
             // Single watcher
@@ -1471,7 +1471,7 @@ export abstract class Project implements LanguageServiceHost, ModuleResolutionHo
         return strBuilder;
     }
 
-    /*@internal*/
+    /** @internal */
     print(writeProjectFileNames: boolean) {
         this.writeLog(`Project '${this.projectName}' (${ProjectKind[this.projectKind]})`);
         this.writeLog(this.filesToString(writeProjectFileNames && this.projectService.logger.hasLevel(LogLevel.verbose)));
@@ -1499,12 +1499,12 @@ export abstract class Project implements LanguageServiceHost, ModuleResolutionHo
         }
     }
 
-    /*@internal*/
+    /** @internal */
     setWatchOptions(watchOptions: WatchOptions | undefined) {
         this.watchOptions = watchOptions;
     }
 
-    /*@internal*/
+    /** @internal */
     getWatchOptions(): WatchOptions | undefined {
         return this.watchOptions;
     }
@@ -1519,7 +1519,7 @@ export abstract class Project implements LanguageServiceHost, ModuleResolutionHo
         return this.typeAcquisition || {};
     }
 
-    /* @internal */
+    /** @internal */
     getChangesSinceVersion(lastKnownVersion?: number, includeProjectReferenceRedirectInfo?: boolean): ProjectFilesWithTSDiagnostics {
         const includeProjectReferenceRedirectInfoIfRequested =
             includeProjectReferenceRedirectInfo
@@ -1630,7 +1630,7 @@ export abstract class Project implements LanguageServiceHost, ModuleResolutionHo
         this.rootFilesMap.delete(info.path);
     }
 
-    /*@internal*/
+    /** @internal */
     isSourceOfProjectReferenceRedirect(fileName: string) {
         return !!this.program && this.program.isSourceOfProjectReferenceRedirect(fileName);
     }
@@ -1670,7 +1670,7 @@ export abstract class Project implements LanguageServiceHost, ModuleResolutionHo
     /**
      * Performs the initial steps of enabling a plugin by finding and instantiating the module for a plugin synchronously using 'require'.
      */
-    /*@internal*/
+    /** @internal */
     beginEnablePluginSync(pluginConfigEntry: PluginImport, searchPaths: string[], pluginConfigOverrides: Map<any> | undefined): BeginEnablePluginResult {
         Debug.assertIsDefined(this.projectService.host.require);
 
@@ -1687,7 +1687,7 @@ export abstract class Project implements LanguageServiceHost, ModuleResolutionHo
     /**
      * Performs the initial steps of enabling a plugin by finding and instantiating the module for a plugin asynchronously using dynamic `import`.
      */
-    /*@internal*/
+    /** @internal */
     async beginEnablePluginAsync(pluginConfigEntry: PluginImport, searchPaths: string[], pluginConfigOverrides: Map<any> | undefined): Promise<BeginEnablePluginResult> {
         Debug.assertIsDefined(this.projectService.host.importPlugin);
 
@@ -1710,7 +1710,7 @@ export abstract class Project implements LanguageServiceHost, ModuleResolutionHo
     /**
      * Performs the remaining steps of enabling a plugin after its module has been instantiated.
      */
-    /*@internal*/
+    /** @internal */
     endEnablePlugin({ pluginConfigEntry, pluginConfigOverrides, resolvedModule, errorLogs }: BeginEnablePluginResult) {
         if (resolvedModule) {
             const configurationOverride = pluginConfigOverrides && pluginConfigOverrides.get(pluginConfigEntry.name);
@@ -1767,7 +1767,7 @@ export abstract class Project implements LanguageServiceHost, ModuleResolutionHo
         }
     }
 
-    /*@internal*/
+    /** @internal */
     onPluginConfigurationChanged(pluginName: string, configuration: any) {
         this.plugins.filter(plugin => plugin.name === pluginName).forEach(plugin => {
             if (plugin.module.onConfigurationChanged) {
@@ -1781,45 +1781,45 @@ export abstract class Project implements LanguageServiceHost, ModuleResolutionHo
         this.projectService.sendProjectsUpdatedInBackgroundEvent();
     }
 
-    /*@internal*/
+    /** @internal */
     getPackageJsonsVisibleToFile(fileName: string, rootDir?: string): readonly ProjectPackageJsonInfo[] {
         if (this.projectService.serverMode !== LanguageServiceMode.Semantic) return emptyArray;
         return this.projectService.getPackageJsonsVisibleToFile(fileName, rootDir);
     }
 
-    /*@internal*/
+    /** @internal */
     getNearestAncestorDirectoryWithPackageJson(fileName: string): string | undefined {
         return this.projectService.getNearestAncestorDirectoryWithPackageJson(fileName);
     }
 
-    /*@internal*/
+    /** @internal */
     getPackageJsonsForAutoImport(rootDir?: string): readonly ProjectPackageJsonInfo[] {
         const packageJsons = this.getPackageJsonsVisibleToFile(combinePaths(this.currentDirectory, inferredTypesContainingFile), rootDir);
         this.packageJsonsForAutoImport = new Set(packageJsons.map(p => p.fileName));
         return packageJsons;
     }
 
-    /* @internal */
+    /** @internal */
     getPackageJsonCache() {
         return this.projectService.packageJsonCache;
     }
 
-    /*@internal*/
+    /** @internal */
     getCachedExportInfoMap() {
         return this.exportMapCache ||= createCacheableExportInfoMap(this);
     }
 
-    /*@internal*/
+    /** @internal */
     clearCachedExportInfoMap() {
         this.exportMapCache?.clear();
     }
 
-    /*@internal*/
+    /** @internal */
     getModuleSpecifierCache() {
         return this.moduleSpecifierCache;
     }
 
-    /*@internal*/
+    /** @internal */
     includePackageJsonAutoImports(): PackageJsonAutoImportPreference {
         if (this.projectService.includePackageJsonAutoImports() === PackageJsonAutoImportPreference.Off ||
             !this.languageServiceEnabled ||
@@ -1830,7 +1830,7 @@ export abstract class Project implements LanguageServiceHost, ModuleResolutionHo
         return this.projectService.includePackageJsonAutoImports();
     }
 
-    /*@internal*/
+    /** @internal */
     getModuleResolutionHostForAutoImportProvider(): ModuleResolutionHost {
         if (this.program) {
             return {
@@ -1847,7 +1847,7 @@ export abstract class Project implements LanguageServiceHost, ModuleResolutionHo
         return this.projectService.host;
     }
 
-    /*@internal*/
+    /** @internal */
     getPackageJsonAutoImportProvider(): Program | undefined {
         if (this.autoImportProviderHost === false) {
             return undefined;
@@ -1881,24 +1881,24 @@ export abstract class Project implements LanguageServiceHost, ModuleResolutionHo
         }
     }
 
-    /*@internal*/
+    /** @internal */
     private isDefaultProjectForOpenFiles(): boolean {
         return !!forEachEntry(
             this.projectService.openFiles,
             (_, fileName) => this.projectService.tryGetDefaultProjectForFile(toNormalizedPath(fileName)) === this);
     }
 
-    /*@internal*/
+    /** @internal */
     watchNodeModulesForPackageJsonChanges(directoryPath: string) {
         return this.projectService.watchPackageJsonsInNodeModules(this.toPath(directoryPath), this);
     }
 
-    /*@internal*/
+    /** @internal */
     getIncompleteCompletionsCache() {
         return this.projectService.getIncompleteCompletionsCache();
     }
 
-    /*@internal*/
+    /** @internal */
     getNoDtsResolutionProject(rootFileNames: readonly string[]): Project {
         Debug.assert(this.projectService.serverMode === LanguageServiceMode.Semantic);
         if (!this.noDtsResolutionProject) {
@@ -1930,7 +1930,7 @@ export abstract class Project implements LanguageServiceHost, ModuleResolutionHo
         return this.noDtsResolutionProject;
     }
 
-    /*@internal*/
+    /** @internal */
     private getCompilerOptionsForNoDtsResolutionProject() {
         return {
             ...this.getCompilerOptions(),
@@ -2005,11 +2005,11 @@ export class InferredProject extends Project {
     /** this is canonical project root path */
     readonly projectRootPath: string | undefined;
 
-    /*@internal*/
+    /** @internal */
     /** stored only if their is no projectRootPath and this isnt single inferred project */
     readonly canonicalCurrentDirectory: string | undefined;
 
-    /*@internal*/
+    /** @internal */
     constructor(
         projectService: ProjectService,
         documentRegistry: DocumentRegistry,
@@ -2058,7 +2058,7 @@ export class InferredProject extends Project {
         }
     }
 
-    /*@internal*/
+    /** @internal */
     isOrphan() {
         return !this.hasRoots();
     }
@@ -2104,7 +2104,7 @@ class AuxiliaryProject extends Project {
         return true;
     }
 
-    /*@internal*/
+    /** @internal */
     scheduleInvalidateResolutionsOfFailedLookupLocations(): void {
         // Invalidation will happen on-demand as part of updateGraph
         return;
@@ -2112,10 +2112,10 @@ class AuxiliaryProject extends Project {
 }
 
 export class AutoImportProviderProject extends Project {
-    /*@internal*/
+    /** @internal */
     private static readonly maxDependencies = 10;
 
-    /*@internal*/
+    /** @internal */
     static getRootFileNames(dependencySelection: PackageJsonAutoImportPreference, hostProject: Project, moduleResolutionHost: ModuleResolutionHost, compilerOptions: CompilerOptions): string[] {
         if (!dependencySelection) {
             return ts.emptyArray;
@@ -2235,7 +2235,7 @@ export class AutoImportProviderProject extends Project {
         }
     }
 
-    /*@internal*/
+    /** @internal */
     static readonly compilerOptionsOverrides: CompilerOptions = {
         diagnostics: false,
         skipLibCheck: true,
@@ -2245,7 +2245,7 @@ export class AutoImportProviderProject extends Project {
         noLib: true,
     };
 
-    /*@internal*/
+    /** @internal */
     static create(dependencySelection: PackageJsonAutoImportPreference, hostProject: Project, moduleResolutionHost: ModuleResolutionHost, documentRegistry: DocumentRegistry): AutoImportProviderProject | undefined {
         if (dependencySelection === PackageJsonAutoImportPreference.Off) {
             return undefined;
@@ -2266,7 +2266,7 @@ export class AutoImportProviderProject extends Project {
 
     private rootFileNames: string[] | undefined;
 
-    /*@internal*/
+    /** @internal */
     constructor(
         private hostProject: Project,
         initialRootNames: string[],
@@ -2290,7 +2290,7 @@ export class AutoImportProviderProject extends Project {
         this.getParsedCommandLine = maybeBind(this.hostProject, this.hostProject.getParsedCommandLine);
     }
 
-    /*@internal*/
+    /** @internal */
     isEmpty() {
         return !some(this.rootFileNames);
     }
@@ -2319,7 +2319,7 @@ export class AutoImportProviderProject extends Project {
         return hasSameSetOfFiles;
     }
 
-    /*@internal*/
+    /** @internal */
     scheduleInvalidateResolutionsOfFailedLookupLocations(): void {
         // Invalidation will happen on-demand as part of updateGraph
         return;
@@ -2342,12 +2342,12 @@ export class AutoImportProviderProject extends Project {
         throw new Error("AutoImportProviderProject language service should never be used. To get the program, use `project.getCurrentProgram()`.");
     }
 
-    /*@internal*/
+    /** @internal */
     onAutoImportProviderSettingsChanged(): never {
         throw new Error("AutoImportProviderProject is an auto import provider; use `markAsDirty()` instead.");
     }
 
-    /*@internal*/
+    /** @internal */
     onPackageJsonChange(): never {
         throw new Error("package.json changes should be notified on an AutoImportProvider's host project");
     }
@@ -2360,7 +2360,7 @@ export class AutoImportProviderProject extends Project {
         return this.hostProject.getProjectReferences();
     }
 
-    /*@internal*/
+    /** @internal */
     includePackageJsonAutoImports() {
         return PackageJsonAutoImportPreference.Off;
     }
@@ -2369,12 +2369,12 @@ export class AutoImportProviderProject extends Project {
         return { enable: false };
     }
 
-    /*@internal*/
+    /** @internal */
     getSymlinkCache() {
         return this.hostProject.getSymlinkCache();
     }
 
-    /*@internal*/
+    /** @internal */
     getModuleResolutionCache() {
         return this.hostProject.getCurrentProgram()?.getModuleResolutionCache();
     }
@@ -2386,15 +2386,15 @@ export class AutoImportProviderProject extends Project {
  * Otherwise it will create an InferredProject.
  */
 export class ConfiguredProject extends Project {
-    /* @internal */
+    /** @internal */
     pendingReload: ConfigFileProgramReloadLevel | undefined;
-    /* @internal */
+    /** @internal */
     pendingReloadReason: string | undefined;
 
-    /* @internal */
+    /** @internal */
     openFileWatchTriggered = new Map<string, ConfigFileProgramReloadLevel>();
 
-    /*@internal*/
+    /** @internal */
     canConfigFileJsonReportNoInputFiles = false;
 
     /** Ref count to the project when opened from external project */
@@ -2403,22 +2403,22 @@ export class ConfiguredProject extends Project {
     private projectReferences: readonly ProjectReference[] | undefined;
 
     /** Potential project references before the project is actually loaded (read config file) */
-    /*@internal*/
+    /** @internal */
     potentialProjectReferences: Set<string> | undefined;
 
-    /*@internal*/
+    /** @internal */
     projectOptions?: ProjectOptions | true;
 
-    /*@internal*/
+    /** @internal */
     isInitialLoadPending: () => boolean = returnTrue;
 
-    /*@internal*/
+    /** @internal */
     sendLoadingProjectFinish = false;
 
-    /*@internal*/
+    /** @internal */
     private compilerHost?: CompilerHost;
 
-    /*@internal*/
+    /** @internal */
     constructor(configFileName: NormalizedPath,
         readonly canonicalConfigFilePath: NormalizedPath,
         projectService: ProjectService,
@@ -2438,22 +2438,22 @@ export class ConfiguredProject extends Project {
         );
     }
 
-    /* @internal */
+    /** @internal */
     setCompilerHost(host: CompilerHost) {
         this.compilerHost = host;
     }
 
-    /* @internal */
+    /** @internal */
     getCompilerHost(): CompilerHost | undefined {
         return this.compilerHost;
     }
 
-    /* @internal */
+    /** @internal */
     useSourceOfProjectReferenceRedirect() {
         return this.languageServiceEnabled;
     }
 
-    /* @internal */
+    /** @internal */
     getParsedCommandLine(fileName: string) {
         const configFileName = asNormalizedPath(normalizePath(fileName));
         const canonicalConfigFilePath = asNormalizedPath(this.projectService.toCanonicalFileName(configFileName));
@@ -2471,12 +2471,12 @@ export class ConfiguredProject extends Project {
         return configFileExistenceInfo.exists ? configFileExistenceInfo.config!.parsedCommandLine : undefined;
     }
 
-    /* @internal */
+    /** @internal */
     onReleaseParsedCommandLine(fileName: string) {
         this.releaseParsedConfig(asNormalizedPath(this.projectService.toCanonicalFileName(asNormalizedPath(normalizePath(fileName)))));
     }
 
-    /* @internal */
+    /** @internal */
     private releaseParsedConfig(canonicalConfigFilePath: NormalizedPath) {
         this.projectService.stopWatchingWildCards(canonicalConfigFilePath, this);
         this.projectService.releaseParsedConfig(canonicalConfigFilePath, this);
@@ -2513,7 +2513,7 @@ export class ConfiguredProject extends Project {
         return result;
     }
 
-    /*@internal*/
+    /** @internal */
     getCachedDirectoryStructureHost() {
         return this.directoryStructureHost as CachedDirectoryStructureHost;
     }
@@ -2531,26 +2531,26 @@ export class ConfiguredProject extends Project {
         this.potentialProjectReferences = undefined;
     }
 
-    /*@internal*/
+    /** @internal */
     setPotentialProjectReference(canonicalConfigPath: NormalizedPath) {
         Debug.assert(this.isInitialLoadPending());
         (this.potentialProjectReferences || (this.potentialProjectReferences = new Set())).add(canonicalConfigPath);
     }
 
-    /*@internal*/
+    /** @internal */
     getResolvedProjectReferenceToRedirect(fileName: string): ResolvedProjectReference | undefined {
         const program = this.getCurrentProgram();
         return program && program.getResolvedProjectReferenceToRedirect(fileName);
     }
 
-    /*@internal*/
+    /** @internal */
     forEachResolvedProjectReference<T>(
         cb: (resolvedProjectReference: ResolvedProjectReference) => T | undefined
     ): T | undefined {
         return this.getCurrentProgram()?.forEachResolvedProjectReference(cb);
     }
 
-    /*@internal*/
+    /** @internal */
     enablePluginsWithOptions(options: CompilerOptions, pluginConfigOverrides: ESMap<string, any> | undefined): void {
         const host = this.projectService.host;
         if (!host.require && !host.importPlugin) {
@@ -2605,23 +2605,23 @@ export class ConfiguredProject extends Project {
         super.close();
     }
 
-    /* @internal */
+    /** @internal */
     addExternalProjectReference() {
         this.externalProjectRefCount++;
     }
 
-    /* @internal */
+    /** @internal */
     deleteExternalProjectReference() {
         this.externalProjectRefCount--;
     }
 
-    /* @internal */
+    /** @internal */
     isSolution() {
         return this.getRootFilesMap().size === 0 &&
             !this.canConfigFileJsonReportNoInputFiles;
     }
 
-    /* @internal */
+    /** @internal */
     /** Find the configured project from the project references in project which contains the info directly */
     getDefaultChildProjectFromProjectWithReferences(info: ScriptInfo) {
         return forEachResolvedProjectReferenceProject(
@@ -2635,7 +2635,7 @@ export class ConfiguredProject extends Project {
     }
 
     /** Returns true if the project is needed by any of the open script info/external project */
-    /* @internal */
+    /** @internal */
     hasOpenRef() {
         if (!!this.externalProjectRefCount) {
             return true;
@@ -2672,7 +2672,7 @@ export class ConfiguredProject extends Project {
         ) || false;
     }
 
-    /*@internal*/
+    /** @internal */
     hasExternalProjectRef() {
         return !!this.externalProjectRefCount;
     }
@@ -2681,7 +2681,7 @@ export class ConfiguredProject extends Project {
         return getEffectiveTypeRoots(this.getCompilationSettings(), this.directoryStructureHost) || [];
     }
 
-    /*@internal*/
+    /** @internal */
     updateErrorOnNoInputFiles(fileNames: string[]) {
         updateErrorForNoInputFiles(fileNames, this.getConfigFilePath(), this.getCompilerOptions().configFile!.configFileSpecs!, this.projectErrors!, this.canConfigFileJsonReportNoInputFiles);
     }
@@ -2693,7 +2693,7 @@ export class ConfiguredProject extends Project {
  */
 export class ExternalProject extends Project {
     excludedFiles: readonly NormalizedPath[] = [];
-    /*@internal*/
+    /** @internal */
     constructor(public externalProjectName: string,
         projectService: ProjectService,
         documentRegistry: DocumentRegistry,
@@ -2728,17 +2728,17 @@ export class ExternalProject extends Project {
     }
 }
 
-/* @internal */
+/** @internal */
 export function isInferredProject(project: Project): project is InferredProject {
     return project.projectKind === ProjectKind.Inferred;
 }
 
-/* @internal */
+/** @internal */
 export function isConfiguredProject(project: Project): project is ConfiguredProject {
     return project.projectKind === ProjectKind.Configured;
 }
 
-/* @internal */
+/** @internal */
 export function isExternalProject(project: Project): project is ExternalProject {
     return project.projectKind === ProjectKind.External;
 }
diff --git a/src/server/protocol.ts b/src/server/protocol.ts
index 3af465ec2b..6cbb1717b1 100644
--- a/src/server/protocol.ts
+++ b/src/server/protocol.ts
@@ -15,7 +15,7 @@ import {
 export const enum CommandTypes {
     JsxClosingTag = "jsxClosingTag",
     Brace = "brace",
-    /* @internal */
+    /** @internal */
     BraceFull = "brace-full",
     BraceCompletion = "braceCompletion",
     GetSpanOfEnclosingComment = "getSpanOfEnclosingComment",
@@ -24,36 +24,36 @@ export const enum CommandTypes {
     /** @deprecated Prefer CompletionInfo -- see comment on CompletionsResponse */
     Completions = "completions",
     CompletionInfo = "completionInfo",
-    /* @internal */
+    /** @internal */
     CompletionsFull = "completions-full",
     CompletionDetails = "completionEntryDetails",
-    /* @internal */
+    /** @internal */
     CompletionDetailsFull = "completionEntryDetails-full",
     CompileOnSaveAffectedFileList = "compileOnSaveAffectedFileList",
     CompileOnSaveEmitFile = "compileOnSaveEmitFile",
     Configure = "configure",
     Definition = "definition",
-    /* @internal */
+    /** @internal */
     DefinitionFull = "definition-full",
     DefinitionAndBoundSpan = "definitionAndBoundSpan",
-    /* @internal */
+    /** @internal */
     DefinitionAndBoundSpanFull = "definitionAndBoundSpan-full",
     Implementation = "implementation",
-    /* @internal */
+    /** @internal */
     ImplementationFull = "implementation-full",
-    /* @internal */
+    /** @internal */
     EmitOutput = "emit-output",
     Exit = "exit",
     FileReferences = "fileReferences",
-    /* @internal */
+    /** @internal */
     FileReferencesFull = "fileReferences-full",
     Format = "format",
     Formatonkey = "formatonkey",
-    /* @internal */
+    /** @internal */
     FormatFull = "format-full",
-    /* @internal */
+    /** @internal */
     FormatonkeyFull = "formatonkey-full",
-    /* @internal */
+    /** @internal */
     FormatRangeFull = "formatRange-full",
     Geterr = "geterr",
     GeterrForProject = "geterrForProject",
@@ -61,34 +61,34 @@ export const enum CommandTypes {
     SyntacticDiagnosticsSync = "syntacticDiagnosticsSync",
     SuggestionDiagnosticsSync = "suggestionDiagnosticsSync",
     NavBar = "navbar",
-    /* @internal */
+    /** @internal */
     NavBarFull = "navbar-full",
     Navto = "navto",
-    /* @internal */
+    /** @internal */
     NavtoFull = "navto-full",
     NavTree = "navtree",
     NavTreeFull = "navtree-full",
     /** @deprecated */
     Occurrences = "occurrences",
     DocumentHighlights = "documentHighlights",
-    /* @internal */
+    /** @internal */
     DocumentHighlightsFull = "documentHighlights-full",
     Open = "open",
     Quickinfo = "quickinfo",
-    /* @internal */
+    /** @internal */
     QuickinfoFull = "quickinfo-full",
     References = "references",
-    /* @internal */
+    /** @internal */
     ReferencesFull = "references-full",
     Reload = "reload",
     Rename = "rename",
-    /* @internal */
+    /** @internal */
     RenameInfoFull = "rename-full",
-    /* @internal */
+    /** @internal */
     RenameLocationsFull = "renameLocations-full",
     Saveto = "saveto",
     SignatureHelp = "signatureHelp",
-    /* @internal */
+    /** @internal */
     SignatureHelpFull = "signatureHelp-full",
     FindSourceDefinition = "findSourceDefinition",
     Status = "status",
@@ -99,65 +99,65 @@ export const enum CommandTypes {
     OpenExternalProject = "openExternalProject",
     OpenExternalProjects = "openExternalProjects",
     CloseExternalProject = "closeExternalProject",
-    /* @internal */
+    /** @internal */
     SynchronizeProjectList = "synchronizeProjectList",
-    /* @internal */
+    /** @internal */
     ApplyChangedToOpenFiles = "applyChangedToOpenFiles",
     UpdateOpen = "updateOpen",
-    /* @internal */
+    /** @internal */
     EncodedSyntacticClassificationsFull = "encodedSyntacticClassifications-full",
-    /* @internal */
+    /** @internal */
     EncodedSemanticClassificationsFull = "encodedSemanticClassifications-full",
-    /* @internal */
+    /** @internal */
     Cleanup = "cleanup",
     GetOutliningSpans = "getOutliningSpans",
-    /* @internal */
+    /** @internal */
     GetOutliningSpansFull = "outliningSpans", // Full command name is different for backward compatibility purposes
     TodoComments = "todoComments",
     Indentation = "indentation",
     DocCommentTemplate = "docCommentTemplate",
-    /* @internal */
+    /** @internal */
     CompilerOptionsDiagnosticsFull = "compilerOptionsDiagnostics-full",
-    /* @internal */
+    /** @internal */
     NameOrDottedNameSpan = "nameOrDottedNameSpan",
-    /* @internal */
+    /** @internal */
     BreakpointStatement = "breakpointStatement",
     CompilerOptionsForInferredProjects = "compilerOptionsForInferredProjects",
     GetCodeFixes = "getCodeFixes",
-    /* @internal */
+    /** @internal */
     GetCodeFixesFull = "getCodeFixes-full",
     GetCombinedCodeFix = "getCombinedCodeFix",
-    /* @internal */
+    /** @internal */
     GetCombinedCodeFixFull = "getCombinedCodeFix-full",
     ApplyCodeActionCommand = "applyCodeActionCommand",
     GetSupportedCodeFixes = "getSupportedCodeFixes",
 
     GetApplicableRefactors = "getApplicableRefactors",
     GetEditsForRefactor = "getEditsForRefactor",
-    /* @internal */
+    /** @internal */
     GetEditsForRefactorFull = "getEditsForRefactor-full",
 
     OrganizeImports = "organizeImports",
-    /* @internal */
+    /** @internal */
     OrganizeImportsFull = "organizeImports-full",
     GetEditsForFileRename = "getEditsForFileRename",
-    /* @internal */
+    /** @internal */
     GetEditsForFileRenameFull = "getEditsForFileRename-full",
     ConfigurePlugin = "configurePlugin",
     SelectionRange = "selectionRange",
-    /* @internal */
+    /** @internal */
     SelectionRangeFull = "selectionRange-full",
     ToggleLineComment = "toggleLineComment",
-    /* @internal */
+    /** @internal */
     ToggleLineCommentFull = "toggleLineComment-full",
     ToggleMultilineComment = "toggleMultilineComment",
-    /* @internal */
+    /** @internal */
     ToggleMultilineCommentFull = "toggleMultilineComment-full",
     CommentSelection = "commentSelection",
-    /* @internal */
+    /** @internal */
     CommentSelectionFull = "commentSelection-full",
     UncommentSelection = "uncommentSelection",
-    /* @internal */
+    /** @internal */
     UncommentSelectionFull = "uncommentSelection-full",
     PrepareCallHierarchy = "prepareCallHierarchy",
     ProvideCallHierarchyIncomingCalls = "provideCallHierarchyIncomingCalls",
@@ -403,7 +403,7 @@ export interface OutliningSpansResponse extends Response {
 /**
  * Request to obtain outlining spans in file.
  */
-/* @internal */
+/** @internal */
 export interface OutliningSpansRequestFull extends FileRequest {
     command: CommandTypes.GetOutliningSpansFull;
 }
@@ -411,7 +411,7 @@ export interface OutliningSpansRequestFull extends FileRequest {
 /**
  * Response to OutliningSpansRequest request.
  */
-/* @internal */
+/** @internal */
 export interface OutliningSpansResponseFull extends Response {
     body?: ts.OutliningSpan[];
 }
@@ -561,7 +561,7 @@ export interface FileLocationRequestArgs extends FileRequestArgs {
     /**
      * Position (can be specified instead of line/offset pair)
      */
-    /* @internal */
+    /** @internal */
     position?: number;
 }
 
@@ -751,7 +751,7 @@ export interface FileRangeRequestArgs extends FileRequestArgs {
     /**
      * Position (can be specified instead of line/offset pair)
      */
-    /* @internal */
+    /** @internal */
     startPosition?: number;
 
     /**
@@ -767,7 +767,7 @@ export interface FileRangeRequestArgs extends FileRequestArgs {
     /**
      * Position (can be specified instead of line/offset pair)
      */
-    /* @internal */
+    /** @internal */
     endPosition?: number;
 }
 
@@ -1254,13 +1254,13 @@ export interface RenameRequest extends FileLocationRequest {
     arguments: RenameRequestArgs;
 }
 
-/* @internal */
+/** @internal */
 export interface RenameFullRequest extends FileLocationRequest {
     readonly command: CommandTypes.RenameLocationsFull;
     readonly arguments: RenameRequestArgs;
 }
 
-/* @internal */
+/** @internal */
 export interface RenameFullResponse extends Response {
     readonly body: readonly RenameLocation[];
 }
@@ -1415,7 +1415,7 @@ export type ExternalProjectCompilerOptions = CompilerOptions & CompileOnSaveMixi
 /**
  * Contains information about current project version
  */
-/* @internal */
+/** @internal */
 export interface ProjectVersionInfo {
     /**
      * Project name
@@ -1485,7 +1485,7 @@ export interface ProjectChanges {
  * if changes is set - then this is the set of changes that should be applied to existing project
  * otherwise - assume that nothing is changed
  */
-/* @internal */
+/** @internal */
 export interface ProjectFiles {
     /**
      * Information about project verison
@@ -1506,7 +1506,7 @@ export interface ProjectFiles {
 /**
  * Combines project information with project level errors.
  */
-/* @internal */
+/** @internal */
 export interface ProjectFilesWithDiagnostics extends ProjectFiles {
     /**
      * List of errors in project
@@ -1517,7 +1517,7 @@ export interface ProjectFilesWithDiagnostics extends ProjectFiles {
 /**
  * Represents set of changes in open file
  */
-/* @internal */
+/** @internal */
 export interface ChangedOpenFile {
     /**
      * Name of file
@@ -1770,7 +1770,7 @@ export interface CloseExternalProjectResponse extends Response {
 /**
  * Request to check if given list of projects is up-to-date and synchronize them if necessary
  */
-/* @internal */
+/** @internal */
 export interface SynchronizeProjectListRequest extends Request {
     arguments: SynchronizeProjectListRequestArgs;
 }
@@ -1778,7 +1778,7 @@ export interface SynchronizeProjectListRequest extends Request {
 /**
  * Arguments to SynchronizeProjectListRequest
  */
-/* @internal */
+/** @internal */
 export interface SynchronizeProjectListRequestArgs {
     /**
      * List of last known projects
@@ -1794,7 +1794,7 @@ export interface SynchronizeProjectListRequestArgs {
 /**
  * Request to synchronize list of open files with the client
  */
-/* @internal */
+/** @internal */
 export interface ApplyChangedToOpenFilesRequest extends Request {
     arguments: ApplyChangedToOpenFilesRequestArgs;
 }
@@ -1802,7 +1802,7 @@ export interface ApplyChangedToOpenFilesRequest extends Request {
 /**
  * Arguments to ApplyChangedToOpenFilesRequest
  */
-/* @internal */
+/** @internal */
 export interface ApplyChangedToOpenFilesRequestArgs {
     /**
      * List of newly open files
@@ -2046,7 +2046,7 @@ export interface FormatRequestArgs extends FileLocationRequestArgs {
     /**
      * End position of the range for which to format text in file.
      */
-    /* @internal */
+    /** @internal */
     endPosition?: number;
     /**
      * Format options to be used.
@@ -2958,7 +2958,7 @@ export interface LargeFileReferencedEventBody {
     maxFileSize: number;
 }
 
-/*@internal*/
+/** @internal */
 export type AnyEvent =
     RequestCompletedEvent
     | DiagnosticEvent
diff --git a/src/server/scriptInfo.ts b/src/server/scriptInfo.ts
index aa160e17d2..25c77fe3d4 100644
--- a/src/server/scriptInfo.ts
+++ b/src/server/scriptInfo.ts
@@ -17,7 +17,7 @@ export interface ScriptInfoVersion {
     text: number;
 }
 
-/* @internal */
+/** @internal */
 export class TextStorage {
     version: ScriptInfoVersion;
 
@@ -290,13 +290,13 @@ export function isDynamicFileName(fileName: NormalizedPath) {
         (stringContains(fileName, ":^") && !stringContains(fileName, directorySeparator));
 }
 
-/*@internal*/
+/** @internal */
 export interface DocumentRegistrySourceFileCache {
     key: DocumentRegistryBucketKeyWithMode;
     sourceFile: SourceFile;
 }
 
-/*@internal*/
+/** @internal */
 export interface SourceMapFileWatcher {
     watcher: FileWatcher;
     sourceInfos?: Set<Path>;
@@ -310,35 +310,35 @@ export class ScriptInfo {
     private formatSettings: FormatCodeSettings | undefined;
     private preferences: protocol.UserPreferences | undefined;
 
-    /* @internal */
+    /** @internal */
     fileWatcher: FileWatcher | undefined;
     private textStorage: TextStorage;
 
-    /*@internal*/
+    /** @internal */
     readonly isDynamic: boolean;
 
-    /*@internal*/
+    /** @internal */
     /** Set to real path if path is different from info.path */
     private realpath: Path | undefined;
 
-    /*@internal*/
+    /** @internal */
     cacheSourceFile: DocumentRegistrySourceFileCache | undefined;
 
-    /*@internal*/
+    /** @internal */
     mTime?: number;
 
-    /*@internal*/
+    /** @internal */
     sourceFileLike?: SourceFileLike;
 
-    /*@internal*/
+    /** @internal */
     sourceMapFilePath?: Path | SourceMapFileWatcher | false;
 
     // Present on sourceMapFile info
-    /*@internal*/
+    /** @internal */
     declarationInfoPath?: Path;
-    /*@internal*/
+    /** @internal */
     sourceInfos?: Set<Path>;
-    /*@internal*/
+    /** @internal */
     documentPositionMapper?: DocumentPositionMapper | false;
 
     constructor(
@@ -360,17 +360,17 @@ export class ScriptInfo {
             : getScriptKindFromFileName(fileName);
     }
 
-    /*@internal*/
+    /** @internal */
     getVersion() {
         return this.textStorage.version;
     }
 
-    /*@internal*/
+    /** @internal */
     getTelemetryFileSize() {
         return this.textStorage.getTelemetryFileSize();
     }
 
-    /*@internal*/
+    /** @internal */
     public isDynamicOrHasMixedContent() {
         return this.hasMixedContent || this.isDynamic;
     }
@@ -423,7 +423,7 @@ export class ScriptInfo {
         }
     }
 
-    /*@internal*/
+    /** @internal */
     getRealpathIfDifferent(): Path | undefined {
         return this.realpath && this.realpath !== this.path ? this.realpath : undefined;
     }
@@ -592,7 +592,7 @@ export class ScriptInfo {
         this.host.writeFile(fileName, getSnapshotText(this.textStorage.getSnapshot()));
     }
 
-    /*@internal*/
+    /** @internal */
     delayReloadNonMixedContentFile() {
         Debug.assert(!this.isDynamicOrHasMixedContent());
         this.textStorage.delayReloadFromFileIntoText();
@@ -614,7 +614,7 @@ export class ScriptInfo {
         return false;
     }
 
-    /*@internal*/
+    /** @internal */
     getAbsolutePositionAndLineText(line: number): AbsolutePositionAndLineText {
         return this.textStorage.getAbsolutePositionAndLineText(line);
     }
@@ -634,7 +634,7 @@ export class ScriptInfo {
         return !forEach(this.containingProjects, p => !p.isOrphan());
     }
 
-    /*@internal*/
+    /** @internal */
     isContainedByBackgroundProject() {
         return some(
             this.containingProjects,
@@ -653,7 +653,7 @@ export class ScriptInfo {
      * @param offset 1 based index
      */
     lineOffsetToPosition(line: number, offset: number): number;
-    /*@internal*/
+    /** @internal */
     lineOffsetToPosition(line: number, offset: number, allowEdits?: true): number; // eslint-disable-line @typescript-eslint/unified-signatures
     lineOffsetToPosition(line: number, offset: number, allowEdits?: true): number {
         return this.textStorage.lineOffsetToPosition(line, offset, allowEdits);
@@ -670,12 +670,12 @@ export class ScriptInfo {
         return this.scriptKind === ScriptKind.JS || this.scriptKind === ScriptKind.JSX;
     }
 
-    /*@internal*/
+    /** @internal */
     getLineInfo(): LineInfo {
         return this.textStorage.getLineInfo();
     }
 
-    /*@internal*/
+    /** @internal */
     closeSourceMapFileWatcher() {
         if (this.sourceMapFilePath && !isString(this.sourceMapFilePath)) {
             closeFileWatcherOf(this.sourceMapFilePath);
diff --git a/src/server/session.ts b/src/server/session.ts
index e28017ab24..7046133a20 100644
--- a/src/server/session.ts
+++ b/src/server/session.ts
@@ -3531,7 +3531,7 @@ export interface HandlerResponse {
     responseRequired?: boolean;
 }
 
-/* @internal */ // Exported only for tests
+/** @internal */ // Exported only for tests
 export function getLocationInNewDocument(oldText: string, renameFilename: string, renameLocation: number, edits: readonly FileTextChanges[]): protocol.Location {
     const newText = applyEdits(oldText, renameFilename, edits);
     const { line, character } = computeLineAndCharacterOfPosition(computeLineStarts(newText), renameLocation);
diff --git a/src/server/types.ts b/src/server/types.ts
index 4f76ed311a..3ebc765594 100644
--- a/src/server/types.ts
+++ b/src/server/types.ts
@@ -21,6 +21,6 @@ export interface ServerHost extends System {
     gc?(): void;
     trace?(s: string): void;
     require?(initialPath: string, moduleName: string): ModuleImportResult;
-    /*@internal*/
+    /** @internal */
     importPlugin?(root: string, moduleName: string): Promise<ModuleImportResult>;
 }
diff --git a/src/server/typingsCache.ts b/src/server/typingsCache.ts
index ae47f2d76e..fa35a6842e 100644
--- a/src/server/typingsCache.ts
+++ b/src/server/typingsCache.ts
@@ -86,7 +86,7 @@ function unresolvedImportsChanged(imports1: SortedReadonlyArray<string> | undefi
     return !arrayIsEqualTo(imports1, imports2);
 }
 
-/*@internal*/
+/** @internal */
 export class TypingsCache {
     private readonly perProjectCache = new Map<string, TypingsCacheEntry>();
 
diff --git a/src/server/utilitiesPublic.ts b/src/server/utilitiesPublic.ts
index 758a8bce01..4af5e8394b 100644
--- a/src/server/utilitiesPublic.ts
+++ b/src/server/utilitiesPublic.ts
@@ -102,7 +102,7 @@ export function createNormalizedPathMap<T>(): NormalizedPathMap<T> {
     };
 }
 
-/*@internal*/
+/** @internal */
 export interface ProjectOptions {
     configHasExtendsProperty: boolean;
     /**
@@ -122,12 +122,12 @@ export function makeInferredProjectName(counter: number): string {
     return `/dev/null/inferredProject${counter}*`;
 }
 
-/*@internal*/
+/** @internal */
 export function makeAutoImportProviderProjectName(counter: number): string {
     return `/dev/null/autoImportProviderProject${counter}*`;
 }
 
-/*@internal*/
+/** @internal */
 export function makeAuxiliaryProjectName(counter: number): string {
     return `/dev/null/auxiliaryProject${counter}*`;
 }
diff --git a/src/services/classifier.ts b/src/services/classifier.ts
index 82413d86f3..800eb2a649 100644
--- a/src/services/classifier.ts
+++ b/src/services/classifier.ts
@@ -466,7 +466,7 @@ function classFromKind(token: SyntaxKind): ClassificationType {
     }
 }
 
-/* @internal */
+/** @internal */
 export function getSemanticClassifications(typeChecker: TypeChecker, cancellationToken: CancellationToken, sourceFile: SourceFile, classifiableNames: ReadonlySet<__String>, span: TextSpan): ClassifiedSpan[] {
     return convertClassificationsToSpans(getEncodedSemanticClassifications(typeChecker, cancellationToken, sourceFile, classifiableNames, span));
 }
@@ -494,7 +494,7 @@ function checkForClassificationCancellation(cancellationToken: CancellationToken
     }
 }
 
-/* @internal */
+/** @internal */
 export function getEncodedSemanticClassifications(typeChecker: TypeChecker, cancellationToken: CancellationToken, sourceFile: SourceFile, classifiableNames: ReadonlySet<__String>, span: TextSpan): Classifications {
     const spans: number[] = [];
     sourceFile.forEachChild(function cb(node: Node): void {
@@ -609,12 +609,12 @@ function convertClassificationsToSpans(classifications: Classifications): Classi
     return result;
 }
 
-/* @internal */
+/** @internal */
 export function getSyntacticClassifications(cancellationToken: CancellationToken, sourceFile: SourceFile, span: TextSpan): ClassifiedSpan[] {
     return convertClassificationsToSpans(getEncodedSyntacticClassifications(cancellationToken, sourceFile, span));
 }
 
-/* @internal */
+/** @internal */
 export function getEncodedSyntacticClassifications(cancellationToken: CancellationToken, sourceFile: SourceFile, span: TextSpan): Classifications {
     const spanStart = span.start;
     const spanLength = span.length;
diff --git a/src/services/documentHighlights.ts b/src/services/documentHighlights.ts
index f6a5e2f5ea..fb04985135 100644
--- a/src/services/documentHighlights.ts
+++ b/src/services/documentHighlights.ts
@@ -18,7 +18,7 @@ export interface DocumentHighlights {
     highlightSpans: HighlightSpan[];
 }
 
-/* @internal */
+/** @internal */
 export namespace DocumentHighlights {
     export function getDocumentHighlights(program: Program, cancellationToken: CancellationToken, sourceFile: SourceFile, position: number, sourceFilesToSearch: readonly SourceFile[]): DocumentHighlights[] | undefined {
         const node = getTouchingPropertyName(sourceFile, position);
diff --git a/src/services/documentRegistry.ts b/src/services/documentRegistry.ts
index d9197886cf..9a080872b1 100644
--- a/src/services/documentRegistry.ts
+++ b/src/services/documentRegistry.ts
@@ -124,13 +124,13 @@ export interface DocumentRegistry {
     releaseDocumentWithKey(path: Path, key: DocumentRegistryBucketKey, scriptKind?: ScriptKind): void;
     releaseDocumentWithKey(path: Path, key: DocumentRegistryBucketKey, scriptKind: ScriptKind, impliedNodeFormat: SourceFile["impliedNodeFormat"]): void; // eslint-disable-line @typescript-eslint/unified-signatures
 
-    /*@internal*/
+    /** @internal */
     getLanguageServiceRefCounts(path: Path, scriptKind: ScriptKind): [string, number | undefined][];
 
     reportStats(): string;
 }
 
-/*@internal*/
+/** @internal */
 export interface ExternalDocumentCache {
     setDocument(key: DocumentRegistryBucketKeyWithMode, path: Path, sourceFile: SourceFile): void;
     getDocument(key: DocumentRegistryBucketKeyWithMode, path: Path): SourceFile | undefined;
@@ -156,9 +156,9 @@ export function createDocumentRegistry(useCaseSensitiveFileNames?: boolean, curr
     return createDocumentRegistryInternal(useCaseSensitiveFileNames, currentDirectory);
 }
 
-/*@internal*/
+/** @internal */
 export type DocumentRegistryBucketKeyWithMode = string & { __documentRegistryBucketKeyWithMode: any; };
-/*@internal*/
+/** @internal */
 export function createDocumentRegistryInternal(useCaseSensitiveFileNames?: boolean, currentDirectory = "", externalCache?: ExternalDocumentCache): DocumentRegistry {
     // Maps from compiler setting target (ES3, ES5, etc.) to all the cached documents we have
     // for those settings.
diff --git a/src/services/exportAsModule.ts b/src/services/exportAsModule.ts
index da2c68619c..757f9f7cd3 100644
--- a/src/services/exportAsModule.ts
+++ b/src/services/exportAsModule.ts
@@ -3,7 +3,7 @@ import * as ts from "./_namespaces/ts";
 // Here we expose the TypeScript services as an external module
 // so that it may be consumed easily like a node module.
 // @ts-ignore
-/* @internal */ declare const module: { exports: {} };
+/** @internal */ declare const module: { exports: {} };
 if (typeof module !== "undefined" && module.exports) {
     module.exports = ts;
-}
\ No newline at end of file
+}
diff --git a/src/services/globalThisShim.ts b/src/services/globalThisShim.ts
index c7bc8a28e1..9a8978bdb2 100644
--- a/src/services/globalThisShim.ts
+++ b/src/services/globalThisShim.ts
@@ -7,7 +7,7 @@ import { TypeScriptServicesFactory, versionMajorMinor } from "./_namespaces/ts";
 
 // #region The polyfill starts here.
 /* eslint-disable no-var */
-/* @internal */
+/** @internal */
 declare global {
     // Module transform: converted from ambient declaration
     /** @internal */
@@ -62,4 +62,4 @@ if (typeof process === "undefined" || process.browser) {
 
     //@ts-ignore
     globalThis.toolsVersion = versionMajorMinor;
-}
\ No newline at end of file
+}
diff --git a/src/services/services.ts b/src/services/services.ts
index a5ae54eeab..80f57420c1 100644
--- a/src/services/services.ts
+++ b/src/services/services.ts
@@ -473,7 +473,7 @@ class IdentifierObject extends TokenOrIdentifierObject implements Identifier {
     _unaryExpressionBrand: any;
     _expressionBrand: any;
     _declarationBrand: any;
-    /*@internal*/typeArguments!: NodeArray<TypeNode>;
+    /** @internal */typeArguments!: NodeArray<TypeNode>;
     constructor(_kind: SyntaxKind.Identifier, pos: number, end: number) {
         super(pos, end);
     }
@@ -995,12 +995,12 @@ function getServicesObjectAllocator(): ObjectAllocator {
 
 /// Language Service
 
-/* @internal */
+/** @internal */
 export interface DisplayPartsSymbolWriter extends EmitTextWriter {
     displayParts(): SymbolDisplayPart[];
 }
 
-/* @internal */
+/** @internal */
 export function toEditorSettings(options: FormatCodeOptions | FormatCodeSettings): FormatCodeSettings;
 export function toEditorSettings(options: EditorOptions | EditorSettings): EditorSettings;
 export function toEditorSettings(optionsAsMap: MapLike<any>): MapLike<any> {
@@ -1194,7 +1194,7 @@ class CancellationTokenObject implements CancellationToken {
     }
 }
 
-/* @internal */
+/** @internal */
 /** A cancellation that throttles calls to the host */
 export class ThrottledCancellationToken implements CancellationToken {
     // Store when we last tried to cancel.  Checking cancellation can be expensive (as we have
@@ -2797,7 +2797,7 @@ export function createLanguageService(
     return ls;
 }
 
-/* @internal */
+/** @internal */
 /** Names in the name table are escaped, so an identifier `__foo` will have a name table entry `___foo`. */
 export function getNameTable(sourceFile: SourceFile): UnderscoreEscapedMap<number> {
     if (!sourceFile.nameTable) {
@@ -2844,7 +2844,7 @@ function literalIsName(node: StringLiteralLike | NumericLiteral): boolean {
 /**
  * Returns the containing object literal property declaration given a possible name node, e.g. "a" in x = { "a": 1 }
  */
-/* @internal */
+/** @internal */
 export function getContainingObjectLiteralElement(node: Node): ObjectLiteralElementWithName | undefined {
     const element = getContainingObjectLiteralElementWorker(node);
     return element && (isObjectLiteralExpression(element.parent) || isJsxAttributes(element.parent)) ? element as ObjectLiteralElementWithName : undefined;
@@ -2867,7 +2867,7 @@ function getContainingObjectLiteralElementWorker(node: Node): ObjectLiteralEleme
     return undefined;
 }
 
-/* @internal */
+/** @internal */
 export type ObjectLiteralElementWithName = ObjectLiteralElement & { name: PropertyName; parent: ObjectLiteralExpression | JsxAttributes };
 
 function getSymbolAtLocationForQuickInfo(node: Node, checker: TypeChecker): Symbol | undefined {
@@ -2883,7 +2883,7 @@ function getSymbolAtLocationForQuickInfo(node: Node, checker: TypeChecker): Symb
 }
 
 /** Gets all symbols for one property. Does not get symbols for every property. */
-/* @internal */
+/** @internal */
 export function getPropertySymbolsFromContextualType(node: ObjectLiteralElementWithName, checker: TypeChecker, contextualType: Type, unionSymbolOk: boolean): readonly Symbol[] {
     const name = getNameFromPropertyName(node.name);
     if (!name) return emptyArray;
diff --git a/src/services/shims.ts b/src/services/shims.ts
index b3ba7f3e8a..4a1a2d8c19 100644
--- a/src/services/shims.ts
+++ b/src/services/shims.ts
@@ -28,7 +28,7 @@ import {
 // limitations under the License.
 //
 
-/* @internal */
+/** @internal */
 let debugObjectHost: { CollectGarbage(): void } = (function (this: any) { // eslint-disable-line prefer-const
     return this;
 })();
diff --git a/src/services/transpile.ts b/src/services/transpile.ts
index d588995353..e9d8a61513 100644
--- a/src/services/transpile.ts
+++ b/src/services/transpile.ts
@@ -128,7 +128,7 @@ export function transpile(input: string, compilerOptions?: CompilerOptions, file
 let commandLineOptionsStringToEnum: CommandLineOptionOfCustomType[];
 
 /** JS users may pass in string values for enum compiler options (such as ModuleKind), so convert. */
-/*@internal*/
+/** @internal */
 export function fixupCompilerOptions(options: CompilerOptions, diagnostics: Diagnostic[]): CompilerOptions {
     // Lazily create this value to fix module loading errors.
     commandLineOptionsStringToEnum = commandLineOptionsStringToEnum ||
diff --git a/src/services/types.ts b/src/services/types.ts
index 26790a88df..cba7b6e51a 100644
--- a/src/services/types.ts
+++ b/src/services/types.ts
@@ -15,10 +15,10 @@ declare module "../compiler/types" {
         getChildCount(sourceFile?: SourceFile): number;
         getChildAt(index: number, sourceFile?: SourceFile): Node;
         getChildren(sourceFile?: SourceFile): Node[];
-        /* @internal */
+        /** @internal */
         getChildren(sourceFile?: SourceFileLike): Node[]; // eslint-disable-line @typescript-eslint/unified-signatures
         getStart(sourceFile?: SourceFile, includeJsDocComment?: boolean): number;
-        /* @internal */
+        /** @internal */
         getStart(sourceFile?: SourceFileLike, includeJsDocComment?: boolean): number; // eslint-disable-line @typescript-eslint/unified-signatures
         getFullStart(): number;
         getEnd(): number;
@@ -28,10 +28,10 @@ declare module "../compiler/types" {
         getFullText(sourceFile?: SourceFile): string;
         getText(sourceFile?: SourceFile): string;
         getFirstToken(sourceFile?: SourceFile): Node | undefined;
-        /* @internal */
+        /** @internal */
         getFirstToken(sourceFile?: SourceFileLike): Node | undefined; // eslint-disable-line @typescript-eslint/unified-signatures
         getLastToken(sourceFile?: SourceFile): Node | undefined;
-        /* @internal */
+        /** @internal */
         getLastToken(sourceFile?: SourceFileLike): Node | undefined; // eslint-disable-line @typescript-eslint/unified-signatures
         // See ts.forEachChild for documentation.
         forEachChild<T>(cbNode: (node: Node) => T | undefined, cbNodeArray?: (nodes: NodeArray<Node>) => T | undefined): T | undefined;
@@ -61,10 +61,10 @@ declare module "../compiler/types" {
         getName(): string;
         getDeclarations(): Declaration[] | undefined;
         getDocumentationComment(typeChecker: TypeChecker | undefined): SymbolDisplayPart[];
-        /* @internal */
+        /** @internal */
         getContextualDocumentationComment(context: Node | undefined, checker: TypeChecker | undefined): SymbolDisplayPart[]
         getJsDocTags(checker?: TypeChecker): JSDocTagInfo[];
-        /* @internal */
+        /** @internal */
         getContextualJsDocTags(context: Node | undefined, checker: TypeChecker | undefined): JSDocTagInfo[];
     }
 }
@@ -83,8 +83,8 @@ declare module "../compiler/types" {
         getNumberIndexType(): Type | undefined;
         getBaseTypes(): BaseType[] | undefined;
         getNonNullableType(): Type;
-        /*@internal*/ getNonOptionalType(): Type;
-        /*@internal*/ isNullableType(): boolean;
+        /** @internal */ getNonOptionalType(): Type;
+        /** @internal */ isNullableType(): boolean;
         getConstraint(): Type | undefined;
         getDefault(): Type | undefined;
 
@@ -124,11 +124,11 @@ declare module "../compiler/types" {
 declare module "../compiler/types" {
     // Module transform: converted from interface augmentation
     export interface SourceFile {
-        /* @internal */ version: string;
-        /* @internal */ scriptSnapshot: IScriptSnapshot | undefined;
-        /* @internal */ nameTable: UnderscoreEscapedMap<number> | undefined;
+        /** @internal */ version: string;
+        /** @internal */ scriptSnapshot: IScriptSnapshot | undefined;
+        /** @internal */ nameTable: UnderscoreEscapedMap<number> | undefined;
 
-        /* @internal */ getNamedDeclarations(): ESMap<string, readonly Declaration[]>;
+        /** @internal */ getNamedDeclarations(): ESMap<string, readonly Declaration[]>;
 
         getLineAndCharacterOfPosition(pos: number): LineAndCharacter;
         getLineEndOfPosition(pos: number): number;
@@ -136,7 +136,7 @@ declare module "../compiler/types" {
         getPositionOfLineAndCharacter(line: number, character: number): number;
         update(newText: string, textChangeRange: TextChangeRange): SourceFile;
 
-        /* @internal */ sourceMapper?: DocumentPositionMapper;
+        /** @internal */ sourceMapper?: DocumentPositionMapper;
     }
 }
 
@@ -226,7 +226,7 @@ export interface InstallPackageOptions {
     packageName: string;
 }
 
-/* @internal */
+/** @internal */
 export const enum PackageJsonDependencyGroup {
     Dependencies         = 1 << 0,
     DevDependencies      = 1 << 1,
@@ -235,7 +235,7 @@ export const enum PackageJsonDependencyGroup {
     All = Dependencies | DevDependencies | PeerDependencies | OptionalDependencies,
 }
 
-/* @internal */
+/** @internal */
 export interface ProjectPackageJsonInfo {
     fileName: string;
     parseable: boolean;
@@ -247,12 +247,12 @@ export interface ProjectPackageJsonInfo {
     has(dependencyName: string, inGroups?: PackageJsonDependencyGroup): boolean;
 }
 
-/* @internal */
+/** @internal */
 export interface FormattingHost {
     getNewLine?(): string;
 }
 
-/* @internal */
+/** @internal */
 export const enum PackageJsonAutoImportPreference {
     Off,
     On,
@@ -326,12 +326,12 @@ export interface LanguageServiceHost extends GetEffectiveTypeRootsHost, MinimalR
     resolveModuleNames?(moduleNames: string[], containingFile: string, reusedNames: string[] | undefined, redirectedReference: ResolvedProjectReference | undefined, options: CompilerOptions, containingSourceFile?: SourceFile): (ResolvedModule | undefined)[];
     getResolvedModuleWithFailedLookupLocationsFromCache?(modulename: string, containingFile: string, resolutionMode?: ModuleKind.CommonJS | ModuleKind.ESNext): ResolvedModuleWithFailedLookupLocations | undefined;
     resolveTypeReferenceDirectives?(typeDirectiveNames: string[] | FileReference[], containingFile: string, redirectedReference: ResolvedProjectReference | undefined, options: CompilerOptions, containingFileMode?: SourceFile["impliedNodeFormat"] | undefined): (ResolvedTypeReferenceDirective | undefined)[];
-    /* @internal */ hasInvalidatedResolution?: HasInvalidatedResolution;
-    /* @internal */ hasChangedAutomaticTypeDirectiveNames?: HasChangedAutomaticTypeDirectiveNames;
-    /* @internal */ getGlobalTypingsCacheLocation?(): string | undefined;
-    /* @internal */ getSymlinkCache?(files?: readonly SourceFile[]): SymlinkCache;
+    /** @internal */ hasInvalidatedResolution?: HasInvalidatedResolution;
+    /** @internal */ hasChangedAutomaticTypeDirectiveNames?: HasChangedAutomaticTypeDirectiveNames;
+    /** @internal */ getGlobalTypingsCacheLocation?(): string | undefined;
+    /** @internal */ getSymlinkCache?(files?: readonly SourceFile[]): SymlinkCache;
     /* Lets the Program from a AutoImportProviderProject use its host project's ModuleResolutionCache */
-    /* @internal */ getModuleResolutionCache?(): ModuleResolutionCache | undefined;
+    /** @internal */ getModuleResolutionCache?(): ModuleResolutionCache | undefined;
 
     /*
      * Required for full import and type reference completions.
@@ -348,23 +348,23 @@ export interface LanguageServiceHost extends GetEffectiveTypeRootsHost, MinimalR
     installPackage?(options: InstallPackageOptions): Promise<ApplyCodeActionCommandResult>;
     writeFile?(fileName: string, content: string): void;
 
-    /* @internal */ getDocumentPositionMapper?(generatedFileName: string, sourceFileName?: string): DocumentPositionMapper | undefined;
-    /* @internal */ getSourceFileLike?(fileName: string): SourceFileLike | undefined;
-    /* @internal */ getPackageJsonsVisibleToFile?(fileName: string, rootDir?: string): readonly ProjectPackageJsonInfo[];
-    /* @internal */ getNearestAncestorDirectoryWithPackageJson?(fileName: string): string | undefined;
-    /* @internal */ getPackageJsonsForAutoImport?(rootDir?: string): readonly ProjectPackageJsonInfo[];
-    /* @internal */ getCachedExportInfoMap?(): ExportInfoMap;
-    /* @internal */ getModuleSpecifierCache?(): ModuleSpecifierCache;
-    /* @internal */ setCompilerHost?(host: CompilerHost): void;
-    /* @internal */ useSourceOfProjectReferenceRedirect?(): boolean;
-    /* @internal */ getPackageJsonAutoImportProvider?(): Program | undefined;
-    /* @internal */ sendPerformanceEvent?(kind: PerformanceEvent["kind"], durationMs: number): void;
+    /** @internal */ getDocumentPositionMapper?(generatedFileName: string, sourceFileName?: string): DocumentPositionMapper | undefined;
+    /** @internal */ getSourceFileLike?(fileName: string): SourceFileLike | undefined;
+    /** @internal */ getPackageJsonsVisibleToFile?(fileName: string, rootDir?: string): readonly ProjectPackageJsonInfo[];
+    /** @internal */ getNearestAncestorDirectoryWithPackageJson?(fileName: string): string | undefined;
+    /** @internal */ getPackageJsonsForAutoImport?(rootDir?: string): readonly ProjectPackageJsonInfo[];
+    /** @internal */ getCachedExportInfoMap?(): ExportInfoMap;
+    /** @internal */ getModuleSpecifierCache?(): ModuleSpecifierCache;
+    /** @internal */ setCompilerHost?(host: CompilerHost): void;
+    /** @internal */ useSourceOfProjectReferenceRedirect?(): boolean;
+    /** @internal */ getPackageJsonAutoImportProvider?(): Program | undefined;
+    /** @internal */ sendPerformanceEvent?(kind: PerformanceEvent["kind"], durationMs: number): void;
     getParsedCommandLine?(fileName: string): ParsedCommandLine | undefined;
-    /* @internal */ onReleaseParsedCommandLine?(configFileName: string, oldResolvedRef: ResolvedProjectReference | undefined, optionOptions: CompilerOptions): void;
-    /* @internal */ getIncompleteCompletionsCache?(): IncompleteCompletionsCache;
+    /** @internal */ onReleaseParsedCommandLine?(configFileName: string, oldResolvedRef: ResolvedProjectReference | undefined, optionOptions: CompilerOptions): void;
+    /** @internal */ getIncompleteCompletionsCache?(): IncompleteCompletionsCache;
 }
 
-/* @internal */
+/** @internal */
 export const emptyOptions = {};
 
 export type WithMetadata<T> = T & { metadata?: unknown; };
@@ -514,10 +514,10 @@ export interface LanguageService {
 
     getSmartSelectionRange(fileName: string, position: number): SelectionRange;
 
-    /*@internal*/
+    /** @internal */
     // eslint-disable-next-line @typescript-eslint/unified-signatures
     getDefinitionAtPosition(fileName: string, position: number, searchOtherFilesOnly: false, stopAtAlias: boolean): readonly DefinitionInfo[] | undefined;
-    /*@internal*/
+    /** @internal */
     // eslint-disable-next-line @typescript-eslint/unified-signatures
     getDefinitionAtPosition(fileName: string, position: number, searchOtherFilesOnly: boolean, stopAtAlias: false): readonly DefinitionInfo[] | undefined;
     getDefinitionAtPosition(fileName: string, position: number): readonly DefinitionInfo[] | undefined;
@@ -590,15 +590,15 @@ export interface LanguageService {
     getEmitOutput(fileName: string, emitOnlyDtsFiles?: boolean, forceDtsEmit?: boolean): EmitOutput;
 
     getProgram(): Program | undefined;
-    /*@internal*/ getCurrentProgram(): Program | undefined;
+    /** @internal */ getCurrentProgram(): Program | undefined;
 
-    /* @internal */ getNonBoundSourceFile(fileName: string): SourceFile;
-    /* @internal */ getAutoImportProvider(): Program | undefined;
+    /** @internal */ getNonBoundSourceFile(fileName: string): SourceFile;
+    /** @internal */ getAutoImportProvider(): Program | undefined;
 
     /// Returns true if a suitable symbol was found in the project.
     /// May set isDefinition properties in `referencedSymbols` to false.
     /// May add elements to `knownSymbolSpans`.
-    /* @internal */ updateIsDefinitionOfReferencedSymbols(referencedSymbols: readonly ReferencedSymbol[], knownSymbolSpans: Set<DocumentSpan>): boolean;
+    /** @internal */ updateIsDefinitionOfReferencedSymbols(referencedSymbols: readonly ReferencedSymbol[], knownSymbolSpans: Set<DocumentSpan>): boolean;
 
     toggleLineComment(fileName: string, textRange: TextRange): TextChange[];
     toggleMultilineComment(fileName: string, textRange: TextRange): TextChange[];
@@ -836,9 +836,9 @@ export interface CombinedCodeActions {
 export type CodeActionCommand = InstallPackageAction;
 
 export interface InstallPackageAction {
-    /* @internal */ readonly type: "install package";
-    /* @internal */ readonly file: string;
-    /* @internal */ readonly packageName: string;
+    /** @internal */ readonly type: "install package";
+    /** @internal */ readonly file: string;
+    /** @internal */ readonly packageName: string;
 }
 
 /**
@@ -1076,7 +1076,7 @@ export function getDefaultFormatCodeSettings(newLineCharacter?: string): FormatC
     };
 }
 
-/* @internal */
+/** @internal */
 export const testFormatSettings = getDefaultFormatCodeSettings("\n");
 
 export interface DefinitionInfo extends DocumentSpan {
@@ -1091,8 +1091,8 @@ export interface DefinitionInfo extends DocumentSpan {
      * may be "incomplete" if this span has yet to be checked.
      */
     isLocal?: boolean;
-    /* @internal */ isAmbient?: boolean;
-    /* @internal */ failedAliasResolution?: boolean;
+    /** @internal */ isAmbient?: boolean;
+    /** @internal */ failedAliasResolution?: boolean;
 }
 
 export interface DefinitionInfoAndBoundSpan {
diff --git a/src/services/utilities.ts b/src/services/utilities.ts
index 1f4a950a3b..d3752d76b1 100644
--- a/src/services/utilities.ts
+++ b/src/services/utilities.ts
@@ -60,7 +60,7 @@ import {
     unescapeLeadingUnderscores, UserPreferences, VariableDeclaration, visitEachChild, VoidExpression, YieldExpression,
 } from "./_namespaces/ts";
 
-/* @internal */ // Don't expose that we use this
+/** @internal */ // Don't expose that we use this
 // Based on lib.es6.d.ts
 declare global {
     // Module transform: converted from ambient declaration
@@ -71,7 +71,7 @@ declare global {
         all<T>(values: (T | PromiseLike<T>)[]): Promise<T[]>;
     }
 }
-/* @internal */
+/** @internal */
 declare global {
     // Module transform: converted from ambient declaration
     /** @internal */
@@ -2966,7 +2966,7 @@ function indexInTextChange(change: string, name: string): number {
     return idx === -1 ? -1 : idx + 1;
 }
 
-/* @internal */
+/** @internal */
 export function needsParentheses(expression: Expression): boolean {
     return isBinaryExpression(expression) && expression.operatorToken.kind === SyntaxKind.CommaToken
         || isObjectLiteralExpression(expression)
@@ -3526,12 +3526,12 @@ export function getDiagnosticsWithinSpan(span: TextSpan, sortedFileDiagnostics:
     return result;
 }
 
-/* @internal */
+/** @internal */
 export function getRefactorContextSpan({ startPosition, endPosition }: RefactorContext): TextSpan {
     return createTextSpanFromBounds(startPosition, endPosition === undefined ? startPosition : endPosition);
 }
 
-/* @internal */
+/** @internal */
 export function getFixableErrorSpanExpression(sourceFile: SourceFile, span: TextSpan): Expression | undefined {
     const token = getTokenAtPosition(sourceFile, span.start);
     // Checker has already done work to determine that await might be possible, and has attached
diff --git a/src/testRunner/unittests/tsbuild/amdModulesWithOut.ts b/src/testRunner/unittests/tsbuild/amdModulesWithOut.ts
index d137e70ecc..e4618ca596 100644
--- a/src/testRunner/unittests/tsbuild/amdModulesWithOut.ts
+++ b/src/testRunner/unittests/tsbuild/amdModulesWithOut.ts
@@ -104,7 +104,7 @@ describe("unittests:: tsbuild:: outFile:: on amd modules with --out", () => {
 
         describe("stripInternal", () => {
             function stripInternalScenario(fs: vfs.FileSystem) {
-                const internal = "/*@internal*/";
+                const internal = "/** @internal */";
                 ts.replaceText(fs, "/src/app/tsconfig.json", `"composite": true,`, `"composite": true,
 "stripInternal": true,`);
                 ts.replaceText(fs, "/src/lib/file0.ts", "const", `${internal} const`);
@@ -140,7 +140,7 @@ ${internal} export enum internalEnum { a, b, c }`);
             verifyOutFileScenario({
                 subScenario: "stripInternal",
                 modifyFs: stripInternalScenario,
-                modifyAgainFs: fs => ts.replaceText(fs, "/src/lib/file1.ts", `export const`, `/*@internal*/ export const`),
+                modifyAgainFs: fs => ts.replaceText(fs, "/src/lib/file1.ts", `export const`, `/** @internal */ export const`),
             });
         });
 
diff --git a/src/testRunner/unittests/tsbuild/outFile.ts b/src/testRunner/unittests/tsbuild/outFile.ts
index 08a80e200e..6f0807633a 100644
--- a/src/testRunner/unittests/tsbuild/outFile.ts
+++ b/src/testRunner/unittests/tsbuild/outFile.ts
@@ -385,7 +385,7 @@ describe("unittests:: tsbuild:: outFile::", () => {
             }
 
             function stripInternalScenario(fs: vfs.FileSystem, removeCommentsDisabled?: boolean, jsDocStyle?: boolean) {
-                const internal: string = jsDocStyle ? `/**@internal*/` : `/*@internal*/`;
+                const internal: string = jsDocStyle ? `/**@internal*/` : `/** @internal */`;
                 if (removeCommentsDisabled) {
                     diableRemoveCommentsInAll(fs);
                 }
@@ -423,14 +423,14 @@ ${internal} enum internalEnum { a, b, c }`);
             verifyOutFileScenario({
                 subScenario: "stripInternal",
                 modifyFs: stripInternalScenario,
-                modifyAgainFs: fs => ts.replaceText(fs, "/src/first/first_PART1.ts", `/*@internal*/ interface`, "interface"),
+                modifyAgainFs: fs => ts.replaceText(fs, "/src/first/first_PART1.ts", `/** @internal */ interface`, "interface"),
             });
 
             // Verify ignore dtsChanged
             verifyOutFileScenario({
                 subScenario: "stripInternal with comments emit enabled",
                 modifyFs: fs => stripInternalScenario(fs, /*removeCommentsDisabled*/ true),
-                modifyAgainFs: fs => ts.replaceText(fs, "/src/first/first_PART1.ts", `/*@internal*/ interface`, "interface"),
+                modifyAgainFs: fs => ts.replaceText(fs, "/src/first/first_PART1.ts", `/** @internal */ interface`, "interface"),
                 ignoreDtsChanged: true,
                 baselineOnly: true
             });
@@ -468,14 +468,14 @@ ${internal} enum internalEnum { a, b, c }`);
                 verifyOutFileScenario({
                     subScenario: "stripInternal when one-two-three are prepended in order",
                     modifyFs: stripInternalWithDependentOrder,
-                    modifyAgainFs: fs => ts.replaceText(fs, "/src/first/first_PART1.ts", `/*@internal*/ interface`, "interface"),
+                    modifyAgainFs: fs => ts.replaceText(fs, "/src/first/first_PART1.ts", `/** @internal */ interface`, "interface"),
                 });
 
                 // Verify ignore dtsChanged
                 verifyOutFileScenario({
                     subScenario: "stripInternal with comments emit enabled when one-two-three are prepended in order",
                     modifyFs: fs => stripInternalWithDependentOrder(fs, /*removeCommentsDisabled*/ true),
-                    modifyAgainFs: fs => ts.replaceText(fs, "/src/first/first_PART1.ts", `/*@internal*/ interface`, "interface"),
+                    modifyAgainFs: fs => ts.replaceText(fs, "/src/first/first_PART1.ts", `/** @internal */ interface`, "interface"),
                     ignoreDtsChanged: true,
                     baselineOnly: true
                 });
diff --git a/src/typingsInstallerCore/typingsInstaller.ts b/src/typingsInstallerCore/typingsInstaller.ts
index ad08facc3c..c404433663 100644
--- a/src/typingsInstallerCore/typingsInstaller.ts
+++ b/src/typingsInstallerCore/typingsInstaller.ts
@@ -42,7 +42,7 @@ function typingToFileName(cachePath: string, packageName: string, installTypingH
     }
 }
 
-/*@internal*/
+/** @internal */
 export function installNpmPackages(npmPath: string, tsVersion: string, packageNames: string[], install: (command: string) => boolean) {
     let hasError = false;
     for (let remaining = packageNames.length; remaining > 0;) {
@@ -53,7 +53,7 @@ export function installNpmPackages(npmPath: string, tsVersion: string, packageNa
     return hasError;
 }
 
-/*@internal*/
+/** @internal */
 export function getNpmCommandForInstallation(npmPath: string, tsVersion: string, packageNames: string[], remaining: number) {
     const sliceStart = packageNames.length - remaining;
     let command: string, toSlice = remaining;
@@ -116,7 +116,7 @@ export abstract class TypingsInstaller {
     private inFlightRequestCount = 0;
 
     abstract readonly typesRegistry: ESMap<string, MapLike<string>>;
-    /*@internal*/
+    /** @internal */
     private readonly watchFactory: WatchFactory<string, ProjectWatchers>;
 
     constructor(
@@ -551,7 +551,7 @@ export abstract class TypingsInstaller {
     protected readonly latestDistTag = "latest";
 }
 
-/* @internal */
+/** @internal */
 export function typingsName(packageName: string): string {
     return `@types/${packageName}@ts${versionMajorMinor}`;
 }
diff --git a/src/webServer/webServer.ts b/src/webServer/webServer.ts
index e7ed996016..ece05e4db6 100644
--- a/src/webServer/webServer.ts
+++ b/src/webServer/webServer.ts
@@ -225,7 +225,7 @@ export function createWebSystem(host: WebHost, args: string[], getExecutingFileP
         // createSHA256Hash // telemetry of the project
 
         // Logging related
-        // /*@internal*/ bufferFrom?(input: string, encoding?: string): Buffer;
+        // /** @internal */ bufferFrom?(input: string, encoding?: string): Buffer;
         // gc?(): void;
         // getMemoryUsage?(): number;
     };
-- 
2.37.1

